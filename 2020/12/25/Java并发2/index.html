<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java并发2"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java并发2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池"><span class="toc-number">2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拒绝策略"><span class="toc-number">2.1.</span> <span class="toc-text">拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadFactory"><span class="toc-number">2.2.</span> <span class="toc-text">ThreadFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展线程池"><span class="toc-number">2.3.</span> <span class="toc-text">扩展线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化线程池线程数量"><span class="toc-number">2.4.</span> <span class="toc-text">优化线程池线程数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆栈"><span class="toc-number">2.5.</span> <span class="toc-text">堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-Join"><span class="toc-number">2.6.</span> <span class="toc-text">Fork&#x2F;Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK并发容器"><span class="toc-number">2.7.</span> <span class="toc-text">JDK并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">2.7.1.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的优化"><span class="toc-number">3.</span> <span class="toc-text">锁的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#提高锁性能"><span class="toc-number">3.1.</span> <span class="toc-text">提高锁性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#减小持有锁的时间"><span class="toc-number">3.1.1.</span> <span class="toc-text">减小持有锁的时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#减小锁粒度"><span class="toc-number">3.1.2.</span> <span class="toc-text">减小锁粒度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写分离锁来替换独占锁"><span class="toc-number">3.1.3.</span> <span class="toc-text">读写分离锁来替换独占锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁分离"><span class="toc-number">3.1.4.</span> <span class="toc-text">锁分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁粗化"><span class="toc-number">3.1.5.</span> <span class="toc-text">锁粗化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM对锁的优化"><span class="toc-number">3.2.</span> <span class="toc-text">JVM对锁的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#锁偏向"><span class="toc-number">3.2.1.</span> <span class="toc-text">锁偏向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#轻量级锁"><span class="toc-number">3.2.2.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重量级锁"><span class="toc-number">3.2.3.</span> <span class="toc-text">重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋锁"><span class="toc-number">3.2.4.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁消除"><span class="toc-number">3.2.5.</span> <span class="toc-text">锁消除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.3.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无锁"><span class="toc-number">3.4.</span> <span class="toc-text">无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS"><span class="toc-number">3.4.1.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">3.4.2.</span> <span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsafe"><span class="toc-number">3.4.3.</span> <span class="toc-text">Unsafe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicReference"><span class="toc-number">3.4.4.</span> <span class="toc-text">AtomicReference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-number">3.4.5.</span> <span class="toc-text">AtomicStampedReference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicIntegerArray"><span class="toc-number">3.4.6.</span> <span class="toc-text">AtomicIntegerArray</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicIntegerFieldUpdater"><span class="toc-number">3.4.7.</span> <span class="toc-text">AtomicIntegerFieldUpdater</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无锁的Vector"><span class="toc-number">3.4.8.</span> <span class="toc-text">无锁的Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">3.4.9.</span> <span class="toc-text">SynchronousQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">3.5.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行模式与算法"><span class="toc-number">4.</span> <span class="toc-text">并行模式与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">4.1.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不变模式"><span class="toc-number">4.2.</span> <span class="toc-text">不变模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者消费者模式"><span class="toc-number">4.3.</span> <span class="toc-text">生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高性能生产者消费者模式"><span class="toc-number">4.4.</span> <span class="toc-text">高性能生产者消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Disruptor"><span class="toc-number">4.4.1.</span> <span class="toc-text">Disruptor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future模式"><span class="toc-number">4.5.</span> <span class="toc-text">Future模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行流水线"><span class="toc-number">4.6.</span> <span class="toc-text">并行流水线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA8与并发"><span class="toc-number">5.</span> <span class="toc-text">JAVA8与并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Akka"><span class="toc-number">6.</span> <span class="toc-text">Akka</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java并发2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/25/Java%E5%B9%B6%E5%8F%912/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/25/Java并发2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java高并发程序设计》</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>接下来看一下ThreadPoolExecutor线程池的核心调度代码 <img src="/2020/12/25/Java%E5%B9%B6%E5%8F%912/1.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">            <span class="comment">//workerCountOf函数取得当前池线程的线程总数</span></span><br><span class="line">            <span class="comment">//如果小于核心线程数就将任务通过addWorker直接调度执行</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &lt; <span class="keyword">this</span>.corePoolSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.addWorker(command, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果大于核心线程数会进入等待队列workQueue</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) &amp;&amp; <span class="keyword">this</span>.workQueue.offer(command)) &#123;</span><br><span class="line">                <span class="keyword">int</span> recheck = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">                <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; <span class="keyword">this</span>.remove(command)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.reject(command);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.addWorker((Runnable)<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">     		  <span class="comment">//如果进入队列失败，比如有界队列达到上限或使用SynchronousQueue</span></span><br><span class="line">              <span class="comment">//将任务直接提交给线程池</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.addWorker(command, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            	<span class="comment">//如果线程数达到最大线程数提交失败，此时执行拒绝策略</span></span><br><span class="line">                <span class="keyword">this</span>.reject(command);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>拒绝策略是系统超负荷运行时的补救措施，JDK内置提供四种补救措施</p>
<ol>
<li>AbortPolicy 该策略直接抛出异常，阻止系统正常工作</li>
<li>CallRunsPolicy 只要线程池没关闭，直接在调用者线程中运行当前被丢弃<br>的任务</li>
<li>DiscardOledestPolicy 丢弃即将被执行的任务，并尝试再次提交当前任务</li>
<li>DiscardPolicy 丢弃无法处理的任务</li>
</ol>
<p>以上内置的策略均实现RejectedExecutionHandler接口，自定义的线程池可以<br>重写这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r,ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>线程池的主要作用是为了线程复用，最开始的线程是通过ThreadFactory产生，<br>ThreadFactory是一个接口，它只有一个方法，就是用来创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure>
<p>自定义线程池时可以更加自由设置池子中所有线程的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; </span></span></span><br><span class="line"><span class="function"><span class="params">	workQueue, ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function"><span class="comment">//可以自定义实现newThread方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; </span></span></span><br><span class="line"><span class="function"><span class="params">	workQueue, new ThreadFactory()</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">			Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">			t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h3><p>ThreadPoolExecutor 是一个可扩展的线程池，它提供 beforeExecute()<br>afterExecute()和terminated()三个接口对线程池进行控制，Worker 是<br>ThreadPoolExecutor 的内部类，线程池中的工作线程也正是Worker实例<br>，runWorker方法会被线程池以多线程模式异步调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(ThreadPoolExecutor.Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock();</span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(task != <span class="keyword">null</span> || (task = <span class="keyword">this</span>.getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(<span class="keyword">this</span>.ctl.get(), <span class="number">536870912</span>) || </span><br><span class="line">                	Thread.interrupted() &amp;&amp; runStateAtLeast(</span><br><span class="line">                		<span class="keyword">this</span>.ctl.get(), <span class="number">536870912</span>)) &amp;&amp; !wt.isInterrupted()) &#123;</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beforeExecute(wt, task);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                        <span class="keyword">this</span>.afterExecute(task, (Throwable)<span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var14) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.afterExecute(task, var14);</span><br><span class="line">                        <span class="keyword">throw</span> var14;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    ++w.completedTasks;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>默认提供了空的实现，可以对其进行扩展来实现对线程池运行状态的跟踪</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">5</span>,<span class="number">0L</span>,TimeUnit.MILLISECONDS,</span><br><span class="line">	<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t,Runnable r)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行前"</span>+(MyTask)r.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Thread t,Runnable r)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"执行后"</span>+(MyTask)r.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">(Thread t,Runnable r)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化线程池线程数量"><a href="#优化线程池线程数量" class="headerlink" title="优化线程池线程数量"></a>优化线程池线程数量</h3><p>线程池的大小对系统的性能优化有一定影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ncpu&#x3D;CPU的数量 &#x2F;&#x2F;JAVA中通过Runtime.getRuntime().availableProcessors()</span><br><span class="line">Ucpu&#x3D;目标CPU的使用率 0&lt;&#x3D;Ucpu&lt;&#x3D;1</span><br><span class="line">W&#x2F;C&#x3D;等待时间与计算时间的比率</span><br><span class="line">Nthreads&#x3D;Ncpu*Ucpu*(1+W&#x2F;C)</span><br></pre></td></tr></table></figure>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>线程池可能会“吃”掉程序抛出的异常，比如有一个任务要打印两个数的商，如果<br>分母是0的话正常情况应该抛出异常，但是提交到线程池可能不会有任何异常打<br>印，如果用submit提交方式可能出现上述情况，如果想要知道详细的堆栈信息<br>可以扩展线程池，让它在调度任务之前先保存提交任务线程的堆栈信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.execute(wrap(task,clientTrace(),Thread.currentThread().</span><br><span class="line">			getName()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task,<span class="keyword">final</span> Execption clinetStack,</span></span></span><br><span class="line"><span class="function"><span class="params">		String clientThreadName)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					task.run();</span><br><span class="line">				&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">					clientStack.printStackTrace();</span><br><span class="line">					<span class="keyword">throw</span> e;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h3><p>将一个大任务拆分成若干小任务执行，fork可以创建子线程，join表示等待，<br>当使用fork后系统多了一个分支，所以需要等待这个执行分支执行完毕才有可<br>能得到最终结果。JDK中提供了一个ForkJoinPool线程池，对于fork方法并不<br>急着开启线程，而是提交给线程池进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span></span></span><br></pre></td></tr></table></figure>
<p>ForkJoinTask任务支持fork分解以及join等待，还有两个子类分别表示没有<br>返回值的任务和有返回值的任务RecursiveAction RecursiveTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CountTash</span><span class="params">(<span class="keyword">long</span> start,<span class="keyword">long</span> end)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.start=start;</span><br><span class="line">		<span class="keyword">this</span>.end=end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> canCompute=(end-start)&lt;<span class="number">10000</span>;</span><br><span class="line">		<span class="keyword">if</span>(canCompute)&#123;</span><br><span class="line">			<span class="comment">//如果任务足够小就直接计算</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">long</span> i=start;i&lt;=end;i++)</span><br><span class="line">				sum+=i;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//分成100个小任务</span></span><br><span class="line">			<span class="keyword">long</span> step=(start+end)/<span class="number">100</span>;</span><br><span class="line">			ArrayList&lt;CountTask&gt; subTasks=<span class="keyword">new</span> ArrayList&lt;CountTask&gt;();</span><br><span class="line">			<span class="keyword">long</span> pos=start;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">				<span class="keyword">long</span> lastOne=pos+step;</span><br><span class="line">				<span class="keyword">if</span>(lastOne&gt;end)</span><br><span class="line">					lastOne=end;</span><br><span class="line">				CountTask subTask=<span class="keyword">new</span> CountTask(pos,lastOne);</span><br><span class="line">				pos+=step+<span class="number">1</span>;</span><br><span class="line">				subTasks.add(subTask);</span><br><span class="line">				subTask.fork();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(CountTask t:subTasks)&#123;</span><br><span class="line">				<span class="comment">//必须等到目标线程执行完后才会继续执行当前线程</span></span><br><span class="line">				sum+=t.join();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">		CountTask task=<span class="keyword">new</span> CountTask(<span class="number">0</span>,<span class="number">200000L</span>);</span><br><span class="line">		ForkJoinPool&lt;Long&gt; result=forkJoinPool.submit(task);</span><br><span class="line">		<span class="comment">//如果任务没有结束主线程会等待</span></span><br><span class="line">		<span class="keyword">long</span> res=result.get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK并发容器"><a href="#JDK并发容器" class="headerlink" title="JDK并发容器"></a>JDK并发容器</h3><ul>
<li>ConcurrentHashMap 这是一个高效并发的HashMap</li>
<li>CopyOnWriteArrayList 在读多写少的场合性能远远好于Vector</li>
<li>ConcurrentLinkedQueue 线程安全的LinkedList</li>
<li>BlockingQueue 阻塞队列</li>
<li>ConcurrentSkipListMap 跳表的实现</li>
</ul>
<p>Collections工具类也可以将任何集合类包装成线程安全的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map m=Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure>
<p>接下来看一下这个包装类的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">synchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Object mutes;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;</span><br><span class="line">	<span class="comment">//使用mutex实现同步</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">			<span class="keyword">return</span> m.get(key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h2 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h2><p>对于单线程引用而言，其主要资源消耗都花在任务本身，不需要维护并行数据<br>结构间的一致性状态，也不需要为线程的切换和调度花费时间，对于多线程应<br>用来说，系统除了处理功能需求外，还需要维护多线程环境特有的信息，如线<br>程本身的元数据、线程的调度、线程上下文的切换。在单核CPU上，并行算法的<br>效率一般要低于原始的串行算法，并行之所以能够提高系统性能，根本原因<br>就是充分利用各个CPU的资源</p>
<h3 id="提高锁性能"><a href="#提高锁性能" class="headerlink" title="提高锁性能"></a>提高锁性能</h3><p>锁的竞争必然会导致程序的整体性能下降，以下有几种方式降低这种副作用</p>
<h4 id="减小持有锁的时间"><a href="#减小持有锁的时间" class="headerlink" title="减小持有锁的时间"></a>减小持有锁的时间</h4><p>如果线程持有锁的时间越长锁的竞争也会越激烈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span></span>&#123;</span><br><span class="line">	oth(); <span class="comment">//不需同步</span></span><br><span class="line">	mut(); <span class="comment">//需要同步</span></span><br><span class="line">	oth2(); <span class="comment">//不需同步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不需同步的方法是重量级方法则会导致大量线程等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span></span>&#123;</span><br><span class="line">	oth();</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">		mut();</span><br><span class="line">	&#125;</span><br><span class="line">	oth2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h4><p>对于HashMap来说最重要的就是get()和put()方法，一种方式就是对整个HashMap<br>加锁，但这样加锁粒度太大，对于ConcurrentHashMap，其内部进一步细分成若干<br>HashMap ，称之为段(SEGMENT)，默认情况细分为16个段。如果需要在该对象中加<br>一个新的表项，并不是给整个对象加锁，而是根据 hashcode得到该表项应被存到<br>哪个段中，然后对该段加锁，并完成put操作，多线程环境如果多个线程同时进行<br>put操作，是有可能同时接受16个线程的put操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//计算Hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="comment">//获取段序号</span></span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">            <span class="comment">// 若j偏移指定值处有segment就返回，若没有就创建并返回</span></span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="comment">// 将值put到segment中去</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>减少锁粒度会引入一个新问题，当系统需要获取全局锁的时候，需要同时获取所有<br>的锁才能操作，比如ConcurrentHashMap中的size方法，事实上size方法会先使<br>用无锁的方式求和，如果失败才会采用以下的加锁方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;segments.length;++i)</span><br><span class="line">	segments[i].lock(); <span class="comment">//对所有段加锁</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;segments.length;++i)</span><br><span class="line">	sum+=segments[i].count; <span class="comment">//统计总数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;segments.length;++i)</span><br><span class="line">	segments[i].unlock(); <span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>
<p>减少锁粒度的核心就是缩小锁定对象的范围，从而减少锁冲突的可能</p>
<h4 id="读写分离锁来替换独占锁"><a href="#读写分离锁来替换独占锁" class="headerlink" title="读写分离锁来替换独占锁"></a>读写分离锁来替换独占锁</h4><p>如果之前减少锁粒度是通过分割数据结构来实现，那么读写锁是对系统功能点的分<br>割，在读多写少的情况下使用读写锁较好</p>
<h4 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h4><p>读写锁根据读写操作功能上的不同进行有效分离，依据应用程序的功能特点使用类<br>似的分离思想也可以对独占锁进行分离，比如 LinkedBlockingQueue的实现，该<br>类中take和put分别实现从队列中取数据和增加数据的功能，这两个操作一个是在<br>链表的前端一个是在末尾，理论上并不会冲突，该阻塞队列就是用到了锁分离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty=takeLock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull=takeLock.newCondition();</span><br></pre></td></tr></table></figure>

<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>通常情况为了保证多线程的有效并发，会要求每个线程持有锁的时间尽量短，即完<br>成操作后立即释放锁，但是如果对一个锁频繁进行请求、同步的释放本身也会消耗<br>系统资源，为此虚拟机在遇到一连串连续对同一个锁进行请求的释放的操作时，<br>会将所有的锁操作整合成一次对锁的请求，从而减少锁的同步请求次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meth</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">		..</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">		..</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以整合成一次锁请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meth</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">		..</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在循环时应注意锁的粗化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JVM对锁的优化"><a href="#JVM对锁的优化" class="headerlink" title="JVM对锁的优化"></a>JVM对锁的优化</h3><p><img src="/2020/12/25/Java%E5%B9%B6%E5%8F%912/2.jpg" alt></p>
<h4 id="锁偏向"><a href="#锁偏向" class="headerlink" title="锁偏向"></a>锁偏向</h4><p>如果一个线程获得了锁那么锁就进入偏向模式，当这个线程再次请求锁的时候<br>无需再做任何同步操作，在几乎没有锁竞争的场合偏向锁比较好，如果每次都<br>是不同线程来请求锁那么偏向模式会失效，以下参数可以开启偏向锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking</span><br></pre></td></tr></table></figure>
<p>在锁对象的对象头中有一个ThreadId 字段，当第一个线程访问锁时如果该锁没<br>有被其他线程访问，即ThreadId 为空，那么JVM就会让第一个线程持有偏向锁<br>，并且ThreadId为该线程的Id，当下次获取锁时，判断锁对象的ThreadId 与<br>该线程Id是否一致，如果一致不需重复获取锁，如果存在竞争偏向锁会被撤销<br>为轻量级锁，如果竞争非常激烈会替换为重量级锁，偏向锁不是互斥锁</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>如果偏向锁失败，虚拟机并不会立即挂起线程，还会使用一种叫轻量级锁的优<br>化手段，它只是简单将对象头部作为指针，指向持有锁的线程堆栈的内部，来<br>判断一个线程是否持有对象锁，如果线程获得轻量级锁成功则会顺利进入临界<br>区</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>参考 <a href="https://www.jianshu.com/p/36eedeb3f912" target="_blank" rel="noopener">https://www.jianshu.com/p/36eedeb3f912</a><br>内置锁是JVM提供的最便捷的线程同步工具，在代码块或方法声明synchronized<br>关机子即可使用内置锁，内置锁在JAVA中被抽象为监视器monitor，JDK1.6以前<br>监视器可以直接认为对应底层操作系统中的互斥量mutex，这也就是重量级锁</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>由于当前线程暂时无法获取锁，但是没有必要直接挂起，因此会让该线程先做<br>几个空循环，如果还不能获取锁就挂起</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>JVM在JIT 编译时会对运行上下文进行扫描，通过对运行上下文的扫描，去除不<br>可能存在资源竞争锁，比如在使用JDK内置的API时，StringBuffer  Vector<br>，很可能在一个不可能存在并发竞争的场合使用Vector，比如在函数内部创建<br>一个Vector对象，所以JVM会将这些无用的锁去除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis 打开逃逸分析</span><br><span class="line">-XX:+EliminateLocks 打开锁消除</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>除了控制资源的访问外，还可以通过增加资源来保证所有对象的线程安全，是<br>线程内部的存储类，ThreadLocal中填充的变量属于当前线程，也就是为每个<br>线程创建了一个变量副本，事实上ThreadLocal只是简单起到了容器的作用，<br>需要在应用层面为每一个线程分配不同的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;T&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;T&gt;();</span><br><span class="line">sThreadLocal.set()</span><br><span class="line">sThreadLocal.get()</span><br></pre></td></tr></table></figure>
<p>接下来看一下如何保证这些对象只被当前线程访问吗，ThreadLocalMap是定<br>义在Thread内部的成员，初始值为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      <span class="comment">//实际存储的数据结构类型</span></span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="comment">//如果存在map就直接set，没有则创建map并set</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//getMap方法</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//thred中维护了一个ThreadLocalMap</span></span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//createMap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span></span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ThreadLocal中get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//ThreadLocalMap中getEntry方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">       Entry e = table[i];</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>并发控制是一种悲观的策略，假设每一次的临界区操作都会产生冲突，所以会<br>牺牲性能让线程等待，无锁是一种乐观的策略，假设对资源的访问是没有冲突<br>的，如果遇到冲突会使用一种叫做比较交换的技术(CAS)来鉴别线程冲突，一<br>旦检测到冲突就会重试当前操作直到没有冲突</p>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS算法的过程如下：它包含三个参数，V表示要更新的变量，E表示预期值，N<br>表示新值。仅当V等于E时才会将V的值设为N，如果V不等于E 说明已经有其他线<br>程做了更新，则当前线程什么也不做，最后CAS 会返回当前V的真实值。当多线<br>程同时使用CAS 操作一个变量时，只会有一个成功更新其余失败，失败的线程<br>不会被挂起，而是被告知失败并且允许再次尝试，也允许失败的线程放弃操作<br>，CAS操作即使没有锁也可以发现其他线程对当前线程的干扰</p>
<h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>JDK并发包中有一个atomic包，里面直接实现一些直接使用CAS操作的线程安全<br>类型，AtomicInteger是一个线程安全的Integer，对其进行修改等任何操作<br>都是用CAS指令进行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.value = newValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>AtomicInteger中保存一个核心字段，它就代表当前实际取值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<p>还有一个字段是实现AtomicInteger的关键，它保存value的偏移量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE;</span><br></pre></td></tr></table></figure>
<p>再来看一下JDK1.7中关于incrementAndGet方法的实现，这里有一个for死循<br>环，因为CAS操作未必是成功的，对于不成功的情况就要不断尝试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    		<span class="keyword">int</span> current=get();</span><br><span class="line">    		<span class="keyword">int</span> next=current+<span class="number">1</span>;</span><br><span class="line">    		<span class="comment">//成功的条件就是期望是current必须是最新的当前值</span></span><br><span class="line">    		<span class="keyword">if</span>(compareAndSet(current,next))</span><br><span class="line">    			<span class="keyword">return</span> next;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h4><p>Unsafe封装了一些类似指针的操作，以下是JDK11中的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Unsafe类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           v = <span class="keyword">this</span>.getIntVolatile(o, offset);</span><br><span class="line">       &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> v;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, </span></span></span><br><span class="line"><span class="function"><span class="params">   	<span class="keyword">int</span> expected, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">//调用一个本地方法</span></span><br><span class="line">   	<span class="comment">//o为给定的对象,offset为对象内的偏移量，expected表示期望值，x是要设置的值</span></span><br><span class="line">   	<span class="comment">//通过offset可以快速定位字段</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.compareAndSetInt(o, offset, expected, x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>对应普通对象的引用，保证在修改对象引用时的线程安全性，之前讲解中有一<br>个问题，就是通过当前值和期望值是否一致来判断线程是否修改了这个值，当<br>其他线程把这个值修改了两次的话如果又修改为旧值那么就无法判断了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;Integer&gt; money=<span class="keyword">new</span> AtomicReference&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>AtomicReference无法解决上述问题是因为对象在修改过程中丢失了状态信息，<br>所以需要记录对象在修改过程中的状态值，就可以很好解决对象被反复修改导致<br>线程无法正确判断对象状态的问题，这个类内部不仅维护了对象值，还维护了一<br>个时间戳，这个时间戳可以用任何一个整数表示，设置对象值时对象值与时间戳<br>都必须满足期望值写入才会成功</p>
<h4 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h4><p>除了提供基本数据类型外，JDK还准备了数组等符合结构</p>
<h4 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h4><p>一些普通变量可能也会有线程安全的需求</p>
<h4 id="无锁的Vector"><a href="#无锁的Vector" class="headerlink" title="无锁的Vector"></a>无锁的Vector</h4><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁就是两个或多个线程相互占用对方需要的资源，而都不进行释放，导致彼此<br>之间都相互等待对方释放资源，产生无限制等待的线程。注意参数死锁的线程不<br>占用CPU</p>
<h2 id="并行模式与算法"><a href="#并行模式与算法" class="headerlink" title="并行模式与算法"></a>并行模式与算法</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>这是一种对象创建模式，用于产生一个对象的具体实例，可以确保系统中一个<br>类只产生一个对象，这种方式有两种好处</p>
<ul>
<li>对于频繁使用的对象，可以省略new花费的时间</li>
<li>由于new操作的较少，对系统内存的使用频率也降低，减轻GC压力</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="comment">//保证不会创建多个实例</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Singleton is created"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上单例有一个问题，就是instance会在类第一次初始化的时候被创建，并不是<br>getInstance第一次被调用的时候，采用加载延迟策略可以控制instance创建时<br>间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="comment">//保证不会创建多个实例</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Singleton is created"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//为了防止多次多次被创建必须加锁，同时也降低了性能</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">			instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方式能够综合以上两种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="comment">//保证不会创建多个实例</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Singleton is created"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h3><p>不变模式的核心思想是一个对象一旦被创建，则它的内部状态将永远不会被<br>改变，所以没有一个线程可以修改其内部状态和数据，同时其内部状态也不<br>会自行发生改变。不变模式的主要使用场景需要满足两个条件</p>
<ol>
<li>当对象创建后，其内部状态和数据不再发生任何变化</li>
<li>对象需要被共享，被多线程频繁访问</li>
</ol>
<p>由于基本数据类型和String类型在实际开发中引用极其广泛，使用不变模式<br>后所有的实例方法均不需要进行同步操作</p>
<h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>有两类线程，即若干生产者线程和若干消费者线程和若干消费者线程</p>
<h3 id="高性能生产者消费者模式"><a href="#高性能生产者消费者模式" class="headerlink" title="高性能生产者消费者模式"></a>高性能生产者消费者模式</h3><p>BlockingQueue用于实现生产者和消费者是一个不错的选择，但是它使用锁<br>和阻塞等待来实现线程间的同步，在高并发场合性能并不优越。Concurrent<br>LinkedQueue是一个高性能队列，使用大量无锁的CAS操作，自己使用CAS<br>实现生产者消费者模式十分困难，Disruptor框架可以帮助实现</p>
<h4 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h4><p>Disruptor是一款高效的无锁内存队列，使用无锁的方式实现了一个环形队<br>列</p>
<h3 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h3><p>Future模式的核心思想是异步调用，当调用一个函数时并不急着要结果，可<br>以先让被调用者立即返回，让它在后台慢慢处理这个请求</p>
<h3 id="并行流水线"><a href="#并行流水线" class="headerlink" title="并行流水线"></a>并行流水线</h3><h2 id="JAVA8与并发"><a href="#JAVA8与并发" class="headerlink" title="JAVA8与并发"></a>JAVA8与并发</h2><h2 id="Akka"><a href="#Akka" class="headerlink" title="Akka"></a>Akka</h2><p>Akka提供了一种称为Actor的并发模型，其粒度比线程小</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/25/Java%E5%B9%B6%E5%8F%912/">https://skysea-gaoming.github.io/2020/12/25/Java%E5%B9%B6%E5%8F%912/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>Java并发总结</span></a></div><div class="next-post pull-right"><a href="/2020/12/21/Java%E5%B9%B6%E5%8F%91/"><span>Java并发</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/25/Java%E5%B9%B6%E5%8F%912/';
  this.page.identifier = '2020/12/25/Java并发2/';
  this.page.title = 'Java并发2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>