<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java并发"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java并发 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行世界"><span class="toc-number">2.</span> <span class="toc-text">并行世界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步"><span class="toc-number">2.1.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发和并行"><span class="toc-number">2.2.</span> <span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区"><span class="toc-number">2.3.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞和非阻塞"><span class="toc-number">2.4.</span> <span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁、饥饿和活锁"><span class="toc-number">2.5.</span> <span class="toc-text">死锁、饥饿和活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发级别"><span class="toc-number">2.6.</span> <span class="toc-text">并发级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞"><span class="toc-number">2.6.1.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无饥饿"><span class="toc-number">2.6.2.</span> <span class="toc-text">无饥饿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无障碍"><span class="toc-number">2.6.3.</span> <span class="toc-text">无障碍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无锁"><span class="toc-number">2.6.4.</span> <span class="toc-text">无锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无等待"><span class="toc-number">2.6.5.</span> <span class="toc-text">无等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个定律"><span class="toc-number">2.7.</span> <span class="toc-text">两个定律</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Amdahl"><span class="toc-number">2.7.1.</span> <span class="toc-text">Amdahl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gustafson"><span class="toc-number">2.7.2.</span> <span class="toc-text">Gustafson</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM"><span class="toc-number">2.8.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性"><span class="toc-number">2.8.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可见性"><span class="toc-number">2.8.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序性"><span class="toc-number">2.8.3.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重排规则"><span class="toc-number">2.8.4.</span> <span class="toc-text">重排规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA并行程序基础"><span class="toc-number">3.</span> <span class="toc-text">JAVA并行程序基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">3.1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的终止"><span class="toc-number">3.1.1.</span> <span class="toc-text">线程的终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程中断"><span class="toc-number">3.1.2.</span> <span class="toc-text">线程中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK并发包"><span class="toc-number">4.</span> <span class="toc-text">JDK并发包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">4.1.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实例演示"><span class="toc-number">4.1.1.</span> <span class="toc-text">实例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中断响应"><span class="toc-number">4.1.2.</span> <span class="toc-text">中断响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁申请等待限时"><span class="toc-number">4.1.3.</span> <span class="toc-text">锁申请等待限时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公平锁"><span class="toc-number">4.1.4.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-number">4.1.5.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">4.1.6.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReadWriteLock"><span class="toc-number">4.1.7.</span> <span class="toc-text">ReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">4.1.8.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CycliBarrier"><span class="toc-number">4.1.9.</span> <span class="toc-text">CycliBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LockSupport"><span class="toc-number">4.1.10.</span> <span class="toc-text">LockSupport</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-number">4.2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors"><span class="toc-number">4.2.1.</span> <span class="toc-text">Executors</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">45</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1608455550997&amp;di=bdcbdc0e59e4cf9547a1b4280b5f05ec&amp;imgtype=0&amp;src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2019-02-20%2F5c6d045c8c9be.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java并发</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/21/Java%E5%B9%B6%E5%8F%91/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/21/Java并发/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java高并发程序设计》</p>
<h2 id="并行世界"><a href="#并行世界" class="headerlink" title="并行世界"></a>并行世界</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步通常用来形容一次方法调用。同步方法一旦开始，调用者必须等<br>到方法调用返回后才能继续后面的操作。异步方法更像一个消息传递，一旦<br>开始就会立即返回，调用者就会执行后面的操作，异步方法通常会在另一<br>个线程执行 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/1.jpg" alt></p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>严格意义上并发是多个任务同时执行，并行是多个任务交替执行。并发只有<br>在多核CPU的系统中才可以实现 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/2.jpg" alt></p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区用来表示一种公共资源或者说是共享资源，多个线程都可以使用这个<br>资源，但是在一个时刻只有一个线程能够使用这个资源，其余线程都要等待</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞通常用来形容多线程间的相互影响。刚刚多个线程都想使用临界<br>区的资源，但是一个时刻只有一个线程能够使用，其余线程等待的情况就是<br>阻塞，非阻塞就是没有线程妨碍其他线程执行</p>
<h3 id="死锁、饥饿和活锁"><a href="#死锁、饥饿和活锁" class="headerlink" title="死锁、饥饿和活锁"></a>死锁、饥饿和活锁</h3><p>死锁就是多个线程相互竞争资源而造成的彼此阻塞 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/3.jpg" alt><br>饥饿是指一个或多个线程因为种种原因无法获得所需资源，导致一直无法执<br>行，比如线程的优先级过低，与死锁相比在未来一段时间内还是有可能解决<br>的。活锁就是获得资源但还未加上锁时就又将资源释放，这种情况比较少见</p>
<h3 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h3><p>由于临界区的存在，多线程的并发必须受到控制，根据控制并发的策略可以<br>把并发的级别进行分类，也就是阻塞和非阻塞两大部分。非阻塞包括无障碍<br>、无锁和无等待</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>一个线程是阻塞的，那么在其他线程释放资源之前当前线程无法继续执行，<br>当使用synchronized或重入锁得到的就是阻塞的线程，会对临界区进行加<br>锁，如果得不到锁就会挂起一直等待</p>
<h4 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h4><p>如果线程之间有优先级，那么线程的调度总是会倾向于满足高优先级的线程<br>，对于非公平锁，系统允许高优先级的线程插队，如果锁是公平的，那么线<br>程就会按照先来后到进行排队 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/4.jpg" alt></p>
<h4 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h4><p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍执行，那么不会因<br>为临界区的问题导致一方被挂起，也就是可以共同修改数据，可是这样的<br>话数据就可能出问题，对于无障碍线程来说一旦出现这种情况就会对所做<br>的修改进行回滚，确保数据安全，如果没有数据竞争发生那么就很顺利。<br>如果说阻塞的控制方式是悲观策略，系统认为两个线程有可能发生冲突因<br>此以保护数据为第一优先级，那么非阻塞调度就是乐观策略，认为两个线<br>程不会发生冲突，但是一旦检测到冲突就会回滚。一种可行的无障碍实现<br>可以依赖一个一致性标记来实现，线程在操作之前先读取这个标记，在操<br>作完成后再次读取这个标记，如果两者一致说明资源访问没有冲突，如果<br>不一致说明则需要重试操作</p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁的并行都是无障碍的，在无锁的情况下每个线程都尝试对临界区进行<br>访问，但是无锁的并发保证必然有一个线程能够在有限步完成操作离开临<br>界区。实际上每个线程都会读取一个数据副本互不干涉</p>
<h4 id="无等待"><a href="#无等待" class="headerlink" title="无等待"></a>无等待</h4><p>无锁只要求有一个线程在有限步内完成操作，而无等待在无锁的基础上更<br>进一步扩展，要求所有线程都要在有限步内完成。一种无等待结构是RCU，<br>基本思想是对数据的读不加控制，所有的读线程都是无等待的，在写数据<br>的时候先取得数据的副本，然后只修改副本，修改完成后回写数据。这里<br>我觉得应该没有用到一致性标记</p>
<h3 id="两个定律"><a href="#两个定律" class="headerlink" title="两个定律"></a>两个定律</h3><p>接下来分析并发比串行在性能上提高多少</p>
<h4 id="Amdahl"><a href="#Amdahl" class="headerlink" title="Amdahl"></a>Amdahl</h4><p>Amdahl定律定义了串行系统并行化后的加速比的计算公式和理论上限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加速比&#x3D;优化前系统耗时&#x2F;优化后系统耗时</span><br><span class="line">n表示处理器个数</span><br><span class="line">T表示时间，T1表示优化前耗时，Tn表示优化后耗时</span><br><span class="line">F表示程序中只能串行执行的比例</span><br><span class="line">Tn&#x3D;T1*(F+(1-F)&#x2F;n)</span><br><span class="line">加速比&#x3D;T1&#x2F;Tn&#x3D;1&#x2F;(F+(1-F)&#x2F;n)</span><br></pre></td></tr></table></figure>
<p>如果n趋于无穷那么加速比与系统的串行化率成反比，由此可知加速比取决<br>于处理器的数量和串行的比重</p>
<h4 id="Gustafson"><a href="#Gustafson" class="headerlink" title="Gustafson"></a>Gustafson</h4><p>Gustafson定律跟Amdahl的角度不同 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/5.jpg" alt></p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>接下来探讨一下JAVA的内存模型，如何保障并发程序下数据访问的一致性和安全<br>性，JAVA的关键技术点都是围绕多线程的原子性、可见性和有序性来建立的</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性是指一个操作不可中断，即使多个线程一起操作原子操作也不会受其余线<br>程影响。对于32位的系统long型数据的读写不是原子性的</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指一个线程修改了某一共享变量的值，其他线程是否能够立即知道这个<br>修改。对于串行程序来说可见性问题不存在，并行程序中缓存优化、硬件优化或<br>指令重排以及编译器优化都可能产生可见性问题</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性问题的原因是因为程序在执行时可能会进行指令重排，重排后的指令与原<br>指令的顺序未必一致，但是一定可以保证串行语义的一致性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a&#x3D;0;</span><br><span class="line">boolean flag&#x3D;false;</span><br><span class="line">public void writer()&#123;</span><br><span class="line">	a&#x3D;1;</span><br><span class="line">	flag&#x3D;true;</span><br><span class="line">&#125;</span><br><span class="line">public void reader()&#123;</span><br><span class="line">	if(flag)&#123;</span><br><span class="line">		int i&#x3D;a+1;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程A首先执行writer方法，接着线程B执行reader方法，如果发生指令重排<br><img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/6.jpg" alt><br>接下来分析一下为什么会有指令重排。一般来说一条指令的执行分为5步，每个步骤<br>涉及的硬件也不同，学过计算机组成知道流水线技术执行指令可以极大提高效率 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/7.jpg" alt><br>但是一旦发生中断所有的硬件设备都会进入一个停顿器，再次满载又需要几个周期<br>性能损失较大时，所以指令重排就是用来减少中断 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/8.JPG" alt><br>这个X就表示中断，也就是说ADD在这里停顿了一下，因为R2的数据还没有准备好<br>，ADD必须进行一次等待操作，由于ADD的延迟导致后面的所有操作都要慢一个节<br>拍。接下来看一个跟复杂的情况 a=b+c d=e-f <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/9.jpg" alt><br>如果将指令重新排序就可以消除这些停顿 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/10.jpg" alt> <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/11.jpg" alt></p>
<h4 id="重排规则"><a href="#重排规则" class="headerlink" title="重排规则"></a>重排规则</h4><p>以下原则是指令重排不能违背的<br>顺序执行原则：一个线程内保证语义的串行性</p>
<ol>
<li>volatile规则：volatile变量的写，先发生于读</li>
<li>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前</li>
<li>传递性：A先于B，B先于C，那么A必先于C</li>
<li>线程的start方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结(Thread.join())</li>
<li>线程的中断(interrupt())先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法</li>
</ol>
<h2 id="JAVA并行程序基础"><a href="#JAVA并行程序基础" class="headerlink" title="JAVA并行程序基础"></a>JAVA并行程序基础</h2><p>进程是程序的基本执行实体，比如Windows中后缀为.exe的文件，双击执行时就<br>开启了一个进程，进程中又有若干线程，线程也叫做轻量级进程，线程间切换和<br>调度的成本远远小于进程 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/12.jpg" alt></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h4><p>一般来说线程执行完后就正常结束，不过一些服务器后台线程可能会常驻系统，<br>它们的执行体本身就是一个无穷循环。Thead提供了一个stop方法关闭线程，但<br>这个方法已经不推荐使用，可能导致数据不一致问题，因为stop会直接导致锁<br>的释放 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/13.jpg" alt></p>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>严格讲线程中断并不会使线程立即退出，而是给线程发送一个通知告知线程希望<br>你退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断线程 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt() </span><br><span class="line"><span class="comment">// 判断是否被中断 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> Thread.isInterrupted() </span><br><span class="line"><span class="comment">// 判断是否被中断，并清除当前中断状态isinterrupt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> Thread.interrupted()</span><br></pre></td></tr></table></figure>

<h2 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock锁由上次成功锁定并且尚未解锁的线程拥有，是一个可重入且独<br>占式的锁。与synchronized关键字相比更加灵活强大，重入锁的意思就是这种锁<br>能反复进入，但是只限于一个线程。注意ReentrantLock锁的并不是Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁定几个就要释放几个</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	lock.lock();	</span><br><span class="line">	lock.lock();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重入锁的常用处理框架如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  </span><br><span class="line">     <span class="comment">// 当前执行代码的线程尝试获取锁对象，如果当前锁对象被其他线程获取，则陷入阻塞状态</span></span><br><span class="line">	 <span class="comment">// 保证了在同一时刻只能有一个线程进入 try 代码块中执行代码，即实现线程同步</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// do something...</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock() <span class="comment">// 最后一定记得释放锁对象，不然可能导致死锁</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><p>接下来使用ReentrantLock实现抢车票同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">10</span>; <span class="comment">// 10 张火车票</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">/*注意这个地方一定要加if判断，可以把sleep方法去掉测试一下</span></span><br><span class="line"><span class="comment">			例如线程1进入sell方法，此时tickets是1，然后线程切换到线程2</span></span><br><span class="line"><span class="comment">			因为线程2从主内存中中读取的tickets依然是1，所以线程2通过</span></span><br><span class="line"><span class="comment">			while的判断，只不过目前无法进入sell方法，线程1又切回到sell</span></span><br><span class="line"><span class="comment">			方法执行完tickets为0时解锁，此时主内存已经更新为0，所以if判断</span></span><br><span class="line"><span class="comment">			就表示再次从主内存中读取tickets的值此时已经是0所以不会继续</span></span><br><span class="line"><span class="comment">			执行以下操作</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了第 "</span> </span><br><span class="line">			+ tickets-- + <span class="string">" 张票"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 开启 5 个线程售票</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="string">"窗口"</span> + (i+<span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						sell();</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>在等待锁的过程中，程序可以根据需要取消对锁的请求。比如两个线程使<br>用lockInterruptibly()方法加锁造成死锁时，如果其中一个线程调用<br>interrupt方法将导致线程中断，此时该线程会停止申请锁并释放已经<br>获得的锁退出</p>
<h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><p>除了等待外部通知，还有一种避免死锁的方式就是限时等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前执行代码的线程尝试获取锁，如果获取失败（当前锁已经被其他线程所拥有）</span></span><br><span class="line"><span class="comment">// 当前执行代码的线程会陷入阻塞，直到这个锁对象被其所拥有的线程释放才会从阻塞状态唤醒</span></span><br><span class="line"><span class="keyword">void</span> lock​() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程尝试获取当前锁，如果获取成功，那么返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment">// 和 lock 方法的区别在于当前线程获取锁失败时不会陷入阻塞状态</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock​() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前执行代码的线程在参数给定的时间内不断获取这个锁对象</span></span><br><span class="line"><span class="comment">// 如果在参数给定时间内没有获取这个锁对象, 该方法返回 false 并且当前线程继续往下执行。</span></span><br><span class="line"><span class="comment">// 如果当前执行代码的线程已经被中断，那么方法会抛出一个 InterruptedException 异常，</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock​(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁按照线程申请锁的先后顺序被获取，不会产生饥饿现象，synchronized<br>产生的锁是非公平的，会根据优先级挑选，具有随机性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock.Sync sync;</span><br><span class="line">	<span class="comment">//不传参数是非公平锁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> ReentrantLock.NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*根据传入的参数，来判断是创建公平锁还是非公平锁</span></span><br><span class="line"><span class="comment">    FairSync 和NonfairSync都是ReentrantLock的内部类*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (ReentrantLock.Sync)(fair ? <span class="keyword">new</span> ReentrantLock.FairSync() </span><br><span class="line">        	: <span class="keyword">new</span> ReentrantLock.NonfairSync());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock的源码其余方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询当前锁对象是否被任意一个线程拥有</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询当前锁对象是否被当前执行代码的线程拥有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前执行代码的线程尝试获取锁，如果被其他线程获取，则等待其他线程解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与lock方法的区别在于获取失败则不会等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>Condition与wait()和notify()方法的作用大致相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个 Condition 实例对象用来实现锁的功能</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同 Object.wait() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 和 Object.wait(long time, TimeUnit unit) 方法一样</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	await​<span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 当前线程释放锁资源，陷入等待，时间为参数指定的纳秒数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> awaitNanos​<span class="params">(<span class="keyword">long</span> nanosTimeout)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当前线程释放锁资源，陷入等待状态，</span></span></span><br><span class="line"><span class="function"><span class="comment">// 直到其他线程调用该对象的 signal 、signalAl 方法、等待时间过去或者当前线程发生中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	awaitUntil​<span class="params">(Date deadline)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Wakes up one waiting thread. 相当于 Object.notify 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// Wakes up all waiting threads. 相当于 Object.notifyAll 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量是为多线程协作提供更强大的控制方法，内部锁synchronized和重入锁<br>ReentrantLock一次都只允许一个线程访问一个资源，信号量可以指定多个线<br>程同时访问一个资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Semaphore.Sync sync;</span><br><span class="line">    <span class="comment">//指定多少个许可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Semaphore.NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二个参数指定是否公平</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (Semaphore.Sync)(fair ? <span class="keyword">new</span> Semaphore.FairSync(permits) : </span><br><span class="line">        	<span class="keyword">new</span> Semaphore.NonfairSync(permits));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从此信号量获取一个许可，在提供一个许可前一直将线程阻塞或当前线程被中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与acquire类似但不响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放一个许可，将其返回给信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>读写分离锁能够有效减少锁竞争。比如线程A1 A2 A3进行写操作，线程B1 B2<br>B3 进行读操作，如果使用重入锁或内部锁理论上所有的读之间、读与写之间、<br>写与写之间都是串行操作，当B1进行读时B2 B3都需要等待锁，读写锁能够使<br>多个线程同时读，但是其余操作依然需要等待</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>称为倒计时器，让一个线程等待直到倒计时结束再开始执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数count为计数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;  &#125;;</span><br><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"></span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="CycliBarrier"><a href="#CycliBarrier" class="headerlink" title="CycliBarrier"></a>CycliBarrier</h4><p>可以理解为循环栅栏，实现线程间的计数等待</p>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>是一个非常方便的线程阻塞工具，可以在线程内任意位置让线程阻塞</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>ThreadPoolExecutor表示一个线程池，Executors类表示线程池工厂，通过<br>Executors可以取得一个拥有特定功能的线程池 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/14.jpg" alt></p>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>这个类类似线程池的工厂，用于产生各种线程池，Java5以前需要手动实现线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*创建一个可重用、有固定线程数的线程池，当一个新任务提交时如果</span></span><br><span class="line"><span class="comment">	  线程池有空闲线程则立即执行否则任务会暂时存在一个任务队列中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, </span><br><span class="line">        	TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个只有单线程的线程池，相当于newFixedThreadPool(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Executors.FinalizableDelegatedExecutorService(</span><br><span class="line">        	<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">        	<span class="keyword">new</span> LinkedBlockingQueue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回一个可根据实际情况调整线程数量的线程池，线程池中的线程数量</span></span><br><span class="line"><span class="comment">      不确定，如果有空闲线程可复用那么优先使用可复用的线程，如果所有</span></span><br><span class="line"><span class="comment">      线程都在工作但有新任务提交则会创建新的线程，线程执行完后会复用</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">2147483647</span>, <span class="number">60L</span>, TimeUnit.SECONDS, </span><br><span class="line">        	<span class="keyword">new</span> SynchronousQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上创建线程池的方法都返回一个ThreadPoolExecutor对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> corePoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">		TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">		BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">		RejectedExecutionHandler handler)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, </span><br><span class="line">        	workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分析一下构造方法的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">线程池中的最大核心线程数，默认情况下线程池是空的，没有线程，只有在有任务</span><br><span class="line">提交到线程池中时才会创建线程，如果调用线程池对象的prestartAllCoreThread() </span><br><span class="line">方法，那么线程池会提前创建好所有的核心线程</span><br><span class="line">corePoolSize</span><br><span class="line"></span><br><span class="line">线程池中允许创建的最大线程数，上文所说的非核心线程数为 </span><br><span class="line">maximumPoolSize-corePoolSize ，即为最大线程数减去核心线程数</span><br><span class="line">maximumPoolSize</span><br><span class="line"></span><br><span class="line">线程池中非核心线程允许闲置的最长时间，超过这个时间的非核心线程将会被回收，</span><br><span class="line">对于任务很多并且每个任务处理时间较短的的情况，可以适当提升</span><br><span class="line">keepAliveTime参数来提高线程利用率。当设置 allowCoreThreadTimeOut </span><br><span class="line">属性为true时，keepAliveTime参数也会作用到核心线程上</span><br><span class="line">keepAliveTime</span><br><span class="line"></span><br><span class="line">keepAliveTime 参数的时间单位</span><br><span class="line">（天：DAYS、小时：HOURS、分钟：MINUTES、秒：SECONDS、毫秒：MILLISENDS 等）</span><br><span class="line">unit</span><br><span class="line"></span><br><span class="line">任务队列，被提交当尚未被执行的任务，用于存放Runnnable对象</span><br><span class="line">workQueue</span><br><span class="line"></span><br><span class="line">创建线程的工厂，一般情况使用默认的即可</span><br><span class="line">threadFactory</span><br><span class="line"></span><br><span class="line">饱和策略，即为当任务队列和线程池中线程数均达到饱和时采取的应对策略，</span><br><span class="line">默认是 AbordPolicy，表示无法处理新的任务，</span><br><span class="line">并在有新任务提交时抛出 RejectedExecutionException 异常，此外还有 3 中策略：</span><br><span class="line">1、CallerRunnsPolicy：使用提交该任务的线程来处理此任务</span><br><span class="line">2、DiscardPolicy：不执行该任务，并将该任务删除</span><br><span class="line">3、DiscardOldestPolicy：丢弃队列中最近的任务，并执行当前提交的任务</span><br><span class="line">handler</span><br></pre></td></tr></table></figure>
<p>workQueue指被提交但未执行的任务队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">数组构成的有界阻塞队列，即储存元素的数据结构是数组，按照先进先出的顺序</span><br><span class="line">对元素排序，创建时需要指定队列的最大容量，默认情况不保证线程公平的访问</span><br><span class="line">原则，公平即先被阻塞的线程在唤醒后先获得锁资源继续未完成的操作，也可以</span><br><span class="line">不加第二个参数，默认是非公平锁。</span><br><span class="line">使用有界的任务队列时，如果有新的任务需要执行，如果线程池实际线程数量</span><br><span class="line">小于核心线程数，则会优先创建线程，若大于核心线程数则会将任务加入等待</span><br><span class="line">队列，如果队列已满则在不超过总线程数的情况下创建线程，如果线程数大于</span><br><span class="line">最大线程数就是执行拒绝策略</span><br><span class="line">ArrayBlockingQueue queue &#x3D; new ArrayBlockingQueue(1000, true); </span><br><span class="line"></span><br><span class="line">链表构成的无界阻塞队列，即储存元素的数据结构是链表，当有新的任务到来</span><br><span class="line">时如果线程数小于核心线程数就会创建新线程，线程数达到核心线程数后就不</span><br><span class="line">会继续创建线程，如果有新的任务但没有空闲线程就会加入队列等待</span><br><span class="line">LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">支持按某个优先级对元素进行排序的无界阻塞队列，默认情况下使用升序排序，</span><br><span class="line">通过自定义compareTo方法实现元素自定义排序，或者创建队列的时候传入</span><br><span class="line">参数Compare来对元素排序</span><br><span class="line">PriorityBlockingQueue</span><br><span class="line"></span><br><span class="line">使用优先队列实现的无界阻塞队列，存储的元素必须实现Delay接口，按照</span><br><span class="line">getDelay方法的返回值进行排序</span><br><span class="line">DelayQueue</span><br><span class="line"></span><br><span class="line">不储存元素的阻塞队列，每个生产者线程必须等待另一个消费者线程的执行，</span><br><span class="line">每个消费者个线程必须等待另一个生产者线程的执行，因此队列中没有元素</span><br><span class="line">SynchronousQueue</span><br></pre></td></tr></table></figure>
<p>刚刚提到ArrayBlockingQueue时有一个公平原则，注意notify调用后锁对象<br>依然由调用notify的那个线程持有，原先被阻塞的线程必须等到锁对象释放才<br>可以抢占锁资源，以下的例子可以说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">wa</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"开始等待"</span>);</span><br><span class="line">            wait();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"等待结束"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ov</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"准备唤起"</span>);</span><br><span class="line">            notify();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"唤起线程"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+</span><br><span class="line">            	<span class="string">"唤起后wa执行了吗"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                wa();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                ov();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleTon a=<span class="keyword">new</span> SingleTon();</span><br><span class="line">        a.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程1开始等待</span><br><span class="line">线程2准备唤起</span><br><span class="line">线程2唤起线程</span><br><span class="line">线程2唤起后wa执行了吗</span><br><span class="line">线程1等待结束</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/">https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/12/10/ComputerNetwork2/"><span>计算机网络2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/';
  this.page.identifier = '2020/12/21/Java并发/';
  this.page.title = 'Java并发';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1608455550997&amp;di=bdcbdc0e59e4cf9547a1b4280b5f05ec&amp;imgtype=0&amp;src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2019-02-20%2F5c6d045c8c9be.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>