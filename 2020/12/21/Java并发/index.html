<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java并发"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java并发 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行世界"><span class="toc-number">2.</span> <span class="toc-text">并行世界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步"><span class="toc-number">2.1.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发和并行"><span class="toc-number">2.2.</span> <span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区"><span class="toc-number">2.3.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞和非阻塞"><span class="toc-number">2.4.</span> <span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁、饥饿和活锁"><span class="toc-number">2.5.</span> <span class="toc-text">死锁、饥饿和活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发级别"><span class="toc-number">2.6.</span> <span class="toc-text">并发级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞"><span class="toc-number">2.6.1.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无饥饿"><span class="toc-number">2.6.2.</span> <span class="toc-text">无饥饿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无障碍"><span class="toc-number">2.6.3.</span> <span class="toc-text">无障碍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无锁"><span class="toc-number">2.6.4.</span> <span class="toc-text">无锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无等待"><span class="toc-number">2.6.5.</span> <span class="toc-text">无等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个定律"><span class="toc-number">2.7.</span> <span class="toc-text">两个定律</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Amdahl"><span class="toc-number">2.7.1.</span> <span class="toc-text">Amdahl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gustafson"><span class="toc-number">2.7.2.</span> <span class="toc-text">Gustafson</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM"><span class="toc-number">2.8.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性"><span class="toc-number">2.8.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可见性"><span class="toc-number">2.8.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序性"><span class="toc-number">2.8.3.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重排规则"><span class="toc-number">2.8.4.</span> <span class="toc-text">重排规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA并行程序基础"><span class="toc-number">3.</span> <span class="toc-text">JAVA并行程序基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">3.1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的终止"><span class="toc-number">3.1.1.</span> <span class="toc-text">线程的终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程中断"><span class="toc-number">3.1.2.</span> <span class="toc-text">线程中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐蔽的错误"><span class="toc-number">3.2.</span> <span class="toc-text">隐蔽的错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#并发下的ArrayList"><span class="toc-number">3.2.1.</span> <span class="toc-text">并发下的ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发下的HashMap"><span class="toc-number">3.2.2.</span> <span class="toc-text">并发下的HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#错误加锁"><span class="toc-number">3.2.3.</span> <span class="toc-text">错误加锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK并发包"><span class="toc-number">4.</span> <span class="toc-text">JDK并发包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">4.1.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实例演示"><span class="toc-number">4.1.1.</span> <span class="toc-text">实例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中断响应"><span class="toc-number">4.1.2.</span> <span class="toc-text">中断响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁申请等待限时"><span class="toc-number">4.1.3.</span> <span class="toc-text">锁申请等待限时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公平锁"><span class="toc-number">4.1.4.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-number">4.1.5.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">4.1.6.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReadWriteLock"><span class="toc-number">4.1.7.</span> <span class="toc-text">ReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">4.1.8.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CycliBarrier"><span class="toc-number">4.1.9.</span> <span class="toc-text">CycliBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LockSupport"><span class="toc-number">4.1.10.</span> <span class="toc-text">LockSupport</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-number">4.2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable和Future"><span class="toc-number">4.2.1.</span> <span class="toc-text">Callable和Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors"><span class="toc-number">4.2.2.</span> <span class="toc-text">Executors</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">54</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java并发</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/21/Java%E5%B9%B6%E5%8F%91/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/21/Java并发/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java高并发程序设计》</p>
<h2 id="并行世界"><a href="#并行世界" class="headerlink" title="并行世界"></a>并行世界</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步通常用来形容一次方法调用。同步方法一旦开始，调用者必须等<br>到方法调用返回后才能继续后面的操作。异步方法更像一个消息传递，一旦<br>开始就会立即返回，调用者就会执行后面的操作，异步方法通常会在另一<br>个线程执行 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/1.jpg" alt></p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>严格意义上并行是多个任务同时执行，并发是多个任务交替执行。并发只有<br>在多核CPU的系统中才可以实现 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/2.jpg" alt></p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区用来表示一种公共资源或者说是共享资源，多个线程都可以使用这个<br>资源，但是在一个时刻只有一个线程能够使用这个资源，其余线程都要等待</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞通常用来形容多线程间的相互影响。刚刚多个线程都想使用临界<br>区的资源，但是一个时刻只有一个线程能够使用，其余线程等待的情况就是<br>阻塞，非阻塞就是没有线程妨碍其他线程执行</p>
<h3 id="死锁、饥饿和活锁"><a href="#死锁、饥饿和活锁" class="headerlink" title="死锁、饥饿和活锁"></a>死锁、饥饿和活锁</h3><p>死锁就是多个线程相互竞争资源而造成的彼此阻塞 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/3.jpg" alt><br>饥饿是指一个或多个线程因为种种原因无法获得所需资源，导致一直无法执<br>行，比如线程的优先级过低，与死锁相比在未来一段时间内还是有可能解决<br>的。活锁指线程一直处于运行状态没有阻塞，一直尝试获取锁但只是在做无<br>用功</p>
<h3 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h3><p>由于临界区的存在，多线程的并发必须受到控制，根据控制并发的策略可以<br>把并发的级别进行分类，也就是阻塞和非阻塞两大部分。非阻塞包括无障碍<br>、无锁和无等待</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>一个线程是阻塞的，那么在其他线程释放资源之前当前线程无法继续执行，<br>当使用synchronized或重入锁得到的就是阻塞的线程，会对临界区进行加<br>锁，如果得不到锁就会挂起一直等待</p>
<h4 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h4><p>如果线程之间有优先级，那么线程的调度总是会倾向于满足高优先级的线程<br>，对于非公平锁，系统允许高优先级的线程插队，如果锁是公平的，那么线<br>程就会按照先来后到进行排队 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/4.jpg" alt></p>
<h4 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h4><p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍执行，那么不会因<br>为临界区的问题导致一方被挂起，也就是可以共同修改数据，可是这样的<br>话数据就可能出问题，对于无障碍线程来说一旦出现这种情况就会对所做<br>的修改进行回滚，确保数据安全，如果没有数据竞争发生那么就很顺利。<br>如果说阻塞的控制方式是悲观策略，系统认为两个线程有可能发生冲突因<br>此以保护数据为第一优先级，那么非阻塞调度就是乐观策略，认为两个线<br>程不会发生冲突，但是一旦检测到冲突就会回滚。一种可行的无障碍实现<br>可以依赖一个一致性标记来实现，线程在操作之前先读取这个标记，在操<br>作完成后再次读取这个标记，如果两者一致说明资源访问没有冲突，如果<br>不一致说明则需要重试操作</p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁的并行都是无障碍的，在无锁的情况下每个线程都尝试对临界区进行<br>访问，但是无锁的并发保证必然有一个线程能够在有限步完成操作离开临<br>界区。实际上每个线程都会读取一个数据副本互不干涉</p>
<h4 id="无等待"><a href="#无等待" class="headerlink" title="无等待"></a>无等待</h4><p>无锁只要求有一个线程在有限步内完成操作，而无等待在无锁的基础上更<br>进一步扩展，要求所有线程都要在有限步内完成。一种无等待结构是RCU，<br>基本思想是对数据的读不加控制，所有的读线程都是无等待的，在写数据<br>的时候先取得数据的副本，然后只修改副本，修改完成后回写数据。这里<br>我觉得应该没有用到一致性标记</p>
<h3 id="两个定律"><a href="#两个定律" class="headerlink" title="两个定律"></a>两个定律</h3><p>接下来分析并发比串行在性能上提高多少</p>
<h4 id="Amdahl"><a href="#Amdahl" class="headerlink" title="Amdahl"></a>Amdahl</h4><p>Amdahl定律定义了串行系统并行化后的加速比的计算公式和理论上限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加速比&#x3D;优化前系统耗时&#x2F;优化后系统耗时</span><br><span class="line">n表示处理器个数</span><br><span class="line">T表示时间，T1表示优化前耗时，Tn表示优化后耗时</span><br><span class="line">F表示程序中只能串行执行的比例</span><br><span class="line">Tn&#x3D;T1*(F+(1-F)&#x2F;n)</span><br><span class="line">加速比&#x3D;T1&#x2F;Tn&#x3D;1&#x2F;(F+(1-F)&#x2F;n)</span><br></pre></td></tr></table></figure>
<p>如果n趋于无穷那么加速比与系统的串行化率成反比，由此可知加速比取决<br>于处理器的数量和串行的比重</p>
<h4 id="Gustafson"><a href="#Gustafson" class="headerlink" title="Gustafson"></a>Gustafson</h4><p>Gustafson定律跟Amdahl的角度不同 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/5.jpg" alt></p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>接下来探讨一下JAVA的内存模型，如何保障并发程序下数据访问的一致性和安全<br>性，JAVA的关键技术点都是围绕多线程的原子性、可见性和有序性来建立的</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性是指一个操作不可中断，即使多个线程一起操作原子操作也不会受其余线<br>程影响。对于32位的系统long型数据的读写不是原子性的</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指一个线程修改了某一共享变量的值，其他线程是否能够立即知道这个<br>修改。对于串行程序来说可见性问题不存在，并行程序中缓存优化、硬件优化或<br>指令重排以及编译器优化都可能产生可见性问题</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性问题的原因是因为程序在执行时可能会进行指令重排，重排后的指令与原<br>指令的顺序未必一致，但是一定可以保证串行语义的一致性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a&#x3D;0;</span><br><span class="line">boolean flag&#x3D;false;</span><br><span class="line">public void writer()&#123;</span><br><span class="line">	a&#x3D;1;</span><br><span class="line">	flag&#x3D;true;</span><br><span class="line">&#125;</span><br><span class="line">public void reader()&#123;</span><br><span class="line">	if(flag)&#123;</span><br><span class="line">		int i&#x3D;a+1;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程A首先执行writer方法，接着线程B执行reader方法，如果发生指令重排<br><img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/6.jpg" alt><br>接下来分析一下为什么会有指令重排。一般来说一条指令的执行分为5步，每个步骤<br>涉及的硬件也不同，学过计算机组成知道流水线技术执行指令可以极大提高效率 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/7.jpg" alt><br>但是一旦发生中断所有的硬件设备都会进入一个停顿器，再次满载又需要几个周期<br>性能损失较大时，所以指令重排就是用来减少中断 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/8.JPG" alt><br>这个X就表示中断，也就是说ADD在这里停顿了一下，因为R2的数据还没有准备好<br>，ADD必须进行一次等待操作，由于ADD的延迟导致后面的所有操作都要慢一个节<br>拍。接下来看一个跟复杂的情况 a=b+c d=e-f <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/9.jpg" alt><br>如果将指令重新排序就可以消除这些停顿 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/10.jpg" alt> <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/11.jpg" alt></p>
<h4 id="重排规则"><a href="#重排规则" class="headerlink" title="重排规则"></a>重排规则</h4><p>以下原则是指令重排不能违背的<br>顺序执行原则：一个线程内保证语义的串行性</p>
<ol>
<li>volatile规则：volatile变量的写，先发生于读</li>
<li>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前</li>
<li>传递性：A先于B，B先于C，那么A必先于C</li>
<li>线程的start方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结(Thread.join())</li>
<li>线程的中断(interrupt())先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法</li>
</ol>
<h2 id="JAVA并行程序基础"><a href="#JAVA并行程序基础" class="headerlink" title="JAVA并行程序基础"></a>JAVA并行程序基础</h2><p>进程是程序的基本执行实体，比如Windows中后缀为.exe的文件，双击执行时就<br>开启了一个进程，进程中又有若干线程，线程也叫做轻量级进程，线程间切换和<br>调度的成本远远小于进程 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/12.jpg" alt></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h4><p>一般来说线程执行完后就正常结束，不过一些服务器后台线程可能会常驻系统，<br>它们的执行体本身就是一个无穷循环。Thead提供了一个stop方法关闭线程，但<br>这个方法已经不推荐使用，可能导致数据不一致问题，因为stop会直接导致锁<br>的释放，并终止线程 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/13.jpg" alt></p>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>严格讲线程中断并不会使线程立即退出，而是给线程发送一个通知告知线程希望<br>你退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断线程，是一个实例方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt() </span><br><span class="line"><span class="comment">// 判断是否被中断 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> Thread.isInterrupted() </span><br><span class="line"><span class="comment">// 判断是否被中断，并清除当前中断状态isinterrupt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> Thread.interrupted()</span><br></pre></td></tr></table></figure>
<h3 id="隐蔽的错误"><a href="#隐蔽的错误" class="headerlink" title="隐蔽的错误"></a>隐蔽的错误</h3><h4 id="并发下的ArrayList"><a href="#并发下的ArrayList" class="headerlink" title="并发下的ArrayList"></a>并发下的ArrayList</h4><p>ArrayList是一个线程不安全的容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayThread</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> ArrayList&lt;Integer&gt; al=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">				al.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">		Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t1.join();</span><br><span class="line">		t2.join();</span><br><span class="line">		System.out.println(al.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上程序可能会出现三种结果</p>
<ol>
<li>正常结束，ArrayList确实是200000，说明并行问题有时并不会表现出来</li>
<li>抛出异常，这是因为ArrayList在扩容时内部一致性被破坏，由于没有锁<br>的保护另一个线程访问到不一致的内部状态，导致越界问题</li>
<li>正常结束，值小于200000，两个线程堆同一个位置赋值导致</li>
</ol>
<p>线程安全的Vector可以代替ArrayList</p>
<h4 id="并发下的HashMap"><a href="#并发下的HashMap" class="headerlink" title="并发下的HashMap"></a>并发下的HashMap</h4><p>HashMap的问题比ArrayList更诡异</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayThread</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.start=start;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;<span class="number">100000</span>;i+=<span class="number">2</span>)</span><br><span class="line">				map.put(Integer.toString(i),Integer.toBinaryString(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread(<span class="number">0</span>));</span><br><span class="line">		Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread(<span class="number">1</span>));</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t1.join();</span><br><span class="line">		t2.join();</span><br><span class="line">		System.out.println(map.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种正常结束的情况与ArrayList很像，还可能出现第三种情况就是程序永远无<br>法结束。可能会将链表变成环，可以使用线程安全的ConcurrentHashMap</p>
<h4 id="错误加锁"><a href="#错误加锁" class="headerlink" title="错误加锁"></a>错误加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Integer i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(i)&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对i加锁看起来没有问题，但是Integer属于不变对象，一旦创建就不可能被修改<br>，i++在真实执行时变成 i=Integer.valueOf(i.intValue()+1)，也就是多个<br>线程并没有对同一个对象加锁</p>
<h2 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock锁由上次成功锁定并且尚未解锁的线程拥有，是一个可重入且独<br>占式的锁。与synchronized关键字相比更加灵活强大，重入锁的意思就是这种锁<br>能反复进入，但是只限于一个线程。注意ReentrantLock锁的并不是Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁定几个就要释放几个</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	lock.lock();	</span><br><span class="line">	lock.lock();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重入锁的常用处理框架如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  </span><br><span class="line">     <span class="comment">// 当前执行代码的线程尝试获取锁对象，如果当前锁对象被其他线程获取，则陷入阻塞状态</span></span><br><span class="line">	 <span class="comment">// 保证了在同一时刻只能有一个线程进入 try 代码块中执行代码，即实现线程同步</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// do something...</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock() <span class="comment">// 最后一定记得释放锁对象，不然可能导致死锁</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><p>接下来使用ReentrantLock实现抢车票同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">10</span>; <span class="comment">// 10 张火车票</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">/*注意这个地方一定要加if判断，可以把sleep方法去掉测试一下</span></span><br><span class="line"><span class="comment">			例如线程1进入sell方法，此时tickets是1，然后线程切换到线程2</span></span><br><span class="line"><span class="comment">			因为线程2从主内存中中读取的tickets依然是1，所以线程2通过</span></span><br><span class="line"><span class="comment">			while的判断，只不过目前无法进入sell方法，线程1又切回到sell</span></span><br><span class="line"><span class="comment">			方法执行完tickets为0时解锁，此时主内存已经更新为0，所以if判断</span></span><br><span class="line"><span class="comment">			就表示再次从主内存中读取tickets的值此时已经是0所以不会继续</span></span><br><span class="line"><span class="comment">			执行以下操作</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了第 "</span> </span><br><span class="line">			+ tickets-- + <span class="string">" 张票"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 开启 5 个线程售票</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="string">"窗口"</span> + (i+<span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						sell();</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>在等待锁的过程中，程序可以根据需要取消对锁的请求。比如两个线程使<br>用lockInterruptibly()方法加锁造成死锁时，如果其中一个线程调用<br>interrupt方法将导致线程中断，此时该线程会停止申请锁并释放已经<br>获得的锁然后抛出异常</p>
<h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><p>除了等待外部通知，还有一种避免死锁的方式就是限时等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前执行代码的线程尝试获取锁，如果获取失败（当前锁已经被其他线程所拥有）</span></span><br><span class="line"><span class="comment">// 当前执行代码的线程会陷入阻塞，直到这个锁对象被其所拥有的线程释放才会从阻塞状态唤醒</span></span><br><span class="line"><span class="keyword">void</span> lock​() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程尝试获取当前锁，如果获取成功，那么返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment">// 和lock方法的区别在于当前线程获取锁失败时不会陷入阻塞状态，而是继续执行</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock​() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前执行代码的线程在参数给定的时间内不断获取这个锁对象</span></span><br><span class="line"><span class="comment">// 如果在参数给定时间内没有获取这个锁对象, 该方法返回 false 并且当前线程继续往下执行。</span></span><br><span class="line"><span class="comment">// 如果当前执行代码的线程已经被中断，那么方法会抛出一个 InterruptedException 异常，</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock​(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁按照线程申请锁的先后顺序被获取，不会产生饥饿现象，synchronized<br>产生的锁是非公平的，会根据优先级挑选，具有随机性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock.Sync sync;</span><br><span class="line">	<span class="comment">//不传参数是非公平锁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> ReentrantLock.NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*根据传入的参数，来判断是创建公平锁还是非公平锁</span></span><br><span class="line"><span class="comment">    FairSync 和NonfairSync都是ReentrantLock的内部类*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (ReentrantLock.Sync)(fair ? <span class="keyword">new</span> ReentrantLock.FairSync() </span><br><span class="line">        	: <span class="keyword">new</span> ReentrantLock.NonfairSync());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock的源码其余方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询当前锁对象是否被任意一个线程拥有</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询当前锁对象是否被当前执行代码的线程拥有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前执行代码的线程尝试获取锁，如果被其他线程获取，则等待其他线程解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与lock方法的区别在于获取失败则不会等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>Condition与wait()和notify()方法的作用大致相同，当使用相应方法<br>时要求线程持有相应重入锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个 Condition 实例对象用来实现锁的功能</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同 Object.wait() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 和 Object.wait(long time, TimeUnit unit) 方法一样</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	await​<span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 当前线程释放锁资源，陷入等待，时间为参数指定的纳秒数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> awaitNanos​<span class="params">(<span class="keyword">long</span> nanosTimeout)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当前线程释放锁资源，陷入等待状态，</span></span></span><br><span class="line"><span class="function"><span class="comment">// 直到其他线程调用该对象的 signal 、signalAl 方法、等待时间过去或者当前线程发生中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	awaitUntil​<span class="params">(Date deadline)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Wakes up one waiting thread. 相当于 Object.notify 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// Wakes up all waiting threads. 相当于 Object.notifyAll 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量是为多线程协作提供更强大的控制方法，内部锁synchronized和重入锁<br>ReentrantLock一次都只允许一个线程访问一个资源，信号量可以指定多个线<br>程同时访问一个资源，可以用于数据库连接，同时进行连接的线程有数量限制<br>，还可以用在停车场车位限制场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Semaphore.Sync sync;</span><br><span class="line">    <span class="comment">//指定多少个许可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Semaphore.NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二个参数指定是否公平</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (Semaphore.Sync)(fair ? <span class="keyword">new</span> Semaphore.FairSync(permits) : </span><br><span class="line">        	<span class="keyword">new</span> Semaphore.NonfairSync(permits));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从此信号量获取一个许可，在提供一个许可前一直将线程阻塞或当前线程被中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与acquire类似但不响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放一个许可，将其返回给信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来模拟一下停车场景，停车场容量10个车位，一个车走显示屏车位加1，<br>一个车进显示屏车位减一，如果减为0则车等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停车场同时容纳的车辆10</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟100辆车进入停车场</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"===="</span>+</span><br><span class="line">                        	Thread.currentThread().getName()+<span class="string">"来到停车场"</span>);</span><br><span class="line">                        <span class="keyword">if</span>(semaphore.availablePermits()==<span class="number">0</span>)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"车位不足，请耐心等待"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        semaphore.acquire();<span class="comment">//获取令牌尝试进入停车场</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        	<span class="string">"成功进入停车场"</span>);</span><br><span class="line">                        <span class="comment">//模拟车辆在停车场停留的时间</span></span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        	<span class="string">"驶出停车场"</span>);</span><br><span class="line">                        semaphore.release();<span class="comment">//释放令牌，腾出停车场车位</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+<span class="string">"号车"</span>);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>读写分离锁能够有效减少锁竞争。比如线程A1 A2 A3进行写操作，线程B1 B2<br>B3 进行读操作，如果使用重入锁或内部锁理论上所有的读之间、读与写之间、<br>写与写之间都是串行操作，当B1进行读时B2 B3都需要等待锁，读写锁能够使<br>多个线程同时读，但是其余操作依然需要等待。如果系统中读操作次数远远大<br>于写操作次数，则读写锁可以发挥最大功效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>称为倒计时器，让一个线程等待直到倒计时结束再开始执行，倒计时器一个<br>典型的场景是火箭发射，发射线程必须等待检查线程执行完后才能执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*count表示这个计数器的计数个数，每当一下线程执行完计数器的值就-1</span></span><br><span class="line"><span class="comment">当计数器的值为0表示所有线程执行完毕，然后在闭锁上等待的线程就可以工作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//将count值减1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>以下例子要求两个子线程都执行完后主线程才可以继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程开始执行…… ……"</span>);</span><br><span class="line">        <span class="comment">//第一个子线程执行</span></span><br><span class="line">        ExecutorService es1 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es1.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程："</span>+Thread.currentThread().</span><br><span class="line">                    	getName()+<span class="string">"执行"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es1.shutdown();</span><br><span class="line">        <span class="comment">//第二个子线程执行</span></span><br><span class="line">        ExecutorService es2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es2.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程："</span>+Thread.currentThread().</span><br><span class="line">                	getName()+<span class="string">"执行"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es2.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"等待两个线程执行完毕…… ……"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"两个子线程都执行完毕，继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CycliBarrier"><a href="#CycliBarrier" class="headerlink" title="CycliBarrier"></a>CycliBarrier</h4><p>可以理解为循环栅栏，实现线程间的计数等待，让一组线程相互等待，当所有<br>线程都到达某个屏障点后再进行后续的操作。可以用于多线程计数数据，最后<br>合并计数结果的场景 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/15.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//barrierAction表示当计数器一次计数完成后系统会执行的操作，parties是计数总数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties,Runnbale barrierAction)</span></span></span><br></pre></td></tr></table></figure>
<p>以下是一个实例场景，可以看到CycliBarrier可以重复使用，核心是reset功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,</span><br><span class="line">                <span class="keyword">new</span> BarrierRun(<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">7</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                        <span class="string">"\t 收集到第"</span>+ finalI +<span class="string">"颗龙珠"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"神龙吐出第"</span>+finalI+<span class="string">"颗龙珠"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag=flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"六老师召唤神龙结束，神龙走了"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"六老师召唤神龙"</span>);</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/16.jpg" alt> 接下来总结一下并发控制流程的工具类作用 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/17.jpg" alt></p>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>是一个非常方便的线程阻塞工具，可以在线程内任意位置让线程阻塞，相比<br>suspend，弥补由于resume 在前发生导致线程无法继续执行的情况，相比<br>wait方法不需要先获取某个对象的锁，也不会抛出中断异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span></span>; <span class="comment">// 暂停当前线程</span></span><br><span class="line"><span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line"><span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>; <span class="comment">// 无期限暂停当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span></span>; <span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span></span>; <span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>; <span class="comment">// 恢复当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接下来看一个实例场景，LockSupport 使用类似信号量的机制，为每一个线<br>程准备了一个许可，如果许可可用那park函数会立即返回，并消费这个许可<br>，如果许可不可用就会阻塞，unpark函数就是使得一个许可变为可用，即使<br>unpark发生在park之前也可以使下一次park操作立即返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">                System.out.println(<span class="string">"in "</span> + getName());</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"被中断了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"继续执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="comment">//t1中断之后park会立即返回，继续执行完剩下代码后t2就可以进入临界区</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>ThreadPoolExecutor表示一个线程池，Executors类表示线程池工厂，通过<br>Executors可以取得一个拥有特定功能的线程池 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/14.jpg" alt><br>参考 <a href="https://blog.csdn.net/anhenzhufeng/article/details/88870374" target="_blank" rel="noopener">https://blog.csdn.net/anhenzhufeng/article/details/88870374</a></p>
<h4 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a>Callable和Future</h4><p>通过Runnable接口创建多线程时，Thread类的作用就是把run方法包装成线<br>程执行体，Java只能将run方法包装成线程执行体，C#可以将任意方法都包<br>装成线程执行体，因此JDK5开始Java提供Callable接口，提供一个call方<br>法作为线程执行体，call方法比run方法功能更强大</p>
<ul>
<li>call方法可以有返回值</li>
<li>call方法可以声明异常</li>
</ul>
<p>callable不是Runnable 的子接口，所以不能直接作为 Thread的 target，而<br>且call有一个返回值。Future 接口来代表 callable 接口中call 方法的返回<br>值，并且Future 接口提供了一个FutureTask实现类，这个类实现了Runnable<br>接口可以作为target，而FutureTask 的构造方法又需要Callable接口作为传<br>入参数，而其 run方法会调用Callable 对象的call方法。当使用线程池对象的<br>submit方法向线程池提交任务时，该方法会返回一个Future类型对象，Future<br>接口提供了一些方法来获取向线程池提交的任务的执行状态和结果的信息，接下<br>来看一下Future的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消执行提交的对应任务，如果对应任务已经执行完成或者已经被取消或者</span></span><br><span class="line"><span class="comment">       是其他原因不能被取消，</span></span><br><span class="line"><span class="comment">     * 那该操作将会失败，否则的话提交的对应任务将不会被线程池中的线程执行。</span></span><br><span class="line"><span class="comment">     * 如果尝试取消的任务正在执行，那么通过参数来确定是否应该中断正在执行该任务的线程，</span></span><br><span class="line"><span class="comment">     * 如果为 false，那么将不会中断正在执行该任务的线程。</span></span><br><span class="line"><span class="comment">     * 在该方法返回之后，调用 isDone 方法会返回 true，</span></span><br><span class="line"><span class="comment">     * 调用 isCancalled 方法的返回值和该方法的返回值相同。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果提交的对应任务还没有完全执行完成之前就被取消了，那么</span></span><br><span class="line"><span class="comment">     方法会返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回任务是否完成：包括下面几种情况：</span></span><br><span class="line"><span class="comment">     * 1、任务正常执行完成</span></span><br><span class="line"><span class="comment">     * 2、执行过程发生异常</span></span><br><span class="line"><span class="comment">     * 3、任务被取消</span></span><br><span class="line"><span class="comment">     * 上面几种情况发生，方法均会返回 true，</span></span><br><span class="line"><span class="comment">     * 如果任务正在执行，或者还未执行，那么方法返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞调用该方法的线程，直到提交的对应任务执行完成之后，</span></span><br><span class="line"><span class="comment">     * 方法会返回一个泛型结果对象表示任务执行的结果，</span></span><br><span class="line"><span class="comment">     * 如果提交的任务是一个 Callable 类型的对象，那么返回 Callable </span></span><br><span class="line"><span class="comment">     对象的 call 方法的返回值，</span></span><br><span class="line"><span class="comment">     * 如果提交的任务是一个 Runnable 类型的对象，那么返回 Runnable 对象的 </span></span><br><span class="line"><span class="comment">     run 方法的返回值，即为 null。</span></span><br><span class="line"><span class="comment">     * 如果在调用线程阻塞的过程中发生了中断，那么方法抛出 InterruptedException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能同上面的重载方法，但是添加了一个条件, 即阻塞时间，</span></span><br><span class="line"><span class="comment">     * 该方法使得调用线程的阻塞时间不会超过参数指定的时间，</span></span><br><span class="line"><span class="comment">     * 如果在规定时间内对应任务没有运行完成，方法抛出一个 TimeoutException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下Callable接口的源码，有一个返回值作为结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看两个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Future 接口测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 向线程池中提交一个新的 Callable 类型的任务，提交之后会对任务对象进行包装</span></span><br><span class="line">        Future&lt;String&gt; task = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="comment">// 复写 call() 方法，线程池中线程最终会调用 call() 方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 执行线程休眠 5 秒钟</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 task.get() 获取执行结果，</span></span><br><span class="line">            <span class="comment">// 这里即为获取上述代码中 submit 方法提交的 Callable 中 </span></span><br><span class="line">            <span class="comment">//call() 方法的返回值，</span></span><br><span class="line">            <span class="comment">// 该方法会阻塞当前调用线程，直到任务执行完成后返回</span></span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"方法获取任务结果所用时间："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FutureTaskTest.startTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型形参类型与返回值类型相同</span></span><br><span class="line">FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;&gt;((Callable&lt;Integer&gt;)()-&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(Thread.currentThread.getName()+i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(Thread.currentThread.getName()+i);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="comment">/* 获得返回值，调用该方法将导致程序阻塞，必须等子线程结束才会得到返回</span></span><br><span class="line"><span class="comment">		值，也就是主线程会被阻塞，直到call方法结束并返回为止 */</span></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(task.get());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>这个类类似线程池的工厂，用于产生各种线程池，Java5以前需要手动实现线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*创建一个可重用、有固定线程数的线程池，当一个新任务提交时如果</span></span><br><span class="line"><span class="comment">	  线程池有空闲线程则立即执行否则任务会暂时存在一个任务队列中</span></span><br><span class="line"><span class="comment">	  核心线程数与总线程数一样，这符合固定大小的线程池不存在线程</span></span><br><span class="line"><span class="comment">	  数量动态变化的情况，使用LinkedBlockingQueue可以存放无限量</span></span><br><span class="line"><span class="comment">	  任务（不耗尽资源的情况下）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, </span><br><span class="line">        	TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个只有单线程的线程池，相当于newFixedThreadPool(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Executors.FinalizableDelegatedExecutorService(</span><br><span class="line">        	<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">        	<span class="keyword">new</span> LinkedBlockingQueue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回一个可根据实际情况调整线程数量的线程池，线程池中的线程数量</span></span><br><span class="line"><span class="comment">      不确定，如果有空闲线程可复用那么优先使用可复用的线程，如果所有</span></span><br><span class="line"><span class="comment">      线程都在工作但有新任务提交则会创建新的线程，线程执行完后会复用</span></span><br><span class="line"><span class="comment">      核心线程数为0，最大线程数无穷大。没有任务时线程池内无线程，当</span></span><br><span class="line"><span class="comment">      任务提交时线程池会使用空闲线程，若无空闲线程，此时核心线程为</span></span><br><span class="line"><span class="comment">      0，那么就会把任务加入SynchronousQueue队列，这是一种直接提交</span></span><br><span class="line"><span class="comment">      的队列，总会迫使线程池增加新的线程，空闲线程60s内会被回收，适用</span></span><br><span class="line"><span class="comment">      于处理大量需要立即处理并且每个任务耗时较少的任务集合</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">2147483647</span>, <span class="number">60L</span>, TimeUnit.SECONDS, </span><br><span class="line">        	<span class="keyword">new</span> SynchronousQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先简单看一下线程池的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.prinln(<span class="string">"xxx"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		MyTask task=<span class="keyword">new</span> MyTask();</span><br><span class="line">		ExecutorService es=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			es.submit(task);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上创建线程池的方法都返回一个ThreadPoolExecutor对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> corePoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">		TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">		BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">		RejectedExecutionHandler handler)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, </span><br><span class="line">        	workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分析一下构造方法的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">线程池中的最大核心线程数，默认情况下线程池是空的，没有线程，只有在有任务</span><br><span class="line">提交到线程池中时才会创建核心线程，即使有其他空闲的核心线程可以执行新任务</span><br><span class="line">也会创建新的核心线程，这一点一定要注意，当核心线程数等于corePoolSize的</span><br><span class="line">时候就不会继续创建核心线程了，如果调用线程池对象的prestartAllCoreThread() </span><br><span class="line">方法，那么线程池会提前创建好所有的核心线程</span><br><span class="line">corePoolSize</span><br><span class="line"></span><br><span class="line">线程池中允许创建最大线程数，非核心线程数为 maximumPoolSize-corePoolSize ，</span><br><span class="line">这个参数只有在任务队列已满时才有意义。也就是说当已经达到核心线程数但是队列</span><br><span class="line">未满时不会创建非核心线程，都添加任务到任务队列满的时候才会开始创建非核心</span><br><span class="line">线程，如果使用无界队列则这个参数没有意义</span><br><span class="line">maximumPoolSize</span><br><span class="line"></span><br><span class="line">线程池中非核心线程允许闲置的最长时间，超过这个时间的非核心线程将会被回收，</span><br><span class="line">对于任务很多并且每个任务处理时间较短的的情况，可以适当提升keepAliveTime</span><br><span class="line">参数来提高线程利用率。当设置allowCoreThreadTimeOut属性为true时，keepAliveTime</span><br><span class="line">参数也会作用到核心线程上</span><br><span class="line">keepAliveTime</span><br><span class="line"></span><br><span class="line">keepAliveTime 参数的时间单位</span><br><span class="line">（天：DAYS、小时：HOURS、分钟：MINUTES、秒：SECONDS、毫秒：MILLISENDS 等）</span><br><span class="line">unit</span><br><span class="line"></span><br><span class="line">任务队列，被提交当尚未被执行的任务，用于存放Runnnable对象</span><br><span class="line">workQueue</span><br><span class="line"></span><br><span class="line">创建线程的工厂，一般情况使用默认的即可</span><br><span class="line">threadFactory</span><br><span class="line"></span><br><span class="line">饱和策略，即为当任务队列和线程池中线程数均达到饱和时采取的应对策略，</span><br><span class="line">默认是 AbordPolicy，表示无法处理新的任务，并在有新任务提交时抛出 </span><br><span class="line">RejectedExecutionException 异常，此外还有 3 中策略：</span><br><span class="line">1、CallerRunnsPolicy：使用提交该任务的线程来处理此任务，即调用execute方法</span><br><span class="line">的线程执行该任务</span><br><span class="line">2、DiscardPolicy：不执行该任务，并将该任务删除当不抛出异常</span><br><span class="line">3、DiscardOldestPolicy：丢弃队列中最近的任务，并执行当前提交的任务</span><br><span class="line">handler</span><br></pre></td></tr></table></figure>
<p>以上7个参数决定了线程池执行一个任务的策略，当一个任务被添加时</p>
<ol>
<li>线程数量未达到 corePoolSize，则新建一个线程(核心线程)执行任务</li>
<li>线程数量达到了 corePools，则将任务移入队列等待</li>
<li>队列已满，新建线程(非核心线程)执行任务</li>
<li>队列已满，总线程数又达到了maximumPoolSize，执行饱和策略</li>
</ol>
<p>workQueue指被提交但未执行的任务队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">数组构成的有界阻塞队列，即储存元素的数据结构是数组，按照先进先出的顺序</span><br><span class="line">对元素排序，创建时需要指定队列的最大容量，默认情况不保证线程公平的访问</span><br><span class="line">原则，公平即先被阻塞的线程在唤醒后先获得锁资源继续未完成的操作，也可以</span><br><span class="line">不加第二个参数，默认是非公平锁。</span><br><span class="line">使用有界的任务队列时，如果有新的任务需要执行，如果线程池实际线程数量</span><br><span class="line">小于核心线程数，则会优先创建线程，若大于核心线程数则会将任务加入等待</span><br><span class="line">队列，如果队列已满则在不超过总线程数的情况下创建线程，如果线程数大于</span><br><span class="line">最大线程数就是执行拒绝策略</span><br><span class="line">ArrayBlockingQueue queue &#x3D; new ArrayBlockingQueue(1000, true); </span><br><span class="line"></span><br><span class="line">链表构成的无界阻塞队列，即储存元素的数据结构是链表，当有新的任务到来</span><br><span class="line">时如果线程数小于核心线程数就会创建新线程，线程数达到核心线程数后就不</span><br><span class="line">会继续创建线程，如果有新的任务但没有空闲线程就会加入队列等待</span><br><span class="line">LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">支持按某个优先级对元素进行排序的无界阻塞队列，默认情况下使用升序排序，</span><br><span class="line">通过自定义compareTo方法实现元素自定义排序，或者创建队列的时候传入</span><br><span class="line">参数Compare来对元素排序</span><br><span class="line">PriorityBlockingQueue</span><br><span class="line"></span><br><span class="line">使用优先队列实现的无界阻塞队列，存储的元素必须实现Delay接口，按照</span><br><span class="line">getDelay方法的返回值进行排序</span><br><span class="line">DelayQueue</span><br><span class="line"></span><br><span class="line">不储存元素的阻塞队列，每个生产者线程必须等待另一个消费者线程的执行，</span><br><span class="line">每个消费者个线程必须等待另一个生产者线程的执行，因此队列中没有元素</span><br><span class="line">SynchronousQueue</span><br></pre></td></tr></table></figure>


</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/">https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/25/Java%E5%B9%B6%E5%8F%912/"><i class="fa fa-chevron-left">  </i><span>Java并发2</span></a></div><div class="next-post pull-right"><a href="/2020/12/10/ComputerNetwork2/"><span>计算机网络2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/';
  this.page.identifier = '2020/12/21/Java并发/';
  this.page.title = 'Java并发';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>