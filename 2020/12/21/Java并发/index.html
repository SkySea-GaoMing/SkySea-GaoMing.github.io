<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java并发"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java并发 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行世界"><span class="toc-number">2.</span> <span class="toc-text">并行世界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步"><span class="toc-number">2.1.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发和并行"><span class="toc-number">2.2.</span> <span class="toc-text">并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区"><span class="toc-number">2.3.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞和非阻塞"><span class="toc-number">2.4.</span> <span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁、饥饿和活锁"><span class="toc-number">2.5.</span> <span class="toc-text">死锁、饥饿和活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发级别"><span class="toc-number">2.6.</span> <span class="toc-text">并发级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞"><span class="toc-number">2.6.1.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无饥饿"><span class="toc-number">2.6.2.</span> <span class="toc-text">无饥饿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无障碍"><span class="toc-number">2.6.3.</span> <span class="toc-text">无障碍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无锁"><span class="toc-number">2.6.4.</span> <span class="toc-text">无锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无等待"><span class="toc-number">2.6.5.</span> <span class="toc-text">无等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个定律"><span class="toc-number">2.7.</span> <span class="toc-text">两个定律</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Amdahl"><span class="toc-number">2.7.1.</span> <span class="toc-text">Amdahl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gustafson"><span class="toc-number">2.7.2.</span> <span class="toc-text">Gustafson</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM"><span class="toc-number">2.8.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性"><span class="toc-number">2.8.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可见性"><span class="toc-number">2.8.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序性"><span class="toc-number">2.8.3.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重排规则"><span class="toc-number">2.8.4.</span> <span class="toc-text">重排规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA并行程序基础"><span class="toc-number">3.</span> <span class="toc-text">JAVA并行程序基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">3.1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的终止"><span class="toc-number">3.1.1.</span> <span class="toc-text">线程的终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程中断"><span class="toc-number">3.1.2.</span> <span class="toc-text">线程中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK并发包"><span class="toc-number">4.</span> <span class="toc-text">JDK并发包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">4.1.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实例演示"><span class="toc-number">4.1.1.</span> <span class="toc-text">实例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中断响应"><span class="toc-number">4.1.2.</span> <span class="toc-text">中断响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁申请等待限时"><span class="toc-number">4.1.3.</span> <span class="toc-text">锁申请等待限时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公平锁"><span class="toc-number">4.1.4.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-number">4.1.5.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">4.1.6.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReadWriteLock"><span class="toc-number">4.1.7.</span> <span class="toc-text">ReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">4.1.8.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CycliBarrier"><span class="toc-number">4.1.9.</span> <span class="toc-text">CycliBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LockSupport"><span class="toc-number">4.1.10.</span> <span class="toc-text">LockSupport</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-number">4.2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable和Future"><span class="toc-number">4.2.1.</span> <span class="toc-text">Callable和Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors"><span class="toc-number">4.2.2.</span> <span class="toc-text">Executors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见线程池"><span class="toc-number">4.3.</span> <span class="toc-text">常见线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FixedThreadPool"><span class="toc-number">4.3.1.</span> <span class="toc-text">FixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SingleThreadExecutor"><span class="toc-number">4.3.2.</span> <span class="toc-text">SingleThreadExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CachedThreadPool"><span class="toc-number">4.3.3.</span> <span class="toc-text">CachedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源码分析"><span class="toc-number">4.3.4.</span> <span class="toc-text">源码分析</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">47</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F7fe26ede962c3e048f6e8f1f8c12b3f803e1457f.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611849565&amp;t=29a8f8fb1f5f28e19cc5104ad7f885e5)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java并发</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/21/Java%E5%B9%B6%E5%8F%91/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/21/Java并发/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java高并发程序设计》</p>
<h2 id="并行世界"><a href="#并行世界" class="headerlink" title="并行世界"></a>并行世界</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步通常用来形容一次方法调用。同步方法一旦开始，调用者必须等<br>到方法调用返回后才能继续后面的操作。异步方法更像一个消息传递，一旦<br>开始就会立即返回，调用者就会执行后面的操作，异步方法通常会在另一<br>个线程执行 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/1.jpg" alt></p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>严格意义上并行是多个任务同时执行，并发是多个任务交替执行。并发只有<br>在多核CPU的系统中才可以实现 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/2.jpg" alt></p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区用来表示一种公共资源或者说是共享资源，多个线程都可以使用这个<br>资源，但是在一个时刻只有一个线程能够使用这个资源，其余线程都要等待</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞通常用来形容多线程间的相互影响。刚刚多个线程都想使用临界<br>区的资源，但是一个时刻只有一个线程能够使用，其余线程等待的情况就是<br>阻塞，非阻塞就是没有线程妨碍其他线程执行</p>
<h3 id="死锁、饥饿和活锁"><a href="#死锁、饥饿和活锁" class="headerlink" title="死锁、饥饿和活锁"></a>死锁、饥饿和活锁</h3><p>死锁就是多个线程相互竞争资源而造成的彼此阻塞 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/3.jpg" alt><br>饥饿是指一个或多个线程因为种种原因无法获得所需资源，导致一直无法执<br>行，比如线程的优先级过低，与死锁相比在未来一段时间内还是有可能解决<br>的。活锁就是获得资源但还未加上锁时就又将资源释放，这种情况比较少见</p>
<h3 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h3><p>由于临界区的存在，多线程的并发必须受到控制，根据控制并发的策略可以<br>把并发的级别进行分类，也就是阻塞和非阻塞两大部分。非阻塞包括无障碍<br>、无锁和无等待</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>一个线程是阻塞的，那么在其他线程释放资源之前当前线程无法继续执行，<br>当使用synchronized或重入锁得到的就是阻塞的线程，会对临界区进行加<br>锁，如果得不到锁就会挂起一直等待</p>
<h4 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h4><p>如果线程之间有优先级，那么线程的调度总是会倾向于满足高优先级的线程<br>，对于非公平锁，系统允许高优先级的线程插队，如果锁是公平的，那么线<br>程就会按照先来后到进行排队 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/4.jpg" alt></p>
<h4 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h4><p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍执行，那么不会因<br>为临界区的问题导致一方被挂起，也就是可以共同修改数据，可是这样的<br>话数据就可能出问题，对于无障碍线程来说一旦出现这种情况就会对所做<br>的修改进行回滚，确保数据安全，如果没有数据竞争发生那么就很顺利。<br>如果说阻塞的控制方式是悲观策略，系统认为两个线程有可能发生冲突因<br>此以保护数据为第一优先级，那么非阻塞调度就是乐观策略，认为两个线<br>程不会发生冲突，但是一旦检测到冲突就会回滚。一种可行的无障碍实现<br>可以依赖一个一致性标记来实现，线程在操作之前先读取这个标记，在操<br>作完成后再次读取这个标记，如果两者一致说明资源访问没有冲突，如果<br>不一致说明则需要重试操作</p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁的并行都是无障碍的，在无锁的情况下每个线程都尝试对临界区进行<br>访问，但是无锁的并发保证必然有一个线程能够在有限步完成操作离开临<br>界区。实际上每个线程都会读取一个数据副本互不干涉</p>
<h4 id="无等待"><a href="#无等待" class="headerlink" title="无等待"></a>无等待</h4><p>无锁只要求有一个线程在有限步内完成操作，而无等待在无锁的基础上更<br>进一步扩展，要求所有线程都要在有限步内完成。一种无等待结构是RCU，<br>基本思想是对数据的读不加控制，所有的读线程都是无等待的，在写数据<br>的时候先取得数据的副本，然后只修改副本，修改完成后回写数据。这里<br>我觉得应该没有用到一致性标记</p>
<h3 id="两个定律"><a href="#两个定律" class="headerlink" title="两个定律"></a>两个定律</h3><p>接下来分析并发比串行在性能上提高多少</p>
<h4 id="Amdahl"><a href="#Amdahl" class="headerlink" title="Amdahl"></a>Amdahl</h4><p>Amdahl定律定义了串行系统并行化后的加速比的计算公式和理论上限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加速比&#x3D;优化前系统耗时&#x2F;优化后系统耗时</span><br><span class="line">n表示处理器个数</span><br><span class="line">T表示时间，T1表示优化前耗时，Tn表示优化后耗时</span><br><span class="line">F表示程序中只能串行执行的比例</span><br><span class="line">Tn&#x3D;T1*(F+(1-F)&#x2F;n)</span><br><span class="line">加速比&#x3D;T1&#x2F;Tn&#x3D;1&#x2F;(F+(1-F)&#x2F;n)</span><br></pre></td></tr></table></figure>
<p>如果n趋于无穷那么加速比与系统的串行化率成反比，由此可知加速比取决<br>于处理器的数量和串行的比重</p>
<h4 id="Gustafson"><a href="#Gustafson" class="headerlink" title="Gustafson"></a>Gustafson</h4><p>Gustafson定律跟Amdahl的角度不同 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/5.jpg" alt></p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>接下来探讨一下JAVA的内存模型，如何保障并发程序下数据访问的一致性和安全<br>性，JAVA的关键技术点都是围绕多线程的原子性、可见性和有序性来建立的</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性是指一个操作不可中断，即使多个线程一起操作原子操作也不会受其余线<br>程影响。对于32位的系统long型数据的读写不是原子性的</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指一个线程修改了某一共享变量的值，其他线程是否能够立即知道这个<br>修改。对于串行程序来说可见性问题不存在，并行程序中缓存优化、硬件优化或<br>指令重排以及编译器优化都可能产生可见性问题</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性问题的原因是因为程序在执行时可能会进行指令重排，重排后的指令与原<br>指令的顺序未必一致，但是一定可以保证串行语义的一致性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a&#x3D;0;</span><br><span class="line">boolean flag&#x3D;false;</span><br><span class="line">public void writer()&#123;</span><br><span class="line">	a&#x3D;1;</span><br><span class="line">	flag&#x3D;true;</span><br><span class="line">&#125;</span><br><span class="line">public void reader()&#123;</span><br><span class="line">	if(flag)&#123;</span><br><span class="line">		int i&#x3D;a+1;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程A首先执行writer方法，接着线程B执行reader方法，如果发生指令重排<br><img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/6.jpg" alt><br>接下来分析一下为什么会有指令重排。一般来说一条指令的执行分为5步，每个步骤<br>涉及的硬件也不同，学过计算机组成知道流水线技术执行指令可以极大提高效率 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/7.jpg" alt><br>但是一旦发生中断所有的硬件设备都会进入一个停顿器，再次满载又需要几个周期<br>性能损失较大时，所以指令重排就是用来减少中断 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/8.JPG" alt><br>这个X就表示中断，也就是说ADD在这里停顿了一下，因为R2的数据还没有准备好<br>，ADD必须进行一次等待操作，由于ADD的延迟导致后面的所有操作都要慢一个节<br>拍。接下来看一个跟复杂的情况 a=b+c d=e-f <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/9.jpg" alt><br>如果将指令重新排序就可以消除这些停顿 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/10.jpg" alt> <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/11.jpg" alt></p>
<h4 id="重排规则"><a href="#重排规则" class="headerlink" title="重排规则"></a>重排规则</h4><p>以下原则是指令重排不能违背的<br>顺序执行原则：一个线程内保证语义的串行性</p>
<ol>
<li>volatile规则：volatile变量的写，先发生于读</li>
<li>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前</li>
<li>传递性：A先于B，B先于C，那么A必先于C</li>
<li>线程的start方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结(Thread.join())</li>
<li>线程的中断(interrupt())先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法</li>
</ol>
<h2 id="JAVA并行程序基础"><a href="#JAVA并行程序基础" class="headerlink" title="JAVA并行程序基础"></a>JAVA并行程序基础</h2><p>进程是程序的基本执行实体，比如Windows中后缀为.exe的文件，双击执行时就<br>开启了一个进程，进程中又有若干线程，线程也叫做轻量级进程，线程间切换和<br>调度的成本远远小于进程 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/12.jpg" alt></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h4><p>一般来说线程执行完后就正常结束，不过一些服务器后台线程可能会常驻系统，<br>它们的执行体本身就是一个无穷循环。Thead提供了一个stop方法关闭线程，但<br>这个方法已经不推荐使用，可能导致数据不一致问题，因为stop会直接导致锁<br>的释放 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/13.jpg" alt></p>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>严格讲线程中断并不会使线程立即退出，而是给线程发送一个通知告知线程希望<br>你退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断线程，是一个实例方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt() </span><br><span class="line"><span class="comment">// 判断是否被中断 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> Thread.isInterrupted() </span><br><span class="line"><span class="comment">// 判断是否被中断，并清除当前中断状态isinterrupt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> Thread.interrupted()</span><br></pre></td></tr></table></figure>

<h2 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock锁由上次成功锁定并且尚未解锁的线程拥有，是一个可重入且独<br>占式的锁。与synchronized关键字相比更加灵活强大，重入锁的意思就是这种锁<br>能反复进入，但是只限于一个线程。注意ReentrantLock锁的并不是Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁定几个就要释放几个</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	lock.lock();	</span><br><span class="line">	lock.lock();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重入锁的常用处理框架如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  </span><br><span class="line">     <span class="comment">// 当前执行代码的线程尝试获取锁对象，如果当前锁对象被其他线程获取，则陷入阻塞状态</span></span><br><span class="line">	 <span class="comment">// 保证了在同一时刻只能有一个线程进入 try 代码块中执行代码，即实现线程同步</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// do something...</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock() <span class="comment">// 最后一定记得释放锁对象，不然可能导致死锁</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><p>接下来使用ReentrantLock实现抢车票同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">10</span>; <span class="comment">// 10 张火车票</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">/*注意这个地方一定要加if判断，可以把sleep方法去掉测试一下</span></span><br><span class="line"><span class="comment">			例如线程1进入sell方法，此时tickets是1，然后线程切换到线程2</span></span><br><span class="line"><span class="comment">			因为线程2从主内存中中读取的tickets依然是1，所以线程2通过</span></span><br><span class="line"><span class="comment">			while的判断，只不过目前无法进入sell方法，线程1又切回到sell</span></span><br><span class="line"><span class="comment">			方法执行完tickets为0时解锁，此时主内存已经更新为0，所以if判断</span></span><br><span class="line"><span class="comment">			就表示再次从主内存中读取tickets的值此时已经是0所以不会继续</span></span><br><span class="line"><span class="comment">			执行以下操作</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了第 "</span> </span><br><span class="line">			+ tickets-- + <span class="string">" 张票"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 开启 5 个线程售票</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="string">"窗口"</span> + (i+<span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						sell();</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>在等待锁的过程中，程序可以根据需要取消对锁的请求。比如两个线程使<br>用lockInterruptibly()方法加锁造成死锁时，如果其中一个线程调用<br>interrupt方法将导致线程中断，此时该线程会停止申请锁并释放已经<br>获得的锁退出</p>
<h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><p>除了等待外部通知，还有一种避免死锁的方式就是限时等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前执行代码的线程尝试获取锁，如果获取失败（当前锁已经被其他线程所拥有）</span></span><br><span class="line"><span class="comment">// 当前执行代码的线程会陷入阻塞，直到这个锁对象被其所拥有的线程释放才会从阻塞状态唤醒</span></span><br><span class="line"><span class="keyword">void</span> lock​() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程尝试获取当前锁，如果获取成功，那么返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment">// 和 lock 方法的区别在于当前线程获取锁失败时不会陷入阻塞状态</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock​() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前执行代码的线程在参数给定的时间内不断获取这个锁对象</span></span><br><span class="line"><span class="comment">// 如果在参数给定时间内没有获取这个锁对象, 该方法返回 false 并且当前线程继续往下执行。</span></span><br><span class="line"><span class="comment">// 如果当前执行代码的线程已经被中断，那么方法会抛出一个 InterruptedException 异常，</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock​(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁按照线程申请锁的先后顺序被获取，不会产生饥饿现象，synchronized<br>产生的锁是非公平的，会根据优先级挑选，具有随机性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock.Sync sync;</span><br><span class="line">	<span class="comment">//不传参数是非公平锁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> ReentrantLock.NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*根据传入的参数，来判断是创建公平锁还是非公平锁</span></span><br><span class="line"><span class="comment">    FairSync 和NonfairSync都是ReentrantLock的内部类*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (ReentrantLock.Sync)(fair ? <span class="keyword">new</span> ReentrantLock.FairSync() </span><br><span class="line">        	: <span class="keyword">new</span> ReentrantLock.NonfairSync());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock的源码其余方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询当前锁对象是否被任意一个线程拥有</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询当前锁对象是否被当前执行代码的线程拥有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前执行代码的线程尝试获取锁，如果被其他线程获取，则等待其他线程解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与lock方法的区别在于获取失败则不会等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>Condition与wait()和notify()方法的作用大致相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个 Condition 实例对象用来实现锁的功能</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同 Object.wait() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 和 Object.wait(long time, TimeUnit unit) 方法一样</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	await​<span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 当前线程释放锁资源，陷入等待，时间为参数指定的纳秒数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> awaitNanos​<span class="params">(<span class="keyword">long</span> nanosTimeout)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当前线程释放锁资源，陷入等待状态，</span></span></span><br><span class="line"><span class="function"><span class="comment">// 直到其他线程调用该对象的 signal 、signalAl 方法、等待时间过去或者当前线程发生中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	awaitUntil​<span class="params">(Date deadline)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Wakes up one waiting thread. 相当于 Object.notify 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// Wakes up all waiting threads. 相当于 Object.notifyAll 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量是为多线程协作提供更强大的控制方法，内部锁synchronized和重入锁<br>ReentrantLock一次都只允许一个线程访问一个资源，信号量可以指定多个线<br>程同时访问一个资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Semaphore.Sync sync;</span><br><span class="line">    <span class="comment">//指定多少个许可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Semaphore.NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二个参数指定是否公平</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (Semaphore.Sync)(fair ? <span class="keyword">new</span> Semaphore.FairSync(permits) : </span><br><span class="line">        	<span class="keyword">new</span> Semaphore.NonfairSync(permits));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从此信号量获取一个许可，在提供一个许可前一直将线程阻塞或当前线程被中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与acquire类似但不响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放一个许可，将其返回给信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>读写分离锁能够有效减少锁竞争。比如线程A1 A2 A3进行写操作，线程B1 B2<br>B3 进行读操作，如果使用重入锁或内部锁理论上所有的读之间、读与写之间、<br>写与写之间都是串行操作，当B1进行读时B2 B3都需要等待锁，读写锁能够使<br>多个线程同时读，但是其余操作依然需要等待</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>称为倒计时器，让一个线程等待直到倒计时结束再开始执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数count为计数值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;  &#125;;</span><br><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function"></span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="CycliBarrier"><a href="#CycliBarrier" class="headerlink" title="CycliBarrier"></a>CycliBarrier</h4><p>可以理解为循环栅栏，实现线程间的计数等待</p>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>是一个非常方便的线程阻塞工具，可以在线程内任意位置让线程阻塞</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>ThreadPoolExecutor表示一个线程池，Executors类表示线程池工厂，通过<br>Executors可以取得一个拥有特定功能的线程池 <img src="/2020/12/21/Java%E5%B9%B6%E5%8F%91/14.jpg" alt><br>参考 <a href="https://blog.csdn.net/anhenzhufeng/article/details/88870374" target="_blank" rel="noopener">https://blog.csdn.net/anhenzhufeng/article/details/88870374</a></p>
<h4 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a>Callable和Future</h4><p>通过Runnable接口创建多线程时，Thread类的作用就是把run方法包装成线<br>程执行体，Java只能将run方法包装成线程执行体，C#可以将任意方法都包<br>装成线程执行体，因此JDK5开始Java提供Callable接口，提供一个call方<br>法作为线程执行体，call方法比run方法功能更强大</p>
<ul>
<li>call方法可以有返回值</li>
<li>call方法可以声明异常</li>
</ul>
<p>callable不是Runnable 的子接口，所以不能直接作为 Thread的 target，而<br>且call有一个返回值。Future 接口来代表 callable 接口中call 方法的返回<br>值，并且Future 接口提供了一个FutureTask实现类，这个类实现了Runnable<br>接口可以作为target，而FutureTask 的构造方法又需要Callable接口作为传<br>入参数，而其 run方法会调用Callable 对象的call方法。当使用线程池对象的<br>submit方法向线程池提交任务时，该方法会返回一个Future类型对象，Future<br>接口提供了一些方法来获取向线程池提交的任务的执行状态和结果的信息，接下<br>来看一下Future的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消执行提交的对应任务，如果对应任务已经执行完成或者已经被取消或者</span></span><br><span class="line"><span class="comment">       是其他原因不能被取消，</span></span><br><span class="line"><span class="comment">     * 那该操作将会失败，否则的话提交的对应任务将不会被线程池中的线程执行。</span></span><br><span class="line"><span class="comment">     * 如果尝试取消的任务正在执行，那么通过参数来确定是否应该中断正在执行该任务的线程，</span></span><br><span class="line"><span class="comment">     * 如果为 false，那么将不会中断正在执行该任务的线程。</span></span><br><span class="line"><span class="comment">     * 在该方法返回之后，调用 isDone 方法会返回 true，</span></span><br><span class="line"><span class="comment">     * 调用 isCancalled 方法的返回值和该方法的返回值相同。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果提交的对应任务还没有完全执行完成之前就被取消了，那么</span></span><br><span class="line"><span class="comment">     方法会返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回任务是否完成：包括下面几种情况：</span></span><br><span class="line"><span class="comment">     * 1、任务正常执行完成</span></span><br><span class="line"><span class="comment">     * 2、执行过程发生异常</span></span><br><span class="line"><span class="comment">     * 3、任务被取消</span></span><br><span class="line"><span class="comment">     * 上面几种情况发生，方法均会返回 true，</span></span><br><span class="line"><span class="comment">     * 如果任务正在执行，或者还未执行，那么方法返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞调用该方法的线程，直到提交的对应任务执行完成之后，</span></span><br><span class="line"><span class="comment">     * 方法会返回一个泛型结果对象表示任务执行的结果，</span></span><br><span class="line"><span class="comment">     * 如果提交的任务是一个 Callable 类型的对象，那么返回 Callable </span></span><br><span class="line"><span class="comment">     对象的 call 方法的返回值，</span></span><br><span class="line"><span class="comment">     * 如果提交的任务是一个 Runnable 类型的对象，那么返回 Runnable 对象的 </span></span><br><span class="line"><span class="comment">     run 方法的返回值，即为 null。</span></span><br><span class="line"><span class="comment">     * 如果在调用线程阻塞的过程中发生了中断，那么方法抛出 InterruptedException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能同上面的重载方法，但是添加了一个条件, 即阻塞时间，</span></span><br><span class="line"><span class="comment">     * 该方法使得调用线程的阻塞时间不会超过参数指定的时间，</span></span><br><span class="line"><span class="comment">     * 如果在规定时间内对应任务没有运行完成，方法抛出一个 TimeoutException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下Callable接口的源码，有一个返回值作为结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看两个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Future 接口测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 向线程池中提交一个新的 Callable 类型的任务，提交之后会对任务对象进行包装</span></span><br><span class="line">        Future&lt;String&gt; task = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="comment">// 复写 call() 方法，线程池中线程最终会调用 call() 方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 执行线程休眠 5 秒钟</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 task.get() 获取执行结果，</span></span><br><span class="line">            <span class="comment">// 这里即为获取上述代码中 submit 方法提交的 Callable 中 </span></span><br><span class="line">            <span class="comment">//call() 方法的返回值，</span></span><br><span class="line">            <span class="comment">// 该方法会阻塞当前调用线程，直到任务执行完成后返回</span></span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"方法获取任务结果所用时间："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FutureTaskTest.startTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型形参类型与返回值类型相同</span></span><br><span class="line">FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;&gt;((Callable&lt;Integer&gt;)()-&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(Thread.currentThread.getName()+i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(Thread.currentThread.getName()+i);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="comment">/* 获得返回值，调用该方法将导致程序阻塞，必须等子线程结束才会得到返回</span></span><br><span class="line"><span class="comment">		值，也就是主线程会被阻塞，直到call方法结束并返回为止 */</span></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(task.get());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>这个类类似线程池的工厂，用于产生各种线程池，Java5以前需要手动实现线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*创建一个可重用、有固定线程数的线程池，当一个新任务提交时如果</span></span><br><span class="line"><span class="comment">	  线程池有空闲线程则立即执行否则任务会暂时存在一个任务队列中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, </span><br><span class="line">        	TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个只有单线程的线程池，相当于newFixedThreadPool(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Executors.FinalizableDelegatedExecutorService(</span><br><span class="line">        	<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, </span><br><span class="line">        	<span class="keyword">new</span> LinkedBlockingQueue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*返回一个可根据实际情况调整线程数量的线程池，线程池中的线程数量</span></span><br><span class="line"><span class="comment">      不确定，如果有空闲线程可复用那么优先使用可复用的线程，如果所有</span></span><br><span class="line"><span class="comment">      线程都在工作但有新任务提交则会创建新的线程，线程执行完后会复用</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">2147483647</span>, <span class="number">60L</span>, TimeUnit.SECONDS, </span><br><span class="line">        	<span class="keyword">new</span> SynchronousQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上创建线程池的方法都返回一个ThreadPoolExecutor对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> corePoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">		TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">		BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">		RejectedExecutionHandler handler)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, </span><br><span class="line">        	workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分析一下构造方法的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">线程池中的最大核心线程数，默认情况下线程池是空的，没有线程，只有在有任务</span><br><span class="line">提交到线程池中时才会创建核心线程，即使有其他空闲的核心线程可以执行新任务</span><br><span class="line">也会创建新的核心线程，这一点一定要注意，当核心线程数等于corePoolSize的</span><br><span class="line">时候就不会继续创建核心线程了，如果调用线程池对象的prestartAllCoreThread() </span><br><span class="line">方法，那么线程池会提前创建好所有的核心线程</span><br><span class="line">corePoolSize</span><br><span class="line"></span><br><span class="line">线程池中允许创建最大线程数，非核心线程数为 maximumPoolSize-corePoolSize ，</span><br><span class="line">这个参数只有在任务队列已满时才有意义。也就是说当已经达到核心线程数但是队列</span><br><span class="line">未满时不会创建非核心线程，都添加任务到任务队列满的时候才会开始创建非核心</span><br><span class="line">线程，如果使用无界队列则这个参数没有意义</span><br><span class="line">maximumPoolSize</span><br><span class="line"></span><br><span class="line">线程池中非核心线程允许闲置的最长时间，超过这个时间的非核心线程将会被回收，</span><br><span class="line">对于任务很多并且每个任务处理时间较短的的情况，可以适当提升keepAliveTime</span><br><span class="line">参数来提高线程利用率。当设置allowCoreThreadTimeOut属性为true时，keepAliveTime</span><br><span class="line">参数也会作用到核心线程上</span><br><span class="line">keepAliveTime</span><br><span class="line"></span><br><span class="line">keepAliveTime 参数的时间单位</span><br><span class="line">（天：DAYS、小时：HOURS、分钟：MINUTES、秒：SECONDS、毫秒：MILLISENDS 等）</span><br><span class="line">unit</span><br><span class="line"></span><br><span class="line">任务队列，被提交当尚未被执行的任务，用于存放Runnnable对象</span><br><span class="line">workQueue</span><br><span class="line"></span><br><span class="line">创建线程的工厂，一般情况使用默认的即可</span><br><span class="line">threadFactory</span><br><span class="line"></span><br><span class="line">饱和策略，即为当任务队列和线程池中线程数均达到饱和时采取的应对策略，</span><br><span class="line">默认是 AbordPolicy，表示无法处理新的任务，并在有新任务提交时抛出 </span><br><span class="line">RejectedExecutionException 异常，此外还有 3 中策略：</span><br><span class="line">1、CallerRunnsPolicy：使用提交该任务的线程来处理此任务，即调用execute方法</span><br><span class="line">的线程执行该任务</span><br><span class="line">2、DiscardPolicy：不执行该任务，并将该任务删除当不抛出异常</span><br><span class="line">3、DiscardOldestPolicy：丢弃队列中最近的任务，并执行当前提交的任务</span><br><span class="line">handler</span><br></pre></td></tr></table></figure>
<p>以上7个参数决定了线程池执行一个任务的策略，当一个任务被添加时</p>
<ol>
<li>线程数量未达到 corePoolSize，则新建一个线程(核心线程)执行任务</li>
<li>线程数量达到了 corePools，则将任务移入队列等待</li>
<li>队列已满，新建线程(非核心线程)执行任务</li>
<li>队列已满，总线程数又达到了maximumPoolSize，执行饱和策略</li>
</ol>
<p>workQueue指被提交但未执行的任务队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">数组构成的有界阻塞队列，即储存元素的数据结构是数组，按照先进先出的顺序</span><br><span class="line">对元素排序，创建时需要指定队列的最大容量，默认情况不保证线程公平的访问</span><br><span class="line">原则，公平即先被阻塞的线程在唤醒后先获得锁资源继续未完成的操作，也可以</span><br><span class="line">不加第二个参数，默认是非公平锁。</span><br><span class="line">使用有界的任务队列时，如果有新的任务需要执行，如果线程池实际线程数量</span><br><span class="line">小于核心线程数，则会优先创建线程，若大于核心线程数则会将任务加入等待</span><br><span class="line">队列，如果队列已满则在不超过总线程数的情况下创建线程，如果线程数大于</span><br><span class="line">最大线程数就是执行拒绝策略</span><br><span class="line">ArrayBlockingQueue queue &#x3D; new ArrayBlockingQueue(1000, true); </span><br><span class="line"></span><br><span class="line">链表构成的无界阻塞队列，即储存元素的数据结构是链表，当有新的任务到来</span><br><span class="line">时如果线程数小于核心线程数就会创建新线程，线程数达到核心线程数后就不</span><br><span class="line">会继续创建线程，如果有新的任务但没有空闲线程就会加入队列等待</span><br><span class="line">LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">支持按某个优先级对元素进行排序的无界阻塞队列，默认情况下使用升序排序，</span><br><span class="line">通过自定义compareTo方法实现元素自定义排序，或者创建队列的时候传入</span><br><span class="line">参数Compare来对元素排序</span><br><span class="line">PriorityBlockingQueue</span><br><span class="line"></span><br><span class="line">使用优先队列实现的无界阻塞队列，存储的元素必须实现Delay接口，按照</span><br><span class="line">getDelay方法的返回值进行排序</span><br><span class="line">DelayQueue</span><br><span class="line"></span><br><span class="line">不储存元素的阻塞队列，每个生产者线程必须等待另一个消费者线程的执行，</span><br><span class="line">每个消费者个线程必须等待另一个生产者线程的执行，因此队列中没有元素</span><br><span class="line">SynchronousQueue</span><br></pre></td></tr></table></figure>
<h3 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, </span></span></span><br><span class="line"><span class="function"><span class="params">	ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心线程数与最大线程数相同，只存在核心线程没有非核心线程,所以第三和第<br>四个参数就没有用，除非allowCoreThreadTimeOut设置为true，任务队列用<br>的是LinkedBlockingQueue</p>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个核心线程处理任务</p>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有核心线程，非核心线程的数量是最大整数，每个线程的过期时间是60s，<br>任务队列采取的是SynchronousQueue，这个队列不存储元素，这个线程用于<br>处理大量需要立即处理并且每个任务耗时较少的任务集合</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>ThreadPoolExecutor继承于AbstractExecutorService类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractExecutorService实现ExecutorService接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口又继承了Executor接口，Executors是一个类注意区分，一个线程池可以<br>接受任务类型有Runnable和Callable，分别对应了execute和submit方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这个方法就是向线程池中提交任务的核心方法，由var1执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到最初看一下ExecutorService的源码，ExecutorServiec代表尽快执行<br>线程的线程池，只要线程池中有空闲线程就会立刻执行线程任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	这个方法用于关闭线程池，调用这个方法之后，通过execute 方法提交的任务将不会被接受，</span></span><br><span class="line"><span class="comment"> 	但是其会等待线程池中任务队列中已有的任务和正在执行的任务执行完成之后再关闭线程池</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这个方法尝试立即关闭线程池，停止处理器正在执行的任务并拒绝接受新的任务，</span></span><br><span class="line"><span class="comment">      并且将任务队列中未被执行的任务添加到一个 List 列表作为返回值返回，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//线程池是否已经被关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//判断线程池中所有任务是否被完全终止，只有调用shutdown或shutdownNow才可能返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   		阻塞调用该方法的线程，直到发生了下面三种情况：</span></span><br><span class="line"><span class="comment"> 		1、方法参数规定的时间段过去，此时方法返回</span></span><br><span class="line"><span class="comment"> 		2、线程池中所有的任务执行完成并且线程池被关闭，方法返回</span></span><br><span class="line"><span class="comment"> 		3、调用该方法的线程发生了 InterruptedException 异常，此时方法</span></span><br><span class="line"><span class="comment"> 		会抛出 InterruptedException 异常</span></span><br><span class="line"><span class="comment"> 		如果线程池中所有任务被成功的完成并且线程池成功关闭，那么方法返</span></span><br><span class="line"><span class="comment"> 		回 true，否则方法返回 false</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//提交新任务到线程池中，返回Future对象，这个对象封装了获取任务执行状态信息的方法</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    <span class="comment">/*提交新任务到线程池中，将任务执行状态信息储存在 result 对象中，</span></span><br><span class="line"><span class="comment">      最后返回一个 Future 对象，提供获取任务执行状态信息的方法*/</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    <span class="comment">//返回null</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable var1);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 		提交多个任务到线程池中，并且阻塞调用该方法的线程，</span></span><br><span class="line"><span class="comment"> 		直到所有的任务都被执行完成或者调用该方法的线程发生 </span></span><br><span class="line"><span class="comment"> 		InterruptedException 异常，此时方法会抛出该异常，</span></span><br><span class="line"><span class="comment"> 		方法返回一个保存了每个任务的执行状态信息的 Future 对象的 List 对象</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1) </span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	功能同上，不过添加了时间参数限制，即为如果线程池没有在参数规定的时间内执行完成所</span></span><br><span class="line"><span class="comment"> 	有的任务，那么方法会强制返回，此时，执行完成的任务对应的 Future 对象的 </span></span><br><span class="line"><span class="comment"> 	isDone() 方法返回 true，代表对应任务执行完成，其他任务对应的 Future 对象</span></span><br><span class="line"><span class="comment"> 	的 isCancelled() 方法返回 true，代表任务未执行完成并且被取消</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1, </span><br><span class="line">    	<span class="keyword">long</span> var2, TimeUnit var4) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	也是提交多个任务到线程池中，并且阻塞调用该方法的线程，但是这个方法是有任意</span></span><br><span class="line"><span class="comment"> 	一个任务被执行完成就会返回，返回执行完成的那个任务的执行结果（即为对应任</span></span><br><span class="line"><span class="comment"> 	务 Callable 对象的 call() 方法的返回结果）同样的如果在执行任务过程中调</span></span><br><span class="line"><span class="comment"> 	用该方法的线程发生了中断，方法会抛出一个 ExecutionException 异常</span></span><br><span class="line"><span class="comment">     如果没有任何一个任务成功执行，那么方法会抛出一个 ExecutionException 异常</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; var1)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	和上面方法同样的功能，在其基础上加了时间限制，即如果在规定时间内没有任何一</span></span><br><span class="line"><span class="comment"> 	个提交的任务执行完成，该方法会返回，同时抛出一个 TimeoutException 异常</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; var1, <span class="keyword">long</span> var2, </span></span></span><br><span class="line"><span class="function"><span class="params">    	TimeUnit var4)</span> <span class="keyword">throws</span> InterruptedException, </span></span><br><span class="line"><span class="function">    ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下AbstractExecutorService的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RunnableFuture&lt;Void&gt; ftask = <span class="keyword">this</span>.newTaskFor(task, (Object)<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.execute(ftask);</span><br><span class="line">            <span class="keyword">return</span> ftask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RunnableFuture&lt;T&gt; ftask = <span class="keyword">this</span>.newTaskFor(task, result);</span><br><span class="line">            <span class="keyword">this</span>.execute(ftask);</span><br><span class="line">            <span class="keyword">return</span> ftask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RunnableFuture&lt;T&gt; ftask = <span class="keyword">this</span>.newTaskFor(task);</span><br><span class="line">            <span class="keyword">this</span>.execute(ftask);</span><br><span class="line">            <span class="keyword">return</span> ftask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上submit的重载方法，方法中先是调用newTashFor方法获取RunnableFuture<br>对象，RunnableFuture是一个接口，这个接口继承了Runnable和Future，因此<br>其对象既可以作为Runnable 对象来给execute(Runnable task) 提供参数，也<br>可以作为submit的返回值，而其实现类FutureTask则是实现了RunnableFuture<br>接口的方法，在其的run()方法中会调用创建FutureTask对象时传入的Callable<br>对象的call()方法或者是Runnable对象的run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个submit方法通过execute来向线程池中提交任务AbstractExecutorService<br>并没有实现execute方法，其子类实现了execute方法，这个方法的执行逻辑可以<br>分为三步</p>
<ol>
<li>如果当前活动线程数 &lt; 指定的核心线程数，则创建并启动一个线程来执行新<br>提交的任务（此时新建的线程相当于核心线程）</li>
<li>如果当前活动线程数 &gt;= 指定的核心线程数，且缓存队列未满，则将任务添<br>加到缓存队列中</li>
<li>如果当前活动线程数 &gt;= 指定的核心线程数，且缓存队列已满，则创建并启<br>动一个线程来执行新提交的任务（此时新建的线程相当于非核心线程）；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 代表线程池运行状态的常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">// 获取线程池的运行状态</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="comment">// 获取线程池的当前线程总数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// ctl 是一个 AtomicInteger 类型的对象，即为原子类，</span></span><br><span class="line">        	<span class="comment">// 可以将 ctl 理解成保存了线程池的线程数、运行状态等信息的变量，</span></span><br><span class="line">        	<span class="comment">// 通过对应的方法可以提取出对应的信息，</span></span><br><span class="line">        	<span class="comment">// 比如 workerCount(ctl) 方法可以得到当前线程池中的线程总数</span></span><br><span class="line">            <span class="keyword">int</span> c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">            <span class="comment">// 第一步：如果线程数量小于核心线程数，则启动一个核心线程执行任务</span></span><br><span class="line">        	<span class="comment">// 并且将当前任务作为该核心线程的第一个执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &lt; <span class="keyword">this</span>.corePoolSize) &#123;</span><br><span class="line">            	<span class="comment">// 如果成功创建了核心线程处理任务，方法返回</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.addWorker(command, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 防止在这个过程中又有新的任务提交了造成错误，于是需要再次获取检查</span></span><br><span class="line"><span class="comment">                一次变量值 */</span></span><br><span class="line">                c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//第二步：当前线程数量大于等于核心线程数，加入任务队列，成功的话会进行二次检查</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) &amp;&amp; <span class="keyword">this</span>.workQueue.offer(command)) &#123;</span><br><span class="line">            	<span class="comment">/* 同样的道理，为了防止添加任务到任务队列中又有新的任务提交造成错误，</span></span><br><span class="line"><span class="comment">            	再次更新变量值 */</span></span><br><span class="line">                <span class="keyword">int</span> recheck = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">                <span class="comment">// 如果线程池不处于运行状态（shutdown、stop），</span></span><br><span class="line">            	<span class="comment">// 并且将刚添加的任务成功从任务队列移除，执行饱和策略</span></span><br><span class="line">                <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; <span class="keyword">this</span>.remove(command)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.reject(command);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//启动非核心线程执行，注意这里任务是null，其实里面会去取任务队列里的任务执行</span></span><br><span class="line">                    <span class="keyword">this</span>.addWorker((Runnable)<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第三步：加入不了队列（即队列满了），尝试启动非核心线程</span></span><br><span class="line">   <span class="comment">//如果启动不了非核心线程执行，说明到达了最大线程数量的限制，会使用第7个参数抛出异常</span></span><br><span class="line">                <span class="comment">/*如果创建非核心线程执行任务失败，那么证明整个线程池的线程数达到</span></span><br><span class="line"><span class="comment">                最大线程数、任务队列已满，或者是调用了线程池的 </span></span><br><span class="line"><span class="comment">                shutdown() 方法，拒绝接受任何新的任务，此时应该调用饱和策略*/</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.addWorker(command, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.reject(command);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上代码可以看出即便当前活动的线程有空闲的，只要这个活动的线程数量小<br>于设定的核心线程数，那么依旧会启动一个新线程来执行任务execute方法中<br>多次通过addWorker方法添加线程任务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加新的线程来将 firstTask任务作为第一任务执行，执行完成之后执</span></span><br><span class="line"><span class="comment">//行线程池任务队列中其他任务,core 参数为是否添加核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 记录当前线程池运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 如果线程池已经被停止或者关闭等，那么返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程池中线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">   <span class="comment">//如果线程数大于线程池最大线程或者想添加核心线程来处理firstTask但是核心线程已经饱和</span></span><br><span class="line">   <span class="comment">// 或者添加非核心线程来处理 firstTask 但是线程池总线程数已达到饱和，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="comment">// 如果保存线程池状态信息的变量没发生变化，证明这个过程线程池是没有发生状态变化的，</span></span><br><span class="line">            <span class="comment">// 此时将 ctl 值更新，使得其包装的线程池工作线程数信息加一</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 防止这个过程中又有其他操作进行造成错误，再次读取 ctl 的值</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">        <span class="comment">// 如果线程池当前运行状态和线程池前面的运行状态不等，证明线程池状态发生改变，</span></span><br><span class="line">            <span class="comment">// 调到外层循环重新执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 添加新的工作对象来处理任务，</span></span><br><span class="line">        <span class="comment">// Worker 对象为 任务--线程 的包装类，创建该对象时会创建一个新的线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 同步块</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 检测当前线程池运行状态和方法参数是否合法</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">             <span class="comment">// 工作集中添加新建的线程包装类, workers 为一个 HashSet&lt;Woker&gt; 的对象</span></span><br><span class="line">                    <span class="comment">// 保存的是线程池中的所有 Worker 对象</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// 更新线程池中出现过的最大的线程数</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 工作添加标志置为 true</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动新建的线程，执行任务</span></span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 线程启动标志置为 true</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
创建新线程处理firstTask任务时通过新建Worker对象完成，Worker是<br>ThreadPoolExecutor类的内部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> </span></span><br><span class="line"><span class="class"><span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Thread thread;</span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">/*在创建一个新的线程时传入一个Runnable对象，线程运行时执行</span></span><br><span class="line"><span class="comment">              该Runnable对象的run方法</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">            <span class="keyword">this</span>.thread = ThreadPoolExecutor.<span class="keyword">this</span>.getThreadFactory()</span><br><span class="line">            .newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ThreadPoolExecutor.<span class="keyword">this</span>.runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个类封装了要执行的任务和执行这个任务的Thread线程对象，创建线程时传入 this<br>参数，那么创建的线程在执行时就会调用这个对象的run方法，即调用runWorker方法<br>到这里就应该知道线程池存储的并不是Thread对象，而是封装后的Worker对象，并且<br>每新建一个Worker对象都会吧这个对象存入workers集合中，wokers集合实际是<br>ThreadPoolExecutor的一个HashSet<Worker>集合类型的成员变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(ThreadPoolExecutor.Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        <span class="comment">/*如果Worker对象的firstTask不为空，则先执行第一个任务，即创建Worker对象</span></span><br><span class="line"><span class="comment">        传入的Runnable参数*/</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock();</span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//从线程池的任务阻塞队列中取出任务，如果任务队列为空则会使线程陷入阻塞</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="keyword">null</span> || (task = <span class="keyword">this</span>.getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(<span class="keyword">this</span>.ctl.get(), <span class="number">536870912</span>) || </span><br><span class="line">                	Thread.interrupted() &amp;&amp; runStateAtLeast(<span class="keyword">this</span>.ctl.get(), </span><br><span class="line">                	<span class="number">536870912</span>)) &amp;&amp; !wt.isInterrupted()) &#123;</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beforeExecute(wt, task);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">//执行任务</span></span><br><span class="line">                        task.run();</span><br><span class="line">                        <span class="keyword">this</span>.afterExecute(task, (Throwable)<span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var14) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.afterExecute(task, var14);</span><br><span class="line">                        <span class="keyword">throw</span> var14;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    ++w.completedTasks;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
在这个方法中线程会不断从线程池中取出任务并执行任务，直到取出的任务对象<br>为空，这是线程池已经关闭或任务队列为空，这是就会跳出while循环进入<br>finally语句块，接下来是getTask的源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//死循环，方法要么返回null要么返回Runnable对象代表取到任务</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, <span class="number">0</span>) &amp;&amp; (runStateAtLeast(c, <span class="number">536870912</span>) || </span><br><span class="line">            	<span class="keyword">this</span>.workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">this</span>.decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">boolean</span> timed = <span class="keyword">this</span>.allowCoreThreadTimeOut || wc &gt; </span><br><span class="line">            <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (wc &lt;= <span class="keyword">this</span>.maximumPoolSize &amp;&amp; (!timed || !timedOut) || wc &lt;= <span class="number">1</span> </span><br><span class="line">            	&amp;&amp; !<span class="keyword">this</span>.workQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Runnable r = timed ? (Runnable)<span class="keyword">this</span>.workQueue.poll(</span><br><span class="line">                    	<span class="keyword">this</span>.keepAliveTime, TimeUnit.NANOSECONDS) : </span><br><span class="line">                    (Runnable)<span class="keyword">this</span>.workQueue.take();</span><br><span class="line">                    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    timedOut = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException var6) &#123;</span><br><span class="line">                    timedOut = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.compareAndDecrementWorkerCount(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
以下是一个线程池的实际用例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPollTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Execption</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个具有固定线程数 (6) 线程</span></span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">6</span>); </span><br><span class="line">		<span class="comment">// 使用 Lambda 表达式创建 Runnable对象</span></span><br><span class="line">		Runnable target = () -&gt; &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i ++ ) </span><br><span class="line">			System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">				&#125; ; </span><br><span class="line">		<span class="comment">//向线程池提交两个线程</span></span><br><span class="line">		pool.submit(target);</span><br><span class="line">		pool.submit(target);</span><br><span class="line">		<span class="comment">//关闭线程池</span></span><br><span class="line">		pool.shutdown() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</Worker></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/">https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/25/Java%E5%B9%B6%E5%8F%912/"><i class="fa fa-chevron-left">  </i><span>Java并发2</span></a></div><div class="next-post pull-right"><a href="/2020/12/10/ComputerNetwork2/"><span>计算机网络2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/21/Java%E5%B9%B6%E5%8F%91/';
  this.page.identifier = '2020/12/21/Java并发/';
  this.page.title = 'Java并发';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F7fe26ede962c3e048f6e8f1f8c12b3f803e1457f.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611849565&amp;t=29a8f8fb1f5f28e19cc5104ad7f885e5)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>