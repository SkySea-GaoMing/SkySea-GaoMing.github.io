<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机网络2"><meta name="keywords" content="NetWork"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>计算机网络2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运输层"><span class="toc-number">2.</span> <span class="toc-text">运输层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#协议"><span class="toc-number">2.1.</span> <span class="toc-text">协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#区别"><span class="toc-number">2.1.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#传输层的端口"><span class="toc-number">2.1.2.</span> <span class="toc-text">传输层的端口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">2.2.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP首部格式"><span class="toc-number">2.2.1.</span> <span class="toc-text">UDP首部格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">2.3.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP的连接"><span class="toc-number">2.3.1.</span> <span class="toc-text">TCP的连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可靠传输"><span class="toc-number">2.3.2.</span> <span class="toc-text">可靠传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#停止等待协议"><span class="toc-number">2.3.3.</span> <span class="toc-text">停止等待协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连续ARQ协议"><span class="toc-number">2.3.4.</span> <span class="toc-text">连续ARQ协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP报文段"><span class="toc-number">2.4.</span> <span class="toc-text">TCP报文段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP可靠传输的实现"><span class="toc-number">2.5.</span> <span class="toc-text">TCP可靠传输的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#超时重传时间的选择"><span class="toc-number">2.5.1.</span> <span class="toc-text">超时重传时间的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择确认SACK"><span class="toc-number">2.5.2.</span> <span class="toc-text">选择确认SACK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的流量控制"><span class="toc-number">2.6.</span> <span class="toc-text">TCP的流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的传输效率"><span class="toc-number">2.7.</span> <span class="toc-text">TCP的传输效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的拥塞控制"><span class="toc-number">2.8.</span> <span class="toc-text">TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP的拥塞控制方法"><span class="toc-number">2.8.1.</span> <span class="toc-text">TCP的拥塞控制方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#慢开始和拥塞避免"><span class="toc-number">2.8.2.</span> <span class="toc-text">慢开始和拥塞避免</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP的运输连接管理"><span class="toc-number">2.9.</span> <span class="toc-text">TCP的运输连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP的连接建立"><span class="toc-number">2.9.1.</span> <span class="toc-text">TCP的连接建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP的连接释放"><span class="toc-number">2.9.2.</span> <span class="toc-text">TCP的连接释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP的有限状态机"><span class="toc-number">2.9.3.</span> <span class="toc-text">TCP的有限状态机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络安全"><span class="toc-number">3.</span> <span class="toc-text">网络安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拒绝服务DoS"><span class="toc-number">3.1.</span> <span class="toc-text">拒绝服务DoS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对称密钥密码体制"><span class="toc-number">3.2.</span> <span class="toc-text">对称密钥密码体制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公钥密码体制"><span class="toc-number">3.3.</span> <span class="toc-text">公钥密码体制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运输层安全协议"><span class="toc-number">3.4.</span> <span class="toc-text">运输层安全协议</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">计算机网络2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/10/ComputerNetwork2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/10/ComputerNetwork2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《网络是怎样连接的》 《计算机网络》 <a href="http://www.cyc2018.xyz" target="_blank" rel="noopener">http://www.cyc2018.xyz</a></p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>网络层为主机之间提供逻辑通信，而传输层为应用进程之间提供端到端的<br>逻辑通信，此外传输层还要对收到的报文进行差错检测，在网络层只对IP<br>数据报的首部进行检测而不检查数据部分</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>传输层有两种不同的协议：面向连接的TCP和无连接的UDP</p>
<ol>
<li>用户数据报协议UDP 是无连接的，尽最大可能交付，没有拥塞控制，面<br>向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）<br>，支持一对一、一对多、多对一和多对多的交互通信</li>
<li>传输控制协议TCP 是面向连接的，提供可靠交付，有流量控制，拥塞控<br>制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，<br>把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的<br>（一对一）</li>
</ol>
<p>两个对等运输实体在通信时传送的数据单位叫运输协议数据单元TPDU，在<br>TCP/IP体系中，根据使用的协议分别叫做TCP报文段或UDP用户数据报</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后<br>，不需要给出任何确认。TCP 则提供面向连接的服务。TCP 不提供广播或多<br>播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地<br>增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许<br>多的处理机资源 <img src="/2020/12/10/ComputerNetwork2/1.jpg" alt></p>
<h4 id="传输层的端口"><a href="#传输层的端口" class="headerlink" title="传输层的端口"></a>传输层的端口</h4><p>应用层所有的应用进程都可以通过传输层再传送到IP层，这就是复用。传输<br>层从IP 层收到发送给各应用进程的数据后，必须分别交付指明的各应用进<br>程，这就是分用，要实现复用和分用就要给每个应用进程一个明确的标志。<br>在传输层使用协议端口号，这是一种软件端口，是应用层的各种协议进程<br>与运输实体进行层间交互的一种地址。端口用一个16位端口号进行标志 <img src="/2020/12/10/ComputerNetwork2/2.jpg" alt></p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP只在IP的数据报服务之上增加了很少一点的功能，即端口的功能和差错<br>检测的功能，虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方<br>面有其特殊的优点</p>
<ul>
<li>UDP 是无连接的，即发送数据之前不需要建立连接</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制，<br>因此网络出现的拥塞不会使源主机的发送速率降低</li>
<li>UDP 是面向报文的。UDP没有拥塞控制，很适合多媒体通信的要求，注意<br>面向报文是说应用层交给UDP多长的报文，UDP就照样发送，即一次发送一<br>个报文</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li>
<li>UDP 的首部开销小，只有8个字节</li>
</ul>
<p><img src="/2020/12/10/ComputerNetwork2/3.jpg" alt></p>
<h4 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h4><p>一共8个字节，每个字段2个字节</p>
<ol>
<li>源端口 需要对方回信时使用，不需要是可全为0</li>
<li>目的端口 在终点交付报文时必须使用</li>
<li>长度 UDP用户数据报的长度，最小值为8</li>
<li>检验和 检测UDP用户数据报在传输中是否有错</li>
</ol>
<p><img src="/2020/12/10/ComputerNetwork2/4.jpg" alt><br>在计算检验和时，要在UDP 用户数据报之前增加12个字节的伪首部，伪首部并<br>不是UDP用户数据报真正的首部，只是在计算检验和时临时添加在UDP 用户数<br>据报前面。注意计算IP数据报的检验只是检验IP数据报的首部，而UDP的检验<br>是把首部和数据部分一起检验 <img src="/2020/12/10/ComputerNetwork2/5.jpg" alt><br>在之前讲解traceroute时，就是让发送的UDP用户数据报故意使用一个非法的<br>UDP端口，结果ICMP就返回端口不可达差错报文，从而达到测试目的。虽然UDP<br>之间的通信需要用到端口号，但是是无连接的，并不需要套接字来建立连接</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP的主要特点如下</p>
<ol>
<li>TCP是面向连接的传输层协议，也就是说应用程序在使用TCP协议之前必须先<br>建立TCP连接，在传送数据完成之后必须释放已经建立的TCP连接</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</li>
<li>TCP提供可靠交付的服务，无差错、不丢失、不重复，并且按序到达</li>
<li>TCP 提供全双工通信，TCP允许通信双方的应用进程在任何时候都能发送数<br>据，并且在TCP两端都有发送缓存和接收缓存</li>
<li>面向字节流，TCP把应用程序交下来的数据仅仅看成一连串的无结构字节流，<br>具体分为多少数据块是根据对方给出的窗口值和当前网络拥塞的程度 <img src="/2020/12/10/ComputerNetwork2/6.jpg" alt></li>
</ol>
<h4 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h4><p>之前已经讲过每一条TCP连接有两个端点，连接的端点叫做套接字socket，端口号<br>拼接到IP地址即构成socket。每一条TCP连接唯一地被通信两端的两个端点所确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket &#x3D; (IP地址: 端口号)</span><br><span class="line">TCP 连接 ::&#x3D; &#123;socket1, socket2&#125; &#x3D; &#123;(IP1: port1), (IP2: port2)&#125;</span><br></pre></td></tr></table></figure>
<p>socket有很多种不同的意思</p>
<ul>
<li>应用编程接口 API 称为 socket API, 简称为 socket</li>
<li>socket API 中使用的一个函数名也叫作 socket</li>
<li>调用 socket 函数的端点称为 socket</li>
<li>调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket</li>
<li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现</li>
</ul>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>TCP提供的传输是可靠的，理想的传输条件有两个特点</p>
<ol>
<li>传输信道不产生差错</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理受到的数据</li>
</ol>
<p>然而实际的网络不具备理想条件，可以使用一些可靠的协议，当出现差错时<br>让发送方重传数据，同时接收方来不及处理数据时及时告知发送方降低发送<br>速度</p>
<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>停止等待就是每发送完一个分组就停止发送，等待对方确认后再发送下一个<br><img src="/2020/12/10/ComputerNetwork2/7.jpg" alt><br>这里要注意三点</p>
<ol>
<li>在发送完一个分组后，必须暂时保留已发送的分组的副本，只有收到相<br>应的确认后才能清楚暂时保留的分组副本</li>
<li>分组和确认分组都必须进行编号，这样才能确认哪个分组发送成功</li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些</li>
</ol>
<p>还有确认丢失和确认迟到的情况 <img src="/2020/12/10/ComputerNetwork2/8.jpg" alt><br>停止等待协议也称为自动重传请求ARQ，意思是重传的请求是自动进行的，<br>不需要接收方发送重传请求，停止等待协议的优点是简单，但是信道利用<br>率太低 <img src="/2020/12/10/ComputerNetwork2/9.jpg" alt><br>为了提高传输效率可以采用流水线传输，流水线传输就是发送方可以连续<br>发送多个分组，不必每发完一个分组就停下来等待对方的确认，流水线传<br>输需要连续ARQ协议和滑动窗口协议</p>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>位于发送窗口中的分组都可以连续被发送出去而不需要等待对方的确认，<br>每收到一个确认就把发送窗口向前滑动一个分组的位置，接收方一般采用<br>累积确认的方式，接收方不必逐个发送确认，而是在收到几个分组后对按<br>序到达的最后一个分组发送确认，这就表示到这个分组为止的所有分组都<br>已经正确收到 <img src="/2020/12/10/ComputerNetwork2/10.jpg" alt><br>累积确认的缺点是不能向发送方反映出接收方已经正确收到的所有分组的<br>信息，比如发送方发送前5个分组，中间第三个丢失，这时接收方只能对<br>前两个分组发出确认，发送方不知道后三个分组的下落所有只能重传，<br>这就叫做Go-back-N，表示需要再退回来重传已发送的N个分组</p>
<h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3><p>TCP传输的数据单元是报文段，一个TCP报文段分为首部和数据，而TCP的<br>全部功能都体现在它首部中各字段的作用，TCP报文首部的前20个字节是<br>固定的，后面4n个字节是根据需要而增加的 <img src="/2020/12/10/ComputerNetwork2/11.jpg" alt></p>
<ol>
<li>源端口和目的端口 分别写入源端口号和目的端口号</li>
<li>序号 占 4字节。TCP 连接中传送的数据流中的每一个字节都编上一个<br>序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</li>
<li>确认号 占4字节，是期望收到对方的下一个报文段的数据的第一个字<br>节的序号。比如B正确收到A发送来的一个报文段，其序号是501，数据长度<br>是200，那么B期望下次收到的数据序号是701，所以确认号就是701。也就<br>是说确认号之前的数据都正确收到</li>
<li>数据偏移 它指出TCP报文段的数据起始处距离TCP报文段的起始处有多<br>远，也就是TCP报文段的首部长度，注意数据偏移的单位是4个字节，所以<br>4位二进制最大表示1111的十进制数为15，所以最大值是60个字节，所以<br>选项长度不能超过40个字节</li>
<li>保留 占6位，保留为今后使用，但目前应置为0</li>
<li>紧急URG 当 URG=1时，表明紧急指针字段有效。它告诉系统此报文段中<br>有紧急数据，应尽快传送（相当于高优先级的数据）</li>
<li>确认ACK 只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效，<br>连接建立后所有报文段ACK必须置为1</li>
<li>推送PSH 接收TCP收到PSH = 1的报文段，就尽快地交付接收应用进程，<br>而不再等到整个缓存都填满了后再向上交付</li>
<li>复位RST 当RST=1 时，表明TCP 连接中出现严重差错（如由于主机崩<br>溃或其他原因），必须释放连接，然后再重新建立运输连接</li>
<li>同步SYN 同步SYN = 1表示这是一个连接请求或连接接受报文。当SYN<br>=1而ACK=0标明这是一个连接请求报文，若对方同意建立连接，则在响应<br>报文段中SYN=1 ACK=1</li>
<li>终止FIN 用来释放一个连接。FIN=1 表明此报文段的发送端的数据已发<br>送完毕，并要求释放运输连接</li>
<li>窗口 占2字节，用来让对方设置发送窗口的依据，单位为字节，比如发<br>送一个报文段，其确认号是701，窗口字段是1000，这就是告诉对方从701<br>号算起，我（即发送此报文段的一方）的接收缓存空间还可以接收1000个<br>字节数据，你在给我发送数据时需要考虑这一点</li>
<li>检验和 检验和字段检验的范围包括首部和数据这两部分。在计算检验和<br>时，要在TCP报文段的前面加上12字节的伪首部</li>
<li>紧急指针 指出在本报文段中紧急数据共有多少个字节（紧急数据放在<br>本报文段数据的最前面）</li>
<li>选项 最长是40个字节，TCP最初只规定了一种选项，即最大报文段长度<br>MSS，MSS是每一个TCP报文段中的数据字段的最大长度，默认是536字节</li>
</ol>
<h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><p>TCP的滑动窗口是以字节为单位的，现在假定A受到了B发来的确认报文段，其<br>中窗口是20字节，而确认号是31（表示B希望接收的下一个序号是31），根据<br>这两个数据A就可以构造自己的发送窗口 <img src="/2020/12/10/ComputerNetwork2/12.jpg" alt><br>现在假定A发送了序号为31~41的数据，这时发送窗口位置并未改变 <img src="/2020/12/10/ComputerNetwork2/13.jpg" alt><br><img src="/2020/12/10/ComputerNetwork2/14.jpg" alt> <img src="/2020/12/10/ComputerNetwork2/15.jpg" alt><br>之前提过发送方的应用进程把字节流写入TCP的发送缓存，接收方的应用进程<br>从TCP的接收缓存中读取字节流 <img src="/2020/12/10/ComputerNetwork2/16.jpg" alt> <img src="/2020/12/10/ComputerNetwork2/17.jpg" alt></p>
<h4 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h4><p>之前提过TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段<br>，时间不能太长或太短，TCP采用一种自适应算法，它记录一个报文段发出的<br>时间以及收到相应的确认时间，这两个时间之差就是报文段的往返时间RTT，<br>TCP保留了RTT的一个加权平均往返时间RTTS（这又称为平滑的往返时间）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a是0.125</span><br><span class="line">新的RTTS&#x3D;(1-a)*(旧的RTTS)+a*(新的RTT样本)</span><br></pre></td></tr></table></figure>
<p>显然超时计时器设置的超时重传时间RTO应该略大于加权平均往返时间RTTS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RTTD是RTT的偏差的加权平均值</span><br><span class="line">B是0.25</span><br><span class="line">RTTD&#x3D;(1-B)*(旧的RTTD)+B*|RTTS-新的RTT样本|</span><br><span class="line">RTO&#x3D;RTTS+4*RTTD</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/10/ComputerNetwork2/18.jpg" alt><br>Karn算法是在加算加权平均RTTS时只要报文段重传了，就不采用其往返时间<br>样本，进一步修正就是报文段每重传一次就把超时重传时间RTO增大一些</p>
<h4 id="选择确认SACK"><a href="#选择确认SACK" class="headerlink" title="选择确认SACK"></a>选择确认SACK</h4><p>如果收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，可以<br>通过选择确认来确保只传送缺少的数据而不重传已经正确到达接收方的数据，<br>比如1~1000收到了，当1001~1500没有收到，如果要使用选择确认，那么<br>在建立 TCP 连接时，就要在TCP首部的选项中加上允许SACK的选项</p>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收，有一种<br>情况是A一直等待收到B发送的非零窗口通知，B也一直在等待A发送的数据，<br>为了解决这个问题TCP为每一个连接设有一个持续计数器，只要时间到期A就<br>发送一个零窗口探测报文段（1字节） <img src="/2020/12/10/ComputerNetwork2/20.jpg" alt></p>
<h3 id="TCP的传输效率"><a href="#TCP的传输效率" class="headerlink" title="TCP的传输效率"></a>TCP的传输效率</h3><p>应用进程把数据传送到TCP的发送缓存后，剩下的任务就由TCP完成。有不同的<br>机制来控制TCP报文段的发送时机。第一种机制是TCP维持一个变量，它等于最<br>大报文段长度MSS，当缓存中的数据达到MSS字节时就组装一个TCP报文段发送<br>出去，第二种机制是由发送方的应用进程执行要求发送报文段，TCP支持推送<br>操作，第三种机制是发送方的一个计时器到期，这是就把缓存装入报文段发送</p>
<h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网<br>络的性能就要变坏——产生拥塞，若网络中有许多资源同时产生拥塞，网络的性<br>能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。拥塞控制就<br>是防止过多的数据注入网络中，前提是网络能够承受现有的网络负荷，流量<br>控制外网是点对点通信量的控制 <img src="/2020/12/10/ComputerNetwork2/21.jpg" alt></p>
<h4 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h4><p>参考 <a href="https://blog.csdn.net/qq_41431406/article/details/97926927" target="_blank" rel="noopener">https://blog.csdn.net/qq_41431406/article/details/97926927</a><br>TCP进行拥塞控制的算法有四种</p>
<ol>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ol>
<h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>发送方让自己的发送窗口等于拥塞窗口，只要没有拥塞就增大拥塞窗口否则减<br>少拥塞窗口。只要发生了超时说明网络可能有拥塞。慢开始算法的思路是一开<br>始不发送大量数据，由小到大逐渐增大发送窗口 <img src="/2020/12/10/ComputerNetwork2/31.jpg" alt><br>假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，<br>因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发<br>送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认<br>报文段，发送方收到该确认报文后，将拥塞窗口的值变为2。<br>拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT<br>就把发送方的拥塞窗口cwnd加1，而不是加倍增长 <img src="/2020/12/10/ComputerNetwork2/32.jpg" alt> <img src="/2020/12/10/ComputerNetwork2/33.jpg" alt><br>快速重传算法可以让发送方尽早知道发生了个别报文段的丢失。比如接收方<br>收到了M1和M2 都即时确认，但是没有收到M3，如果收到了M4这时不能等待<br>而是继续发送对M2的确认，发送方只要一连收到3个重复的确认就知道接收<br>方没有收到M3，此时立即进行重传 <img src="/2020/12/10/ComputerNetwork2/34.jpg" alt> <img src="/2020/12/10/ComputerNetwork2/35.jpg" alt> <img src="/2020/12/10/ComputerNetwork2/36.jpg" alt><br>可以用一张流程图总结，发送窗口的上限值是受接受方窗口和网络的拥塞程<br>度共同影响 <img src="/2020/12/10/ComputerNetwork2/37.jpg" alt></p>
<h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><p>TCP是面向连接的协议，TCP运输连接的建立和释放是每一次面向连接的通信中<br>必不可少的过程，有三个阶段：连接建立、数据传送和连接释放。TCP建立连接<br>要解决三个问题</p>
<ol>
<li>要使每一方能够确知对方的存在</li>
<li>要允许双方协商一些参数</li>
<li>能够对运输实体资源进行分配</li>
</ol>
<h4 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h4><p>参考 <a href="https://yuanrengu.com/2020/77eef79f.html" target="_blank" rel="noopener">https://yuanrengu.com/2020/77eef79f.html</a><br>TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交互三个TCP报文<br>段，也叫三次握手（不太准确）。客户和服务器都是先创建传输控制模块TCB，<br>TCB存储了每一个连接中的一些重要信息，如TCP连接表，指向发送和接收缓存<br>的指针等</p>
<ol>
<li>注意SYN=1的报文段不能携带数据，此时TCP客户端进入SYN-SENT状态，注<br>意SYN=1的报文段不能传送数据 <img src="/2020/12/10/ComputerNetwork2/22.jpg" alt></li>
<li>B接收到连接请求报文，在确认报文段中把SYN和ACK置为1而且不能携带数<br>据。这时TCP服务器进程进入SYN-RCVD状态 <img src="/2020/12/10/ComputerNetwork2/23.jpg" alt></li>
<li>TCP客户进程收到B确认后，还要向B给出确认，确认报文段ACK为1，ACK<br>报文段可以携带数据，如果不携带数据则不消耗序号，这种情况下下一个数<br>据报文段的序号仍是x+1，这时TCP连接已建立，A进入ESTABLISHED状态 <img src="/2020/12/10/ComputerNetwork2/24.jpg" alt></li>
<li>B收到A的确认后也进入ESTABLISHED状态，到此的建立过程叫三报文握手</li>
<li>注意B发送给A的报文段可以拆分成两个报文段，可以先发送一个确认报文<br>段(ACK=1 ack=x+1)，然后再发送一个同步报文段(SYN=1 seq=y)，这样就<br>变成了四报文握手</li>
</ol>
<p>注意为什么A最后还要发送一次确认，这是为了防止已失效的连接请求报文段<br>突然又传送到了B。假定A发出的第一个连接请求没有丢失而是因为延迟到了B<br>，这本是一个早已失效的报文段，但是B在接收到这个报文段后误认为是A又<br>发出的一个新的连接请求，于是向A发送确认请求建立连接，但是目前的A并<br>没有打算发送连接请求，所以不会理睬B的确认，当B认为这个连接已经建立<br>所以会一直等待A发来数据，B的很多资源白白浪费</p>
<h4 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h4><p>数据传输结束后通信的双方都可以释放连接 <img src="/2020/12/10/ComputerNetwork2/25.jpg" alt><br>B收到连接释放报文后发出确认 <img src="/2020/12/10/ComputerNetwork2/26.jpg" alt> <img src="/2020/12/10/ComputerNetwork2/27.jpg" alt><br>A收到B的连接释放报文段后必须对此发出确认，然后进入TIME-WAIT状态，<br>此时TCP连接还没有被释放掉，必须经过时间等待计时器设置的是时间2MSL<br>，A才会进入到CLOSED状态，时间MSL叫做最长报文段寿命，这时撤销TCB<br>就结束了TCP连接 <img src="/2020/12/10/ComputerNetwork2/28.jpg" alt> <img src="/2020/12/10/ComputerNetwork2/29.jpg" alt></p>
<p>为什么A在TIME-WAIT状态必须等待两个2MSL？第一是为了保证A发送的最后<br>一个报文段能够到达B，这个报文段可能丢失，如果处在LAST-ACK状态的B<br>收不到已发送的FIN+ACK报文段的确认就会超时重传这个报文段，A在2MSL<br>时间内能收到这个重传的报文段那么A就重传一次确认，重新启动2MSL计时<br>，最后A和B都能进入CLOSED状态，如果不等待2MSL的话就无法收到重传的<br>报文段，那么B就无法进入CLOSED状态。第二关闭链接一段时间后可能会在<br>相同的IP地址和端口建立新的连接，为了防止旧连接的重复分组在新连接<br>已经终止后再现。2MSL足以让所有分组都消失</p>
<h4 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h4><p>下图更清晰展示TCP连接的各种状态之间的关系 <img src="/2020/12/10/ComputerNetwork2/30.jpg" alt></p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>计算机网络上的通信面临以下的四种威胁</p>
<ol>
<li>截获 从网络上窃听他人的通信内容</li>
<li>中断 有意中断他人在网络上的通信</li>
<li>篡改 故意篡改网络上传送的报文</li>
<li>伪造 伪造信息在网络上传送</li>
</ol>
<p>截获信息的攻击称为被动攻击，而更改信息和拒绝用户使用资源的攻击称<br>为主动攻击</p>
<h3 id="拒绝服务DoS"><a href="#拒绝服务DoS" class="headerlink" title="拒绝服务DoS"></a>拒绝服务DoS</h3><p>攻击者向互联网上的某个服务器不停发送大量分组，使该服务器无法提供<br>正常服务，这种攻击称为拒绝服务，若从互联网上成百上千个网站一起攻<br>击一个网站，称为分布式拒绝服务DDoS，有时也称为网络带宽服务或连<br>通性攻击</p>
<h3 id="对称密钥密码体制"><a href="#对称密钥密码体制" class="headerlink" title="对称密钥密码体制"></a>对称密钥密码体制</h3><p>加密密钥和解密密钥是使用相同的密码体制，数据加密标准DES属于对称<br>密钥密码体制</p>
<h3 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h3><p>使用不同的加密密钥和解密密钥</p>
<h3 id="运输层安全协议"><a href="#运输层安全协议" class="headerlink" title="运输层安全协议"></a>运输层安全协议</h3><p>有以下两个协议</p>
<ol>
<li>安全套接字层SSL</li>
<li>运输层安全TLS</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/10/ComputerNetwork2/">https://skysea-gaoming.github.io/2020/12/10/ComputerNetwork2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NetWork/">NetWork</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/21/Java%E5%B9%B6%E5%8F%91/"><i class="fa fa-chevron-left">  </i><span>Java并发</span></a></div><div class="next-post pull-right"><a href="/2020/12/07/MySQL3/"><span>MySQL3</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/10/ComputerNetwork2/';
  this.page.identifier = '2020/12/10/ComputerNetwork2/';
  this.page.title = '计算机网络2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>