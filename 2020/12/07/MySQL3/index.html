<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MySQL3"><meta name="keywords" content="DataBase"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>MySQL3 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表"><span class="toc-number">2.</span> <span class="toc-text">表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引组织表"><span class="toc-number">2.1.</span> <span class="toc-text">索引组织表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB逻辑存储结构"><span class="toc-number">2.2.</span> <span class="toc-text">InnoDB逻辑存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#表空间"><span class="toc-number">2.2.1.</span> <span class="toc-text">表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#段"><span class="toc-number">2.2.2.</span> <span class="toc-text">段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区"><span class="toc-number">2.2.3.</span> <span class="toc-text">区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#页"><span class="toc-number">2.2.4.</span> <span class="toc-text">页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行"><span class="toc-number">2.2.5.</span> <span class="toc-text">行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB行记录格式"><span class="toc-number">2.3.</span> <span class="toc-text">InnoDB行记录格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Compact"><span class="toc-number">2.3.1.</span> <span class="toc-text">Compact</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redundant"><span class="toc-number">2.3.2.</span> <span class="toc-text">Redundant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行溢出数据"><span class="toc-number">2.3.3.</span> <span class="toc-text">行溢出数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dynamic"><span class="toc-number">2.3.4.</span> <span class="toc-text">Dynamic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB数据页结构"><span class="toc-number">2.4.</span> <span class="toc-text">InnoDB数据页结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#约束"><span class="toc-number">2.5.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#约束的创建和查找"><span class="toc-number">2.5.1.</span> <span class="toc-text">约束的创建和查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#约束和索引"><span class="toc-number">2.5.2.</span> <span class="toc-text">约束和索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对错误数据的约束"><span class="toc-number">2.5.3.</span> <span class="toc-text">对错误数据的约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENUM和SET"><span class="toc-number">2.5.4.</span> <span class="toc-text">ENUM和SET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#触发器与约束"><span class="toc-number">2.5.5.</span> <span class="toc-text">触发器与约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外键约束"><span class="toc-number">2.5.6.</span> <span class="toc-text">外键约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图"><span class="toc-number">2.6.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区表"><span class="toc-number">2.7.</span> <span class="toc-text">分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RANGE分区"><span class="toc-number">2.7.1.</span> <span class="toc-text">RANGE分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LIST分区"><span class="toc-number">2.7.2.</span> <span class="toc-text">LIST分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HASH分区"><span class="toc-number">2.7.3.</span> <span class="toc-text">HASH分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KEY分区"><span class="toc-number">2.7.4.</span> <span class="toc-text">KEY分区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引与算法"><span class="toc-number">3.</span> <span class="toc-text">索引与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构与算法"><span class="toc-number">3.1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二分查找法"><span class="toc-number">3.1.1.</span> <span class="toc-text">二分查找法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树"><span class="toc-number">3.1.2.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树索引"><span class="toc-number">3.2.</span> <span class="toc-text">B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#聚集索引"><span class="toc-number">3.2.1.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#辅助索引"><span class="toc-number">3.2.2.</span> <span class="toc-text">辅助索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树索引的分裂"><span class="toc-number">3.2.3.</span> <span class="toc-text">B+树索引的分裂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树索引的管理"><span class="toc-number">3.2.4.</span> <span class="toc-text">B+树索引的管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cardinality"><span class="toc-number">3.3.</span> <span class="toc-text">Cardinality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的使用"><span class="toc-number">3.4.</span> <span class="toc-text">索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#联合索引"><span class="toc-number">3.4.1.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖索引"><span class="toc-number">3.4.2.</span> <span class="toc-text">覆盖索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希算法"><span class="toc-number">3.5.</span> <span class="toc-text">哈希算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全文检索"><span class="toc-number">3.6.</span> <span class="toc-text">全文检索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#倒排索引"><span class="toc-number">3.6.1.</span> <span class="toc-text">倒排索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-number">4.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lock与latch"><span class="toc-number">4.1.</span> <span class="toc-text">lock与latch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的类型"><span class="toc-number">4.2.</span> <span class="toc-text">锁的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#快照"><span class="toc-number">4.2.1.</span> <span class="toc-text">快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一致性非锁定读"><span class="toc-number">4.2.2.</span> <span class="toc-text">一致性非锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVVC的实现原理"><span class="toc-number">4.2.3.</span> <span class="toc-text">MVVC的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一致性锁定读"><span class="toc-number">4.2.4.</span> <span class="toc-text">一致性锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自增长与锁"><span class="toc-number">4.2.5.</span> <span class="toc-text">自增长与锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外键和锁"><span class="toc-number">4.2.6.</span> <span class="toc-text">外键和锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的算法"><span class="toc-number">4.3.</span> <span class="toc-text">锁的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Phantom"><span class="toc-number">4.3.1.</span> <span class="toc-text">Phantom</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁问题"><span class="toc-number">4.4.</span> <span class="toc-text">锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#脏读"><span class="toc-number">4.4.1.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不可重复读"><span class="toc-number">4.4.2.</span> <span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#丢失更新"><span class="toc-number">4.4.3.</span> <span class="toc-text">丢失更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞"><span class="toc-number">4.4.4.</span> <span class="toc-text">阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">4.5.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务"><span class="toc-number">5.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#扁平事务"><span class="toc-number">5.1.</span> <span class="toc-text">扁平事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#带有保存点的事务"><span class="toc-number">5.1.1.</span> <span class="toc-text">带有保存点的事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链事务"><span class="toc-number">5.1.2.</span> <span class="toc-text">链事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套事务"><span class="toc-number">5.1.3.</span> <span class="toc-text">嵌套事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式事务"><span class="toc-number">5.1.4.</span> <span class="toc-text">分布式事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务的实现"><span class="toc-number">5.2.</span> <span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo"><span class="toc-number">5.2.1.</span> <span class="toc-text">redo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log-block"><span class="toc-number">5.2.2.</span> <span class="toc-text">log block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log-group"><span class="toc-number">5.2.3.</span> <span class="toc-text">log group</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重做日志格式"><span class="toc-number">5.2.4.</span> <span class="toc-text">重做日志格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LSN"><span class="toc-number">5.2.5.</span> <span class="toc-text">LSN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#恢复"><span class="toc-number">5.2.6.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo"><span class="toc-number">5.3.</span> <span class="toc-text">undo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undo存储管理"><span class="toc-number">5.3.1.</span> <span class="toc-text">undo存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log格式"><span class="toc-number">5.3.2.</span> <span class="toc-text">undo log格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#purge"><span class="toc-number">5.3.3.</span> <span class="toc-text">purge</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务控制语句"><span class="toc-number">5.4.</span> <span class="toc-text">事务控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式提交的SQL语句"><span class="toc-number">5.5.</span> <span class="toc-text">隐式提交的SQL语句</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">50</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F7fe26ede962c3e048f6e8f1f8c12b3f803e1457f.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611849565&amp;t=29a8f8fb1f5f28e19cc5104ad7f885e5)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">MySQL3</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/07/MySQL3/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/07/MySQL3/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《MySQL技术内幕》</p>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>表是关于特定实体的数据集合，也是关系型数据库模型的核心</p>
<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式<br>的表称为索引组织表。每张表都有一个主键</p>
<ul>
<li>首先判断表中是否有非空的唯一索引，如果有则该列为主键。当有多个<br>非空唯一索引时，将选择建表时第一个定义的非空唯一索引为主键</li>
<li>如果不符上述条件则InnoDB自动创建一个6字节大小的指针</li>
</ul>
<p>接下来用一个表来说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create table z(</span><br><span class="line">a int not null,</span><br><span class="line">b int null,</span><br><span class="line">c int not null,</span><br><span class="line">d int not null,</span><br><span class="line">unique key(b),</span><br><span class="line">unique key(d),unique key(c));</span><br><span class="line"></span><br><span class="line">mysql&gt; select *,_rowid from z;</span><br><span class="line">+---+------+----+----+--------+</span><br><span class="line">| a | b    | c  | d  | _rowid |</span><br><span class="line">+---+------+----+----+--------+</span><br><span class="line">| 1 |    2 |  3 |  4 |      4 |</span><br><span class="line">| 5 |    6 |  7 |  8 |      8 |</span><br><span class="line">| 9 |   10 | 11 | 12 |     12 |</span><br><span class="line">+---+------+----+----+--------+</span><br></pre></td></tr></table></figure>
<p>_rowid可以显示表的主键，但只能显示单个列为主键的情况</p>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>之前在MySQL2中已经讲了表空间文件存放所有数据。表空间又由段、区、页<br>组成，页在某些文档也称为块 <img src="/2020/12/07/MySQL3/1.jpg" alt></p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>在默认情况下InnoDB存储引擎有一个共享表空间ibdata1，即所有的数据都存放<br>在这个表空间中，如果用户启动参数innodb_file_per_table，则每张表内的<br>数据可以单独存放到一个表空间中，注意这里存放的只是数据、索引和插入缓冲<br>Bitmap页，其他类的数据还是在共享表空间中</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>上图已经说明表空间是由各个段组成，常见的段有数据段、索引段、回滚段等。<br>数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点 <img src="/2020/12/07/MySQL3/8.jpg" alt></p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由连续的页组成，在任何情况下每个区的大小都为1MB，为了保证区中页的<br>连续性，InnoDB存储引擎一次磁盘申请4~5个区，一个区有64个连续的页</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位，在InnoDB存储引擎中默认每个页的大小是<br>16KB。现在版本可以通过innodb_page_size将页的大小设置为4K、8K、16K。<br>常见的页类型如下</p>
<ul>
<li>数据页</li>
<li>undo页</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲列表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩的二进制大对象页</li>
</ul>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB存储引擎是面向列的，也就是说数据是按照行进行存放的。每个页最多<br>存放 16KB/2-200=7992 行记录</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>页中存放的是表中一行行数据，InnoDB存储引擎提供多种格式来存放行记录数据</p>
<h4 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h4><p>一个页中存放的数据越多性能越高 <img src="/2020/12/07/MySQL3/9.jpg" alt><br>Compact行记录格式的首部是一个非NULL变长字段长度列表，并且按照列的顺序<br>逆序放置</p>
<ul>
<li>若列的长度小于255字节，用1字节表示</li>
<li>若大于255字节，用2字节表示，因为VARCHAR类型最大长度是65535</li>
</ul>
<p>第二个部分是NULL标志位，用于指示改行数据是否有NULL值，有则用1表示，<br>第三个部分是记录头信息，固定占5个字节 <img src="/2020/12/07/MySQL3/10.jpg" alt><br>最后的部分就是实际存储每个列的数据，注意NULL不占该部分空间，还有一点是<br>除了用户定义的列外，还有两个隐藏列：事务ID和回滚指针列，分别为6字节和<br>7字节大小，若InnoDB表没有主键则还会增加一个rowid列</p>
<h4 id="Redundant"><a href="#Redundant" class="headerlink" title="Redundant"></a>Redundant</h4><p>Redundant是老版本的行记录存储方式 <img src="/2020/12/07/MySQL3/11.jpg" alt></p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnonDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外，<br>比如BLOB LOB这类大对象列类型会存储在数据页面之外</p>
<h4 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h4><p>支持Compact和Redundant格式的称为Antelope文件格式，新的文件格式<br>Barracuda支持Compressed和Dynamic</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>InnoDB数据页由7个部分组成 <img src="/2020/12/07/MySQL3/12.jpg" alt></p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>关系型数据库系统和文件系统的一个不同点是关系数据库本身能保证存储<br>数据的完整性，约束机制可以保证数据的完整性。数据完整性有以下三种<br>形式</p>
<ol>
<li>实体完整性保证表中有一个主键。在InnoDB 中可以通过定义primary<br>key或Unique Key来保证实体完整性。还可以通过编写一个触发器来保证<br>实体完整性</li>
<li>域完整性保证数据每列的值满足特定条件。可以通过以下方式来保证</li>
</ol>
<ul>
<li>选择合适数据类型</li>
<li>外键约束</li>
<li>编写触发器</li>
<li>用DEFAULT约束作为强制域完整性的一个方面</li>
</ul>
<ol start="3">
<li>参考完整性保证两张表之间的关系，可以通过定义外键或编写触发器</li>
</ol>
<p>InnoDB存储引擎提供的约束如下</p>
<ul>
<li>Primary Key</li>
<li>Unique Key</li>
<li>Foreign Key</li>
<li>Default</li>
<li>NOT NULL</li>
</ul>
<h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><p>约束的创建有两种方式</p>
<ol>
<li>表建立时就进行约束定义</li>
<li>使用alter table创建约束，Unique Key还可以通过create unique<br>index 来创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index bb on z(b);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>主键约束默认约束名为PRIMARY，Unique Key约束默认约束名为列名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select constraint_name,constraint_type from information_schema.TABLE_CONSTRAINTS</span><br><span class="line">where table_schema&#x3D;&#39;mytest&#39; and table_name&#x3D;&#39;z&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="约束和索引"><a href="#约束和索引" class="headerlink" title="约束和索引"></a>约束和索引</h4><p>约束是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，<br>在数据库中代表物理存储的方式</p>
<h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><p>在某些默认设置下MySQL数据库允许非法或不正确的数据的插入或更新，可以在<br>内部将其转化为一个合法的值，如向NOT NULL的字段插入一个NULL值，MySQL<br>会将其更改为0再插入，可以设置sql_mode保证数据库提示报错而不是警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set sql_mode&#x3D;&#39;STRICT_TRANS_TABLES&#39;</span><br></pre></td></tr></table></figure>
<h4 id="ENUM和SET"><a href="#ENUM和SET" class="headerlink" title="ENUM和SET"></a>ENUM和SET</h4><p>MySQL数据库不支持传统的CHECK约束，但是可以通过ENUM和SET类型解决这个<br>需求，例如有一个性别类型，范围只能是male或female</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table a(</span><br><span class="line">	id int,</span><br><span class="line">	sex enum(&#39;male&#39;,&#39;female&#39;));</span><br></pre></td></tr></table></figure>
<h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><p>完整性约束通常也可以使用触发器来实现，触发器的作用就是在执行INSERT<br>DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。创建触发器<br>的命令是create trigger</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE</span><br><span class="line">[DEFINER&#x3D;&#123;user|CURRENT_USER&#125;]</span><br><span class="line">TRIGGER trigger_name BEFORE|AFTER INSERT|UPDATE|DELETE</span><br><span class="line">ON tb1_name FOR EACH ROW trigger_stmt</span><br></pre></td></tr></table></figure>
<p>最多可以为一个表建立6个触发器，分别为 INSERT UPDATE DELETE的BEFORE<br>和AFTER各定义一个。BEFORE和AFTER 代表触发器发生的时间，表示在每行操<br>做之前还是之后发生。通过触发器可以实现MySQL 数据库本身并不支持的一些<br>特性。假设有张用户表，用户每次购买物品后金额都是减的，但是如果有一个<br>减去负值的操作，那么用户的钱反而会增多，语句本身没有问题但是逻辑错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table usercash(</span><br><span class="line">	userid int not null,</span><br><span class="line">	cash int not null);</span><br><span class="line">insert into usercash values(1,1000);</span><br><span class="line">update usercash set cash&#x3D;cash-(-20) where userid&#x3D;1;</span><br></pre></td></tr></table></figure>
<p>这时需要一个触发器来约束这个逻辑行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tgr_usercash_update BEFORE UPDATE ON usercash(</span><br><span class="line">	FOR EACH ROW</span><br><span class="line">	BEGIN </span><br><span class="line">	IF new.cash-oil.cash &gt; 0 THEN</span><br><span class="line">	INSERT INTO usercash_err_log</span><br><span class="line">	SELECT old.userid, old.cash, new.cash,USER(),NOW();</span><br><span class="line">	SET new.cash &#x3D; old.cash;</span><br><span class="line">	END IF;</span><br><span class="line">	END;</span><br><span class="line">	$$</span><br><span class="line">);</span><br><span class="line">DELIMITER $$;</span><br></pre></td></tr></table></figure>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>MyISAM不支持外键，InnoDB支持外键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE parent(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">)ENGINE &#x3D; INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE child(</span><br><span class="line">id INT, parent_id INT,</span><br><span class="line">FOREIGN KEY(parent_id) REFERENCES parent(id)</span><br><span class="line">)ENGINE&#x3D;INNODB;</span><br></pre></td></tr></table></figure>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个命名的虚表，但是视图中的数据没有实际的物理存储</p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>分区的过程是将一个表或索引分解为更小、更可管理的部分。就访问数据库而言<br>就一个表或一个索引，但是在物理上这个表或索引可以有数十个物理分区组成<br>，每个分区都是独立的对象，MySQL支持的分区类型是水平分区，不支持垂直<br>分区，此外MySQL的分区是局部分区索引，一个分区中既存放了数据又存放了<br>索引。全局分区指的是数据存放在各个分区，但是所有数据的索引存放在一个<br>对象中</p>
<ul>
<li>水平分区 同一个表中不同行的记录分配到不同物理文件中</li>
<li>垂直分区 同一个表中不同列的记录分配到不同物理文件中</li>
</ul>
<h4 id="RANGE分区"><a href="#RANGE分区" class="headerlink" title="RANGE分区"></a>RANGE分区</h4><p>行数据基于一个给定连续区间的列值被放入分区</p>
<h4 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h4><p>和RANGE分区类似，只是LIST面向的是离散的值</p>
<h4 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h4><p>根据用户自定义的表达式的返回值来进行分区</p>
<h4 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h4><p>根据MySQL提供的哈希函数进行分区</p>
<h2 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h2><p>索引并不是越多越好，在一开始就应该在需要处添加索引，MySQL 支持如下<br>索引，B+树索引并不能找到一个给定键值的具体行，而是找到行所在的页，<br>然后数据库把页读入到内存中</p>
<ul>
<li>B+树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><p>每页Page Directory中的槽是按照主键的顺序存放，对于某一条具体记录的<br>查询时通过对Page Direcotry进行二分查找得到</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树的插入分为三种情况 <img src="/2020/12/07/MySQL3/2.jpg" alt><br>当插入28时满足第一种情况，所以直接插入到叶子节点 <img src="/2020/12/07/MySQL3/3.jpg" alt><br>继续插入70满足第二种情况，这时插入Leaf Page后的顺序为 50 55 60 65<br>70，中间值是60所以放到分页节点 <img src="/2020/12/07/MySQL3/4.jpg" alt><br>最后插入95满足第三种情况，首先拆分叶子节点 75 80 85 90 95，中间值是<br>85将小于85的放在左边大于85的放在右边，然后拆分分页节点，25 50 60 75<br>85，中间值是60，小于60的放在左边大于60的放在右边 <img src="/2020/12/07/MySQL3/5.jpg" alt><br>B+树为了保持平衡可能会做大量拆分页的操作，因为B+树结构主要用于磁盘，<br>所以提供了旋转来减少拆分。旋转发生在Leaf Page已经满当左右兄弟节点没有<br>满的情况，这时不会拆分而是将记录移到兄弟节点上，通常情况左新兄弟先进<br>行旋转操作，现在插入70 <img src="/2020/12/07/MySQL3/6.jpg" alt><br>B+树使用填充因子来控制树的删除变化，50%是填充因子可设的最小值，B+树<br>的删除也分为三种情况 <img src="/2020/12/07/MySQL3/7.jpg" alt></p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树索引的本质就是B+树在数据库中的实现，B+索引在数据库中有一个特点就<br>是高扇出性，因此在数据库中B+树的高度一般在2~4层，也就是说查找某一键<br>值的行记录最多只需2到4次，B+索引可以分为聚集索引和辅助索引</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>聚集索引是按照每一张表的主键构造一棵B+树，叶子节点存放的就是整张表的<br>行记录数据，也将叶子节点称为数据页，聚集索引这个特性决定了索引组织表<br>中数据也是索引的一部分。每张表只能有一个聚集索引，多数情况下查询优化<br>器倾向采用聚集索引</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>也称为非聚集索引，叶子节点并不包含行记录的所有数据，叶子节点除了包含<br>键值以外，每个叶子节点的索引行还包含一个书签(bookmark)，该书签用来<br>告诉InnoDB存储引擎在哪里可以找到与索引相对应的行数据，这个书签实际<br>就是相应的聚集索引键。每张表可以有多个辅助索引，先通过辅助索引找到<br>相应的主键索引，再通过主键索引找到一个完整的行记录 <img src="/2020/12/07/MySQL3/13.jpg" alt></p>
<h4 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h4><p>B+树索引页的分裂并不总是从页的中间记录开始，这样可能导致页的浪费</p>
<h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><p>用户可以设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据</p>
<h3 id="Cardinality"><a href="#Cardinality" class="headerlink" title="Cardinality"></a>Cardinality</h3><p>并不是在所有的查询条件中出现的列都需要添加索引，可以通过Cardinality<br>来观察索引中不重复记录数量的预估值</p>
<h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p>根据OLTP和OLAP两种应用</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>对表的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值<br>的数量不是1而是大于等于2 <img src="/2020/12/07/MySQL3/14.jpg" alt><br>根据这棵B+树可以知道以下查询语句可以使用联合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a&#x3D;xxx and b&#x3D;xxx</span><br><span class="line">select * from table where a&#x3D;xxx</span><br></pre></td></tr></table></figure>
<p>但是对于b列的查询不能使用联合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where b&#x3D;xxx</span><br></pre></td></tr></table></figure>

<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>即从辅助索引中就可以得到查询的记录，不需要查询聚集索引的记录。覆盖<br>索引的另一个好处是对于某些统计问题而言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from buy_log;</span><br></pre></td></tr></table></figure>
<p>InnoDB并不会选择通过查询聚集索引来进行统计，由于buy_log表上还有<br>辅助索引，而辅助索引远小于聚集索引，所以会选择辅助索引</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>InnoDB存储引擎使用哈希算法来对字典进行查找，其冲突机制采用链表方式<br>，哈希函数采用的是除法散列方式</p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>可以通过索引字段的前缀进行查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from blog where content like &#39;xxx%&#39;;</span><br></pre></td></tr></table></figure>
<p>但是更多的是如下情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from blog where content like &#39;%xxx%&#39;;</span><br></pre></td></tr></table></figure>
<p>全文索引是将储存于数据库中的整本书或整篇文章中的任意内容信息查找出来<br>的技术</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>全文索引通常使用倒排索引来实现</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的<br>并发访问</p>
<h3 id="lock与latch"><a href="#lock与latch" class="headerlink" title="lock与latch"></a>lock与latch</h3><p>lock与latch都被称为锁。latch 一般称为闩锁（轻量级的锁)），其要求锁定的<br>时间非常短，若持续的时间长则应用的性能非常差，在InnoDB存储引擎中latch<br>又可以分为mutex（互斥量）和rwlock（读写锁）。lock的对象是事务，用来锁<br>定的是数据库中的对象，如表、页、行。并且仅在事务commit或rollback或unlock<br>后释放，有死锁机制 <img src="/2020/12/07/MySQL3/15.jpg" alt></p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>InnoDB存储引擎实现了两种标准的行级锁</p>
<ul>
<li>共享锁(S Lock) 允许事务读一行数据</li>
<li>排他锁(X Lock) 允许事务删除或更新一行数据</li>
</ul>
<p>如果一个事务T1已经获取了行r的共享锁，那么另外的事务T2可以立即获取行r<br>的共享锁，因为读取并没有改变行r的数据，这种情况为锁兼容。若有其他事务<br>T3想获得行r的排他锁，必须等事务T1、T2释放行r上的共享锁–这种情况称为<br>锁不兼容 <img src="/2020/12/07/MySQL3/16.jpg" alt><br>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的<br>锁同时存在。InnoDB存储引擎支持意向锁，意向锁是将锁定的对象分为多个层<br>次 <img src="/2020/12/07/MySQL3/17.jpg" alt></p>
<ul>
<li>意向共享锁(IS Lock) 事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock) 事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>这里对意向锁的解释很清晰 <a href="https://www.zhihu.com/question/51513268" target="_blank" rel="noopener">https://www.zhihu.com/question/51513268</a><br>意向锁是 InnoDB 自动加的，不需用户干预。对于UPDATE、 DELETE 和 INSERT<br>语句，InnoDB会自动给涉及数据集加排他锁(X)，对于普通SELECT语句，InnoDB<br>不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE </span><br><span class="line">其他session仍然可以查询记录，并也可以对该记录加share mode 的共享锁。</span><br><span class="line">但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁</span><br><span class="line">排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br><span class="line">其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</span><br><span class="line">表锁的语法如下</span><br><span class="line">需要注意lock tables语法除了会限制别的线程的读写之外，也限定了本线程接下来的操作对象</span><br><span class="line">lock tables .. read&#x2F;write </span><br><span class="line">unlock tables</span><br><span class="line"></span><br><span class="line">对于 insert、update、delete，InnoDB 会自动给涉及的数据加排他锁（X），只</span><br><span class="line">有查询 select 需要我们手动设置排他锁对于一般的 select 语句，InnoDB 不会</span><br><span class="line">加任何锁，也就是可以多个并发去进行 select 的操作，不会有任何的锁冲突，因</span><br><span class="line">为根本没有锁</span><br><span class="line">注意 select * 这样的全表扫描会给表加意向共享锁</span><br></pre></td></tr></table></figure>

<p>注意下图的X和S都是表级锁，书上的原句是“在对记录r加X锁之前，已经有事<br>务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上<br>加IX锁，由于不兼容，所以事务需要等待表锁操作的完成”，这里的X锁也是<br>表锁，行级锁只会和行级锁发生冲突，表级锁只会和表级锁发生冲突 <img src="/2020/12/07/MySQL3/18.jpg" alt></p>
<p>参考 <a href="https://blog.csdn.net/weixin_43935927/article/details/109438506" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43935927/article/details/109438506</a><br>行锁锁的究竟是什么，事实上行锁锁的并不是某一行的数据，而是这一行数据<br>的索引，比如先操作一个没有索引的表 <img src="/2020/12/07/MySQL3/25.jpg" alt><br>给id=1的数据加排他锁，但是id=3和id=5的数据都被阻塞了，说明锁住的不<br>是Record。接下来操作一个有主键索引的表 <img src="/2020/12/07/MySQL3/26.jpg" alt><br>使用相同的id加锁会冲突，使用不同的id加锁成功，但是不能确定是否是锁<br>定了id这个字段，接下来操作一个有唯一索引的表 <img src="/2020/12/07/MySQL3/27.jpg" alt><br>第二个事务想获取name=’4’的排它锁肯定会失败，但是为什么id=4的数据<br>也被阻塞，说明并没有锁定name这个字段，否则锁定id应该不会被阻塞，<br>结论就是InnoDB的行锁是通过锁住索引来实现的。第一个表中因为没有索引<br>所以会自动创建一个主键，查询没有使用索引所以会全表扫描把每一个隐藏<br>的聚集索引都锁住了，这里加的应该是一个表级排他锁。第二个表中给唯一<br>索引加锁时主键索引也会被锁住，辅助索引中，索引存储的是二级索引和<br>主键的值，也就是通过二级索引最终要找到主键索引，比如name=4存储<br>的是索引和主键id的值4，主键索引中除了索引还有完整的数据 <img src="/2020/12/07/MySQL3/28.jpg" alt></p>
<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>参考 <a href="https://www.cnblogs.com/qcloud1001/p/9322321.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcloud1001/p/9322321.html</a><br>快照的定义：关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据<br>在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的<br>一个副本，也可以是数据的一个复制品。<br>存储快照，是一种数据保护措施，可以对源数据进行一定程度的保护 <img src="/2020/12/07/MySQL3/29.jpg" alt><br>快照是一份完全可用的副本，那么，它完全可以被上层业务当做源数据 <img src="/2020/12/07/MySQL3/30.jpg" alt></p>
<h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>参考 <a href="https://blog.csdn.net/u010900754/article/details/106772974" target="_blank" rel="noopener">https://blog.csdn.net/u010900754/article/details/106772974</a><br>一致性非锁定读指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时<br>间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取<br>操作不会因此等待行上锁的释放，因为一般的读取操作是没有锁的，所以可以<br>直接读取到加锁的数据，会去读取行的一个快照 <img src="/2020/12/07/MySQL3/19.jpg" alt><br>快照数据是指该行的之前版本的数据，也即是 undo 中的数据，不需要加锁。<br>不同事物隔离级别下，读取的方式不同，并不是在每个事物隔离级别下都采用<br>非锁定的一致性读。<br>一个行记录可能不止一个快照数据，一般称这种技术为行多版本技术，由此带<br>来的并发控制称之为多版本并发控制。<br>在事务隔离级别为READ COMMITTED和REPETABLE READ下，InnoDB存储引擎<br>使用非锁定的一致性读，但是对于快照数据的定义不同</p>
<ul>
<li>READ COMMITTED 对于快照数据，非一致性读总是读取被锁定行的最新一份<br>快照数据</li>
<li>REPEATABLE READ 读取事务开始时的行数据版本</li>
</ul>
<p>参考 <a href="https://www.jianshu.com/p/8845ddca3b23" target="_blank" rel="noopener">https://www.jianshu.com/p/8845ddca3b23</a><br>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式<br>去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</p>
<ul>
<li>当前读 像select lock in share mode(共享锁), select for update;<br>update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前<br>读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改<br>当前记录，会对读取的记录进行加锁。</li>
<li>快照读 像不加锁的select操作就是快照读，即不加锁的非阻塞读，快照读<br>的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所<br>以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版<br>本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，<br>避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不<br>一定是数据的最新版本，而有可能是之前的历史版本</li>
</ul>
<h4 id="MVVC的实现原理"><a href="#MVVC的实现原理" class="headerlink" title="MVVC的实现原理"></a>MVVC的实现原理</h4><p>在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中<br>的 3个隐式字段，undo日志 ，Read View 来实现的。<br>InnoDB为每行记录都实现了三个隐藏字段 <img src="/2020/12/07/MySQL3/31.jpg" alt></p>
<ul>
<li>DB_TRX_ID，6字节 插入或更新行的最后一个事务的事务ID，事务编号是自<br>动递增的（我们把它理解为创建版本号，在数据新增或者修改为新数据的时候<br>，记录当前事务ID）</li>
<li>DB_ROLL_PTR，7字节 回滚指针（我们把它理解为删除版本号，数据被删除<br>或记录为旧数据的时候，记录当前事务ID）。我们把这两个事务ID理解为版本号</li>
<li>DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，<br>InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
</ul>
<p>快照是在第一条快照读的语句中生成，而不是在事务开始时创建快照<br><a href="https://zhuanlan.zhihu.com/p/55819387" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55819387</a></p>
<h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>某些情况下需要对数据库读取操作进行加锁以保证数据逻辑的一致性，即使是<br>对SELECT的只读操作也有两种一致性的锁定读操作，必须在事务中操作，注<br>意对于一致性非锁定读这两个操作不会加锁</p>
<ol>
<li>SELECT … FOR UPDATE 对读取的行记录加X锁，其余事务不能加任何锁</li>
<li>SELECT … LOCK IN SHARE MODE 加S锁，其余事务可以加S锁</li>
</ol>
<h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><p>每个含有自增长值的表都有一个自增长计数器，当对含有自增长计数器的表进<br>行插入操作时这个计数器会被初始化，插入操作会依据这个自增长的计数器值<br>加1赋予自增长列，这种锁采用一种特殊的表锁机制，并不是在一个事务完成<br>后才会释放，而是在完成自增长值插入的SQL语句后立即释放。但是对于有自<br>增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不<br>用等待事务的完成），对于INSERT .. SELECT的大数据量插入会影响插入<br>的性能，目前的版本采用一种轻量级互斥量的自增长实现机制。注意自增长<br>的列必须是索引，同时必须是索引的第一个列 <img src="/2020/12/07/MySQL3/32.jpg" alt> <img src="/2020/12/07/MySQL3/33.jpg" alt></p>
<h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><p>对于一个外键列，如果没有显示对这个列加锁，则自动加一个索引避免表锁<br>，当外键值插入或更新的时候需要查询父表中的记录，即SELECT 父表，但<br>对于父表的SELECT并不是采用一致性非锁定读的方式，而是使用S锁</p>
<h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><p>InnoDB有3种行锁的算法</p>
<ol>
<li>Record Lock 单个行记录上的锁，之前已经提过总是锁定索引记录</li>
<li>Gap Lock 间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock Gap+Record 锁定一个范围并且锁定记录本身，例如<br>一个索引有10 11 13 20四个值，那么Next-Key Locking的区间为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞,10]</span><br><span class="line">(10,11]</span><br><span class="line">(11,13]</span><br><span class="line">(13,20]</span><br><span class="line">(20,+∞)</span><br></pre></td></tr></table></figure>
当查询的索引还有唯一属性时，InnoDB存储引擎会将Next-Key Lock进行<br>优化，将其降级为Record Lock，即仅锁定索引本身而不是范围<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table t( a int primary key)</span><br><span class="line">insert into t values(1),(2),(3);</span><br><span class="line">会话A                  会话B</span><br><span class="line">BEGIN; </span><br><span class="line">SELECT * from t</span><br><span class="line">where a&#x3D;5 for update;</span><br><span class="line">					   BEGIN;</span><br><span class="line">					   INSERT INTO T 4;</span><br><span class="line">					   COMMIT;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
会话A首先对a=5进行X锁定，因为a是主键所以仅仅锁定这一个值。这样在会<br>话B中插入4不会被阻塞<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table z (a int,b int,primary key(a),key(b))</span><br><span class="line">insert into z values(1,1),(3,1),(5,3),(7,6),(10,8);</span><br><span class="line">b是辅助索引，如果会话A中执行的是</span><br><span class="line">SELECT * FROM z where b&#x3D;3 for update;</span><br></pre></td></tr></table></figure>
那么就会使用Next-Key Locking技术加锁，并且由于有两个索引所以会分别<br>进行锁定。对于聚集索引仅对a=5的索引加Record Lock，对于辅助索引，锁<br>定的范围是(1,3)，注意InnoDB存储引擎还会对辅助索引下一个键值进行加<br>gap Lock，即范围为(3,6)的锁，以下语句都会阻塞<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from z where a&#x3D;5 lock in share mode;</span><br><span class="line">insert into z values(4,2);</span><br><span class="line">insert into z values(6,5);</span><br></pre></td></tr></table></figure>
用户可以通过两种方式显示关闭Gap Lock</li>
<li>将事务的隔离级别设置为READ COMMITED</li>
<li>将参数 innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<p>在上述的配置下，除了外键约束和唯一性检查依然需要Gap Lock，其余情况<br>使用Record Lock进行锁定</p>
<h4 id="Phantom"><a href="#Phantom" class="headerlink" title="Phantom"></a>Phantom</h4><p>Phantom Problem是指在同一事务下，连续执行两次同样的SQL语句可能导致<br>不同的结果，第二次SQL语句可能返回之前不存在的行。例如之前的表t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where a&gt;2 for update;</span><br></pre></td></tr></table></figure>
<p>如果事务A没有提交应该返回5，现在另一个事务B插入4，那么在此查询发现<br>多了4这个数据，这就是幻读。上述的情况是在隔离级别为READ COMMITED<br>的条件下，如果是在REPEATABLE READ条件下会对(2,+∞)这个范围加X锁</p>
<h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3><p>锁会带来三种问题</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>注意区分两个概念：脏页和脏数据</p>
<ul>
<li>脏页 在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，当然在刷新<br>之前日志都已经被写入到重做日志中</li>
<li>脏数据 事务对缓冲池中的行记录的修改，并且还没有被提交</li>
</ul>
<p>脏读发生的条件是事务的隔离级别为READ UNCOMMITTED，有一个问题就是在<br>该隔离级别下的加锁情况究竟是什么样的，核心就是读操作不加锁，写加锁<br><a href="https://www.imooc.com/article/17291" target="_blank" rel="noopener">https://www.imooc.com/article/17291</a><br><img src="/2020/12/07/MySQL3/20.jpg" alt></p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>在一个事务内多次读取同一数据集合，这个事务还未结束时，另外一个事务也<br>访问该同一数据集合，并做了一些DML操作并提交，那么第一个事务再次读取<br>的数据可能就与之前读取的数据不一样，不可重复读发生的条件是事务的隔离<br>级别是READ COMMITTED <img src="/2020/12/07/MySQL3/21.jpg" alt></p>
<h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>一个事务的更新操作被另一个事务的更新操作覆盖，从而导致数据的不一致，<br>但是目前任何隔离级别下都不会导致数据库理论上的丢失更新</p>
<ol>
<li>事务1将行记录r更新为v1，但是还未提交</li>
<li>与此同时事务2将记录r更新为v2，但是还未提交</li>
<li>事务1提交</li>
<li>事务2提交</li>
</ol>
<p>在当前数据库的任何隔离级别下都不会导致丢失更新问题，要出现这个问题，在<br>多用户计算机系统环境下有可能出现这种问题</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>因为不同锁之间的兼容性关系，在有些时候一个事务的锁需要等待另一个事务中<br>的锁释放它锁占用的资源，这就是阻塞。可以使用innodb_lock_wait_timeout<br>来控制等待时间（默认是50s），innodb_rollback_on_timeout用来设定是否<br>在等待超时时对进行的事务进行回滚操作</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等<br>待现象，解决死锁最简单的方式就是设置超时时间，当两个事务相互等待时当一<br>个事务的等待时间超时其中一个事务就会回滚，另一个事务继续执行，除此还可<br>以采用wait-for-garph方式进行死锁检测</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务会把数据库从一种一致性状态转换为另一种一致性状态，在数据库提交工作<br>时，可以确保要么所有修改都已经保存，要么所有修改都不保存，事务可以分为<br>以下类型</p>
<ul>
<li>扁平事务</li>
<li>带有保存点的扁平事务</li>
<li>链事务</li>
<li>嵌套事务</li>
<li>分布式事务</li>
</ul>
<h3 id="扁平事务"><a href="#扁平事务" class="headerlink" title="扁平事务"></a>扁平事务</h3><p>在扁平事务中，所有的操作都处于同一层次，由BEGIN WORK开始，由COMMIT WORK<br>结束，要么都执行要么都回滚，扁平事务是应用程序成为原子操作的基本组成模块。<br>扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交</p>
<h4 id="带有保存点的事务"><a href="#带有保存点的事务" class="headerlink" title="带有保存点的事务"></a>带有保存点的事务</h4><p>允许事务在执行过程中回滚到同一事务中较早的一个状态，保存点用来通知系统<br>应该记住事务当前的状态，以便当之后发生错误时事务能够回到保存点当时的位<br>置，保存点用SAVE WORK函数建立 <img src="/2020/12/07/MySQL3/22.jpg" alt></p>
<h4 id="链事务"><a href="#链事务" class="headerlink" title="链事务"></a>链事务</h4><p>保存点模式的一种变种，带有保存点的扁平事务，当系统发生崩溃时所有的保存<br>点都会消失，因此其保存点是易失的而非持久的，当恢复时事务需要从开始出重<br>新执行，而不能从最近的一个保存点继续执行。链事务的思想是：在提交一个事<br>务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始<br>的事务，注意提交事务操作和开始下一个事务操作将合并为一个原子操作 <img src="/2020/12/07/MySQL3/23.jpg" alt></p>
<h4 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h4><p>由一个顶层事务控制各个层次的事务，顶层事务之下嵌套的事务被称为子事务，<br>其控制的是一个局部的变换 <img src="/2020/12/07/MySQL3/24.jpg" alt></p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中<br>的不同节点</p>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务隔离性由锁实现，原子性、一致性、持久性通过数据库的redo log和undo<br>log来实现，redo log为重做日志，用来保证事务的原子性和持久性，undo<br>log用来保证事务的一致性。redo和undo并不是逆过程，redo 恢复提交事务<br>修改的页操作，而undo回滚行记录到特定版本。redo通常是物理日志，记录<br>页的物理修改操作，undo是逻辑操作根据每行记录进行记录</p>
<h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p>重做日志用来实现事务的持久性，其由两部分组成：一是内存中的重做缓冲日志<br>，其是易失的，二是重做日志文件，其是持久的。当事务提交时必须先将事务的<br>所有日志写入到重做日志文件进行持久化，然后COMMIT 操作才算完成。为了确<br>保每次日志都写入重做日志，在每次将重做日志缓冲写入重做日志文件后存储<br>引擎都需要调用一次fsync操作，重做日志缓冲先写入文件系统缓冲，为了确<br>保日志写入磁盘，必须进行fsync操作，fsync的效率取决于磁盘的性能。<br>InnoDB存储引擎允许用户手工设置非持久性的情况发生，即当事务提交时，日志<br>不写入重做日志文件，而是等待一个时间周期后再执行fsync操作，这样可以提<br>高数据库的性能，但是当数据库发生宕机时由于部分日志为刷新会丢失部分数据</p>
<h4 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h4><p>在InnoDB存储引擎中，重做日志都是以512字节进行存储的，这意味着重做日志<br>缓存、重做日志文件都是以块的方式进行保存，称之为重做日志块，每块的大小<br>为512字节</p>
<h4 id="log-group"><a href="#log-group" class="headerlink" title="log group"></a>log group</h4><p>log group为重做日志组，其中有很多重做日志文件，InnoDB实际只有一个log<br>group</p>
<h4 id="重做日志格式"><a href="#重做日志格式" class="headerlink" title="重做日志格式"></a>重做日志格式</h4><p>InnoDB存储引擎的管理是基于页的，故其重做日志格式也是基于页的</p>
<h4 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h4><p>日志序列号，在InnoDB存储引擎中占8个字节，并且单调递增，含义如下</p>
<ul>
<li>重做日志写入的总量</li>
<li>checkpoint的位置</li>
<li>页的版本</li>
</ul>
<p>LSN代表事务写入重做日志的字节总量，例如当前重做日志的LSN为1000，有一个<br>事务T1写入100字节的重做日志，那么LSN就变为1100</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>InnoDB存储引擎在启动时不管上次数据库运行是否正常关闭，都会尝试进行恢复<br>操作</p>
<h3 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h3><p>如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK 语句<br>请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。undo 存放在数<br>据库内部的一个特殊字段中(segment)，这个段称为undo 段，位于共享表空间中，<br>注意undo并不是将数据库物理地恢复到执行语句或事物之前的样子，undo是逻辑日<br>志，只是将数据库逻辑地恢复到原来的样子，所有修改都被逻辑取消。除了回滚操<br>作undo的另一个作用就是MVVC，当用户读取一行记录时，若该行记录已经被其他<br>事务占用，当前事务可以通过undo读取之前的行版本信息以实现非锁定读取，最<br>后注意undo log会产生redo log，也就是undo log的产生会伴随redo log的<br>产生，因为undo log 也需要持久性的保护   </p>
<h4 id="undo存储管理"><a href="#undo存储管理" class="headerlink" title="undo存储管理"></a>undo存储管理</h4><p>InnoDB存储引擎对undo的管理同样采用段的方式</p>
<h4 id="undo-log格式"><a href="#undo-log格式" class="headerlink" title="undo log格式"></a>undo log格式</h4><p>在InnoDB存储引擎中，undo log分为</p>
<ol>
<li>insert undo log</li>
<li>update undo log</li>
</ol>
<h4 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h4><p>delete和updaet操作可能并不直接删除原有的数据</p>
<h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><p>MySQL默认设置下事务都是自动提交的，即执行SQL语句后马上就会执行COMMIT<br>操作，可以通过SET AUTOCOMMIT=0 禁用自动提交</p>
<ol>
<li>START TRANSACTION|BEGIN 显示开启一个事务</li>
<li>COMMIT 提交事务，对数据库永久性修改</li>
<li>ROLLBACK 回滚结束事务，撤销未提交的修改</li>
<li>SAVEPOINT identifier 在事务中创建一个保存点，一个事务可以有多个保存点</li>
<li>RELEASE SAVEPOINT identifier 删除一个保存点</li>
<li>ROLLBACK TO identifier 回滚到标记点</li>
<li>SET TRANSACTION 设置事务的隔离级别</li>
</ol>
<h3 id="隐式提交的SQL语句"><a href="#隐式提交的SQL语句" class="headerlink" title="隐式提交的SQL语句"></a>隐式提交的SQL语句</h3><p>以下这些SQL语句会产生一个隐式的提交操作</p>
<ul>
<li>DDL语句: ALTER DATABASEUPGRADE DATA DIRECTORY NAME,ALTER<br>EVENT, ALTER PROCEDURE, ALTER TABLE, ALTER VIEW，CREATE<br>DATABASE, CREATE EVENT, CREATE INDEX, CREATE PROCEDURE,<br>CREATE TABLE, CREATE TRIGGER, CREATE VIEW,DROP DATABASE,<br>DROP EVENT, DROP INDEX, DROP PROCEDURE，DROP TABLE, DROP<br>TRIGGER, DROP VIEW, RENAME TABLE，TRUNCATE TABLE</li>
<li>用来隐式地修改 MySQL架构的操作: CREATE USER、 DROP USER、<br>GRANT 、RENAME USER、 REVOKE、 SET PASSWORD</li>
<li>管理语句: ANALYZE TABLE、 CACHE INDEX、 CHECK TABLE、 LOAD<br>INDEX  INTO CACHE、 OPTIMIZE TABLE、 REPAIR TABLE</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/07/MySQL3/">https://skysea-gaoming.github.io/2020/12/07/MySQL3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataBase/">DataBase</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/10/ComputerNetwork2/"><i class="fa fa-chevron-left">  </i><span>计算机网络2</span></a></div><div class="next-post pull-right"><a href="/2020/11/24/Mysql2/"><span>MySQL2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/07/MySQL3/';
  this.page.identifier = '2020/12/07/MySQL3/';
  this.page.title = 'MySQL3';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F7fe26ede962c3e048f6e8f1f8c12b3f803e1457f.jpg&amp;refer=http%3A%2F%2Fi2.hdslb.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611849565&amp;t=29a8f8fb1f5f28e19cc5104ad7f885e5)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>