<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MySQL3"><meta name="keywords" content="DataBase"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>MySQL3 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表"><span class="toc-number">2.</span> <span class="toc-text">表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引组织表"><span class="toc-number">2.1.</span> <span class="toc-text">索引组织表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB逻辑存储结构"><span class="toc-number">2.2.</span> <span class="toc-text">InnoDB逻辑存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#表空间"><span class="toc-number">2.2.1.</span> <span class="toc-text">表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#段"><span class="toc-number">2.2.2.</span> <span class="toc-text">段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区"><span class="toc-number">2.2.3.</span> <span class="toc-text">区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#页"><span class="toc-number">2.2.4.</span> <span class="toc-text">页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行"><span class="toc-number">2.2.5.</span> <span class="toc-text">行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB行记录格式"><span class="toc-number">2.3.</span> <span class="toc-text">InnoDB行记录格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Compact"><span class="toc-number">2.3.1.</span> <span class="toc-text">Compact</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redundant"><span class="toc-number">2.3.2.</span> <span class="toc-text">Redundant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行溢出数据"><span class="toc-number">2.3.3.</span> <span class="toc-text">行溢出数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dynamic"><span class="toc-number">2.3.4.</span> <span class="toc-text">Dynamic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB数据页结构"><span class="toc-number">2.4.</span> <span class="toc-text">InnoDB数据页结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#约束"><span class="toc-number">2.5.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#约束的创建和查找"><span class="toc-number">2.5.1.</span> <span class="toc-text">约束的创建和查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#约束和索引的区别"><span class="toc-number">2.5.2.</span> <span class="toc-text">约束和索引的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对错误数据的约束"><span class="toc-number">2.5.3.</span> <span class="toc-text">对错误数据的约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENUM和SET"><span class="toc-number">2.5.4.</span> <span class="toc-text">ENUM和SET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#触发器与约束"><span class="toc-number">2.5.5.</span> <span class="toc-text">触发器与约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外键约束"><span class="toc-number">2.5.6.</span> <span class="toc-text">外键约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区表"><span class="toc-number">2.6.</span> <span class="toc-text">分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RANGE分区"><span class="toc-number">2.6.1.</span> <span class="toc-text">RANGE分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LIST分区"><span class="toc-number">2.6.2.</span> <span class="toc-text">LIST分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HASH分区"><span class="toc-number">2.6.3.</span> <span class="toc-text">HASH分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KEY分区"><span class="toc-number">2.6.4.</span> <span class="toc-text">KEY分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COLUMNS分区"><span class="toc-number">2.6.5.</span> <span class="toc-text">COLUMNS分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#子分区"><span class="toc-number">2.6.6.</span> <span class="toc-text">子分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分库分表"><span class="toc-number">2.6.7.</span> <span class="toc-text">分库分表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引与算法"><span class="toc-number">3.</span> <span class="toc-text">索引与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构与算法"><span class="toc-number">3.1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二分查找法"><span class="toc-number">3.1.1.</span> <span class="toc-text">二分查找法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树"><span class="toc-number">3.1.2.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树索引"><span class="toc-number">3.2.</span> <span class="toc-text">B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#聚集索引"><span class="toc-number">3.2.1.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#辅助索引"><span class="toc-number">3.2.2.</span> <span class="toc-text">辅助索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的使用"><span class="toc-number">3.3.</span> <span class="toc-text">索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#联合索引"><span class="toc-number">3.3.1.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组合索引的结构"><span class="toc-number">3.3.2.</span> <span class="toc-text">组合索引的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖索引"><span class="toc-number">3.3.3.</span> <span class="toc-text">覆盖索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希算法"><span class="toc-number">3.4.</span> <span class="toc-text">哈希算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全文检索"><span class="toc-number">3.5.</span> <span class="toc-text">全文检索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-number">4.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lock与latch"><span class="toc-number">4.1.</span> <span class="toc-text">lock与latch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的类型"><span class="toc-number">4.2.</span> <span class="toc-text">锁的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#意向锁"><span class="toc-number">4.2.1.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用意向锁"><span class="toc-number">4.2.2.</span> <span class="toc-text">为什么使用意向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁的使用"><span class="toc-number">4.2.3.</span> <span class="toc-text">锁的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行锁锁的到底是什么"><span class="toc-number">4.2.4.</span> <span class="toc-text">行锁锁的到底是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行锁锁的是索引"><span class="toc-number">4.2.5.</span> <span class="toc-text">行锁锁的是索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引类型对锁类型的影响"><span class="toc-number">4.2.6.</span> <span class="toc-text">索引类型对锁类型的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快照"><span class="toc-number">4.2.7.</span> <span class="toc-text">快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一致性非锁定读"><span class="toc-number">4.2.8.</span> <span class="toc-text">一致性非锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一致性锁定读"><span class="toc-number">4.2.9.</span> <span class="toc-text">一致性锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自增长与锁"><span class="toc-number">4.2.10.</span> <span class="toc-text">自增长与锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外键和锁"><span class="toc-number">4.2.11.</span> <span class="toc-text">外键和锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的算法"><span class="toc-number">4.3.</span> <span class="toc-text">锁的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#间隙锁"><span class="toc-number">4.3.1.</span> <span class="toc-text">间隙锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#临键锁"><span class="toc-number">4.3.2.</span> <span class="toc-text">临键锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决幻读"><span class="toc-number">4.3.3.</span> <span class="toc-text">解决幻读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快照读与当前读"><span class="toc-number">4.3.4.</span> <span class="toc-text">快照读与当前读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">4.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁问题"><span class="toc-number">4.4.</span> <span class="toc-text">锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#丢失更新"><span class="toc-number">4.4.1.</span> <span class="toc-text">丢失更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#脏读"><span class="toc-number">4.4.2.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不可重复读"><span class="toc-number">4.4.3.</span> <span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞"><span class="toc-number">4.4.4.</span> <span class="toc-text">阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">4.5.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁概率"><span class="toc-number">4.5.1.</span> <span class="toc-text">死锁概率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁升级"><span class="toc-number">4.6.</span> <span class="toc-text">锁升级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#页级锁"><span class="toc-number">4.6.1.</span> <span class="toc-text">页级锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVC实现原理"><span class="toc-number">4.7.</span> <span class="toc-text">MVVC实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">4.7.1.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行更新过程"><span class="toc-number">4.7.2.</span> <span class="toc-text">行更新过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-View"><span class="toc-number">4.7.3.</span> <span class="toc-text">Read View</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务分类"><span class="toc-number">4.8.</span> <span class="toc-text">事务分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扁平事务"><span class="toc-number">4.8.1.</span> <span class="toc-text">扁平事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带有保存点的事务"><span class="toc-number">4.8.2.</span> <span class="toc-text">带有保存点的事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链事务"><span class="toc-number">4.8.3.</span> <span class="toc-text">链事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套事务"><span class="toc-number">4.8.4.</span> <span class="toc-text">嵌套事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式事务"><span class="toc-number">4.8.5.</span> <span class="toc-text">分布式事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务控制语句"><span class="toc-number">4.9.</span> <span class="toc-text">事务控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对于事务操作的统计"><span class="toc-number">4.10.</span> <span class="toc-text">对于事务操作的统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务的隔离级别"><span class="toc-number">4.11.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式事务-1"><span class="toc-number">4.12.</span> <span class="toc-text">分布式事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#备份与恢复"><span class="toc-number">5.</span> <span class="toc-text">备份与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#冷备份"><span class="toc-number">5.1.</span> <span class="toc-text">冷备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制"><span class="toc-number">5.2.</span> <span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查询性能优化"><span class="toc-number">6.</span> <span class="toc-text">查询性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select-type"><span class="toc-number">6.1.</span> <span class="toc-text">select_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化数据访问"><span class="toc-number">6.2.</span> <span class="toc-text">优化数据访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#慢查询日志"><span class="toc-number">6.3.</span> <span class="toc-text">慢查询日志</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">61</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">MySQL3</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/07/MySQL3/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/07/MySQL3/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《MySQL技术内幕》</p>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>表是关于特定实体的数据集合，也是关系型数据库模型的核心</p>
<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式<br>的表称为索引组织表。每张表都有一个主键</p>
<ul>
<li>首先判断表中是否有非空的唯一索引，如果有则该列为主键。当有多个<br>非空唯一索引时，将选择建表时第一个定义的非空唯一索引为主键</li>
<li>如果不符上述条件则InnoDB自动创建一个6字节大小的指针</li>
</ul>
<p>接下来用一个表来说明</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *,_rowid from z;</span><br><span class="line">+<span class="comment">---+------+----+----+--------+</span></span><br><span class="line">| a | b    | c  | d  | _rowid |</span><br><span class="line">+<span class="comment">---+------+----+----+--------+</span></span><br><span class="line">| 1 |    2 |  3 |  4 |      4 |</span><br><span class="line">| 5 |    6 |  7 |  8 |      8 |</span><br><span class="line">| 9 |   10 | 11 | 12 |     12 |</span><br><span class="line">+<span class="comment">---+------+----+----+--------+</span></span><br></pre></td></tr></table></figure>
<p>_rowid可以显示表的主键，但只能显示单个列为主键的情况</p>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>之前在MySQL2中已经讲了表空间文件存放所有数据。表空间又由段、区、页<br>组成，页在某些文档也称为块 <img src="/2020/12/07/MySQL3/1.jpg" alt></p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>在默认情况下InnoDB存储引擎有一个共享表空间ibdata1，即所有的数据都存放<br>在这个表空间中，如果用户启动参数innodb_file_per_table，则每张表内的<br>数据可以单独存放到一个表空间中，注意这里存放的只是数据、索引和插入缓冲<br>Bitmap页，其他类的数据还是在共享表空间中，比如回滚信息undo log，插入<br>缓冲索引页，系统事务信息，二次写缓冲</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>上图已经说明表空间是由各个段组成，常见的段有数据段、索引段、回滚段等。<br>数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点 <img src="/2020/12/07/MySQL3/8.jpg" alt></p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由连续的页组成，在任何情况下每个区的大小都为1MB，为了保证区中页的<br>连续性，InnoDB存储引擎一次磁盘申请4~5个区，一个区有64个连续的页</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位，在InnoDB存储引擎中默认每个页的大小是<br>16KB。现在版本可以通过innodb_page_size将页的大小设置为4K、8K、16K。<br>常见的页类型如下</p>
<ul>
<li>数据页，数据即索引，索引即数据</li>
<li>undo页</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲列表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩的二进制大对象页</li>
</ul>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB存储引擎是面向列的，也就是说数据是按照行进行存放的。每个页最多<br>存放 16KB/2-200=7992 行记录</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>页中存放的是表中一行行数据，InnoDB存储引擎提供两种格式来存放行记录数<br>据，Compact和Redundant</p>
<h4 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h4><p>一个页中存放的数据越多性能越高 <img src="/2020/12/07/MySQL3/9.jpg" alt><br>Compact行记录格式的首部是一个非NULL变长字段长度列表，并且按照列的顺序<br>逆序放置</p>
<ul>
<li>若列的长度小于255字节，用1字节表示</li>
<li>若大于255字节，用2字节表示，因为VARCHAR类型最大长度是65535</li>
</ul>
<p>第二个部分是NULL标志位，用于指示该行数据是否有NULL值，有则用1表示，<br>第三个部分是记录头信息，固定占5个字节 <img src="/2020/12/07/MySQL3/10.jpg" alt><br>根据头信息最后两个字节可以知道下条记录的位置，InnoDB存储引擎在页内部<br>是通过一种链表的结构来串连各个行记录的。<br>最后的部分就是实际存储每个列的数据，注意NULL不占该部分空间，还有一点<br>是除了用户定义的列外，还有两个隐藏列：事务ID和回滚指针列，分别为6字<br>节和7字节大小，若InnoDB表没有主键则还会增加一个rowid列</p>
<h4 id="Redundant"><a href="#Redundant" class="headerlink" title="Redundant"></a>Redundant</h4><p>Redundant是老版本的行记录存储方式 <img src="/2020/12/07/MySQL3/11.jpg" alt></p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnonDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外，<br>比如BLOB LOB这类大对象列类型会存储在数据页面之外</p>
<h4 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h4><p>支持Compact和Redundant格式的称为Antelope文件格式，新的文件格式<br>Barracuda支持Compressed和Dynamic</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>InnoDB数据页由7个部分组成 <img src="/2020/12/07/MySQL3/12.jpg" alt></p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>关系型数据库系统和文件系统的一个不同点是关系数据库本身能保证存储<br>数据的完整性，约束机制可以保证数据的完整性。数据完整性有以下三种<br>形式</p>
<ol>
<li>实体完整性保证表中有一个主键。在InnoDB 中可以通过定义primary<br>key或Unique Key来保证实体完整性。还可以通过编写一个触发器来保证<br>实体完整性</li>
<li>域完整性保证数据每列的值满足特定条件。可以通过以下方式来保证</li>
</ol>
<ul>
<li>选择合适数据类型</li>
<li>外键约束</li>
<li>编写触发器</li>
<li>用DEFAULT约束作为强制域完整性的一个方面</li>
</ul>
<ol start="3">
<li>参考完整性保证两张表之间的关系，可以通过定义外键或编写触发器</li>
</ol>
<p>InnoDB存储引擎提供的约束如下</p>
<ul>
<li>Primary Key</li>
<li>Unique Key</li>
<li>Foreign Key</li>
<li>Default</li>
<li>NOT NULL</li>
</ul>
<h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><p>约束的创建有两种方式</p>
<ol>
<li>表建立时就进行约束定义</li>
<li>使用alter table创建约束，Unique Key还可以通过create unique<br>index 来创建<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> bb <span class="keyword">on</span> z(b);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>主键约束默认约束名为PRIMARY，Unique Key约束默认约束名为列名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> constraint_name,constraint_type <span class="keyword">from</span> information_schema.TABLE_CONSTRAINTS</span><br><span class="line"><span class="keyword">where</span> table_schema=<span class="string">'mytest'</span> <span class="keyword">and</span> table_name=<span class="string">'z'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><p>约束是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，<br>既有逻辑的概念，在数据库中还代表物理存储的方式</p>
<h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><p>在某些默认设置下MySQL数据库允许非法或不正确的数据的插入或更新，可以在<br>内部将其转化为一个合法的值，如向NOT NULL的字段插入一个NULL值，MySQL<br>会将其更改为0再插入，可以设置sql_mode保证数据库提示报错而不是警告</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> sql_mode=<span class="string">'STRICT_TRANS_TABLES'</span></span><br></pre></td></tr></table></figure>
<h4 id="ENUM和SET"><a href="#ENUM和SET" class="headerlink" title="ENUM和SET"></a>ENUM和SET</h4><p>MySQL数据库不支持传统的CHECK约束，但是可以通过ENUM和SET类型解决这个<br>需求，例如有一个性别类型，范围只能是male或female</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(</span><br><span class="line">		<span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">		sex enum(<span class="string">'male'</span>,<span class="string">'female'</span>)</span><br><span class="line">	);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> a <span class="keyword">select</span> <span class="number">22</span>,female<span class="string">';</span></span><br></pre></td></tr></table></figure>
<h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><p>完整性约束通常也可以使用触发器来实现，触发器的作用就是在执行INSERT<br>DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。创建触发器<br>的命令是create trigger</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">[DEFINER=&#123;<span class="keyword">user</span>|<span class="keyword">CURRENT_USER</span>&#125;]</span><br><span class="line"><span class="keyword">TRIGGER</span> trigger_name <span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span> <span class="keyword">INSERT</span>|<span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tb1_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> trigger_stmt</span><br></pre></td></tr></table></figure>
<p>最多可以为一个表建立6个触发器，分别为 INSERT UPDATE DELETE的BEFORE<br>和AFTER各定义一个。BEFORE和AFTER 代表触发器发生的时间，表示在每行操<br>做之前还是之后发生。通过触发器可以实现MySQL 数据库本身并不支持的一些<br>特性。假设有张用户表，用户每次购买物品后金额都是减的，但是如果有一个<br>减去负值的操作，那么用户的钱反而会增多，语句本身没有问题但是逻辑错误</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> usercash(</span><br><span class="line">	userid <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">	cash <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> usercash <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">update</span> usercash <span class="keyword">set</span> cash=cash-(<span class="number">-20</span>) <span class="keyword">where</span> userid=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这时需要一个触发器来约束这个逻辑行为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tgr_usercash_update <span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> usercash(</span><br><span class="line">	<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">	<span class="keyword">BEGIN</span> </span><br><span class="line">	<span class="keyword">IF</span> new.cash-oil.cash &gt; <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> usercash_err_log</span><br><span class="line">	<span class="keyword">SELECT</span> old.userid, old.cash, new.cash,<span class="keyword">USER</span>(),<span class="keyword">NOW</span>();</span><br><span class="line">	<span class="keyword">SET</span> new.cash = old.cash;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">	<span class="keyword">END</span>;</span><br><span class="line">	$$</span><br><span class="line">);</span><br><span class="line">DELIMITER $$;</span><br></pre></td></tr></table></figure>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>MyISAM不支持外键，InnoDB支持外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">parent</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">child</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>, parent_id <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(parent_id) <span class="keyword">REFERENCES</span> <span class="keyword">parent</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>InnoDB MyISAM NDB支持分区。<br>分区的过程是将一个表或索引分解为更小、更可管理的部分。就访问数据库而言<br>就一个表或一个索引，但是在物理上这个表或索引可以有数十个物理分区组成<br>，每个分区都是独立的对象，MySQL支持的分区类型是水平分区，不支持垂直<br>分区，此外MySQL的分区是局部分区索引，一个分区中既存放了数据又存放了<br>索引。全局分区指的是数据存放在各个分区，但是所有数据的索引存放在一个<br>对象中</p>
<ul>
<li>水平分区 同一个表中不同行的记录分配到不同物理文件中 <img src="/2020/12/07/MySQL3/43.jpg" alt></li>
<li>垂直分区 同一个表中不同列的记录分配到不同物理文件中 <img src="/2020/12/07/MySQL3/44.jpg" alt></li>
</ul>
<p>不管创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是<br>唯一索引的一个组成部分。如果建表时没有指定主键或唯一索引，可以指定<br>任何一个列为分区列</p>
<h4 id="RANGE分区"><a href="#RANGE分区" class="headerlink" title="RANGE分区"></a>RANGE分区</h4><p>行数据基于一个给定连续区间的列值被放入分区，以下语句创建一个id列的<br>区间分区表，id小于10时数据插入p0分区，id在10到20之间数据插入p1分<br>区，启用分区后表就不止一个ibd文件，t#P#p0.ibd t#P#p1.ibd</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>)<span class="keyword">engine</span>=<span class="keyword">innodb</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(<span class="keyword">id</span>)(</span><br><span class="line"><span class="keyword">partition</span> p0 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">10</span>),</span><br><span class="line"><span class="keyword">partition</span> p1 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">20</span>));</span><br></pre></td></tr></table></figure>
<p>如果插入的数据不在分区中可以对分区添加一个MAXVALUE值的分区</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p2 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> maxvalue);</span><br><span class="line"><span class="comment"># 删除一个分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">drop</span> <span class="keyword">partition</span> p2;</span><br></pre></td></tr></table></figure>
<p>RANGE分区主要用于日期列的分区，例如对于销售类的表可以根据年来分区<br>存放销售记录。创建分区的好处是可以加快某些查询操作，通过 explain<br>SQL优化器只需搜索p1这个分区即可，这就是Partitions Pruning分区<br>修剪，如果改为id&lt;20那么会搜索p1 p2两个分区，所以注意写法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">partitions</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">10</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;=<span class="number">19</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意实际上SQL优化器并不会对以上的写法进行分区，为了好讲解我才<br>这样写，书中写对于RANGE分区的查询，优化器只能对YEAR() TO_DAYS()<br>TO_SECONDS() UNIX_TIMESTAMP()这类函数进行优化选择</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如date表示日期</span></span><br><span class="line">partition by range(YEAR(date))(...);</span><br></pre></td></tr></table></figure>
<h4 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h4><p>和RANGE分区类似，只是LIST面向的是离散的值，而非连续的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line">a <span class="built_in">int</span>,b <span class="built_in">int</span>)<span class="keyword">engine</span>=<span class="keyword">innodb</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">list</span>(b)(</span><br><span class="line"><span class="keyword">partition</span> p0 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>),</span><br><span class="line"><span class="keyword">partition</span> p1 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>));</span><br></pre></td></tr></table></figure>
<p>在插入多个行数据的过程遇到分区未定义的值时，MyISAM和InnoDB存储引<br>擎的处理完全不同，MyISAM会将之前的行数据都插入但是之后的不会插入<br>，而InnoDB存储引擎会将其视为一个事务，也就是说如果有未定义则所有<br>的插入都无效</p>
<h4 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h4><p>根据用户自定义的表达式的返回值来进行分区，目的是将数据均匀分布到<br>预先定义的各个分区中，保证各分区的数据量大致都是一样的。在RANGE<br>和LIST分区中必须明确指定一个给定的列值或列值集合应该保存在哪个<br>分区中，在HASH分区中需要指定一个列值或表达式以及被指定分区的表<br>将要被分割成的分区数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line">a <span class="built_in">int</span>,b datetime)<span class="keyword">engine</span>=<span class="keyword">innodb</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">hash</span>(<span class="keyword">year</span>(b)) <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment"># 2010 mod 4=2 记录会放到p2分区中</span></span><br></pre></td></tr></table></figure>
<h4 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h4><p>根据MySQL提供的哈希函数进行分区</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line">a <span class="built_in">int</span>,b datetime)<span class="keyword">engine</span>=<span class="keyword">innodb</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">key</span>(<span class="keyword">year</span>(b)) <span class="keyword">partitions</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<h4 id="COLUMNS分区"><a href="#COLUMNS分区" class="headerlink" title="COLUMNS分区"></a>COLUMNS分区</h4><p>前四种分区的条件是数据必须是整型或者转化为整型，COLUMNS可以直接对<br>非整型的数据进行分区，也可以对多个列的值进行分区</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line">a <span class="built_in">int</span>,b datetime)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span> <span class="keyword">columns</span>(B)(</span><br><span class="line"><span class="keyword">partition</span> p0 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="string">'2009-01-01'</span>));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line">a <span class="built_in">int</span>,b datetime)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span> <span class="keyword">columns</span>(a,B)(</span><br><span class="line"><span class="keyword">partition</span> p0 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">5</span>,<span class="string">'2009-01-01'</span>));</span><br></pre></td></tr></table></figure>
<h4 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h4><p>是在分区的基础上再进行分区，有时也称这种分区为复合分区。MySQL允许在<br>RANGE和LIST的分区上再进行HASH或KEY的子分区</p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>mycat shardingsphere drds</p>
<h2 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h2><p>索引并不是越多越好，在一开始就应该在需要处添加索引，MySQL 支持如下<br>索引</p>
<ul>
<li>B+树索引 B+树索引并不能找到一个给定键值的具体行，而是找到行所在<br>的页，然后数据库把页读入到内存中</li>
<li>全文索引 基于相似度的查询</li>
<li>哈希索引 会根据表的使用情况自动为表生成哈希索引</li>
</ul>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>索引是帮助Mysql 高效获取数据的数据结构。数据库的一个重要功能就是查询，<br>所以数据库系统设计者就会从查询算法的角度进行优化。最容易想到的就是顺序<br>查询，就好像遍历一个数组一样，时间复杂度为O(n)，当数据量非常大的时候<br>效果不好。学习数据结构后就知道还有其他的查询算法，比如二分查找二叉树<br>查找等，但是这些算法与特定的数据结构有关，比如二分查找必须保证数据<br>是有序的，二叉树查找必须建立二叉查找树结构，但是数据本身可能无法满<br>足各种数据结构，数据库系统维护满足特定查找算法的数据结构，这种数据<br>结构以某种方式指向数据，这种数据结构就是索引</p>
<h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><p>每页Page Directory中的槽是按照主键的顺序存放，对于某一条具体记录的<br>查询时通过对Page Direcotry进行二分查找得到</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树的插入分为三种情况 <img src="/2020/12/07/MySQL3/2.jpg" alt><br>当插入28时满足第一种情况，所以直接插入到叶子节点 <img src="/2020/12/07/MySQL3/3.jpg" alt><br>继续插入70满足第二种情况，这时插入Leaf Page后的顺序为 50 55 60 65<br>70，中间值是60所以放到分页节点 <img src="/2020/12/07/MySQL3/4.jpg" alt><br>最后插入95满足第三种情况，首先拆分叶子节点 75 80 85 90 95，中间值是<br>85将小于85的放在左边大于85的放在右边，然后拆分分页节点，25 50 60 75<br>85，中间值是60，小于60的放在左边大于60的放在右边 <img src="/2020/12/07/MySQL3/5.jpg" alt><br>B+树为了保持平衡可能会做大量拆分页的操作，因为B+树结构主要用于磁盘，<br>所以提供了旋转来减少拆分。旋转发生在Leaf Page已经满当左右兄弟节点没有<br>满的情况，这时不会拆分而是将记录移到兄弟节点上，通常情况左新兄弟先进<br>行旋转操作，现在插入70 <img src="/2020/12/07/MySQL3/6.jpg" alt><br>B+树使用填充因子来控制树的删除变化，50%是填充因子可设的最小值，B+树<br>的删除也分为三种情况 <img src="/2020/12/07/MySQL3/7.jpg" alt></p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树索引的本质就是B+树在数据库中的实现，B+索引在数据库中有一个特点就<br>是高扇出性，因此在数据库中B+树的高度一般在2~4层，也就是说查找某一键<br>值的行记录最多只需2到4次，B+索引可以分为聚集索引和辅助索引</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>聚集索引是按照每一张表的主键构造一棵B+树，叶子节点存放的就是整张表的<br>行记录数据，也将叶子节点称为数据页，聚集索引这个特性决定了索引组织表<br>中数据也是索引的一部分。每张表只能有一个聚集索引，多数情况下查询优化<br>器倾向采用聚集索引。聚集索引并不是顺序物理地存储数据，而是在逻辑上连<br>续的</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>也称为非聚集索引，叶子节点并不包含行记录的所有数据，叶子节点除了包含<br>键值以外，每个叶子节点的索引行还包含一个书签(bookmark)，该书签用来<br>告诉InnoDB存储引擎在哪里可以找到与索引相对应的行数据，这个书签实际<br>就是相应的聚集索引键。每张表可以有多个辅助索引，先通过辅助索引找到<br>相应的主键索引，再通过主键索引找到一个完整的行记录 <img src="/2020/12/07/MySQL3/13.jpg" alt></p>
<h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p>根据OLTP和OLAP两种应用</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>对表的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值<br>的数量不是1而是大于等于2 <img src="/2020/12/07/MySQL3/14.jpg" alt><br>根据这棵B+树可以知道以下查询语句可以使用联合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a&#x3D;xxx and b&#x3D;xxx</span><br><span class="line">select * from table where a&#x3D;xxx</span><br></pre></td></tr></table></figure>
<p>但是对于b列的查询不能使用联合索引，因为b值在叶子节点中并不是顺序的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where b&#x3D;xxx</span><br></pre></td></tr></table></figure>
<h4 id="组合索引的结构"><a href="#组合索引的结构" class="headerlink" title="组合索引的结构"></a>组合索引的结构</h4><p>当表中的字段全部都是索引列的时候，无论进行怎样的查询都会使用<br>索引，索引并不是越多越好，也不需要在全部列上加索引。关于为什<br>么字段全是索引列的时候都会使用索引，举个栗子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id是主键 a,b,c是组合索引</span><br><span class="line">当根据a b c查询整行数据时一定会用到索引，因为组合索引abc对应</span><br><span class="line">的就是主键id，此时不需要回表就可以查询到所有数据</span><br><span class="line">如果增加一个字段d，此时根据组合索引abc查询到对应id，然后根据</span><br><span class="line">id查询到整行数据，如果直接顺序查询的效率高于使用索引查询，那</span><br><span class="line">么就不会根据索引查询</span><br></pre></td></tr></table></figure>

<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>即从辅助索引中就可以得到查询的记录，不需要查询聚集索引的记录。覆盖<br>索引的另一个好处是对于某些统计问题而言，索引包含所有需要查询的字<br>段的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from buy_log;</span><br></pre></td></tr></table></figure>
<p>InnoDB并不会选择通过查询聚集索引来进行统计，由于buy_log表上还有<br>辅助索引，而辅助索引远小于聚集索引，所以会选择辅助索引。优点如下</p>
<ol>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作<br>系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引</li>
</ol>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>InnoDB存储引擎使用哈希算法来对字典进行查找，其冲突机制采用链表方式<br>，哈希函数采用的是除法散列方式</p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>可以通过索引字段的前缀进行查找。通常使用倒排索引来实现，倒排索引同<br>B+树索引一样是一种索引结构，它在辅助表中存储了单词与单词自身在一<br>个或多个文档中所在位置之间的映射，这通常使用关联数组实现，有两种<br>形式</p>
<ol>
<li>inverted file index 表现形式为{单词，单词所在文档的ID}</li>
<li>full inverted index 表现形式为{单词，(单词所在文档的ID，在具<br>体文档中的位置)}</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from blog where content like &#39;xxx%&#39;;</span><br></pre></td></tr></table></figure>
<p>但是更多的是如下情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from blog where content like &#39;%xxx%&#39;;</span><br></pre></td></tr></table></figure>
<p>全文索引有以下限制</p>
<ol>
<li>每张表只能有一个全文检索的索引</li>
<li>由多列组合而成的全文检索的索引列必须使用相同的字符集与排序规则</li>
<li>不支持没有单词界定符的语言，比如中文 日文 韩语</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的<br>并发访问。MySQL 中提供了两种封锁粒度：行级锁以及表级锁。<br>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，<br>发生锁争用的可能就越小，系统的并发程度就越高。加锁需要消耗资源，锁的各<br>种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。<br>当有多个请求读取表中数据时可以不采用任何操作，但是请求中有写请求时一<br>定要进行相应的并发控制。使用锁就是为了支持对共享资源的并发访问，提供<br>数据完整性和一致性</p>
<h3 id="lock与latch"><a href="#lock与latch" class="headerlink" title="lock与latch"></a>lock与latch</h3><p>lock与latch都被称为锁。latch 一般称为闩锁（轻量级的锁），其要求锁定的<br>时间非常短，若持续的时间长则应用的性能非常差，在InnoDB存储引擎中latch<br>又可以分为mutex（互斥量）和rwlock（读写锁）。lock的对象是事务，用来锁<br>定的是数据库中的对象，如表、页、行。并且仅在事务commit或rollback或unlock<br>后释放，有死锁机制 <img src="/2020/12/07/MySQL3/15.jpg" alt></p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>InnoDB存储引擎实现了两种标准的行级锁</p>
<ul>
<li>共享锁(S Lock) 又叫读锁 读锁是可以共享的，或者说多个请求可以共享一<br>把锁读数据不会造成阻塞，允许事务读一行数据</li>
<li>排他锁(X Lock) 又叫写锁 写锁会排斥其他所有锁的请求，一直阻塞，直到<br>写入完成释放锁，允许事务删除或更新一行数据</li>
</ul>
<p>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其<br>它事务不能对 A 加任何锁。<br>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更<br>新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。<br>如果一个事务T1已经获取了行r的共享锁，那么另外的事务T2可以立即获取行r<br>的共享锁，因为读取并没有改变行r的数据，这种情况为锁兼容。若有其他事务<br>T3想获得行r的排他锁，必须等事务T1、T2释放行r上的共享锁–这种情况称为<br>锁不兼容 <img src="/2020/12/07/MySQL3/16.jpg" alt></p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的<br>锁同时存在。InnoDB存储引擎支持意向锁，意向锁是将锁定的对象分为多个层<br>次 <img src="/2020/12/07/MySQL3/17.jpg" alt></p>
<ul>
<li>意向共享锁(IS Lock) 事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock) 事务想要获得一张表中某几行的排他锁</li>
</ul>
<h4 id="为什么使用意向锁"><a href="#为什么使用意向锁" class="headerlink" title="为什么使用意向锁"></a>为什么使用意向锁</h4><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测<br>是否有其它事务对表 A或者表A中的任意一行加了锁，那么就需要对表A的每一<br>行都检测一次，这是非常耗时的。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事<br>务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定</p>
<ol>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更<br>强的锁</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁</li>
</ol>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对<br>表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中<br>某一行的锁，因此事务 T 加 X 锁失败。<br>注意下图的X和S都是表级锁，书上的原句是“在对记录r加X锁之前，已经有事<br>务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上<br>加IX锁，由于不兼容，所以事务需要等待表锁操作的完成”，这里的X锁也是<br>表锁，行级锁只会和行级锁发生冲突，表级锁只会和表级锁发生冲突 <img src="/2020/12/07/MySQL3/18.jpg" alt></p>
<h4 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h4><p>这里对意向锁的解释很清晰 <a href="https://www.zhihu.com/question/51513268" target="_blank" rel="noopener">https://www.zhihu.com/question/51513268</a><br>意向锁是 InnoDB 自动加的，不需用户干预。对于UPDATE、 DELETE 和 INSERT<br>语句，InnoDB会自动给涉及数据集加排他锁(X)，对于普通SELECT语句，InnoDB<br>不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享锁（S）</span></span><br><span class="line"><span class="comment"># 其他session仍然可以查询记录，并也可以对该记录加share mode 的共享锁。</span></span><br><span class="line"><span class="comment"># 但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 排他锁（X)</span></span><br><span class="line"><span class="comment"># 其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表锁的语法如下</span></span><br><span class="line"><span class="comment"># 需要注意lock tables语法除了会限制别的线程的读写之外，也限定了本线程接下来的操作对象</span></span><br><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> .. <span class="keyword">read</span>/write </span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span></span><br></pre></td></tr></table></figure>
<p>对于 insert、update、delete，InnoDB 会自动给涉及的数据加排他锁（X），只<br>有查询 select 需要我们手动设置排他锁对于一般的 select 语句，InnoDB 不会<br>加任何锁，也就是可以多个并发去进行 select 的操作，不会有任何的锁冲突，因<br>为根本没有锁。注意 select * 这样的全表扫描会给表加意向共享锁</p>
<h4 id="行锁锁的到底是什么"><a href="#行锁锁的到底是什么" class="headerlink" title="行锁锁的到底是什么"></a>行锁锁的到底是什么</h4><p>参考 <a href="https://blog.csdn.net/weixin_43935927/article/details/109438506" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43935927/article/details/109438506</a><br>行锁锁的究竟是什么，事实上行锁锁的并不是某一行的数据，而是这一行数据<br>的索引，比如先操作一个没有索引的表 <img src="/2020/12/07/MySQL3/25.jpg" alt><br>给id=1的数据加排他锁，但是id=3和id=5的数据都被阻塞了，说明锁住的不<br>是Record，而且整个表都被锁住了。接下来操作一个有主键索引的表 <img src="/2020/12/07/MySQL3/26.jpg" alt><br>使用相同的id加锁会冲突，使用不同的id加锁成功，但是不能确定是否是锁<br>定了id这个字段，接下来操作一个有唯一索引的表 <img src="/2020/12/07/MySQL3/27.jpg" alt><br>第二个事务想获取name=’4’的排它锁肯定会失败，但是为什么id=4的数据<br>也被阻塞，说明并没有锁定name这个字段，否则锁定id应该不会被阻塞，<br>结论就是InnoDB的行锁是通过锁住索引来实现的。第一个表中因为没有索引<br>所以会自动创建一个主键，查询没有使用索引所以会全表扫描把每一个隐藏<br>的聚集索引都锁住了，这里加的应该是一个表级排他锁。第二个表中给唯一<br>索引加锁时主键索引也会被锁住，辅助索引中，索引存储的是二级索引和<br>主键的值，也就是通过二级索引最终要找到主键索引，比如name=4存储<br>的是索引和主键id的值4，主键索引中除了索引还有完整的数据，所以<br>会将主键索引也锁定 <img src="/2020/12/07/MySQL3/28.jpg" alt><br>总结一句话就是如果表中有索引就索索引，否则就锁整个表。所以InnoDB的<br>行锁就是靠锁住索引来实现的</p>
<h4 id="行锁锁的是索引"><a href="#行锁锁的是索引" class="headerlink" title="行锁锁的是索引"></a>行锁锁的是索引</h4><p>参考 <a href="https://www.cnblogs.com/frankltf/p/9127440.html" target="_blank" rel="noopener">https://www.cnblogs.com/frankltf/p/9127440.html</a><br>接下来自己实现一下以上操作，开启两个端口，创建一个test表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">------+------+</span></span><br><span class="line">| id   | name |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 | fd   |</span><br><span class="line">|    2 | fds  |</span><br><span class="line">|    3 | vv   |</span><br><span class="line">|    4 | fda  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br></pre></td></tr></table></figure>
<ol>
<li>test表没有索引，会对整个表进行加锁。用两种情况演示，一种是加S锁，<br>一种是加X锁。可以看到第一张图加了表级S锁，第二种图加了表级X锁 <img src="/2020/12/07/MySQL3/45.jpg" alt> <img src="/2020/12/07/MySQL3/46.jpg" alt></li>
<li>test表有主键索引id，但是不通过索引来对数据进行加锁，那么锁的依<br>然是整个表。第一张表使用非索引name来锁数据那么会锁整个表，第二张表<br>通过索引id来锁数据那么对该行加锁 <img src="/2020/12/07/MySQL3/47.jpg" alt> <img src="/2020/12/07/MySQL3/48.jpg" alt></li>
<li>test表有主键索引id和非主键索引name，如果操作非主键索引name，那<br>么先锁定非主键索引，然后锁定相关的主键索引。 在UPDATE、DELETE操作时<br>，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值<br>，即所谓的next-key locking <img src="/2020/12/07/MySQL3/49.jpg" alt></li>
<li>如果明确指定主键但是表中没有该值那么不会锁定任何数据，如果主键不<br>明确的话会锁表，不明确就是没有使用等于而是使用像like等 <img src="/2020/12/07/MySQL3/50.jpg" alt></li>
</ol>
<h4 id="索引类型对锁类型的影响"><a href="#索引类型对锁类型的影响" class="headerlink" title="索引类型对锁类型的影响"></a>索引类型对锁类型的影响</h4><ul>
<li>主键：众所周知，自带最高效的索引属性</li>
<li>唯一索引：属性值重复率为0，可以作为业务主键</li>
<li>普通索引：属性值重复率大于0，不能作为唯一指定条件，对于普通索引，<br>当“重复率”低时，甚至接近主键或者唯一索引的效果时，依然是行锁；但是<br>如果“重复率”高时，Mysql不会把这个普通索引当做索引，即会造成一个没<br>有索引的SQL，从而形成表锁。普通索引就是非唯一索引</li>
</ul>
<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>快照数据是指该行的之前版本的数据，也即是 undo中的数据，读取快照数据<br>不需要加锁，因为没有事务需要对历史的数据进行修改。<br>不同事物隔离级别下，读取的方式不同，并不是在每个事物隔离级别下都采用<br>非锁定的一致性读。<br>一个行记录可能不止一个快照数据，一般称这种技术为行多版本技术，由此带<br>来的并发控制称之为多版本并发控制。<br>事实上新的版本数据会覆盖旧的版本数据，那事务还能够读取到旧版本的数据<br>是因为undo log，也就是说undo log能够实现MVCC。我在上一篇博客中解释<br>undo log是保存在内存中的没有必要存入磁盘是针对回滚这个问题而言，事<br>实上undo log也是要存入磁盘的<br>参考 <a href="https://www.cnblogs.com/qcloud1001/p/9322321.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcloud1001/p/9322321.html</a><br>快照的定义：关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据<br>在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的<br>一个副本，也可以是数据的一个复制品。<br>存储快照，是一种数据保护措施，可以对源数据进行一定程度的保护 <img src="/2020/12/07/MySQL3/29.jpg" alt><br>快照是一份完全可用的副本，那么它完全可以被上层业务当做源数据 <img src="/2020/12/07/MySQL3/30.jpg" alt></p>
<h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>参考 <a href="https://blog.csdn.net/u010900754/article/details/106772974" target="_blank" rel="noopener">https://blog.csdn.net/u010900754/article/details/106772974</a><br>一致性非锁定读指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时<br>间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取<br>操作不会因此等待行上锁的释放，因为一般的读取操作是没有锁的，所以可以<br>直接读取到加锁的数据，会去读取行的一个快照 <img src="/2020/12/07/MySQL3/19.jpg" alt><br>一致性非锁定读包含两层含义</p>
<ol>
<li>非锁定 这种读操作不需要加S锁，即便其他事务已经对该数据加了X锁依然<br>可以读</li>
<li>一致性 这个一致性取决于隔离级别，不同的隔离级别下读取的值不同，非<br>锁定读可以保证即便其他事务修改了数据，但是当前读操作是不会被阻塞的，<br>并且保证返回相应一致性要求下的快照数据</li>
</ol>
<p>MVVC用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取<br>最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取<br>的行都加锁，单纯使用 MVCC 无法实现。<br>在事务隔离级别为READ COMMITTED和REPETABLE READ下，InnoDB存储引擎<br>使用非锁定的一致性读，但是对于快照数据的定义不同</p>
<ul>
<li>READ COMMITTED 对于快照数据，总是读取被锁定行的最新一份快照数据</li>
<li>REPEATABLE READ 读取事务开始时的行版本数据</li>
</ul>
<h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>某些情况下需要对数据库读取操作进行加锁以保证数据逻辑的一致性，即使是<br>对SELECT的只读操作也有两种一致性的锁定读操作，必须在事务中操作，注<br>意对于一致性非锁定读这两个操作不会加锁</p>
<ol>
<li>SELECT … FOR UPDATE 对读取的行记录加X锁，其余事务不能加任何锁</li>
<li>SELECT … LOCK IN SHARE MODE 加S锁，其余事务可以加S锁</li>
<li>在serializable隔离级别下，读操作加S锁</li>
</ol>
<p>非锁定读和锁定读的本质区别就在于在读取数据时是否加锁。使用场景如下</p>
<ul>
<li>一致性锁定读 对数据一致性，实时性比较高的情况下（会破坏事务隔离性，<br>，因为获取的都是最新的数据，比较慢，性能低）</li>
<li>一致性非锁定读  对数据一致性，实时性不高的情况下（数据可能不是最新<br>的，不会破坏事务隔离性）</li>
</ul>
<h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><p>每个含有自增长值的表都有一个自增长计数器，当对含有自增长计数器的表进<br>行插入操作时这个计数器会被初始化，插入操作会依据这个自增长的计数器值<br>加1赋予自增长列，这种锁采用一种特殊的表锁机制，并不是在一个事务完成<br>后才会释放，而是在完成自增长值插入的SQL语句后立即释放。但是对于有自<br>增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不<br>用等待事务的完成），对于INSERT .. SELECT的大数据量插入会影响插入<br>的性能，目前的版本采用一种轻量级互斥量的自增长实现机制。注意自增长<br>的列必须是索引，同时必须是索引的第一个列 <img src="/2020/12/07/MySQL3/32.jpg" alt> <img src="/2020/12/07/MySQL3/33.jpg" alt></p>
<h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><p>对于一个外键列，如果没有显示对这个列加锁，则自动加一个索引避免表锁<br>，当外键值插入或更新的时候需要查询父表中的记录，即SELECT 父表，但<br>对于父表的SELECT并不是采用一致性非锁定读的方式，而是使用S锁</p>
<h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><p>InnoDB有3种行锁的算法，区别在于加锁范围的不同</p>
<ol>
<li>Record Lock 单个行记录上的锁，之前已经提过总是锁定索引记录</li>
<li>Gap Lock 间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock Gap+Record 锁定一个范围并且锁定记录本身，例如<br>一个索引有10 11 13 20四个值，那么Next-Key Locking的区间为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞,10]</span><br><span class="line">(10,11]</span><br><span class="line">(11,13]</span><br><span class="line">(13,20]</span><br><span class="line">(20,+∞)</span><br></pre></td></tr></table></figure>
采用Next-Key Lock是为了解决幻读 <img src="/2020/12/07/MySQL3/34.jpg" alt><br>当查询的索引含有唯一属性进行等值查询时（唯一索引的主键索引），InnoDB<br>存储引擎会将Next-Key Lock进行优化，将其降级为Record Lock，即仅锁定<br>索引本身而不是范围 <img src="/2020/12/07/MySQL3/51.jpg" alt><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a是主键</span></span><br><span class="line">+<span class="comment">---+</span></span><br><span class="line">| a |</span><br><span class="line">+<span class="comment">---+</span></span><br><span class="line">| 1 |</span><br><span class="line">| 2 |</span><br><span class="line">| 5 |</span><br><span class="line">+<span class="comment">---+</span></span><br></pre></td></tr></table></figure>
会话A首先对a=5进行X锁定，因为a是主键所以仅仅锁定这一个值。这样在会<br>话B中插入4不会被阻塞，锁的降级仅在查询的列是唯一索引的情况下<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> z(a <span class="built_in">int</span> ,b <span class="built_in">int</span>,primary <span class="keyword">key</span>(a),<span class="keyword">key</span>(b));</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| a  | b    |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 |    1 |</span><br><span class="line">|  3 |    1 |</span><br><span class="line">|  5 |    3 |</span><br><span class="line">|  7 |    6 |</span><br><span class="line">| 10 |    8 |</span><br><span class="line">+<span class="comment">----+------+</span></span><br></pre></td></tr></table></figure>
b是辅助索引，所以要使用Next-Key Locking技术加锁，并且由于有两个锁<br>引，需要分别进行锁定。对于聚集索引，对a=5的索引加上Record Lock，对<br>于辅助索引需要加上Next-Key Lock,锁定的范围是(1,3)，注意InnoDB存<br>储引擎还会对辅助索引下一个键值进行加gap Lock，即范围为(3,6)的锁<br>，以下语句都会阻塞，也就是(1,6]的范围都被锁定 <img src="/2020/12/07/MySQL3/52.jpg" alt><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> z <span class="keyword">where</span> a=<span class="number">5</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">values</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> z <span class="keyword">values</span>(<span class="number">6</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>当我们查询的记录不存在，没有命中任何一个record，无论是用等值查询还<br>是范围查询的时候，它使用的都是间隙锁。注意间隙锁主要是阻塞insert，<br>而没有阻塞select，相同的间隙锁之间不冲突。<br>Gap Lock只在隔离级别RR中存在，如果要关闭间隙锁，事务隔离级别设置成<br>RC，innodb_locks_unsafe_for_binlog设置为ON。这种情况下除了外键约<br>束和唯一性检查会加间隙锁，其他情况都不会用间隙锁</p>
<h4 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h4><p>当我们使用了范围查询，不仅仅命中了Record记录，还包含了Gap间隙，在这<br>种情况下我们使用的就是临键锁，它是MySQL里面默认的行锁算法，相当于记<br>录锁加上间隙锁，临键锁有两种退化的情况</p>
<ul>
<li>记录锁：唯一性索引，等值查询匹配到一条记录的时候，退化成记录锁</li>
<li>间隙锁：没有匹配到任何记录的时候，退化成间隙锁</li>
</ul>
<p>比如要查询(5,9)之间的范围，锁住的是 (4,7]和(7,10] <img src="/2020/12/07/MySQL3/35.jpg" alt><br>临键锁与间隙锁不同的是，它除了锁住原本的临键区间，还会锁住最后一个<br>key的下一个左开右闭的区间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id&gt;5 and id&lt;&#x3D;7 for update; -- 锁住(4,7]和(7,10] </span><br><span class="line">select * from t where id&gt;8 and id&lt;&#x3D;10 for update; -- 锁住 (7,10]和(10,+∞)</span><br></pre></td></tr></table></figure>
<p>为什么要锁住下一个左开右闭的区间？——为了解决幻读的问题。所以，我们看<br>下MySQL InnoDB里面事务隔离级别的实现。为什么InnoDB 的RR 级别能够解<br>决幻读的问题，就是用临键锁实现的 <img src="/2020/12/07/MySQL3/36.jpg" alt><br>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。<br>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在<br>的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key<br>Locks 可以解决幻读问题</p>
<h4 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h4><p>Phantom Problem是指在同一事务下，连续执行两次同样的SQL语句可能导致<br>不同的结果，第二次SQL语句可能返回之前不存在的行。例如之前的表t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where a&gt;2 for update;</span><br></pre></td></tr></table></figure>
<p>如果事务A没有提交应该返回5，现在另一个事务B插入4，那么在此查询发现<br>多了4这个数据，这就是幻读。上述的情况是在隔离级别为 READ COMMITED<br>的条件下，如果是在REPEATABLE READ条件下会对(2,+∞)这个范围加X锁。<br>这里的select都是用for update，如果只是普通的select那么读取的就<br>是快照数据，一样不会产生幻读，如果加了for updata就是给数据加排<br>斥锁，这时会通过行锁算法锁定一个范围，同样解决了幻读。<br>幻读和不可重复读的区别是，前者是一个范围，后者是本身</p>
<h4 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h4><ol>
<li>快照读，也叫做普通读<br>MVCC 的 SELECT 操作是读取快照中的数据，不需要进行加锁操作。故不会有<br>next-key locks的使用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure></li>
<li>当前读<br>所谓当前读，指的是加锁的select(S或者X), update, delete等语句。<br>在RR的事务隔离级别下，数据库会使用next-key locks来锁住本条记录<br>以及索引区间，从而读取最新的数据。可以看到 MVCC 并不是完全不用<br>加锁，而只是避免了 SELECT 的加锁操作。<br>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要<br>加 S 锁，第二个需要加 X 锁<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在mysql中，提供了两种事务隔离技术，第一个是mvcc，第二个是next-key技<br>术。在RR的隔离级别下，Innodb使用MVVC和next-key locks解决幻读，MVVC<br>解决的是普通读(快照读)的幻读，next-key locks 解决的是当前读情况下的<br>幻读。<br>这个在使用不同的语句的时候可以动态选择。不加lock in share mode之类的<br>就使用mvcc。否则使用next-key。mvcc的优势是不加锁，并发性高。缺点是不<br>是实时数据。next-key的优势是获取实时数据，但是需要加锁。同时需要注意<br>几点</p>
<ol>
<li>事务的快照时间点是以第一个select来确认的。所以即便事务先开始。但是<br>select在后面的事务的update之类的语句后进行，那么它是可以获取后面的<br>事务的对应的数据</li>
<li>mysql中数据的存放还是会通过版本记录一系列的历史数据，这样可以根<br>据版本查找数据</li>
</ol>
<h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3><p>因为事务隔离性的要求，锁会带来三种问题</p>
<h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>一个事务的更新操作会被另一个事务的更新操作覆盖，从而导致数据的不一致<br>，但是当前数据库的任何隔离级别下都不会导致数据库理论意义上的丢失更新<br>，因为update操作会加锁，所以事务1更新记录时，事务2没有办法更新，只<br>有等事务1提交释放锁后事务2才会获取事务1已经修改的数据 <img src="/2020/12/07/MySQL3/53.jpg" alt></p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>注意区分两个概念：脏页和脏数据</p>
<ul>
<li>脏页 在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，当然在刷新<br>之前日志都已经被写入到重做日志中</li>
<li>脏数据 事务对缓冲池中的行记录的修改，并且还没有被提交</li>
</ul>
<p>参考 <a href="https://www.imooc.com/article/17291" target="_blank" rel="noopener">https://www.imooc.com/article/17291</a><br>脏读是指在不同的事务下当前事务可以读到另外事务未提交的数据，也就是脏<br>数据。脏读发生的条件是事务的隔离级别为READ UNCOMMITTED，有一个问题<br>就是在该隔离级别下的加锁情况究竟是什么样的，核心就是读操作不加锁，<br>写加锁，这与一开始的锁讲解一致，该隔离级别下并没有使用MVVC，而是读<br>取最新的行数据，所以可以读到其他事务还未提交的修改 <img src="/2020/12/07/MySQL3/20.jpg" alt></p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>在一个事务内多次读取同一数据集合，这个事务还未结束时，另外一个事务也<br>访问该同一数据集合，并做了一些DML操作并提交，那么第一个事务再次读取<br>的数据可能就与之前读取的数据不一样，不可重复读发生的条件是事务的隔离<br>级别是READ COMMITTED。事实上之前已经讲解过会读取一个快照，在RC隔离<br>级别下读取的是最新的快照，不可重复读和脏读的区别就是脏读是读到未提<br>交的数据，不可重复读读到的是已经提交的数据，违反一致性要求，可以使<br>用Next-Key Lock算法来避免不可重复读问题<img src="/2020/12/07/MySQL3/21.jpg" alt></p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>在一个事务结束时（ commit rollback ）或者客户端断开连接时就会释放锁。<br>因为不同锁之间的兼容性关系，在有些时候一个事务的锁需要等待另一个事务中<br>的锁释放它锁占用的资源，这就是阻塞。可以使用innodb_lock_wait_timeout<br>来控制等待时间（默认是50s），innodb_rollback_on_timeout用来设定是否<br>在等待超时时对进行的事务进行回滚操作</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等<br>待现象，解决死锁最简单的方式就是设置超时时间，当两个事务相互等待时当一<br>个事务的等待时间超时其中一个事务就会回滚，另一个事务继续执行，除此还可<br>以采用wait-for-garph方式进行死锁检测 <img src="/2020/12/07/MySQL3/37.jpg" alt><br>死锁的发生有如下条件</p>
<ul>
<li>同一时刻只能有一个事务持有这把锁</li>
<li>其他的事务需要在这个事务释放锁之后才能获取锁，而不可以强行剥夺</li>
<li>当多个事务形成等待环路的时候，即发生死锁</li>
</ul>
<p>wait-for graph要求数据库保存以下两种信息</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，若在这个图中存在回路就代表存在死锁，因此<br>资源间相互发生等待，因此wait-for graph是一种较为主动的死锁检测机制，<br>每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，一般<br>会回滚undo量最小的事务，采用的算法是深度优先算法，并且使用非递归优化</p>
<h4 id="死锁概率"><a href="#死锁概率" class="headerlink" title="死锁概率"></a>死锁概率</h4><p>死锁发生的概率与以下几个因素有关</p>
<ul>
<li>系统中事务的数量越多发生死锁的概率越大</li>
<li>每个事务操作的数量越多发生死锁的概率越大</li>
<li>操作数据的集合越小发生死锁的概率越大</li>
</ul>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>锁升级是指将当前锁的粒度降低，比如数据库可以把一个表中1000个行锁升级<br>为一个页锁，或者将页锁升级为一个表锁。如果在数据库的设计中认为锁是一<br>种稀有资源，而且想避免锁的开销，那么就会频繁出现锁升级的现象。InnoDB<br>存储引擎不存在锁升级的问题，不是根据每个记录来产生行锁的，而是根据每<br>个事务访问的页对锁进行管理，采用的是位图的方式，因此不管一个事务锁住<br>页中的是一个记录还是多个记录开销通常都是一样的</p>
<h4 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h4><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。采取了折衷<br>的页级锁，一次锁定相邻的一组记录。BDB支持页级锁</p>
<h3 id="MVVC实现原理"><a href="#MVVC实现原理" class="headerlink" title="MVVC实现原理"></a>MVVC实现原理</h3><p>参考 <a href="https://www.imooc.com/article/17290" target="_blank" rel="noopener">https://www.imooc.com/article/17290</a><br>参考 <a href="https://www.jianshu.com/p/8845ddca3b23" target="_blank" rel="noopener">https://www.jianshu.com/p/8845ddca3b23</a><br>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式<br>去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>
<ul>
<li>当前读 像select lock in share mode(共享锁), select for update<br>;update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当<br>前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能<br>修改当前记录，会对读取的记录进行加锁。</li>
<li>快照读 像不加锁的select操作就是快照读，即不加锁的非阻塞读，快照读<br>的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所<br>以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版<br>本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，<br>避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不<br>一定是数据的最新版本，而有可能是之前的历史版本</li>
</ul>
<p>在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中<br>的3个隐式字段、undo日志和Read View 来实现的<br>InnoDB为每行记录都实现了三个隐藏字段 <img src="/2020/12/07/MySQL3/31.jpg" alt></p>
<ul>
<li>DB_TRX_ID，6字节 插入或更新行的最后一个事务的事务ID，事务编号是自<br>动递增的（我们把它理解为创建版本号，在数据新增或者修改为新数据的时候<br>，记录当前事务ID）</li>
<li>DB_ROLL_PTR，7字节 回滚指针（我们把它理解为删除版本号，数据被删除<br>或记录为旧数据的时候，记录当前事务ID）。我们把这两个事务ID理解为版本号</li>
<li>DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，<br>InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li>undo log undo log中记录的是数据表记录行的多个版本，也就是事务执行<br>过程中的回滚段，其实就是MVCC中的一行原始数据的多个版本镜像数据</li>
<li>read view 主要用来判断当前版本数据的可见性</li>
</ul>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo<br>buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与<br>redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内<br>容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo<br>log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客<br>户端设置了每表一个数据文件也是如此</p>
<h4 id="行更新过程"><a href="#行更新过程" class="headerlink" title="行更新过程"></a>行更新过程</h4><p>接下来看一下事务1对某行记录的更新过程</p>
<ol>
<li>初始数据行 如果这行数据是刚INSERT的，可以认为ID为1，其余两列为<br>NULL <img src="/2020/12/07/MySQL3/38.jpg" alt></li>
<li>更改该行的各字段的值 更改时会先用排他锁锁定该行，记录redo log，<br>把该行修改前的值Copy到undo log，修改当前行的值，填写事务编号，使<br>回滚指针指向undo log中修改前的行  <img src="/2020/12/07/MySQL3/39.jpg" alt></li>
<li>事务2修改该行的值 此时undo log中有两行记录，并且通过回滚指针<br>连在一起 <img src="/2020/12/07/MySQL3/40.jpg" alt></li>
</ol>
<h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>判断当前版本数据项是否可见，实际上也就是内部快照。在innodb 中，创建<br>一个新事务的时候，会将当前系统中的活跃事务列表（trx_sys-&gt;trx_list<br>）创建一个副本（read view），副本中保存的是系统当前不应该被本事务<br>看到的其他事务id列表。当用户在这个事务中要读取该行记录的时候，<br>innodb会将该行当前的版本号与该read view进行比较。具体的算法<br>如下</p>
<ol>
<li>设该行的当前事务id为trx_id_0，read view中最早的事务id为<br>trx_id_1，最迟的事务id为trx_id_2</li>
<li>如果trx_id_0&lt; trx_id_1的话，那么表明该行记录所在的事务已经<br>在本次新事务创建之前就提交了，所以该行记录的当前值是可见的。跳<br>到步骤6</li>
<li>如果trx_id_0&gt;trx_id_2的话，那么表明该行记录所在的事务在本<br>次新事务创建之后才开启，所以该行记录的当前值不可见.跳到步骤5</li>
<li>如果trx_id_1&lt;=trx_id_0&lt;=trx_id_2, 那么表明该行记录所在事<br>务在本次新事务创建的时候处于活动状态，从trx_id_1到trx_id_2进<br>行遍历，如果trx_id_0等于他们之中的某个事务id的话，那么不可见<br>。跳到步骤5</li>
<li>从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的<br>undo-log的版本号，将它赋值该trx_id_0，然后跳到步骤2</li>
<li>将该可见行的值返回</li>
</ol>
<p>注意新建事务(当前事务)与正在内存中commit的事务不在活跃事务链表<br>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">函数：read_view_sees_trx_id。</span><br><span class="line">read_view中保存了当前全局的事务的范围：</span><br><span class="line">【low_limit_id， up_limit_id】</span><br><span class="line">1. 当行记录的事务ID小于当前系统的最小活动id，就是可见的。</span><br><span class="line">　　if (trx_id &lt; view-&gt;up_limit_id) &#123;</span><br><span class="line">　　　　return(TRUE);</span><br><span class="line">　　&#125;</span><br><span class="line">2. 当行记录的事务ID大于当前系统的最大活动id，就是不可见的。</span><br><span class="line">　　if (trx_id &gt;&#x3D; view-&gt;low_limit_id) &#123;</span><br><span class="line">　　　　return(FALSE);</span><br><span class="line">　　&#125;</span><br><span class="line">3. 当行记录的事务ID在活动范围之中时，判断是否在活动链表中，如果</span><br><span class="line">在就不可见，如果不在就是可见的。</span><br><span class="line">　　for (i &#x3D; 0; i &lt; n_ids; i++) &#123;</span><br><span class="line">　　　　trx_id_t view_trx_id</span><br><span class="line">　　　　　　&#x3D; read_view_get_nth_trx_id(view, n_ids - i - 1);</span><br><span class="line">　　　　if (trx_id &lt;&#x3D; view_trx_id) &#123;</span><br><span class="line">　　　　return(trx_id !&#x3D; view_trx_id);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>在RR隔离级别下，数据快照版本是在第一个读请求发起时创建的，之后<br>不会在发生变化，在RC隔离级别下则是在每次读请求都会创建一个快照<br>，也就是每次SELECT都能读取到已经COMMIT的数据，快照是在第一条<br>快照读的语句中生成，而不是在事务开始时创建快照<br><a href="https://zhuanlan.zhihu.com/p/55819387" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55819387</a></p>
<h3 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h3><p>事务可以分为以下类型</p>
<ul>
<li>扁平事务</li>
<li>带有保存点的扁平事务</li>
<li>链事务</li>
<li>嵌套事务</li>
<li>分布式事务</li>
</ul>
<h4 id="扁平事务"><a href="#扁平事务" class="headerlink" title="扁平事务"></a>扁平事务</h4><p>在扁平事务中，所有的操作都处于同一层次，由BEGIN WORK开始，由COMMIT<br>WORK结束，要么都执行要么都回滚，扁平事务是应用程序成为原子操作的基本<br>组成模块。扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几<br>个步骤提交</p>
<h4 id="带有保存点的事务"><a href="#带有保存点的事务" class="headerlink" title="带有保存点的事务"></a>带有保存点的事务</h4><p>允许事务在执行过程中回滚到同一事务中较早的一个状态，保存点用来通知系<br>统应该记住事务当前的状态，以便当之后发生错误时事务能够回到保存点当时<br>的位置，保存点用SAVE WORK函数建立 <img src="/2020/12/07/MySQL3/22.jpg" alt></p>
<h4 id="链事务"><a href="#链事务" class="headerlink" title="链事务"></a>链事务</h4><p>保存点模式的一种变种，带有保存点的扁平事务，当系统发生崩溃时所有的保<br>存点都会消失，因此其保存点是易失的而非持久的，当恢复时事务需要从开始<br>出重新执行，而不能从最近的一个保存点继续执行。链事务的思想是：在提交<br>一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一<br>个要开始的事务，注意提交事务操作和开始下一个事务操作将合并为一个原<br>子操作。一个事务由多个子事务链式组成 <img src="/2020/12/07/MySQL3/23.jpg" alt></p>
<h4 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h4><p>由一个顶层事务控制各个层次的事务，顶层事务之下嵌套的事务被称为子事务<br>，其控制的是一个局部的变换，可以看成一棵树，注意子事务的提交并不会马<br>上生效，除非其父事务已经提交，所以只有顶层事务提交后所有子事务才会提<br>交。树中任意一个事务的回滚都会引起其所有子事务一起回滚，所以子事务不<br>具有持久性。InnoDB不支持 <img src="/2020/12/07/MySQL3/24.jpg" alt></p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中<br>的不同节点，至少需要访问网络中两个节点的数据库，每个节点的数据库执行<br>的事务操作都是扁平的，如果任何一个操作失败都会导致整个分布式事务回滚</p>
<h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><p>MySQL默认设置下事务都是自动提交的，即执行SQL语句后马上就会执行COMMIT<br>操作，可以通过SET AUTOCOMMIT=0 禁用自动提交</p>
<ol>
<li>START TRANSACTION|BEGIN 显示开启一个事务</li>
<li>COMMIT 提交事务，对数据库永久性修改</li>
<li>ROLLBACK 回滚结束事务，撤销未提交的修改</li>
<li>SAVEPOINT identifier 在事务中创建一个保存点，一个事务可以有多个保存点</li>
<li>RELEASE SAVEPOINT identifier 删除一个保存点</li>
<li>ROLLBACK TO identifier 回滚到标记点</li>
<li>SET TRANSACTION 设置事务的隔离级别</li>
</ol>
<h3 id="对于事务操作的统计"><a href="#对于事务操作的统计" class="headerlink" title="对于事务操作的统计"></a>对于事务操作的统计</h3><p>每秒处理事务的能力TPS。计算TPS的方法如下，前提是所有事务都必须是显示<br>提交，隐式提交或回滚不会计算(autocommit=1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(com_commit+com_rollback)&#x2F;time</span><br></pre></td></tr></table></figure>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>在REPEATABLE READ事务隔离级别下，使用Next-Key Lock锁的算法，因此<br>避免了幻读。事实上READ COMMITTED隔离级别和SERIALIZABLE隔离级别的<br>性能差别并不大</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> &#123;</span><br><span class="line">	<span class="keyword">READ</span> UNCOMMITTED</span><br><span class="line">	| <span class="keyword">READ</span> COMMITTED</span><br><span class="line">	| REPEATABLE <span class="keyword">READ</span></span><br><span class="line">	| <span class="keyword">SERIALIZABLE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SERIALIZABLE隔离级别下InnoDB存储引擎对每个SELECT语句自动加上<br>LOCK IN SHARE MODE，即每个读取操作加上一个共享锁，主要用于分布<br>式事务。<br>在READ COMMITTED的事务隔离级别下，除了唯一性的约束检查及外键约束<br>的检查需要gap lock</p>
<h3 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>InnoDB存储引擎提供对XA事务的支持，并通过XA事务来支持分布式事务的<br>实现。分布式事务是指允许多个独立的事务资源参与到一个全局的事务中。<br>事务资源通常是关系型数据库系统，也可以是其他类型的资源。全局事务<br>要求在其中的所有参与的事务要么都提交，要么都回滚。使用分布式事务<br>时隔离级别必须是SERIALIZABLE</p>
<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><p>根据备份的方法可以分为如下备份方式</p>
<ul>
<li>Hot Backup 热备份 指数据库运行中直接备份，对正在运行的数据库操<br>作没有任何影响，也称为在线备份</li>
<li>Cold Backup 冷备份 在数据库停止的情况下备份，这种备份最简单，一<br>般只需要赋值相关的数据库物理文件即可，也称为离线备份</li>
<li>Warm Backup 温备份 同样在数据库运行时备份，但是会对数据库的操作<br>有所影响，比如一个全局读锁以保证备份数据的一致性</li>
</ul>
<p>按照备份后文件的内容可以分为</p>
<ul>
<li>逻辑备份 备份出的文件内容是可读的，内容一般是由一条条SQL语句或者<br>表内实际数据组成。好处是可以观察导出文件的内容，一般适用于数据库的<br>升级、迁移等工作。缺点是恢复所需的时间较长</li>
<li>裸文件备份 复制数据库的物理文件，既可以是在数据库运行中的复制，<br>也可以是停止运行时直接的数据文件复制，恢复时间较短</li>
</ul>
<p>按照备份数据库的内容来分，可以分为</p>
<ul>
<li>完全备份 对数据库进行一个完整的备份</li>
<li>增量备份 在完全备份的基础上对更改的数据进行备份</li>
<li>日志备份 对MySQL数据库二进制日志的备份，通过对一个完全备份进行二<br>进制日志的重做来完成数据库的 point-in-time的恢复工作。MySQL数据库<br>复制的原理就是异步实时将二进制日志重传送并引用到从数据库</li>
</ul>
<h3 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h3><p>只备份MySQL数据库的frm文件，共享表空间文件，独立表空间文件(*.ibd)<br>重做日志文件，优点如下</p>
<ul>
<li>备份简单，只需要复制相关文件</li>
<li>备份文件易于在不同操作系统，不同MySQL版本上恢复</li>
<li>恢复简单，只需把文件恢复到指定位置</li>
<li>恢复速度快，不需要执行任何SQL语句，也不需要重建索引</li>
</ul>
<p>缺点如下</p>
<ul>
<li>冷备的文件比逻辑文件大很多，因为表空间还存放了undo段，插入缓冲等</li>
<li>冷备也不总是可以轻易跨平台</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>一般用于建立大型的应用，主要涉及三个线程</p>
<ol>
<li>binlog 线程 负责将主服务器上的数据更改写入二进制日志（Binary<br>log）中</li>
<li>I/O 线程 负责从主服务器上读取二进制日志，并写入从服务器的中继<br>日志（Relay log）</li>
<li>SQL 线程 负责读取中继日志，解析出主服务器已经执行的数据更改并<br>在从服务器中重放（Replay）</li>
</ol>
<p>复制的工作原理实际就是一个完全备份加上二进制日志备份的还原，不同<br>的是这个二进制日志的还原操作基本上实时进行。注意复制是异步实时 <img src="/2020/12/07/MySQL3/54.jpg" alt></p>
<h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain<br>结果来优化查询语句，并输出 SELECT 执行的详细信息，在 SELECT 语<br>句前加上 Explain 就可以了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line">  id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure>
<p>各列的含义如下</p>
<ul>
<li>id: SELECT查询的标识符，每个SELECT都会自动分配一个唯一的标识符</li>
<li>select_type: SELECT查询的类型</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>表示查询的类型</p>
<ul>
<li>SIMPLE 表示此查询不包含 UNION 查询或子查询</li>
<li>PRIMARY 表示此查询是最外层的查询</li>
<li>UNION 表示此查询是 UNION 的第二或随后的查询</li>
<li>DEPENDENT UNION UNION 中的第二个或后面的查询语句，取决于外面的<br>查询</li>
<li>UNION RESULT UNION 的结果</li>
<li>SUBQUERY 子查询中的第一个 SELECT</li>
<li>DEPENDENT SUBQUERY 子查询中的第一个 SELECT，取决于外面的查询，<br>即子查询依赖于外层查询的结果</li>
</ul>
<h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ol>
<li>减少请求的数据量</li>
</ol>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要<br>查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的</li>
</ul>
<ol start="2">
<li>减少服务器端扫描的行数<br>最有效的方式是使用索引来覆盖查询</li>
</ol>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>某些sql语句执行完毕所花费的时间特别长，我们将这种响应比较慢的语句<br>记录在慢查询日志中，通过慢查询日志，可以查找出哪些查询语句的执行<br>效率低，以便进行优化</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/07/MySQL3/">https://skysea-gaoming.github.io/2020/12/07/MySQL3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataBase/">DataBase</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/10/ComputerNetwork2/"><i class="fa fa-chevron-left">  </i><span>计算机网络2</span></a></div><div class="next-post pull-right"><a href="/2020/11/24/Mysql2/"><span>MySQL2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/07/MySQL3/';
  this.page.identifier = '2020/12/07/MySQL3/';
  this.page.title = 'MySQL3';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>