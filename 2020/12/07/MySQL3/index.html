<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MySQL3"><meta name="keywords" content="DataBase"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>MySQL3 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表"><span class="toc-number">2.</span> <span class="toc-text">表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引组织表"><span class="toc-number">2.1.</span> <span class="toc-text">索引组织表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB逻辑存储结构"><span class="toc-number">2.2.</span> <span class="toc-text">InnoDB逻辑存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#表空间"><span class="toc-number">2.2.1.</span> <span class="toc-text">表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#段"><span class="toc-number">2.2.2.</span> <span class="toc-text">段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区"><span class="toc-number">2.2.3.</span> <span class="toc-text">区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#页"><span class="toc-number">2.2.4.</span> <span class="toc-text">页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行"><span class="toc-number">2.2.5.</span> <span class="toc-text">行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB行记录格式"><span class="toc-number">2.3.</span> <span class="toc-text">InnoDB行记录格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Compact"><span class="toc-number">2.3.1.</span> <span class="toc-text">Compact</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redundant"><span class="toc-number">2.3.2.</span> <span class="toc-text">Redundant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行溢出数据"><span class="toc-number">2.3.3.</span> <span class="toc-text">行溢出数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dynamic"><span class="toc-number">2.3.4.</span> <span class="toc-text">Dynamic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB数据页结构"><span class="toc-number">2.4.</span> <span class="toc-text">InnoDB数据页结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#约束"><span class="toc-number">2.5.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#约束的创建和查找"><span class="toc-number">2.5.1.</span> <span class="toc-text">约束的创建和查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#约束和索引"><span class="toc-number">2.5.2.</span> <span class="toc-text">约束和索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对错误数据的约束"><span class="toc-number">2.5.3.</span> <span class="toc-text">对错误数据的约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENUM和SET"><span class="toc-number">2.5.4.</span> <span class="toc-text">ENUM和SET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#触发器与约束"><span class="toc-number">2.5.5.</span> <span class="toc-text">触发器与约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外键约束"><span class="toc-number">2.5.6.</span> <span class="toc-text">外键约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图"><span class="toc-number">2.6.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区表"><span class="toc-number">2.7.</span> <span class="toc-text">分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RANGE分区"><span class="toc-number">2.7.1.</span> <span class="toc-text">RANGE分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LIST分区"><span class="toc-number">2.7.2.</span> <span class="toc-text">LIST分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HASH分区"><span class="toc-number">2.7.3.</span> <span class="toc-text">HASH分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KEY分区"><span class="toc-number">2.7.4.</span> <span class="toc-text">KEY分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分库分表"><span class="toc-number">2.7.5.</span> <span class="toc-text">分库分表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引与算法"><span class="toc-number">3.</span> <span class="toc-text">索引与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构与算法"><span class="toc-number">3.1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二分查找法"><span class="toc-number">3.1.1.</span> <span class="toc-text">二分查找法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树"><span class="toc-number">3.1.2.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树索引"><span class="toc-number">3.2.</span> <span class="toc-text">B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#聚集索引"><span class="toc-number">3.2.1.</span> <span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#辅助索引"><span class="toc-number">3.2.2.</span> <span class="toc-text">辅助索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树索引的分裂"><span class="toc-number">3.2.3.</span> <span class="toc-text">B+树索引的分裂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树索引的管理"><span class="toc-number">3.2.4.</span> <span class="toc-text">B+树索引的管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cardinality"><span class="toc-number">3.3.</span> <span class="toc-text">Cardinality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的使用"><span class="toc-number">3.4.</span> <span class="toc-text">索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#联合索引"><span class="toc-number">3.4.1.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖索引"><span class="toc-number">3.4.2.</span> <span class="toc-text">覆盖索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希算法"><span class="toc-number">3.5.</span> <span class="toc-text">哈希算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全文检索"><span class="toc-number">3.6.</span> <span class="toc-text">全文检索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#倒排索引"><span class="toc-number">3.6.1.</span> <span class="toc-text">倒排索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-number">4.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lock与latch"><span class="toc-number">4.1.</span> <span class="toc-text">lock与latch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的类型"><span class="toc-number">4.2.</span> <span class="toc-text">锁的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#快照"><span class="toc-number">4.2.1.</span> <span class="toc-text">快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一致性非锁定读"><span class="toc-number">4.2.2.</span> <span class="toc-text">一致性非锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一致性锁定读"><span class="toc-number">4.2.3.</span> <span class="toc-text">一致性锁定读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自增长与锁"><span class="toc-number">4.2.4.</span> <span class="toc-text">自增长与锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外键和锁"><span class="toc-number">4.2.5.</span> <span class="toc-text">外键和锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的算法"><span class="toc-number">4.3.</span> <span class="toc-text">锁的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#间隙锁"><span class="toc-number">4.3.1.</span> <span class="toc-text">间隙锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#临键锁"><span class="toc-number">4.3.2.</span> <span class="toc-text">临键锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Phantom"><span class="toc-number">4.3.3.</span> <span class="toc-text">Phantom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">4.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁问题"><span class="toc-number">4.4.</span> <span class="toc-text">锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#脏读"><span class="toc-number">4.4.1.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不可重复读"><span class="toc-number">4.4.2.</span> <span class="toc-text">不可重复读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVC实现原理"><span class="toc-number">4.5.</span> <span class="toc-text">MVVC实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">4.5.1.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行更新过程"><span class="toc-number">4.5.2.</span> <span class="toc-text">行更新过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-View"><span class="toc-number">4.5.3.</span> <span class="toc-text">Read View</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#丢失更新"><span class="toc-number">4.5.4.</span> <span class="toc-text">丢失更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞"><span class="toc-number">4.5.5.</span> <span class="toc-text">阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">4.6.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁概率"><span class="toc-number">4.6.1.</span> <span class="toc-text">死锁概率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁升级"><span class="toc-number">4.7.</span> <span class="toc-text">锁升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务"><span class="toc-number">5.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分类"><span class="toc-number">5.1.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#扁平事务"><span class="toc-number">5.1.1.</span> <span class="toc-text">扁平事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带有保存点的事务"><span class="toc-number">5.1.2.</span> <span class="toc-text">带有保存点的事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链事务"><span class="toc-number">5.1.3.</span> <span class="toc-text">链事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套事务"><span class="toc-number">5.1.4.</span> <span class="toc-text">嵌套事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式事务"><span class="toc-number">5.1.5.</span> <span class="toc-text">分布式事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务的实现"><span class="toc-number">5.2.</span> <span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log"><span class="toc-number">5.2.1.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log-block"><span class="toc-number">5.2.2.</span> <span class="toc-text">log block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log-group"><span class="toc-number">5.2.3.</span> <span class="toc-text">log group</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重做日志格式"><span class="toc-number">5.2.4.</span> <span class="toc-text">重做日志格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LSN"><span class="toc-number">5.2.5.</span> <span class="toc-text">LSN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#恢复"><span class="toc-number">5.2.6.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log-1"><span class="toc-number">5.3.</span> <span class="toc-text">undo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undo存储管理"><span class="toc-number">5.3.1.</span> <span class="toc-text">undo存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log格式"><span class="toc-number">5.3.2.</span> <span class="toc-text">undo log格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#purge"><span class="toc-number">5.3.3.</span> <span class="toc-text">purge</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务控制语句"><span class="toc-number">5.4.</span> <span class="toc-text">事务控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式提交的SQL语句"><span class="toc-number">5.5.</span> <span class="toc-text">隐式提交的SQL语句</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">MySQL3</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/07/MySQL3/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/07/MySQL3/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《MySQL技术内幕》</p>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>表是关于特定实体的数据集合，也是关系型数据库模型的核心</p>
<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式<br>的表称为索引组织表。每张表都有一个主键</p>
<ul>
<li>首先判断表中是否有非空的唯一索引，如果有则该列为主键。当有多个<br>非空唯一索引时，将选择建表时第一个定义的非空唯一索引为主键</li>
<li>如果不符上述条件则InnoDB自动创建一个6字节大小的指针</li>
</ul>
<p>接下来用一个表来说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create table z(</span><br><span class="line">a int not null,</span><br><span class="line">b int null,</span><br><span class="line">c int not null,</span><br><span class="line">d int not null,</span><br><span class="line">unique key(b),</span><br><span class="line">unique key(d),unique key(c));</span><br><span class="line"></span><br><span class="line">mysql&gt; select *,_rowid from z;</span><br><span class="line">+---+------+----+----+--------+</span><br><span class="line">| a | b    | c  | d  | _rowid |</span><br><span class="line">+---+------+----+----+--------+</span><br><span class="line">| 1 |    2 |  3 |  4 |      4 |</span><br><span class="line">| 5 |    6 |  7 |  8 |      8 |</span><br><span class="line">| 9 |   10 | 11 | 12 |     12 |</span><br><span class="line">+---+------+----+----+--------+</span><br></pre></td></tr></table></figure>
<p>_rowid可以显示表的主键，但只能显示单个列为主键的情况</p>
<h3 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h3><p>之前在MySQL2中已经讲了表空间文件存放所有数据。表空间又由段、区、页<br>组成，页在某些文档也称为块 <img src="/2020/12/07/MySQL3/1.jpg" alt></p>
<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><p>在默认情况下InnoDB存储引擎有一个共享表空间ibdata1，即所有的数据都存放<br>在这个表空间中，如果用户启动参数innodb_file_per_table，则每张表内的<br>数据可以单独存放到一个表空间中，注意这里存放的只是数据、索引和插入缓冲<br>Bitmap页，其他类的数据还是在共享表空间中</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>上图已经说明表空间是由各个段组成，常见的段有数据段、索引段、回滚段等。<br>数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点 <img src="/2020/12/07/MySQL3/8.jpg" alt></p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由连续的页组成，在任何情况下每个区的大小都为1MB，为了保证区中页的<br>连续性，InnoDB存储引擎一次磁盘申请4~5个区，一个区有64个连续的页</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>页是InnoDB磁盘管理的最小单位，在InnoDB存储引擎中默认每个页的大小是<br>16KB。现在版本可以通过innodb_page_size将页的大小设置为4K、8K、16K。<br>常见的页类型如下</p>
<ul>
<li>数据页</li>
<li>undo页</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲列表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩的二进制大对象页</li>
</ul>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>InnoDB存储引擎是面向列的，也就是说数据是按照行进行存放的。每个页最多<br>存放 16KB/2-200=7992 行记录</p>
<h3 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h3><p>页中存放的是表中一行行数据，InnoDB存储引擎提供多种格式来存放行记录数据</p>
<h4 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h4><p>一个页中存放的数据越多性能越高 <img src="/2020/12/07/MySQL3/9.jpg" alt><br>Compact行记录格式的首部是一个非NULL变长字段长度列表，并且按照列的顺序<br>逆序放置</p>
<ul>
<li>若列的长度小于255字节，用1字节表示</li>
<li>若大于255字节，用2字节表示，因为VARCHAR类型最大长度是65535</li>
</ul>
<p>第二个部分是NULL标志位，用于指示改行数据是否有NULL值，有则用1表示，<br>第三个部分是记录头信息，固定占5个字节 <img src="/2020/12/07/MySQL3/10.jpg" alt><br>最后的部分就是实际存储每个列的数据，注意NULL不占该部分空间，还有一点是<br>除了用户定义的列外，还有两个隐藏列：事务ID和回滚指针列，分别为6字节和<br>7字节大小，若InnoDB表没有主键则还会增加一个rowid列</p>
<h4 id="Redundant"><a href="#Redundant" class="headerlink" title="Redundant"></a>Redundant</h4><p>Redundant是老版本的行记录存储方式 <img src="/2020/12/07/MySQL3/11.jpg" alt></p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>InnonDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外，<br>比如BLOB LOB这类大对象列类型会存储在数据页面之外</p>
<h4 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h4><p>支持Compact和Redundant格式的称为Antelope文件格式，新的文件格式<br>Barracuda支持Compressed和Dynamic</p>
<h3 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h3><p>InnoDB数据页由7个部分组成 <img src="/2020/12/07/MySQL3/12.jpg" alt></p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>关系型数据库系统和文件系统的一个不同点是关系数据库本身能保证存储<br>数据的完整性，约束机制可以保证数据的完整性。数据完整性有以下三种<br>形式</p>
<ol>
<li>实体完整性保证表中有一个主键。在InnoDB 中可以通过定义primary<br>key或Unique Key来保证实体完整性。还可以通过编写一个触发器来保证<br>实体完整性</li>
<li>域完整性保证数据每列的值满足特定条件。可以通过以下方式来保证</li>
</ol>
<ul>
<li>选择合适数据类型</li>
<li>外键约束</li>
<li>编写触发器</li>
<li>用DEFAULT约束作为强制域完整性的一个方面</li>
</ul>
<ol start="3">
<li>参考完整性保证两张表之间的关系，可以通过定义外键或编写触发器</li>
</ol>
<p>InnoDB存储引擎提供的约束如下</p>
<ul>
<li>Primary Key</li>
<li>Unique Key</li>
<li>Foreign Key</li>
<li>Default</li>
<li>NOT NULL</li>
</ul>
<h4 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h4><p>约束的创建有两种方式</p>
<ol>
<li>表建立时就进行约束定义</li>
<li>使用alter table创建约束，Unique Key还可以通过create unique<br>index 来创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create unique index bb on z(b);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>主键约束默认约束名为PRIMARY，Unique Key约束默认约束名为列名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select constraint_name,constraint_type from information_schema.TABLE_CONSTRAINTS</span><br><span class="line">where table_schema&#x3D;&#39;mytest&#39; and table_name&#x3D;&#39;z&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="约束和索引"><a href="#约束和索引" class="headerlink" title="约束和索引"></a>约束和索引</h4><p>约束是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，<br>在数据库中代表物理存储的方式</p>
<h4 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h4><p>在某些默认设置下MySQL数据库允许非法或不正确的数据的插入或更新，可以在<br>内部将其转化为一个合法的值，如向NOT NULL的字段插入一个NULL值，MySQL<br>会将其更改为0再插入，可以设置sql_mode保证数据库提示报错而不是警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set sql_mode&#x3D;&#39;STRICT_TRANS_TABLES&#39;</span><br></pre></td></tr></table></figure>
<h4 id="ENUM和SET"><a href="#ENUM和SET" class="headerlink" title="ENUM和SET"></a>ENUM和SET</h4><p>MySQL数据库不支持传统的CHECK约束，但是可以通过ENUM和SET类型解决这个<br>需求，例如有一个性别类型，范围只能是male或female</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table a(</span><br><span class="line">	id int,</span><br><span class="line">	sex enum(&#39;male&#39;,&#39;female&#39;));</span><br></pre></td></tr></table></figure>
<h4 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h4><p>完整性约束通常也可以使用触发器来实现，触发器的作用就是在执行INSERT<br>DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。创建触发器<br>的命令是create trigger</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE</span><br><span class="line">[DEFINER&#x3D;&#123;user|CURRENT_USER&#125;]</span><br><span class="line">TRIGGER trigger_name BEFORE|AFTER INSERT|UPDATE|DELETE</span><br><span class="line">ON tb1_name FOR EACH ROW trigger_stmt</span><br></pre></td></tr></table></figure>
<p>最多可以为一个表建立6个触发器，分别为 INSERT UPDATE DELETE的BEFORE<br>和AFTER各定义一个。BEFORE和AFTER 代表触发器发生的时间，表示在每行操<br>做之前还是之后发生。通过触发器可以实现MySQL 数据库本身并不支持的一些<br>特性。假设有张用户表，用户每次购买物品后金额都是减的，但是如果有一个<br>减去负值的操作，那么用户的钱反而会增多，语句本身没有问题但是逻辑错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table usercash(</span><br><span class="line">	userid int not null,</span><br><span class="line">	cash int not null);</span><br><span class="line">insert into usercash values(1,1000);</span><br><span class="line">update usercash set cash&#x3D;cash-(-20) where userid&#x3D;1;</span><br></pre></td></tr></table></figure>
<p>这时需要一个触发器来约束这个逻辑行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tgr_usercash_update BEFORE UPDATE ON usercash(</span><br><span class="line">	FOR EACH ROW</span><br><span class="line">	BEGIN </span><br><span class="line">	IF new.cash-oil.cash &gt; 0 THEN</span><br><span class="line">	INSERT INTO usercash_err_log</span><br><span class="line">	SELECT old.userid, old.cash, new.cash,USER(),NOW();</span><br><span class="line">	SET new.cash &#x3D; old.cash;</span><br><span class="line">	END IF;</span><br><span class="line">	END;</span><br><span class="line">	$$</span><br><span class="line">);</span><br><span class="line">DELIMITER $$;</span><br></pre></td></tr></table></figure>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>MyISAM不支持外键，InnoDB支持外键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE parent(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">)ENGINE &#x3D; INNODB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE child(</span><br><span class="line">id INT, parent_id INT,</span><br><span class="line">FOREIGN KEY(parent_id) REFERENCES parent(id)</span><br><span class="line">)ENGINE&#x3D;INNODB;</span><br></pre></td></tr></table></figure>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个命名的虚表，但是视图中的数据没有实际的物理存储</p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>分区的过程是将一个表或索引分解为更小、更可管理的部分。就访问数据库而言<br>就一个表或一个索引，但是在物理上这个表或索引可以有数十个物理分区组成<br>，每个分区都是独立的对象，MySQL支持的分区类型是水平分区，不支持垂直<br>分区，此外MySQL的分区是局部分区索引，一个分区中既存放了数据又存放了<br>索引。全局分区指的是数据存放在各个分区，但是所有数据的索引存放在一个<br>对象中</p>
<ul>
<li>水平分区 同一个表中不同行的记录分配到不同物理文件中</li>
<li>垂直分区 同一个表中不同列的记录分配到不同物理文件中</li>
</ul>
<h4 id="RANGE分区"><a href="#RANGE分区" class="headerlink" title="RANGE分区"></a>RANGE分区</h4><p>行数据基于一个给定连续区间的列值被放入分区</p>
<h4 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h4><p>和RANGE分区类似，只是LIST面向的是离散的值</p>
<h4 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h4><p>根据用户自定义的表达式的返回值来进行分区</p>
<h4 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h4><p>根据MySQL提供的哈希函数进行分区</p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>mycat shardingsphere drds</p>
<h2 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h2><p>索引并不是越多越好，在一开始就应该在需要处添加索引，MySQL 支持如下<br>索引，B+树索引并不能找到一个给定键值的具体行，而是找到行所在的页，<br>然后数据库把页读入到内存中</p>
<ul>
<li>B+树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><p>每页Page Directory中的槽是按照主键的顺序存放，对于某一条具体记录的<br>查询时通过对Page Direcotry进行二分查找得到</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树的插入分为三种情况 <img src="/2020/12/07/MySQL3/2.jpg" alt><br>当插入28时满足第一种情况，所以直接插入到叶子节点 <img src="/2020/12/07/MySQL3/3.jpg" alt><br>继续插入70满足第二种情况，这时插入Leaf Page后的顺序为 50 55 60 65<br>70，中间值是60所以放到分页节点 <img src="/2020/12/07/MySQL3/4.jpg" alt><br>最后插入95满足第三种情况，首先拆分叶子节点 75 80 85 90 95，中间值是<br>85将小于85的放在左边大于85的放在右边，然后拆分分页节点，25 50 60 75<br>85，中间值是60，小于60的放在左边大于60的放在右边 <img src="/2020/12/07/MySQL3/5.jpg" alt><br>B+树为了保持平衡可能会做大量拆分页的操作，因为B+树结构主要用于磁盘，<br>所以提供了旋转来减少拆分。旋转发生在Leaf Page已经满当左右兄弟节点没有<br>满的情况，这时不会拆分而是将记录移到兄弟节点上，通常情况左新兄弟先进<br>行旋转操作，现在插入70 <img src="/2020/12/07/MySQL3/6.jpg" alt><br>B+树使用填充因子来控制树的删除变化，50%是填充因子可设的最小值，B+树<br>的删除也分为三种情况 <img src="/2020/12/07/MySQL3/7.jpg" alt></p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树索引的本质就是B+树在数据库中的实现，B+索引在数据库中有一个特点就<br>是高扇出性，因此在数据库中B+树的高度一般在2~4层，也就是说查找某一键<br>值的行记录最多只需2到4次，B+索引可以分为聚集索引和辅助索引</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>聚集索引是按照每一张表的主键构造一棵B+树，叶子节点存放的就是整张表的<br>行记录数据，也将叶子节点称为数据页，聚集索引这个特性决定了索引组织表<br>中数据也是索引的一部分。每张表只能有一个聚集索引，多数情况下查询优化<br>器倾向采用聚集索引</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>也称为非聚集索引，叶子节点并不包含行记录的所有数据，叶子节点除了包含<br>键值以外，每个叶子节点的索引行还包含一个书签(bookmark)，该书签用来<br>告诉InnoDB存储引擎在哪里可以找到与索引相对应的行数据，这个书签实际<br>就是相应的聚集索引键。每张表可以有多个辅助索引，先通过辅助索引找到<br>相应的主键索引，再通过主键索引找到一个完整的行记录 <img src="/2020/12/07/MySQL3/13.jpg" alt></p>
<h4 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h4><p>B+树索引页的分裂并不总是从页的中间记录开始，这样可能导致页的浪费</p>
<h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><p>用户可以设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据</p>
<h3 id="Cardinality"><a href="#Cardinality" class="headerlink" title="Cardinality"></a>Cardinality</h3><p>并不是在所有的查询条件中出现的列都需要添加索引，可以通过Cardinality<br>来观察索引中不重复记录数量的预估值</p>
<h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p>根据OLTP和OLAP两种应用</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>对表的多个列进行索引，联合索引也是一棵B+树，不同的是联合索引的键值<br>的数量不是1而是大于等于2 <img src="/2020/12/07/MySQL3/14.jpg" alt><br>根据这棵B+树可以知道以下查询语句可以使用联合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a&#x3D;xxx and b&#x3D;xxx</span><br><span class="line">select * from table where a&#x3D;xxx</span><br></pre></td></tr></table></figure>
<p>但是对于b列的查询不能使用联合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where b&#x3D;xxx</span><br></pre></td></tr></table></figure>

<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>即从辅助索引中就可以得到查询的记录，不需要查询聚集索引的记录。覆盖<br>索引的另一个好处是对于某些统计问题而言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from buy_log;</span><br></pre></td></tr></table></figure>
<p>InnoDB并不会选择通过查询聚集索引来进行统计，由于buy_log表上还有<br>辅助索引，而辅助索引远小于聚集索引，所以会选择辅助索引</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>InnoDB存储引擎使用哈希算法来对字典进行查找，其冲突机制采用链表方式<br>，哈希函数采用的是除法散列方式</p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>可以通过索引字段的前缀进行查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from blog where content like &#39;xxx%&#39;;</span><br></pre></td></tr></table></figure>
<p>但是更多的是如下情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from blog where content like &#39;%xxx%&#39;;</span><br></pre></td></tr></table></figure>
<p>全文索引是将储存于数据库中的整本书或整篇文章中的任意内容信息查找出来<br>的技术</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>全文索引通常使用倒排索引来实现</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的<br>并发访问</p>
<h3 id="lock与latch"><a href="#lock与latch" class="headerlink" title="lock与latch"></a>lock与latch</h3><p>lock与latch都被称为锁。latch 一般称为闩锁（轻量级的锁)），其要求锁定的<br>时间非常短，若持续的时间长则应用的性能非常差，在InnoDB存储引擎中latch<br>又可以分为mutex（互斥量）和rwlock（读写锁）。lock的对象是事务，用来锁<br>定的是数据库中的对象，如表、页、行。并且仅在事务commit或rollback或unlock<br>后释放，有死锁机制 <img src="/2020/12/07/MySQL3/15.jpg" alt></p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>InnoDB存储引擎实现了两种标准的行级锁</p>
<ul>
<li>共享锁(S Lock) 允许事务读一行数据</li>
<li>排他锁(X Lock) 允许事务删除或更新一行数据</li>
</ul>
<p>如果一个事务T1已经获取了行r的共享锁，那么另外的事务T2可以立即获取行r<br>的共享锁，因为读取并没有改变行r的数据，这种情况为锁兼容。若有其他事务<br>T3想获得行r的排他锁，必须等事务T1、T2释放行r上的共享锁–这种情况称为<br>锁不兼容 <img src="/2020/12/07/MySQL3/16.jpg" alt><br>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的<br>锁同时存在。InnoDB存储引擎支持意向锁，意向锁是将锁定的对象分为多个层<br>次 <img src="/2020/12/07/MySQL3/17.jpg" alt></p>
<ul>
<li>意向共享锁(IS Lock) 事务想要获得一张表中某几行的共享锁</li>
<li>意向排他锁(IX Lock) 事务想要获得一张表中某几行的排他锁</li>
</ul>
<p>这里对意向锁的解释很清晰 <a href="https://www.zhihu.com/question/51513268" target="_blank" rel="noopener">https://www.zhihu.com/question/51513268</a><br>意向锁是 InnoDB 自动加的，不需用户干预。对于UPDATE、 DELETE 和 INSERT<br>语句，InnoDB会自动给涉及数据集加排他锁(X)，对于普通SELECT语句，InnoDB<br>不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE </span><br><span class="line">其他session仍然可以查询记录，并也可以对该记录加share mode 的共享锁。</span><br><span class="line">但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁</span><br><span class="line">排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br><span class="line">其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</span><br><span class="line">表锁的语法如下</span><br><span class="line">需要注意lock tables语法除了会限制别的线程的读写之外，也限定了本线程接下来的操作对象</span><br><span class="line">lock tables .. read&#x2F;write </span><br><span class="line">unlock tables</span><br><span class="line"></span><br><span class="line">对于 insert、update、delete，InnoDB 会自动给涉及的数据加排他锁（X），只</span><br><span class="line">有查询 select 需要我们手动设置排他锁对于一般的 select 语句，InnoDB 不会</span><br><span class="line">加任何锁，也就是可以多个并发去进行 select 的操作，不会有任何的锁冲突，因</span><br><span class="line">为根本没有锁</span><br><span class="line">注意 select * 这样的全表扫描会给表加意向共享锁</span><br></pre></td></tr></table></figure>

<p>注意下图的X和S都是表级锁，书上的原句是“在对记录r加X锁之前，已经有事<br>务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上<br>加IX锁，由于不兼容，所以事务需要等待表锁操作的完成”，这里的X锁也是<br>表锁，行级锁只会和行级锁发生冲突，表级锁只会和表级锁发生冲突 <img src="/2020/12/07/MySQL3/18.jpg" alt></p>
<p>参考 <a href="https://blog.csdn.net/weixin_43935927/article/details/109438506" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43935927/article/details/109438506</a><br>行锁锁的究竟是什么，事实上行锁锁的并不是某一行的数据，而是这一行数据<br>的索引，比如先操作一个没有索引的表 <img src="/2020/12/07/MySQL3/25.jpg" alt><br>给id=1的数据加排他锁，但是id=3和id=5的数据都被阻塞了，说明锁住的不<br>是Record。接下来操作一个有主键索引的表 <img src="/2020/12/07/MySQL3/26.jpg" alt><br>使用相同的id加锁会冲突，使用不同的id加锁成功，但是不能确定是否是锁<br>定了id这个字段，接下来操作一个有唯一索引的表 <img src="/2020/12/07/MySQL3/27.jpg" alt><br>第二个事务想获取name=’4’的排它锁肯定会失败，但是为什么id=4的数据<br>也被阻塞，说明并没有锁定name这个字段，否则锁定id应该不会被阻塞，<br>结论就是InnoDB的行锁是通过锁住索引来实现的。第一个表中因为没有索引<br>所以会自动创建一个主键，查询没有使用索引所以会全表扫描把每一个隐藏<br>的聚集索引都锁住了，这里加的应该是一个表级排他锁。第二个表中给唯一<br>索引加锁时主键索引也会被锁住，辅助索引中，索引存储的是二级索引和<br>主键的值，也就是通过二级索引最终要找到主键索引，比如name=4存储<br>的是索引和主键id的值4，主键索引中除了索引还有完整的数据 <img src="/2020/12/07/MySQL3/28.jpg" alt><br>如果表中有索引就索索引，否则就锁整个表</p>
<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>参考 <a href="https://www.cnblogs.com/qcloud1001/p/9322321.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcloud1001/p/9322321.html</a><br>快照的定义：关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据<br>在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的<br>一个副本，也可以是数据的一个复制品。<br>存储快照，是一种数据保护措施，可以对源数据进行一定程度的保护 <img src="/2020/12/07/MySQL3/29.jpg" alt><br>快照是一份完全可用的副本，那么它完全可以被上层业务当做源数据 <img src="/2020/12/07/MySQL3/30.jpg" alt></p>
<h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>参考 <a href="https://blog.csdn.net/u010900754/article/details/106772974" target="_blank" rel="noopener">https://blog.csdn.net/u010900754/article/details/106772974</a><br>一致性非锁定读指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时<br>间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取<br>操作不会因此等待行上锁的释放，因为一般的读取操作是没有锁的，所以可以<br>直接读取到加锁的数据，会去读取行的一个快照 <img src="/2020/12/07/MySQL3/19.jpg" alt><br>快照数据是指该行的之前版本的数据，也即是 undo 中的数据，不需要加锁。<br>不同事物隔离级别下，读取的方式不同，并不是在每个事物隔离级别下都采用<br>非锁定的一致性读。<br>一个行记录可能不止一个快照数据，一般称这种技术为行多版本技术，由此带<br>来的并发控制称之为多版本并发控制。<br>在事务隔离级别为READ COMMITTED和REPETABLE READ下，InnoDB存储引擎<br>使用非锁定的一致性读，但是对于快照数据的定义不同</p>
<ul>
<li>READ COMMITTED 对于快照数据，非一致性读总是读取被锁定行的最新一份<br>快照数据</li>
<li>REPEATABLE READ 读取事务开始之前最后一个版本的数据</li>
</ul>
<p>事实上新的版本数据会覆盖旧的版本数据，那事务还能够读取到旧版本的数据<br>是因为undo log，也就是说undo log能够实现MVCC。我在上一篇博客中解释<br>undo log是保存在内存中的没有必要存入磁盘是针对回滚这个问题而言，事<br>实上undo log也是要存入磁盘的</p>
<h4 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h4><p>某些情况下需要对数据库读取操作进行加锁以保证数据逻辑的一致性，即使是<br>对SELECT的只读操作也有两种一致性的锁定读操作，必须在事务中操作，注<br>意对于一致性非锁定读这两个操作不会加锁</p>
<ol>
<li>SELECT … FOR UPDATE 对读取的行记录加X锁，其余事务不能加任何锁</li>
<li>SELECT … LOCK IN SHARE MODE 加S锁，其余事务可以加S锁</li>
</ol>
<h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><p>每个含有自增长值的表都有一个自增长计数器，当对含有自增长计数器的表进<br>行插入操作时这个计数器会被初始化，插入操作会依据这个自增长的计数器值<br>加1赋予自增长列，这种锁采用一种特殊的表锁机制，并不是在一个事务完成<br>后才会释放，而是在完成自增长值插入的SQL语句后立即释放。但是对于有自<br>增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不<br>用等待事务的完成），对于INSERT .. SELECT的大数据量插入会影响插入<br>的性能，目前的版本采用一种轻量级互斥量的自增长实现机制。注意自增长<br>的列必须是索引，同时必须是索引的第一个列 <img src="/2020/12/07/MySQL3/32.jpg" alt> <img src="/2020/12/07/MySQL3/33.jpg" alt></p>
<h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><p>对于一个外键列，如果没有显示对这个列加锁，则自动加一个索引避免表锁<br>，当外键值插入或更新的时候需要查询父表中的记录，即SELECT 父表，但<br>对于父表的SELECT并不是采用一致性非锁定读的方式，而是使用S锁</p>
<h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><p>InnoDB有3种行锁的算法，区别在于加锁范围的不同</p>
<ol>
<li>Record Lock 单个行记录上的锁，之前已经提过总是锁定索引记录</li>
<li>Gap Lock 间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-Key Lock Gap+Record 锁定一个范围并且锁定记录本身，例如<br>一个索引有10 11 13 20四个值，那么Next-Key Locking的区间为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞,10]</span><br><span class="line">(10,11]</span><br><span class="line">(11,13]</span><br><span class="line">(13,20]</span><br><span class="line">(20,+∞)</span><br></pre></td></tr></table></figure>
采用Next-Key Lock是为了解决幻读 <img src="/2020/12/07/MySQL3/34.jpg" alt><br>当查询的索引含有唯一属性进行等值查询时（唯一索引的主键索引），InnoDB<br>存储引擎会将Next-Key Lock进行优化，将其降级为Record Lock，即仅锁定<br>索引本身而不是范围<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table t( a int primary key)</span><br><span class="line">insert into t values(1),(2),(3);</span><br><span class="line">会话A                  会话B</span><br><span class="line">BEGIN; </span><br><span class="line">SELECT * from t</span><br><span class="line">where a&#x3D;5 for update;</span><br><span class="line">					   BEGIN;</span><br><span class="line">					   INSERT INTO T 4;</span><br><span class="line">					   COMMIT;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
会话A首先对a=5进行X锁定，因为a是主键所以仅仅锁定这一个值。这样在会<br>话B中插入4不会被阻塞<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table z (a int,b int,primary key(a),key(b))</span><br><span class="line">insert into z values(1,1),(3,1),(5,3),(7,6),(10,8);</span><br><span class="line">b是辅助索引，如果会话A中执行的是</span><br><span class="line">SELECT * FROM z where b&#x3D;3 for update;</span><br></pre></td></tr></table></figure>
那么就会使用Next-Key Locking技术加锁，并且由于有两个索引所以会分别<br>进行锁定。对于聚集索引仅对a=5的索引加Record Lock，对于辅助索引，锁<br>定的范围是(1,3]，注意InnoDB存储引擎还会对辅助索引下一个键值进行加<br>gap Lock，即范围为(3,6)的锁，以下语句都会阻塞<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from z where a&#x3D;5 lock in share mode;</span><br><span class="line">insert into z values(4,2);</span><br><span class="line">insert into z values(6,5);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>当我们查询的记录不存在，没有命中任何一个record，无论是用等值查询还<br>是范围查询的时候，它使用的都是间隙锁。注意间隙锁主要是阻塞insert，<br>而没有阻塞select，相同的间隙锁之间不冲突。<br>Gap Lock只在隔离级别RR中存在，如果要关闭间隙锁，事务隔离级别设置成<br>RC，innodb_locks_unsafe_for_binlog设置为ON。这种情况下除了外键约<br>束和唯一性检查会加间隙锁，其他情况都不会用间隙锁</p>
<h4 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h4><p>当我们使用了范围查询，不仅仅命中了Record记录，还包含了Gap间隙，在这<br>种情况下我们使用的就是临键锁，它是MySQL里面默认的行锁算法，相当于记<br>录锁加上间隙锁，临键锁有两种退化的情况</p>
<ul>
<li>记录锁：唯一性索引，等值查询匹配到一条记录的时候，退化成记录锁</li>
<li>间隙锁：没有匹配到任何记录的时候，退化成间隙锁</li>
</ul>
<p>比如要查询(5,9)之间的范围，锁住的是 (4,7]和(7,10] <img src="/2020/12/07/MySQL3/35.jpg" alt><br>临键锁与间隙锁不同的是，它除了锁住原本的临键区间，还会锁住最后一个<br>key的下一个左开右闭的区间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id&gt;5 and id&lt;&#x3D;7 for update; -- 锁住(4,7]和(7,10] </span><br><span class="line">select * from t where id&gt;8 and id&lt;&#x3D;10 for update; -- 锁住 (7,10]和(10,+∞)</span><br></pre></td></tr></table></figure>
<p>为什么要锁住下一个左开右闭的区间？——为了解决幻读的问题。所以，我们看<br>下MySQL InnoDB里面事务隔离级别的实现。为什么InnoDB 的RR 级别能够解<br>决幻读的问题，就是用临键锁实现的 <img src="/2020/12/07/MySQL3/36.jpg" alt></p>
<h4 id="Phantom"><a href="#Phantom" class="headerlink" title="Phantom"></a>Phantom</h4><p>Phantom Problem是指在同一事务下，连续执行两次同样的SQL语句可能导致<br>不同的结果，第二次SQL语句可能返回之前不存在的行。例如之前的表t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where a&gt;2 for update;</span><br></pre></td></tr></table></figure>
<p>如果事务A没有提交应该返回5，现在另一个事务B插入4，那么在此查询发现<br>多了4这个数据，这就是幻读。上述的情况是在隔离级别为 READ COMMITED<br>的条件下，如果是在REPEATABLE READ条件下会对(2,+∞)这个范围加X锁。<br>这里的select都是用for update，如果只是普通的select那么读取的就<br>是快照数据，一样不会产生幻读，如果加了for updata就是给数据加排<br>斥锁，这时会通过行锁算法锁定一个范围，同样解决了幻读。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在mysql中，提供了两种事务隔离技术，第一个是mvcc，第二个是next-key技<br>术。这个在使用不同的语句的时候可以动态选择。不加lock inshare mode 之<br>类的就使用mvcc。否则使用next-key。mvcc的优势是不加锁，并发性高。缺点<br>是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。同时需要<br>注意几点</p>
<ol>
<li>事务的快照时间点是以第一个select来确认的。所以即便事务先开始。但是<br>select在后面的事务的update之类的语句后进行，那么它是可以获取后面的<br>事务的对应的数据</li>
<li>mysql中数据的存放还是会通过版本记录一系列的历史数据，这样可以根<br>据版本查找数据</li>
</ol>
<h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3><p>因为事务隔离性的要求，锁会带来三种问题</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>注意区分两个概念：脏页和脏数据</p>
<ul>
<li>脏页 在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，当然在刷新<br>之前日志都已经被写入到重做日志中</li>
<li>脏数据 事务对缓冲池中的行记录的修改，并且还没有被提交</li>
</ul>
<p>参考 <a href="https://www.imooc.com/article/17291" target="_blank" rel="noopener">https://www.imooc.com/article/17291</a><br>脏读是指在不同的事务下当前事务可以读到另外事务未提交的数据，也就是脏<br>数据。脏读发生的条件是事务的隔离级别为READ UNCOMMITTED，有一个问题<br>就是在该隔离级别下的加锁情况究竟是什么样的，核心就是读操作不加锁，<br>写加锁，这与一开始的锁讲解一致 <img src="/2020/12/07/MySQL3/20.jpg" alt></p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>在一个事务内多次读取同一数据集合，这个事务还未结束时，另外一个事务也<br>访问该同一数据集合，并做了一些DML操作并提交，那么第一个事务再次读取<br>的数据可能就与之前读取的数据不一样，不可重复读发生的条件是事务的隔离<br>级别是READ COMMITTED。事实上之前已经讲解过会读取一个快照，在RC隔离<br>级别下读取的是最新的快照，不可重复读和脏读的区别就是脏读是读到未提<br>交的数据，不可重复读读到的是已经提交的数据，违反一致性要求，可以使<br>用Next-Key Lock算法来避免不可重复读问题<img src="/2020/12/07/MySQL3/21.jpg" alt></p>
<h3 id="MVVC实现原理"><a href="#MVVC实现原理" class="headerlink" title="MVVC实现原理"></a>MVVC实现原理</h3><p>参考 <a href="https://www.imooc.com/article/17290" target="_blank" rel="noopener">https://www.imooc.com/article/17290</a><br>参考 <a href="https://www.jianshu.com/p/8845ddca3b23" target="_blank" rel="noopener">https://www.jianshu.com/p/8845ddca3b23</a><br>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式<br>去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p>
<ul>
<li>当前读 像select lock in share mode(共享锁), select for update<br>;update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当<br>前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能<br>修改当前记录，会对读取的记录进行加锁。</li>
<li>快照读 像不加锁的select操作就是快照读，即不加锁的非阻塞读，快照读<br>的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所<br>以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版<br>本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，<br>避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不<br>一定是数据的最新版本，而有可能是之前的历史版本</li>
</ul>
<p>在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中<br>的3个隐式字段、undo日志和Read View 来实现的<br>InnoDB为每行记录都实现了三个隐藏字段 <img src="/2020/12/07/MySQL3/31.jpg" alt></p>
<ul>
<li>DB_TRX_ID，6字节 插入或更新行的最后一个事务的事务ID，事务编号是自<br>动递增的（我们把它理解为创建版本号，在数据新增或者修改为新数据的时候<br>，记录当前事务ID）</li>
<li>DB_ROLL_PTR，7字节 回滚指针（我们把它理解为删除版本号，数据被删除<br>或记录为旧数据的时候，记录当前事务ID）。我们把这两个事务ID理解为版本号</li>
<li>DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，<br>InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li>undo log undo log中记录的是数据表记录行的多个版本，也就是事务执行<br>过程中的回滚段，其实就是MVCC中的一行原始数据的多个版本镜像数据</li>
<li>read view 主要用来判断当前版本数据的可见性</li>
</ul>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo<br>buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与<br>redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内<br>容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo<br>log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客<br>户端设置了每表一个数据文件也是如此</p>
<h4 id="行更新过程"><a href="#行更新过程" class="headerlink" title="行更新过程"></a>行更新过程</h4><p>接下来看一下事务1对某行记录的更新过程</p>
<ol>
<li>初始数据行 如果这行数据是刚INSERT的，可以认为ID为1，其余两列为<br>NULL <img src="/2020/12/07/MySQL3/38.jpg" alt></li>
<li>更改该行的各字段的值 更改时会先用排他锁锁定该行，记录redo log，<br>把该行修改前的值Copy到undo log，修改当前行的值，填写事务编号，使<br>回滚指针指向undo log中修改前的行  <img src="/2020/12/07/MySQL3/39.jpg" alt></li>
<li>事务2修改该行的值 此时undo log中有两行记录，并且通过回滚指针<br>连在一起 <img src="/2020/12/07/MySQL3/40.jpg" alt></li>
</ol>
<h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>判断当前版本数据项是否可见，实际上也就是内部快照。在innodb 中，创建<br>一个新事务的时候，会将当前系统中的活跃事务列表（trx_sys-&gt;trx_list<br>）创建一个副本（read view），副本中保存的是系统当前不应该被本事务<br>看到的其他事务id列表。当用户在这个事务中要读取该行记录的时候，<br>innodb会将该行当前的版本号与该read view进行比较。具体的算法<br>如下</p>
<ol>
<li>设该行的当前事务id为trx_id_0，read view中最早的事务id为<br>trx_id_1，最迟的事务id为trx_id_2</li>
<li>如果trx_id_0&lt; trx_id_1的话，那么表明该行记录所在的事务已经<br>在本次新事务创建之前就提交了，所以该行记录的当前值是可见的。跳<br>到步骤6</li>
<li>如果trx_id_0&gt;trx_id_2的话，那么表明该行记录所在的事务在本<br>次新事务创建之后才开启，所以该行记录的当前值不可见.跳到步骤5</li>
<li>如果trx_id_1&lt;=trx_id_0&lt;=trx_id_2, 那么表明该行记录所在事<br>务在本次新事务创建的时候处于活动状态，从trx_id_1到trx_id_2进<br>行遍历，如果trx_id_0等于他们之中的某个事务id的话，那么不可见<br>。跳到步骤5</li>
<li>从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的<br>undo-log的版本号，将它赋值该trx_id_0，然后跳到步骤2</li>
<li>将该可见行的值返回</li>
</ol>
<p>注意新建事务(当前事务)与正在内存中commit的事务不在活跃事务链表<br>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">函数：read_view_sees_trx_id。</span><br><span class="line">read_view中保存了当前全局的事务的范围：</span><br><span class="line">【low_limit_id， up_limit_id】</span><br><span class="line">1. 当行记录的事务ID小于当前系统的最小活动id，就是可见的。</span><br><span class="line">　　if (trx_id &lt; view-&gt;up_limit_id) &#123;</span><br><span class="line">　　　　return(TRUE);</span><br><span class="line">　　&#125;</span><br><span class="line">2. 当行记录的事务ID大于当前系统的最大活动id，就是不可见的。</span><br><span class="line">　　if (trx_id &gt;&#x3D; view-&gt;low_limit_id) &#123;</span><br><span class="line">　　　　return(FALSE);</span><br><span class="line">　　&#125;</span><br><span class="line">3. 当行记录的事务ID在活动范围之中时，判断是否在活动链表中，如果</span><br><span class="line">在就不可见，如果不在就是可见的。</span><br><span class="line">　　for (i &#x3D; 0; i &lt; n_ids; i++) &#123;</span><br><span class="line">　　　　trx_id_t view_trx_id</span><br><span class="line">　　　　　　&#x3D; read_view_get_nth_trx_id(view, n_ids - i - 1);</span><br><span class="line">　　　　if (trx_id &lt;&#x3D; view_trx_id) &#123;</span><br><span class="line">　　　　return(trx_id !&#x3D; view_trx_id);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>在RR隔离级别下，数据快照版本是在第一个读请求发起时创建的，之后<br>不会在发生变化，在RC隔离级别下则是在每次读请求都会创建一个快照<br>，也就是每次SELECT都能读取到已经COMMIT的数据，快照是在第一条<br>快照读的语句中生成，而不是在事务开始时创建快照<br><a href="https://zhuanlan.zhihu.com/p/55819387" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55819387</a></p>
<h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>一个事务的更新操作被另一个事务的更新操作覆盖，从而导致数据的不一致，<br>但是目前任何隔离级别下都不会导致数据库理论上的丢失更新</p>
<ol>
<li>事务1将行记录r更新为v1，但是还未提交</li>
<li>与此同时事务2将记录r更新为v2，但是还未提交</li>
<li>事务1提交</li>
<li>事务2提交</li>
</ol>
<p>在当前数据库的任何隔离级别下都不会导致丢失更新问题，但是注意在实际<br>应用中最好不要直接进行UPDATE操作，可能会首先需要检测数据信息，然<br>后再进行UPDATE操作</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>在一个事务结束时（ commit rollback ）或者客户端断开连接时就会释放锁。<br>因为不同锁之间的兼容性关系，在有些时候一个事务的锁需要等待另一个事务中<br>的锁释放它锁占用的资源，这就是阻塞。可以使用innodb_lock_wait_timeout<br>来控制等待时间（默认是50s），innodb_rollback_on_timeout用来设定是否<br>在等待超时时对进行的事务进行回滚操作</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等<br>待现象，解决死锁最简单的方式就是设置超时时间，当两个事务相互等待时当一<br>个事务的等待时间超时其中一个事务就会回滚，另一个事务继续执行，除此还可<br>以采用wait-for-garph方式进行死锁检测 <img src="/2020/12/07/MySQL3/37.jpg" alt><br>死锁的发生有如下条件</p>
<ul>
<li>同一时刻只能有一个事务持有这把锁</li>
<li>其他的事务需要在这个事务释放锁之后才能获取锁，而不可以强行剥夺</li>
<li>当多个事务形成等待环路的时候，即发生死锁</li>
</ul>
<p>wait-for graph要求数据库保存以下两种信息</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，若在这个图中存在回路就代表存在死锁，因此<br>资源间相互发生等待，因此wait-for graph是一种较为主动的死锁检测机制，<br>每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，一般<br>会回滚undo量最小的事务，采用的算法是深度优先算法，并且使用非递归优化</p>
<h4 id="死锁概率"><a href="#死锁概率" class="headerlink" title="死锁概率"></a>死锁概率</h4><p>死锁发生的概率与以下几个因素有关</p>
<ul>
<li>系统中事务的数量越多发生死锁的概率越大</li>
<li>每个事务操作的数量越多发生死锁的概率越大</li>
<li>操作数据的集合越小发生死锁的概率越大</li>
</ul>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>锁升级是指将当前锁的粒度降低，比如数据库可以把一个表中1000个行锁升级<br>为一个页锁，或者将页锁升级为一个表锁。InnoDB存储引擎不存在锁升级的问<br>题</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务会把数据库从一种一致性状态转换为另一种一致性状态，在数据库提交工作<br>时，可以确保要么所有修改都已经保存，要么所有修改都不保存。InnoDB中的存<br>储引擎完全符合ACID的特性，默认隔离级别是RR</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>事务可以分为以下类型</p>
<ul>
<li>扁平事务</li>
<li>带有保存点的扁平事务</li>
<li>链事务</li>
<li>嵌套事务</li>
<li>分布式事务</li>
</ul>
<h4 id="扁平事务"><a href="#扁平事务" class="headerlink" title="扁平事务"></a>扁平事务</h4><p>在扁平事务中，所有的操作都处于同一层次，由BEGIN WORK开始，由COMMIT<br>WORK结束，要么都执行要么都回滚，扁平事务是应用程序成为原子操作的基本<br>组成模块。扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几<br>个步骤提交</p>
<h4 id="带有保存点的事务"><a href="#带有保存点的事务" class="headerlink" title="带有保存点的事务"></a>带有保存点的事务</h4><p>允许事务在执行过程中回滚到同一事务中较早的一个状态，保存点用来通知系<br>统应该记住事务当前的状态，以便当之后发生错误时事务能够回到保存点当时<br>的位置，保存点用SAVE WORK函数建立 <img src="/2020/12/07/MySQL3/22.jpg" alt></p>
<h4 id="链事务"><a href="#链事务" class="headerlink" title="链事务"></a>链事务</h4><p>保存点模式的一种变种，带有保存点的扁平事务，当系统发生崩溃时所有的保<br>存点都会消失，因此其保存点是易失的而非持久的，当恢复时事务需要从开始<br>出重新执行，而不能从最近的一个保存点继续执行。链事务的思想是：在提交<br>一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一<br>个要开始的事务，注意提交事务操作和开始下一个事务操作将合并为一个原<br>子操作。一个事务由多个子事务链式组成 <img src="/2020/12/07/MySQL3/23.jpg" alt></p>
<h4 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h4><p>由一个顶层事务控制各个层次的事务，顶层事务之下嵌套的事务被称为子事务<br>，其控制的是一个局部的变换，可以看成一棵树，注意子事务的提交并不会马<br>上生效，除非其父事务已经提交，所以只有顶层事务提交后所有子事务才会提<br>交。树中任意一个事务的回滚都会引起其所有子事务一起回滚，所以子事务不<br>具有持久性。InnoDB不支持 <img src="/2020/12/07/MySQL3/24.jpg" alt></p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中<br>的不同节点，至少需要访问网络中两个节点的数据库，每个节点的数据库执行<br>的事务操作都是扁平的，如果任何一个操作失败都会导致整个分布式事务回滚</p>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务隔离性由锁实现，原子性、一致性、持久性通过数据库的redo log和undo<br>log来实现，redo log为重做日志，用来保证事务的原子性和持久性，undo<br>log用来保证事务的一致性。redo和undo并不是逆过程，redo 恢复提交事务<br>修改的页操作，而undo回滚行记录到特定版本。redo通常是物理日志，记录<br>页的物理修改操作，undo是逻辑操作根据每行记录进行记录</p>
<ul>
<li>redo log 重做日志，用来保证事务的持久性，基本是按顺序写的。在事务<br>开始时就会产生redo log，逐步写入日志文件，归属于存储引擎</li>
<li>undo log 回滚日志，用来帮助事务回滚及MVV C功能，需要进行随机读写<br>，保存了事务发生之前的一个版本，在事务提交之后 undo log 并不会马上<br>删除，而是放入待清理的链表，purge线程判断是否由其他事务在使用undo<br>段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志<br>空间，归属于存储引擎</li>
<li>binlog 二进制日志 归属于Server层，error log 和realy log 也是在<br>Server层。用于PIT 的恢复以及主从复制环境的建立，二进制文件是在数据<br>库的上层产生，重做日志是在InnoDB存储引擎中产生，不管是什么存储引<br>擎，对数据库进行了修改都会产生二进制日志</li>
</ul>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>所有的数据在落盘之前一定先经过内存，redo log中记录的是实际物理页<br>的修改</p>
<ol>
<li>Buffer Pool先写到Log Buffer，然后每秒写入OS Buffer并调fsync<br>方法刷新到磁盘</li>
<li>Buffer Pool每次提交写入OS Buffer并调fsync方法刷新到磁盘</li>
<li>Buffer Pool每次提交写入OS Buffer，每秒调fsync方法刷新到磁盘</li>
</ol>
<p>重做日志用来实现事务的持久性，其由两部分组成：一是内存中的重做缓冲日<br>志，其是易失的，二是重做日志文件，其是持久的。当事务提交时必须先将事<br>务的所有日志写入到重做日志文件进行持久化，然后COMMIT 操作才算完成。<br>为了确保每次日志都写入重做日志，在每次将重做日志缓冲写入重做日志文<br>件后存储引擎都需要调用一次fsync操作，重做日志缓冲先写入文件系统缓<br>冲，为了确保日志写入磁盘，必须进行fsync操作，fsync的效率取决于磁<br>盘的性能。InnoDB存储引擎允许用户手工设置非持久性的情况发生，即当<br>事务提交时，日志不写入重做日志文件，而是等待一个时间周期后再执行<br>fsync操作，这样可以提高数据库的性能，但是当数据库发生宕机时由于<br>部分日志为刷新会丢失部分数据</p>
<h4 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h4><p>在InnoDB存储引擎中，重做日志都是以512字节进行存储的，这意味着重做日<br>志缓存、重做日志文件都是以块的方式进行保存，称之为重做日志块，每块的<br>大小为512字节。如果一个页中产生的重做日志数量大于512 个字节，就会分<br>割为多个重做日志块进行存储，由于重做日志块的大小和磁盘扇区大小一样<br>，因此重做日志的写入可以保证原子性，不需要doublewrite。<br>每个redo log block由 3 部分组成：日志块头、日志块尾和日志主体。其中<br>日志块头占用 12 字节，日志块尾占用 8 字节，所以每个redo log block<br>的日志主体部分只有492字节 <img src="/2020/12/07/MySQL3/41.jpg" alt></p>
<h4 id="log-group"><a href="#log-group" class="headerlink" title="log group"></a>log group</h4><p>log group为重做日志组，其中有很多重做日志文件，InnoDB实际只有一个<br>log group</p>
<h4 id="重做日志格式"><a href="#重做日志格式" class="headerlink" title="重做日志格式"></a>重做日志格式</h4><p>InnoDB存储引擎的管理是基于页的，故其重做日志格式也是基于页的 <img src="/2020/12/07/MySQL3/42.jpg" alt></p>
<h4 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h4><p>日志序列号，在InnoDB存储引擎中占8个字节，并且单调递增，含义如下</p>
<ul>
<li>重做日志写入的总量</li>
<li>checkpoint的位置</li>
<li>页的版本</li>
</ul>
<p>LSN代表事务写入重做日志的字节总量，例如当前重做日志的LSN为1000，有一个<br>事务T1写入100字节的重做日志，那么LSN就变为1100</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>InnoDB存储引擎在启动时不管上次数据库运行是否正常关闭，都会尝试进行恢复<br>操作。因为redo log记录的是数据页的物理变化，因此恢复的时候速度比逻辑日<br>志（如二进制日志）要快很多。重启 InnoDB 时，checkpoint表示已经完整刷<br>到磁盘上data page上的 LSN，因此恢复时仅需要恢复从checkpoint开始的日<br>志部分。例如，当数据库在上一次checkpoint的 LSN 为 10000 时宕机，且事<br>务是已经提交过的状态。启动数据库时会检查磁盘中数据页的 LSN，如果数据页<br>的LSN小于日志中的 LSN，则会从检查点开始恢复</p>
<h3 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo log"></a>undo log</h3><p>在操作任何数据之前先将数据备份到一个地方，这个备份的地方就是undo log<br>，然后对数据进行修改，如果出现错误或用户执行ROLLBACK语句，系统就会利<br>用unod log中的备份将会数据恢复到事务开始之前的状态。注意undo log是逻<br>辑日志，回滚的时候根据逻辑操作回滚到最初的值，而不是每一个状态都存储<br>一份值，并不是物理页上的一个修改。想一想undo log有必要存到磁盘吗，刚<br>刚需要undo log的场景并没有进行事务的提交，也就是说修改的数据还未写<br>到磁盘，就算发生宕机也没有问题，因为本身就还未进行提交，所以undo<br>log没有必要写入磁盘中</p>
<ol>
<li>当delete一条记录时会在undo log中记录一条对应的insert记录</li>
<li>当insert一条记录时会在undo log中记录一条对应的delete记录</li>
<li>当update一条记录时会在undo log中记录一条对应相反的update记录</li>
</ol>
<p>存放在数据库内部的一个特殊字段中(segment)，这个段称为undo段，位于<br>共享表空间中，注意undo并不是将数据库物理地恢复到执行语句或事物之前<br>的样子，undo是逻辑日志，只是将数据库逻辑地恢复到原来的样子，所有修<br>改都被逻辑取消。除了回滚操作undo的另一个作用就是MVVC，当用户读取一<br>行记录时，若该行记录已经被其他事务占用，当前事务可以通过undo读取之<br>前的行版本信息以实现非锁定读取，最后注意undo log会产生redo log，<br>也就是undo log的产生会伴随redo log的产生，因为undo log 也需要持<br>久性的保护</p>
<h4 id="undo存储管理"><a href="#undo存储管理" class="headerlink" title="undo存储管理"></a>undo存储管理</h4><p>InnoDB存储引擎对undo的管理同样采用段的方式</p>
<h4 id="undo-log格式"><a href="#undo-log格式" class="headerlink" title="undo log格式"></a>undo log格式</h4><p>在InnoDB存储引擎中，undo log分为</p>
<ol>
<li>insert undo log</li>
<li>update undo log</li>
</ol>
<h4 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h4><p>delete和updaet操作可能并不直接删除原有的数据。purge 用于最终完成<br>delete和update，这样设计是因为InnoDB支持MVVC，所以记录不能在事<br>务提交时立即处理，有可能其他事务也在引用这行，若改行已经不被其他<br>事务引用那么可以真正删除</p>
<h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><p>MySQL默认设置下事务都是自动提交的，即执行SQL语句后马上就会执行COMMIT<br>操作，可以通过SET AUTOCOMMIT=0 禁用自动提交</p>
<ol>
<li>START TRANSACTION|BEGIN 显示开启一个事务</li>
<li>COMMIT 提交事务，对数据库永久性修改</li>
<li>ROLLBACK 回滚结束事务，撤销未提交的修改</li>
<li>SAVEPOINT identifier 在事务中创建一个保存点，一个事务可以有多个保存点</li>
<li>RELEASE SAVEPOINT identifier 删除一个保存点</li>
<li>ROLLBACK TO identifier 回滚到标记点</li>
<li>SET TRANSACTION 设置事务的隔离级别</li>
</ol>
<h3 id="隐式提交的SQL语句"><a href="#隐式提交的SQL语句" class="headerlink" title="隐式提交的SQL语句"></a>隐式提交的SQL语句</h3><p>以下这些SQL语句会产生一个隐式的提交操作</p>
<ul>
<li>DDL语句: ALTER DATABASEUPGRADE DATA DIRECTORY NAME,ALTER<br>EVENT, ALTER PROCEDURE, ALTER TABLE, ALTER VIEW，CREATE<br>DATABASE, CREATE EVENT, CREATE INDEX, CREATE PROCEDURE,<br>CREATE TABLE, CREATE TRIGGER, CREATE VIEW,DROP DATABASE,<br>DROP EVENT, DROP INDEX, DROP PROCEDURE，DROP TABLE, DROP<br>TRIGGER, DROP VIEW, RENAME TABLE，TRUNCATE TABLE</li>
<li>用来隐式地修改 MySQL架构的操作: CREATE USER、 DROP USER、<br>GRANT 、RENAME USER、 REVOKE、 SET PASSWORD</li>
<li>管理语句: ANALYZE TABLE、 CACHE INDEX、 CHECK TABLE、 LOAD<br>INDEX  INTO CACHE、 OPTIMIZE TABLE、 REPAIR TABLE</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/07/MySQL3/">https://skysea-gaoming.github.io/2020/12/07/MySQL3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataBase/">DataBase</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/10/ComputerNetwork2/"><i class="fa fa-chevron-left">  </i><span>计算机网络2</span></a></div><div class="next-post pull-right"><a href="/2020/11/24/Mysql2/"><span>MySQL2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/07/MySQL3/';
  this.page.identifier = '2020/12/07/MySQL3/';
  this.page.title = 'MySQL3';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>