<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java并发总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java并发总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题总结"><span class="toc-number">2.</span> <span class="toc-text">面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发编程三要素是什么？"><span class="toc-number">2.1.</span> <span class="toc-text">并发编程三要素是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全问题有哪些？如何解决？"><span class="toc-number">2.2.</span> <span class="toc-text">线程安全问题有哪些？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程和进程？"><span class="toc-number">2.3.</span> <span class="toc-text">什么是线程和进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程和进程有什么区别？"><span class="toc-number">2.4.</span> <span class="toc-text">线程和进程有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步的区别？"><span class="toc-number">2.5.</span> <span class="toc-text">同步和异步的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行和并发？"><span class="toc-number">2.6.</span> <span class="toc-text">并行和并发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区是什么？"><span class="toc-number">2.7.</span> <span class="toc-text">临界区是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是多线程，多线程的优劣？"><span class="toc-number">2.8.</span> <span class="toc-text">什么是多线程，多线程的优劣？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是上下文切换？"><span class="toc-number">2.9.</span> <span class="toc-text">什么是上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程和用户线程有什么区别？"><span class="toc-number">2.10.</span> <span class="toc-text">守护线程和用户线程有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中活锁和死锁有什么区别？"><span class="toc-number">2.11.</span> <span class="toc-text">Java中活锁和死锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么检测一个线程是否拥有锁？"><span class="toc-number">2.12.</span> <span class="toc-text">怎么检测一个线程是否拥有锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中死锁、活锁和饥饿有什么区别？"><span class="toc-number">2.13.</span> <span class="toc-text">Java中死锁、活锁和饥饿有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发级别分为几类？"><span class="toc-number">2.14.</span> <span class="toc-text">并发级别分为几类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无障碍是什么？"><span class="toc-number">2.15.</span> <span class="toc-text">无障碍是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无锁是什么？"><span class="toc-number">2.16.</span> <span class="toc-text">无锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无等待是什么？"><span class="toc-number">2.17.</span> <span class="toc-text">无等待是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程有哪几种方式？"><span class="toc-number">2.18.</span> <span class="toc-text">创建线程有哪几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable和callable有什么区别？"><span class="toc-number">2.19.</span> <span class="toc-text">runnable和callable有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的run-和start-有什么区别？"><span class="toc-number">2.20.</span> <span class="toc-text">线程的run()和start()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Callable和Future？"><span class="toc-number">2.21.</span> <span class="toc-text">什么是Callable和Future？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future接口的具体内容？"><span class="toc-number">2.22.</span> <span class="toc-text">Future接口的具体内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable接口的具体内容是什么？"><span class="toc-number">2.23.</span> <span class="toc-text">Callable接口的具体内容是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask是什么？"><span class="toc-number">2.24.</span> <span class="toc-text">FutureTask是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用Runnable还是Thread？"><span class="toc-number">2.25.</span> <span class="toc-text">用Runnable还是Thread？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的生命周期是怎样的？"><span class="toc-number">2.26.</span> <span class="toc-text">线程的生命周期是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中用到的线程调度算法是什么？"><span class="toc-number">2.27.</span> <span class="toc-text">Java中用到的线程调度算法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的调度策略是什么？"><span class="toc-number">2.28.</span> <span class="toc-text">线程的调度策略是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程调度器和时间分片？"><span class="toc-number">2.29.</span> <span class="toc-text">什么是线程调度器和时间分片？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何停止一个正在运行的线程？"><span class="toc-number">2.30.</span> <span class="toc-text">如何停止一个正在运行的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义标志与中断标志的区别？"><span class="toc-number">2.31.</span> <span class="toc-text">自定义标志与中断标志的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目标线程与当前线程的区别？"><span class="toc-number">2.32.</span> <span class="toc-text">目标线程与当前线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中interrupted和isInterrupted方法的区别？"><span class="toc-number">2.33.</span> <span class="toc-text">Java中interrupted和isInterrupted方法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存一致性问题是什么？"><span class="toc-number">2.34.</span> <span class="toc-text">缓存一致性问题是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存不一致的根源是什么？"><span class="toc-number">2.35.</span> <span class="toc-text">缓存不一致的根源是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存一致性协议是什么？"><span class="toc-number">2.36.</span> <span class="toc-text">缓存一致性协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存一致性协议有哪些？"><span class="toc-number">2.37.</span> <span class="toc-text">缓存一致性协议有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存模型的具体内容？"><span class="toc-number">2.38.</span> <span class="toc-text">Java内存模型的具体内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性是什么？"><span class="toc-number">2.39.</span> <span class="toc-text">原子性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性是什么？"><span class="toc-number">2.40.</span> <span class="toc-text">可见性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序性是什么？"><span class="toc-number">2.41.</span> <span class="toc-text">有序性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令重排的规则是什么？"><span class="toc-number">2.42.</span> <span class="toc-text">指令重排的规则是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程同步？"><span class="toc-number">2.43.</span> <span class="toc-text">什么是线程同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步的实现有哪些方式？"><span class="toc-number">2.44.</span> <span class="toc-text">同步的实现有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock是什么？"><span class="toc-number">2.45.</span> <span class="toc-text">ReentrantLock是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重入锁的中断响应是什么？"><span class="toc-number">2.46.</span> <span class="toc-text">重入锁的中断响应是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重入锁申请等待限时机制？"><span class="toc-number">2.47.</span> <span class="toc-text">重入锁申请等待限时机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized是什么？"><span class="toc-number">2.48.</span> <span class="toc-text">synchronized是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与线程同步以及线程调度相关的方法有哪些？"><span class="toc-number">2.49.</span> <span class="toc-text">与线程同步以及线程调度相关的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平锁与非公平锁的区别？"><span class="toc-number">2.50.</span> <span class="toc-text">公平锁与非公平锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition是什么？"><span class="toc-number">2.51.</span> <span class="toc-text">Condition是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java多线程中调用wait-和sleep-方法有什么不同？"><span class="toc-number">2.52.</span> <span class="toc-text">Java多线程中调用wait()和sleep()方法有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么wait方法要在循环中调用？"><span class="toc-number">2.53.</span> <span class="toc-text">为什么wait方法要在循环中调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么wait和notify方法要在同步块中调用？"><span class="toc-number">2.54.</span> <span class="toc-text">为什么wait和notify方法要在同步块中调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么wait-notify和notifyAll这些方法不在thread类里面？"><span class="toc-number">2.55.</span> <span class="toc-text">为什么wait, notify和notifyAll这些方法不在thread类里面？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join和yield的区别？"><span class="toc-number">2.56.</span> <span class="toc-text">join和yield的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread类中的start-和run-方法有什么区别？"><span class="toc-number">2.57.</span> <span class="toc-text">Thread类中的start()和run()方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步和线程互斥的区别？"><span class="toc-number">2.58.</span> <span class="toc-text">线程同步和线程互斥的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监视器-Monitor-内部，是如何做线程同步的？"><span class="toc-number">2.59.</span> <span class="toc-text">监视器(Monitor)内部，是如何做线程同步的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#as-if-serial规则和happens-before规则的区别？"><span class="toc-number">2.60.</span> <span class="toc-text">as-if-serial规则和happens-before规则的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发工具有哪些？"><span class="toc-number">2.61.</span> <span class="toc-text">并发工具有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore是什么？"><span class="toc-number">2.62.</span> <span class="toc-text">Semaphore是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadWriteLock是什么？"><span class="toc-number">2.63.</span> <span class="toc-text">ReadWriteLock是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch是什么？"><span class="toc-number">2.64.</span> <span class="toc-text">CountDownLatch是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CycliBarrier是什么？"><span class="toc-number">2.65.</span> <span class="toc-text">CycliBarrier是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LockSupport是什么？"><span class="toc-number">2.66.</span> <span class="toc-text">LockSupport是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存间交互操作有哪些？"><span class="toc-number">2.67.</span> <span class="toc-text">内存间交互操作有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的volatile变量是什么？"><span class="toc-number">2.68.</span> <span class="toc-text">Java中的volatile变量是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile如何保证可见性？"><span class="toc-number">2.69.</span> <span class="toc-text">volatile如何保证可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile如何禁止指令重排序？"><span class="toc-number">2.70.</span> <span class="toc-text">volatile如何禁止指令重排序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile能保证原子性吗？"><span class="toc-number">2.71.</span> <span class="toc-text">volatile能保证原子性吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized和volatile关键字的区别？"><span class="toc-number">2.72.</span> <span class="toc-text">synchronized和volatile关键字的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无锁是什么？-1"><span class="toc-number">2.73.</span> <span class="toc-text">无锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS是什么？"><span class="toc-number">2.74.</span> <span class="toc-text">CAS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS算法如何实现？"><span class="toc-number">2.75.</span> <span class="toc-text">CAS算法如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在Java-API中有哪些原子类？"><span class="toc-number">2.76.</span> <span class="toc-text">在Java API中有哪些原子类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic的原理？"><span class="toc-number">2.77.</span> <span class="toc-text">atomic的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS的原理？"><span class="toc-number">2.78.</span> <span class="toc-text">CAS的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe类的作用？"><span class="toc-number">2.79.</span> <span class="toc-text">Unsafe类的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS的缺点是什么？"><span class="toc-number">2.80.</span> <span class="toc-text">CAS的缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicReference是什么？"><span class="toc-number">2.81.</span> <span class="toc-text">AtomicReference是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA问题是什么？"><span class="toc-number">2.82.</span> <span class="toc-text">ABA问题是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决ABA问题？"><span class="toc-number">2.83.</span> <span class="toc-text">如何解决ABA问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS是什么？"><span class="toc-number">2.84.</span> <span class="toc-text">AQS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS的原理是什么？"><span class="toc-number">2.85.</span> <span class="toc-text">AQS的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS如何实现？"><span class="toc-number">2.86.</span> <span class="toc-text">AQS如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是阻塞队列？阻塞队列的实现原理是什么？"><span class="toc-number">2.87.</span> <span class="toc-text">什么是阻塞队列？阻塞队列的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义阻塞队列如何实现生产者消费者模型？"><span class="toc-number">2.88.</span> <span class="toc-text">自定义阻塞队列如何实现生产者消费者模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的阻塞队列有哪些？"><span class="toc-number">2.89.</span> <span class="toc-text">常用的阻塞队列有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的作用是什么？"><span class="toc-number">2.90.</span> <span class="toc-text">线程池的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池有哪几种创建方式？"><span class="toc-number">2.91.</span> <span class="toc-text">线程池有哪几种创建方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池有什么优点？"><span class="toc-number">2.92.</span> <span class="toc-text">线程池有什么优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拒绝策略有哪些？"><span class="toc-number">2.93.</span> <span class="toc-text">拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池都有哪些状态？"><span class="toc-number">2.94.</span> <span class="toc-text">线程池都有哪些状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么创建线程池？"><span class="toc-number">2.95.</span> <span class="toc-text">怎么创建线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor的构造参数是什么？"><span class="toc-number">2.96.</span> <span class="toc-text">ThreadPoolExecutor的构造参数是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加一个任务时的情况？"><span class="toc-number">2.97.</span> <span class="toc-text">添加一个任务时的情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor和Executors的区别？"><span class="toc-number">2.98.</span> <span class="toc-text">Executor和Executors的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExecutorService是什么？"><span class="toc-number">2.99.</span> <span class="toc-text">ExecutorService是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractExecutorService是什么？"><span class="toc-number">2.100.</span> <span class="toc-text">AbstractExecutorService是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor中的execute如何执行？"><span class="toc-number">2.101.</span> <span class="toc-text">ThreadPoolExecutor中的execute如何执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addWorker的作用？"><span class="toc-number">2.102.</span> <span class="toc-text">addWorker的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runWorker方法的作用？"><span class="toc-number">2.103.</span> <span class="toc-text">runWorker方法的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadFactory是什么？"><span class="toc-number">2.104.</span> <span class="toc-text">ThreadFactory是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池中submit-和execute-方法有什么区别？"><span class="toc-number">2.105.</span> <span class="toc-text">线程池中submit()和execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executors和ThreaPoolExecutor创建线程池的区别？"><span class="toc-number">2.106.</span> <span class="toc-text">Executors和ThreaPoolExecutor创建线程池的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何合理配置线程池？"><span class="toc-number">2.107.</span> <span class="toc-text">如何合理配置线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程组是什么？"><span class="toc-number">2.108.</span> <span class="toc-text">线程组是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池和线程组的区别？"><span class="toc-number">2.109.</span> <span class="toc-text">线程池和线程组的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程组为什么不推荐使用？"><span class="toc-number">2.110.</span> <span class="toc-text">线程组为什么不推荐使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ThreadLocal变量？"><span class="toc-number">2.111.</span> <span class="toc-text">什么是ThreadLocal变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocalMap是什么？"><span class="toc-number">2.112.</span> <span class="toc-text">ThreadLocalMap是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁优化有几种方式？"><span class="toc-number">2.113.</span> <span class="toc-text">锁优化有几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM如何优化锁？"><span class="toc-number">2.114.</span> <span class="toc-text">JVM如何优化锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized锁升级的原理是什么？"><span class="toc-number">2.115.</span> <span class="toc-text">synchronized锁升级的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁是什么？"><span class="toc-number">2.116.</span> <span class="toc-text">死锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁的四个必要条件是什么？"><span class="toc-number">2.117.</span> <span class="toc-text">死锁的四个必要条件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何定位死锁？"><span class="toc-number">2.118.</span> <span class="toc-text">如何定位死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决死锁？"><span class="toc-number">2.119.</span> <span class="toc-text">如何解决死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不变模式是什么？"><span class="toc-number">2.120.</span> <span class="toc-text">不变模式是什么？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java并发总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/27/Java并发总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xiaowangbangzhu&#x2F;p&#x2F;10443289.html</span><br><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;71355?type&#x3D;post&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;1</span><br><span class="line">&amp;channel&#x3D;-1&amp;source_id&#x3D;search_post_nctrack</span><br><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;334?type&#x3D;all&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;1&amp;</span><br><span class="line">channel&#x3D;-1&amp;source_id&#x3D;search_all_nctrack</span><br></pre></td></tr></table></figure>
<h2 id="面试题总结"><a href="#面试题总结" class="headerlink" title="面试题总结"></a>面试题总结</h2><h3 id="并发编程三要素是什么？"><a href="#并发编程三要素是什么？" class="headerlink" title="并发编程三要素是什么？"></a>并发编程三要素是什么？</h3><ol>
<li>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要<br>么全部执行成功要么全部执行失败</li>
<li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到<br>（synchronized,volatile）</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进<br>行重排序）</li>
</ol>
<h3 id="线程安全问题有哪些？如何解决？"><a href="#线程安全问题有哪些？如何解决？" class="headerlink" title="线程安全问题有哪些？如何解决？"></a>线程安全问题有哪些？如何解决？</h3><ol>
<li>线程切换带来的原子性问题 JDK Atomic开头的原子类、synchronized、LOCK</li>
<li>缓存导致的可见性问题 synchronized、volatile、LOCK</li>
<li>编译优化带来的有序性问题 Happens-Before规则、as-if-serial规则<br>和内存屏障</li>
</ol>
<h3 id="什么是线程和进程？"><a href="#什么是线程和进程？" class="headerlink" title="什么是线程和进程？"></a>什么是线程和进程？</h3><ol>
<li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是<br>进程中的实际运作单位</li>
<li>进程是一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空<br>间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就<br>是一个进程</li>
</ol>
<h3 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h3><ol>
<li>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调<br>度和执行的基本单位</li>
<li>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之<br>间的切换会有较大的开销，线程可以看做轻量级的进程，同一类线程共享代<br>码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线<br>程之间切换的开销小</li>
<li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是<br>多条线（线程）共同完成的</li>
<li>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的<br>地址空间和资源是相互独立的</li>
<li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但<br>是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮</li>
<li>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。<br>但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程<br>执行控制，两者均可并发执行</li>
</ol>
<h3 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h3><p>同步和异步通常用来形容一次方法调用。同步方法一旦开始，调用者必须等<br>到方法调用返回后才能继续后面的操作。异步方法更像一个消息传递，一旦<br>开始就会立即返回，调用者就会执行后面的操作</p>
<h3 id="并行和并发？"><a href="#并行和并发？" class="headerlink" title="并行和并发？"></a>并行和并发？</h3><ol>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，<br>从逻辑上来看那些任务是同时执行</li>
<li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真<br>正意义上的“同时进行”</li>
<li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线<br>程执行所以不存在线程不安全情况，也就不存在临界区的问题</li>
</ol>
<h3 id="临界区是什么？"><a href="#临界区是什么？" class="headerlink" title="临界区是什么？"></a>临界区是什么？</h3><p>临界区用来表示一种公共资源或者说是共享资源，多个线程都可以使用这个<br>资源，但是在一个时刻只有一个线程能够使用这个资源，其余线程都要等待</p>
<h3 id="什么是多线程，多线程的优劣？"><a href="#什么是多线程，多线程的优劣？" class="headerlink" title="什么是多线程，多线程的优劣？"></a>什么是多线程，多线程的优劣？</h3><p>多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同<br>的线程来执行不同的任务</p>
<ol>
<li>优势 可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的<br>时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效<br>率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</li>
<li>劣势 线程也是程序，所以线程需要占用内存，线程越多占用内存也越<br>多，多线程需要协调和管理，所以需要 CPU 时间跟踪线程，线程之间对<br>共享资源的访问会相互影响，必须解决竞用共享资源的问题</li>
</ol>
<h3 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h3><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态<br>，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存<br>到再加载的过程就是一次上下文切换</p>
<h3 id="守护线程和用户线程有什么区别？"><a href="#守护线程和用户线程有什么区别？" class="headerlink" title="守护线程和用户线程有什么区别？"></a>守护线程和用户线程有什么区别？</h3><ol>
<li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、<br>连接网络的子线程等都是用户线程</li>
<li>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守<br>护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，<br>守护线程会随 JVM 一起结束工作</li>
</ol>
<p>注意如下</p>
<ol>
<li>setDaemon(true)必须在start()方法前执行，否则会抛出异常</li>
<li>在守护线程中产生的新线程也是守护线程</li>
<li>不要把重要的任务放在守护线程，比如读写操作或者计算逻辑</li>
</ol>
<h3 id="Java中活锁和死锁有什么区别？"><a href="#Java中活锁和死锁有什么区别？" class="headerlink" title="Java中活锁和死锁有什么区别？"></a>Java中活锁和死锁有什么区别？</h3><p>不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊<br>的饥饿，活锁和死锁的主要区别是前者 进程的状态可以改变但是却不能继续执行</p>
<h3 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h3><p>在java.lang.Thread中有一个方法叫holdsLock()，它返回true当且仅当当前线程<br>拥有某个具体对象的锁</p>
<h3 id="Java中死锁、活锁和饥饿有什么区别？"><a href="#Java中死锁、活锁和饥饿有什么区别？" class="headerlink" title="Java中死锁、活锁和饥饿有什么区别？"></a>Java中死锁、活锁和饥饿有什么区别？</h3><p>死锁就是多个线程相互竞争资源而造成的彼此阻塞，饥饿是指一个或多个线<br>程因为种种原因无法获得所需资源，活锁就是获得资源但还未加上锁时就又<br>将资源释放</p>
<h3 id="并发级别分为几类？"><a href="#并发级别分为几类？" class="headerlink" title="并发级别分为几类？"></a>并发级别分为几类？</h3><ol>
<li>阻塞</li>
<li>无饥饿</li>
<li>无障碍</li>
<li>无锁</li>
<li>无等待 </li>
</ol>
<h3 id="无障碍是什么？"><a href="#无障碍是什么？" class="headerlink" title="无障碍是什么？"></a>无障碍是什么？</h3><p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍执行，那么不会因<br>为临界区的问题导致一方被挂起，也就是可以共同修改数据，可是这样的<br>话数据就可能出问题，对于无障碍线程来说一旦出现这种情况就会对所做<br>的修改进行回滚，确保数据安全，如果没有数据竞争发生那么就很顺利。<br>如果说阻塞的控制方式是悲观策略，系统认为两个线程有可能发生冲突因<br>此以保护数据为第一优先级，那么非阻塞调度就是乐观策略，认为两个线<br>程不会发生冲突，但是一旦检测到冲突就会回滚。一种可行的无障碍实现<br>可以依赖一个一致性标记来实现，线程在操作之前先读取这个标记，在操<br>作完成后再次读取这个标记，如果两者一致说明资源访问没有冲突，如果<br>不一致说明则需要重试操作</p>
<h3 id="无锁是什么？"><a href="#无锁是什么？" class="headerlink" title="无锁是什么？"></a>无锁是什么？</h3><p>无锁的并行都是无障碍的，在无锁的情况下每个线程都尝试对临界区进行<br>访问，但是无锁的并发保证必然有一个线程能够在有限步完成操作离开临<br>界区。实际上每个线程都会读取一个数据副本互不干涉</p>
<h3 id="无等待是什么？"><a href="#无等待是什么？" class="headerlink" title="无等待是什么？"></a>无等待是什么？</h3><p>无锁只要求有一个线程在有限步内完成操作，而无等待在无锁的基础上更<br>进一步扩展，要求所有线程都要在有限步内完成。一种无等待结构是RCU，<br>基本思想是对数据的读不加控制，所有的读线程都是无等待的，在写数据<br>的时候先取得数据的副本，然后只修改副本，修改完成后回写数据。这里<br>我觉得应该没有用到一致性标记</p>
<h3 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h3><p>创建线程有四种方式</p>
<ol>
<li>继承Thread类 这个子类需要重写run方法，一个子类的实例可以被分配<br>空间并执行start方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> minPrime;</span><br><span class="line">         PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">             <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">              . . .</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ..</span><br><span class="line">     PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">     p.start();</span><br></pre></td></tr></table></figure></li>
<li>实现Runnable接口 这个类中实现run方法。创建这个类的实例并作为参数传<br>递给Thread类然后Thread类执行start方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> minPrime;</span><br><span class="line">         PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">             <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">              . . .</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//由此可以看出多个Thread实例可以共用一个target</span></span><br><span class="line">     PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line">     <span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure></li>
<li>实现Callable接口 但是Thread的构造方法中并没有提供Thread<br>(Callable callabe) 类型的方法，需要借助另一个类FutureTask<br>类，这个类实现了RunnableFuture 接口，而这个RunnableFuture<br>接口继承了Runnable 接口和Future 接口，所以这个 FutureTask<br>类的对象是可以作为参数作为 Thread(Runnable runnable) 构造<br>方法的参数的。而FutureTask的构造方法又提供通过传入Callable<br>对象作为参数的形式：FutureTask(Callable callable) 。而其<br>run 方法会调用传入的 Callable对象的 call 方法，其本质上<br>还是通过new Thread(Runnable runnable)</li>
</ol>
<ul>
<li>创建实现Callable接口的类myCallable</li>
<li>以myCallable为参数创建FutureTask对象</li>
<li>将FutureTask作为参数创建Thread对象</li>
<li>调用线程对象的start()方法</li>
</ul>
<ol start="4">
<li>使用Executors工具类创建线程池</li>
</ol>
<h3 id="runnable和callable有什么区别？"><a href="#runnable和callable有什么区别？" class="headerlink" title="runnable和callable有什么区别？"></a>runnable和callable有什么区别？</h3><ol>
<li>相同点 都是接口，都可以编写多线程程序，都采用start()启动线程</li>
<li>Runnable接口run方法无返回值，Callable接口call方法有返回值，<br>是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li>
<li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理，<br>Callable接口call方法允许抛出异常，可以获取异常信息</li>
<li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到<br>，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞</li>
</ol>
<h3 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h3><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。<br>run() 可以重复调用，而 start() 只能调用一次</p>
<h3 id="什么是Callable和Future？"><a href="#什么是Callable和Future？" class="headerlink" title="什么是Callable和Future？"></a>什么是Callable和Future？</h3><ol>
<li>Callable 接口类似于Runnable，但是Runnable不会返回结果，并且<br>无法抛出返回结果的异常，而Callable被线程执行后，可以返回值，这个<br>返回值可以被Future拿到，Future可以拿到异步执行任务的返回值</li>
<li>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果<br>。所以说 Callable用于产生结果，Future用于获取结果</li>
</ol>
<h3 id="Future接口的具体内容？"><a href="#Future接口的具体内容？" class="headerlink" title="Future接口的具体内容？"></a>Future接口的具体内容？</h3><p>Future接口提供了一些方法来获取向线程池提交的任务的执行状态和结果<br>的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     尝试取消执行提交的对应任务，如果对应任务已经执行完成或者已经被取消</span></span><br><span class="line"><span class="comment">     或者是其他原因不能被取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果提交的对应任务还没有完全执行完成之前就被取消了，那么方法会返回</span></span><br><span class="line"><span class="comment">     true，否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 返回任务是否完成：包括下面几种情况：</span></span><br><span class="line"><span class="comment">     * 1、任务正常执行完成</span></span><br><span class="line"><span class="comment">     * 2、执行过程发生异常</span></span><br><span class="line"><span class="comment">     * 3、任务被取消</span></span><br><span class="line"><span class="comment">     * 上面几种情况发生，方法均会返回 true，</span></span><br><span class="line"><span class="comment">     * 如果任务正在执行，或者还未执行，那么方法返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 阻塞调用该方法的线程，直到提交的对应任务执行完成之后，</span></span><br><span class="line"><span class="comment">     * 方法会返回一个泛型结果对象表示任务执行的结果，</span></span><br><span class="line"><span class="comment">     * 如果提交的任务是一个 Callable 类型的对象，那么返回 Callable 对象的</span></span><br><span class="line"><span class="comment">     call 方法的返回值，</span></span><br><span class="line"><span class="comment">     * 如果提交的任务是一个 Runnable 类型的对象，那么返回 Runnable 对象的</span></span><br><span class="line"><span class="comment">     run 方法的返回值，即为 null。</span></span><br><span class="line"><span class="comment">     * 如果在调用线程阻塞的过程中发生了中断，那么方法抛出 InterruptedException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callable接口的具体内容是什么？"><a href="#Callable接口的具体内容是什么？" class="headerlink" title="Callable接口的具体内容是什么？"></a>Callable接口的具体内容是什么？</h3><p>这个接口提供了一个call方法，并且这个方法提供了一个返回值作为任务<br>的执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 向线程池中提交一个新的 Callable 类型的任务，提交之后会对任务对象进行包装</span></span><br><span class="line">        Future&lt;String&gt; task = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="comment">// 复写 call() 方法，线程池中线程最终会调用 call() 方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 执行线程休眠 5 秒钟</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 task.get() 获取执行结果，</span></span><br><span class="line">            <span class="comment">// 这里即为获取上述代码中submit方法提交的Callable中call()方法的返回值，</span></span><br><span class="line">            <span class="comment">// 该方法会阻塞当前调用线程，直到任务执行完成后返回</span></span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"方法获取任务结果所用时间："</span> + </span><br><span class="line">        	(endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FutureTask是什么？"><a href="#FutureTask是什么？" class="headerlink" title="FutureTask是什么？"></a>FutureTask是什么？</h3><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个<br>Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获<br>取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才<br>能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask对<br>象可以对调用了 Callable 和 Runnable 的对象进行包装，由于<br>FutureTask 也是Runnable 接口的实现类，所以 FutureTask<br>也可以放入线程池中</p>
<h3 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h3><p>Java 不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他<br>类，当然是调用 Runnable接口。注意一点，有些博客会说Runnable更容易<br>实现资源共享，能多个线程同时处理一个资源，事实上忽视Thread本身也<br>可以当成一个Runnable对象作为参数传给Thread，只是一般不这样写</p>
<h3 id="线程的生命周期是怎样的？"><a href="#线程的生命周期是怎样的？" class="headerlink" title="线程的生命周期是怎样的？"></a>线程的生命周期是怎样的？</h3><ol>
<li>新建：指我们使用关键字 new 新建了一个线程，状态是NEW</li>
<li>运行状态：这个状态可以分成两个部分：可运行状态（就绪状态）、正在<br>运行状态。当线程对象调用了start()方法时，其就处于可运行状态（注意这<br>里是可运行状态），当线程处于可运行状态并且得到了CPU资源时，线程才进<br>入正在运行状态。也就是说你对一个线程调用start()方法只是提醒线程调度<br>器这个线程可以被执行，但是到底执不执行还得看线程调度器的调度结果，<br>如果正在执行就是Runnable状态</li>
<li>阻塞 处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，<br>停止执行，此时进入阻塞状态，直到其进入到就绪状态。分为三种</li>
</ol>
<ul>
<li>等待阻塞：运行状态中的线程执行wait()方法，JVM会把该线程放入等待<br>队列(waitting queue)中，使本线程进入到等待阻塞状态。就是WAITING<br>状态</li>
<li>同步阻塞：线程在获取 synchronized同步锁失败(因为锁被其它线程所占<br>用)，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态</li>
<li>其他阻塞: 通过调用线程的 sleep()或 join()或发出了I/O请求时，线程<br>会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或<br>者I/O处理完毕时，线程重新转入就绪状态，就是TIMED_WAITING</li>
</ul>
<ol start="4">
<li>死亡 不可以对一个已经死亡的线程再次调用start方法，就是TERMINATED</li>
</ol>
<ul>
<li>run方法正常结束</li>
<li>线程抛出一个未捕获的异常Exception或error</li>
<li>直接调用线程的stop方法来结束一个线程，一般不用</li>
</ul>
<h3 id="Java中用到的线程调度算法是什么？"><a href="#Java中用到的线程调度算法是什么？" class="headerlink" title="Java中用到的线程调度算法是什么？"></a>Java中用到的线程调度算法是什么？</h3><p>分时调度模型和抢占式调度模型</p>
<ol>
<li>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每<br>个线程占用的 CPU 的时间片这个也比较好理解</li>
<li>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程<br>占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使<br>其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。Thread<br>类提供的setPriority(int newPriority) 方法来设置线程的优先级，线程<br>的优先级越高，其越容易得到 CPU 资源</li>
</ol>
<h3 id="线程的调度策略是什么？"><a href="#线程的调度策略是什么？" class="headerlink" title="线程的调度策略是什么？"></a>线程的调度策略是什么？</h3><p>线程调度器选择优先级最高的线程运行，但是如果发生以下情况，就会终止线<br>程的运行</p>
<ol>
<li>线程体中调用了 yield 方法让出了对 cpu 的占用权利</li>
<li>线程体中调用了 sleep 方法使线程进入睡眠状态</li>
<li>线程由于 IO 操作受到阻塞</li>
<li>另外一个更高优先级线程出现</li>
<li>在支持时间片的系统中，该线程的时间片用完</li>
</ol>
<h3 id="什么是线程调度器和时间分片？"><a href="#什么是线程调度器和时间分片？" class="headerlink" title="什么是线程调度器和时间分片？"></a>什么是线程调度器和时间分片？</h3><ol>
<li>线程调度器是一个操作系统服务，它负责为 Runnable状态的线程分配CPU<br>时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现</li>
<li>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分<br>配 CPU 时间可以基于线程优先级或者线程等待的时间</li>
</ol>
<h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><ol>
<li>使用退出标志，使线程正常退出，也就是run方法正常结束<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span>(done)</span><br><span class="line">		&#123;</span><br><span class="line">			...</span><br><span class="line">			flag=<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stop方法强行终止，但是不推荐这个方法</li>
<li>使用interrupt方法中断线程</li>
</ol>
<ul>
<li>Thread.interrupt() 实例方法，设置当前中断标记为true</li>
<li>Thread.isInterrupted() 实例方法，检测当前的中断标记</li>
<li>Thread.interrupted() 静态方法，检测当前的中断标记，然后重置中断标记为false</li>
<li>Thread.currentThread() 静态方法，返回执行当前代码的线程对象引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Thread.currentThread().isInterrupted() == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*任务完成*/</span>) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// do something ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="自定义标志与中断标志的区别？"><a href="#自定义标志与中断标志的区别？" class="headerlink" title="自定义标志与中断标志的区别？"></a>自定义标志与中断标志的区别？</h3><p>调用innterrupt 仅仅在线程中打一个标记，并不会立刻停止线程，本质还是<br>通过boolean 标志来控制线程的结束。不过要注意，当调用Object类的wait<br>方法或者线程类的 join sleep 等方法时，如果当前线程已经中断（中断标<br>志标记为true），调用以上那些方法时将会抛出一个异常，同时清除线程的<br>中断标志，抛出InterruptedException异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; Thread.currentThread().isInterrupted() == <span class="keyword">false</span>; </span><br><span class="line">            	i++) &#123;</span><br><span class="line">                <span class="comment">// 如果 i 大于 5 则设置当前线程中断标志为 true，</span></span><br><span class="line">                <span class="comment">// 在此之后 Thread.currentThread().isInterrupted() 方法返回 true</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"i: "</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 在抛出异常的时候会设置当前线程中断标志为 false，</span></span><br><span class="line">                <span class="comment">// 在此之后 Thread.currentThread().isInterrupted() 方法返回 false</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> ; <span class="comment">// 防止死循环，在捕货异常时直接返回结束 run 方法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="目标线程与当前线程的区别？"><a href="#目标线程与当前线程的区别？" class="headerlink" title="目标线程与当前线程的区别？"></a>目标线程与当前线程的区别？</h3><p>目标线程是调用该方法的线程对象所对应的线程，这个线程有可能并不是当<br>前线程，比如在线程A中调用线程B的方法，这个时候线程A就是当前线程，<br>线程B就是目标线程</p>
<h3 id="Java中interrupted和isInterrupted方法的区别？"><a href="#Java中interrupted和isInterrupted方法的区别？" class="headerlink" title="Java中interrupted和isInterrupted方法的区别？"></a>Java中interrupted和isInterrupted方法的区别？</h3><ol>
<li>前者会将中断状态清除而后者不会。 Java多线程的中断机制是用内部标识<br>来实现的</li>
<li>调用实例方法interrupt()中断一个目标线程就会设置中断标识为true，<br>调用静态方法interrupted()来检查当前线程中断状态时，中断状态会被清<br>零</li>
<li>非静态方法isInterrupted()用来查询目标线程中断状态并且不会改变<br>中断状态标识。简单的说就是任何抛出InterruptedException异常的方法<br>都会将中断状态清零。无论如何，一个线程的中断状态有可能被其它线程调<br>用中断来改变，比如调用sleep wait join方法时如果中断了就会抛出异<br>常并清除中断</li>
</ol>
<h3 id="缓存一致性问题是什么？"><a href="#缓存一致性问题是什么？" class="headerlink" title="缓存一致性问题是什么？"></a>缓存一致性问题是什么？</h3><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以使用<br>高速缓存作为缓冲：将运算需要的数据复制到缓存中，让运算快速进行，运<br>算结束后再从缓存同步到内存之中。当高速缓存引入了一个问题：缓存一致<br>性。在多路处理器系统中每个处理器都有自己的高速缓存，而它们又共享同<br>一主内存，这种系统称为共享内存多核系统，当多个处理器的运算任务都<br>涉及同一块主内存区域时，将可能导致各自的内存数据不一致</p>
<h3 id="缓存不一致的根源是什么？"><a href="#缓存不一致的根源是什么？" class="headerlink" title="缓存不一致的根源是什么？"></a>缓存不一致的根源是什么？</h3><p>问题的根源不在于多个核，而是多个缓存，以及缓存的写操作。<br>缓存中存储数据，缓存不一致就意味着相同的数据在不同的缓存中呈现着不同<br>的表现。对于存储的数据，CPU有读操作和写操作，读操作不会影响数据的存<br>储状态，写操作是导致不一致的根源。但是缓存不一致的问题并不是因为我<br>们采用了多核CPU，而是因为我们采用了多个缓存。如果多核CPU共享一个<br>缓存，那么不一致问题也不复存在，在每个时钟周期，几个核通过某种方<br>式竞争使用缓存，每个时刻只允许一个核对缓存进行读写操作，其他的核<br>都需排队等候，这样缓存永远是一致的，但是这种方式会导致CPU计算资<br>源的极大浪费，同时效率极低。采用每个核一个缓存的方式，多核可以同<br>时工作，但是也带来了缓存不一致的问题</p>
<h3 id="缓存一致性协议是什么？"><a href="#缓存一致性协议是什么？" class="headerlink" title="缓存一致性协议是什么？"></a>缓存一致性协议是什么？</h3><p>为了解决缓存不一致的问题，我们需要一种机制来约束各个核，也就是缓存<br>一致性协议。我们常用的缓存一致性协议都是属于“snooping(窥探)”协议，<br>各个核能够时刻监控自己和其他核的状态，从而统一管理协调。窥探的思想<br>是：CPU的各个缓存是独立的，但是内存却是共享的，所有缓存的数据最终<br>都通过总线写入同一个内存，因此CPU各个核都能“看见”总线，即各个缓存<br>不仅在进行内存数据交换的时候访问总线，还可以时刻“窥探”总线，监控<br>其他缓存在干什么。因此当一个缓存在往内存中写数据时，其他缓存也都<br>能“窥探”到，从而按照一致性协议保证缓存间的同步</p>
<h3 id="缓存一致性协议有哪些？"><a href="#缓存一致性协议有哪些？" class="headerlink" title="缓存一致性协议有哪些？"></a>缓存一致性协议有哪些？</h3><p><a href="https://www.cnblogs.com/zhengshuangxi/p/11180610.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengshuangxi/p/11180610.html</a></p>
<ol>
<li>EMSI协议 它通过定义一个状态机来保证缓存的一致性。在MESI协议中有<br>四种状态，这些状态都是针对缓存行（缓存由多个缓存行组成，缓存行的大<br>小单位与机器的位数相关）</li>
</ol>
<ul>
<li>Invalid状态：缓存行无效状态。要么该缓存行数据已经过时，要么缓存<br>行数据已经不在缓存中。对于无效状态，可直接认为缓存行未加载进缓存</li>
<li>Shared状态：缓存行共享状态。缓存行数据与内存中对应数据保持一致，<br>多个缓存中的相应缓存行都是共享状态。该状态下的缓存行只允许读取，不<br>允许写</li>
<li>Exclusive状态：缓存行独有状态。该缓存行中的数据与内存中对应数据<br>保持一致，当某缓存行是独有状态，其他缓存对应的缓存行都必须为无效<br>状态</li>
<li>Modified状态：缓存行已修改状态。缓存行中的数据为脏数据，与内存中<br>的对应数据不一致。如果一个缓存行为已修改状态，那么其他缓存中对应缓<br>存行都必须为无效状态。另外，如果该状态下的缓存行状态被修改为无效，<br>那么脏段必须先回写入内存中</li>
</ul>
<p>MESI协议的定律：所有M状态下的缓存行（脏数据）回写后，任意缓存级别<br>中的缓存行的数据都与内存保持一致。另外如果某个缓存行处于E状态，那<br>么在其他的缓存中就不会存在该缓存行</p>
<h3 id="Java内存模型的具体内容？"><a href="#Java内存模型的具体内容？" class="headerlink" title="Java内存模型的具体内容？"></a>Java内存模型的具体内容？</h3><p>从Java线程角度，我们把Java内存模型分为主内存和每条线程私有的工作内<br>存（可以与处理器高速缓存类比）</p>
<ol>
<li>Java 线程只能直接对其的私有工作内存进行读取和写入数据操作，而不<br>能对主内存直接进行读取和写入操作</li>
<li>主内存对所有的 Java 线程都可见，即所有的Java线程都可以通过其工<br>作内存来间接的修改主内存中的数据</li>
<li>线程的工作内存只对其对应的 Java 线程可见，不同的Java线程不共享<br>其工作内存</li>
</ol>
<h3 id="原子性是什么？"><a href="#原子性是什么？" class="headerlink" title="原子性是什么？"></a>原子性是什么？</h3><p>对于一个操作来说，如果执行它，那么在执行过程中不会被其他因素打断直到<br>完成这个操作，否则这个操作就不执行。我们称这个操作具有原子性。Java中<br>常用的a = 1; 操作通常是具有原子性的，而类似于 a += 1; 和 a++; 等<br>操作就不具有原子性</p>
<ul>
<li>getstatic 指令为从静态储存区取出变量的值并且压入操作栈顶</li>
<li>iconst_1 指令为将整形常量 1 压入操作栈顶</li>
<li>isub 指令为从栈中取出两个整形变量将相减的结果压入操作栈顶</li>
<li>putstatic 指令为从操作栈顶中取出变量的值并将变量值写入主内存中</li>
<li>iload_0 指令为将局部变量压入到操作栈顶</li>
<li>ireturn 指令为方法结束并返回从操作栈顶取出的 int 类型值</li>
<li>return 即为方法的结束返回指令</li>
</ul>
<p>对变量 a 进行改变的字节码只有 putstatic，所以可以理解为原子性，<br>a– 的字节码指令有多条</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic</span><br><span class="line">iconst_1</span><br><span class="line">isub</span><br><span class="line">putstatic</span><br></pre></td></tr></table></figure>
<h3 id="可见性是什么？"><a href="#可见性是什么？" class="headerlink" title="可见性是什么？"></a>可见性是什么？</h3><p>可见性是指一个线程修改了某一共享变量的值，其他线程是否能够立即知道这个<br>修改。对于串行程序来说可见性问题不存在，并行程序中缓存优化、硬件优化或<br>指令重排以及编译器优化都可能产生可见性问题</p>
<h3 id="有序性是什么？"><a href="#有序性是什么？" class="headerlink" title="有序性是什么？"></a>有序性是什么？</h3><p>有序性问题的原因是因为程序在执行时可能会进行指令重排，重排后的指令与原<br>指令的顺序未必一致，但是一定可以保证串行语义的一致性</p>
<h3 id="指令重排的规则是什么？"><a href="#指令重排的规则是什么？" class="headerlink" title="指令重排的规则是什么？"></a>指令重排的规则是什么？</h3><p>以下原则是指令重排不能违背的<br>顺序执行原则：一个线程内保证语义的串行性</p>
<ol>
<li>volatile规则：volatile变量的写，先发生于读</li>
<li>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前</li>
<li>传递性：A先于B，B先于C，那么A必先于C</li>
<li>线程的start方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结(Thread.join())</li>
<li>线程的中断(interrupt())先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法</li>
<li>顺序执行原则：一个线程内保证语义的串行性</li>
</ol>
<h3 id="什么是线程同步？"><a href="#什么是线程同步？" class="headerlink" title="什么是线程同步？"></a>什么是线程同步？</h3><p>线程的同步是指一个线程对内存进行操作时，其他线程都不可以对这个内存<br>地址进行操作，直到该线程完成操作，其他线程才可以对内存地址进行操作</p>
<h3 id="同步的实现有哪些方式？"><a href="#同步的实现有哪些方式？" class="headerlink" title="同步的实现有哪些方式？"></a>同步的实现有哪些方式？</h3><ol>
<li>同步代码方法：sychronized 关键字修饰的方法，给当前实例加锁</li>
<li>同步代码块：sychronized 关键字修饰的代码块，给给定对象加锁</li>
<li>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的<br>访问提供了一种免锁机制</li>
<li>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了<br>lock接口的锁他与sychronized方法具有相同的基本行为和语义</li>
</ol>
<h3 id="ReentrantLock是什么？"><a href="#ReentrantLock是什么？" class="headerlink" title="ReentrantLock是什么？"></a>ReentrantLock是什么？</h3><p>重入锁ReentrantLock由上次成功锁定并且尚未解锁的线程拥有，是一个<br>可重入且独占式的锁。与synchronized 关键字相比更加灵活强大，重入<br>锁的意思就是这种锁能反复进入，但是只限于一个线程。注意<br>ReentrantLock锁的并不是Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁定几个就要释放几个</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	lock.lock();	</span><br><span class="line">	lock.lock();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重入锁的常用处理框架如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  </span><br><span class="line">     <span class="comment">// 当前执行代码的线程尝试获取锁对象，如果当前锁对象被其他线程获取，则陷入阻塞状态</span></span><br><span class="line">	 <span class="comment">// 保证了在同一时刻只能有一个线程进入 try 代码块中执行代码，即实现线程同步</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// do something...</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock() <span class="comment">// 最后一定记得释放锁对象，不然可能导致死锁</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重入锁的中断响应是什么？"><a href="#重入锁的中断响应是什么？" class="headerlink" title="重入锁的中断响应是什么？"></a>重入锁的中断响应是什么？</h3><p>在等待锁的过程中，程序可以根据需要取消对锁的请求。比如两个线程使<br>用lockInterruptibly()方法加锁造成死锁时，如果其中一个线程调用<br>interrupt方法将导致线程中断，此时该线程会停止申请锁并释放已经<br>获得的锁然后抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lockInterruptibly()</span><br></pre></td></tr></table></figure>
<h3 id="重入锁申请等待限时机制？"><a href="#重入锁申请等待限时机制？" class="headerlink" title="重入锁申请等待限时机制？"></a>重入锁申请等待限时机制？</h3><p>除了等待外部通知，还有一种避免死锁的方式就是限时等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>	isLocked​() <span class="comment">// 查询当前锁对象是否被任意一个线程所持有</span></span><br><span class="line"><span class="keyword">boolean</span>	isHeldByCurrentThread​() <span class="comment">// 查询当前锁对象是否被当前执行代码的线程所拥有</span></span><br><span class="line"><span class="comment">//当前执行代码的线程尝试获取锁，如果获取失败（当前锁已经被其他线程所拥有），</span></span><br><span class="line"><span class="comment">//那么当前执行代码的线程会陷入阻塞，直到这个锁对象被其所拥有的线程释放才会从阻塞状态唤醒</span></span><br><span class="line"><span class="keyword">void</span> lock​() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程尝试获取当前锁，如果获取成功，那么返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment">// 和 lock 方法的区别在于当前线程获取锁失败时不会陷入阻塞状态</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock​()</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> tryLock​(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException </span><br><span class="line"><span class="keyword">void</span> unlock​() <span class="comment">// 释放当前执行代码的线程拥有的锁对象</span></span><br></pre></td></tr></table></figure>

<h3 id="synchronized是什么？"><a href="#synchronized是什么？" class="headerlink" title="synchronized是什么？"></a>synchronized是什么？</h3><p>synchronized可以修饰方法、代码块，但是不能修饰变量和构造器，默认实现锁<br>机制，线程获取锁资源和线程释放锁资源），同步方法的同步监视器是this，而<br>this总代表调用该方法的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于实例方法锁住的是对象，对于静态方法锁住的是类，类和对象不冲突</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当线程执行到这里的时候会检查调用该方法的对象是否已经被锁住</span></span><br><span class="line"><span class="comment">如果被锁住则等待锁的释放</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//obj就表示当前对象</span></span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与线程同步以及线程调度相关的方法有哪些？"><a href="#与线程同步以及线程调度相关的方法有哪些？" class="headerlink" title="与线程同步以及线程调度相关的方法有哪些？"></a>与线程同步以及线程调度相关的方法有哪些？</h3><ol>
<li>Object.wait() 使一个线程处于等待（阻塞）状态，并且释放所持有的<br>对象的锁，注意这个方法只能在 synchronized关键字修饰的代码块中调用</li>
<li>Thread.sleep(long millis) 使一个正在运行的线程处于睡眠状态，<br>是一个静态方法，可以指定一个时间参数，单位是毫秒，调用此方法要处理<br>InterruptedException异常</li>
<li>Object.notify() 唤醒一个因调用当前对象的 wait()方法而陷入等待<br>状态的线程，具体哪个线程未知。这个方法也只能在 synchronized关键字<br>修饰的代码块中执行</li>
<li>Object.notifyAll() 唤醒所有因调用当前对象的 wait()方法而陷入等<br>待状态的线程。同样这个方法也只能在 synchronized关键字修饰的代码块中<br>执行该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线<br>程才能进入就绪状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> </span></span></span><br><span class="line"><span class="function"><span class="params">		money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (money &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 此处应做特殊处理</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"账户"</span> + fromIndex + <span class="string">"想向"</span> + toIndex + <span class="string">"账户转账"</span> </span><br><span class="line">			+ money + <span class="string">"元"</span>);</span><br><span class="line">		<span class="comment">/* 如果转账方账户余额不足，那么调用当前对象的 </span></span><br><span class="line"><span class="comment">		wait 方法使得当前线程释放对象锁陷入无限等待，</span></span><br><span class="line"><span class="comment">		直到其它线程调用了 notify 或者 notifyAll 方法，*/</span></span><br><span class="line">		<span class="keyword">while</span> (accountBalance[fromIndex] &lt; money) &#123;</span><br><span class="line">			System.out.println(<span class="string">"账户余额不足，无法转账！"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 账户余额变更</span></span><br><span class="line">		accountBalance[fromIndex] -= money;</span><br><span class="line">		accountBalance[toIndex] += money;</span><br><span class="line">		System.out.println(<span class="string">"转账成功"</span>);</span><br><span class="line">		notifyAll(); <span class="comment">// 唤醒所有因调用了当前对象的 wait 方法而陷入等待的线程</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>Thread.join() 在线程执行过程中插入另外一个线程，并且直到这个插入<br>的线程执行完成之后再继续执行原来的线程。当在某个执行流中调用其他线程<br>的join方法时，调用线程将被阻塞。<br>在main线程中调用jt.join()，main线程会获取线程对象jt的锁，调用到wait<br>方法时当前线程就会一直等待同时释放jt对象的锁，而jt中的线程可以执行，<br>执行完死亡时会调用自己的notifyAll方法，这时主线程就可以继续执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> JoinThread(<span class="string">"新线程"</span>).start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				JoinThread jt=<span class="keyword">new</span> JoinThread(<span class="string">"被join的线程"</span>);</span><br><span class="line">				jt.start();</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 		在main线程的执行流中调用了join方法，所以</span></span><br><span class="line"><span class="comment">			 		main线程被停止，只有两个子线程在执行，当</span></span><br><span class="line"><span class="comment">			 		jt线程执行完后主线程才会继续执行，join方</span></span><br><span class="line"><span class="comment">			 		法也可以加时间参数，过了这个时间方法失效</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				jt.join();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>Thread.yield() yield()也是一个静态方法，可以让正在执行的线程暂<br>停但是不会阻塞该线程，只是将线程转入就绪状态，让系统线程调度器重新<br>调度一次，很有可能该线程又重新执行</li>
</ol>
<h3 id="公平锁与非公平锁的区别？"><a href="#公平锁与非公平锁的区别？" class="headerlink" title="公平锁与非公平锁的区别？"></a>公平锁与非公平锁的区别？</h3><p>公平锁按照线程申请锁的先后顺序被获取，不会产生饥饿现象，synchronized<br>产生的锁是非公平的，会根据优先级挑选，具有随机性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Condition是什么？"><a href="#Condition是什么？" class="headerlink" title="Condition是什么？"></a>Condition是什么？</h3><p>ReentrantLock类中提供了一个方法newCondition()来获取Condition实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//与Object的wait方法相同，直到其他线程调用Condition的signal或signalAll</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">   <span class="comment">/*唤醒在Lock对象上等待的线程，如果所有线程都在该Lock对象上等待，</span></span><br><span class="line"><span class="comment">    则会选择唤醒其中一个线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//唤醒所有等待的线程</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上这些方法需要在获取ReentrantLock锁资源的情况下才能使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 创建锁对象</span></span><br><span class="line">Condition con = lock.newCondition();</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当前线程尝试获取锁资源</span></span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (money &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 此处应做特殊处理</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"账户"</span> + fromIndex + <span class="string">"想向"</span> + toIndex + </span><br><span class="line">			<span class="string">"账户转账"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">		<span class="comment">/* 如果转账方账户余额不足，那么调用 con 对象的 </span></span><br><span class="line"><span class="comment">		await 方法使得当前线程释放对象锁陷入无限等待，</span></span><br><span class="line"><span class="comment">		 直到其它线程调用了 con 对象的 signal 或者 signalAll 方法，*/</span></span><br><span class="line">		<span class="keyword">while</span> (accountBalance[fromIndex] &lt; money) &#123;</span><br><span class="line">			System.out.println(<span class="string">"账户余额不足，无法转账！"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				con.await();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 账户余额变更</span></span><br><span class="line">		accountBalance[fromIndex] -= money;</span><br><span class="line">		accountBalance[toIndex] += money;</span><br><span class="line">		System.out.println(<span class="string">"转账成功"</span>);</span><br><span class="line">		con.signalAll(); </span><br><span class="line">		<span class="comment">// 唤醒所有因调用了 con 对象的 await 方法而陷入等待的线程</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock(); <span class="comment">// 当前线程释放锁资源</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java多线程中调用wait-和sleep-方法有什么不同？"><a href="#Java多线程中调用wait-和sleep-方法有什么不同？" class="headerlink" title="Java多线程中调用wait()和sleep()方法有什么不同？"></a>Java多线程中调用wait()和sleep()方法有什么不同？</h3><p>都可以让线程等待若干时间，</p>
<ol>
<li>类的不同：sleep()是Thread线程类的静态方法，wait()是Object类的方法</li>
<li>是否释放锁：sleep() 不释放锁；wait() 释放锁</li>
<li>用途不同：Wait 通常被用于线程间交互/通信，sleep通常被用于暂停执行</li>
<li>用法不同：wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同<br>一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程<br>会自动苏醒</li>
</ol>
<h3 id="为什么wait方法要在循环中调用？"><a href="#为什么wait方法要在循环中调用？" class="headerlink" title="为什么wait方法要在循环中调用？"></a>为什么wait方法要在循环中调用？</h3><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条<br>件，程序就会在没有满足结束条件的情况下退出</p>
<h3 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h3><p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁<br>，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的<br>notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会<br>释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有<br>的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他<br>们只能在同步方法或者同步块中被调用</p>
<h3 id="为什么wait-notify和notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify和notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify和notifyAll这些方法不在thread类里面？"></a>为什么wait, notify和notifyAll这些方法不在thread类里面？</h3><p>JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线<br>程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait() 方法定义<br>在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说由于wait，notify<br>和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象</p>
<h3 id="join和yield的区别？"><a href="#join和yield的区别？" class="headerlink" title="join和yield的区别？"></a>join和yield的区别？</h3><p>join是阻塞当前线程，直到目标线程执行完毕。yield是一个静态方法，一旦<br>执行就会让出CPU，但是还可以进行CPU资源的争夺，注意yield不会释放锁<br>资源</p>
<h3 id="Thread类中的start-和run-方法有什么区别？"><a href="#Thread类中的start-和run-方法有什么区别？" class="headerlink" title="Thread类中的start()和run()方法有什么区别？"></a>Thread类中的start()和run()方法有什么区别？</h3><p>start() 方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这<br>和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的<br>线程中调用，没有新的线程启动，start()方法才会启动新线程</p>
<h3 id="线程同步和线程互斥的区别？"><a href="#线程同步和线程互斥的区别？" class="headerlink" title="线程同步和线程互斥的区别？"></a>线程同步和线程互斥的区别？</h3><ol>
<li>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当<br>有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用<br>，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥<br>可以看成是一种特殊的线程同步</li>
<li>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核<br>模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与<br>用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。<br>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核<br>模式下的方法有：事件，信号量，互斥量</li>
</ol>
<h3 id="监视器-Monitor-内部，是如何做线程同步的？"><a href="#监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="监视器(Monitor)内部，是如何做线程同步的？"></a>监视器(Monitor)内部，是如何做线程同步的？</h3><p>在java虚拟机中，每个对象(Object 和 class)通过某种逻辑关联监视器，每<br>个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关<br>联着一把锁。java提供了显式监视器(Lock)和隐式监视器(synchronized)两<br>种锁方案</p>
<h3 id="as-if-serial规则和happens-before规则的区别？"><a href="#as-if-serial规则和happens-before规则的区别？" class="headerlink" title="as-if-serial规则和happens-before规则的区别？"></a>as-if-serial规则和happens-before规则的区别？</h3><ol>
<li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before<br>关系保证正确同步的多线程程序的执行结果不被改变</li>
<li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程<br>序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程<br>序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指<br>定的顺序来执行的</li>
<li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变<br>程序执行结果的前提下，尽可能地提高程序执行的并行度</li>
</ol>
<h3 id="并发工具有哪些？"><a href="#并发工具有哪些？" class="headerlink" title="并发工具有哪些？"></a>并发工具有哪些？</h3><p>Semaphore ReadWriteLock CountDownLatch CycliBarrier LockSupport<br><img src="/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<h3 id="Semaphore是什么？"><a href="#Semaphore是什么？" class="headerlink" title="Semaphore是什么？"></a>Semaphore是什么？</h3><p>信号量是为多线程协作提供更强大的控制方法，内部锁synchronized和重入锁<br>ReentrantLock一次都只允许一个线程访问一个资源，信号量可以指定多个线<br>程同时访问一个资源，可以用于数据库连接，同时进行连接的线程有数量限制<br>，还可以用在停车场车位限制场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Semaphore.Sync sync;</span><br><span class="line">    <span class="comment">//指定多少个许可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Semaphore.NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二个参数指定是否公平</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (Semaphore.Sync)(fair ? <span class="keyword">new</span> Semaphore.FairSync(permits) : </span><br><span class="line">        	<span class="keyword">new</span> Semaphore.NonfairSync(permits));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从此信号量获取一个许可，在提供一个许可前一直将线程阻塞或当前线程被中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放一个许可，将其返回给信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来模拟一下停车场景，停车场容量10个车位，一个车走显示屏车位加1，<br>一个车进显示屏车位减一，如果减为0则车等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停车场同时容纳的车辆10</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟100辆车进入停车场</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"===="</span>+</span><br><span class="line">                        	Thread.currentThread().getName()+<span class="string">"来到停车场"</span>);</span><br><span class="line">                        <span class="keyword">if</span>(semaphore.availablePermits()==<span class="number">0</span>)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"车位不足，请耐心等待"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        semaphore.acquire();<span class="comment">//获取令牌尝试进入停车场</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        	<span class="string">"成功进入停车场"</span>);</span><br><span class="line">                        <span class="comment">//模拟车辆在停车场停留的时间</span></span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        	<span class="string">"驶出停车场"</span>);</span><br><span class="line">                        semaphore.release();<span class="comment">//释放令牌，腾出停车场车位</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+<span class="string">"号车"</span>);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReadWriteLock是什么？"><a href="#ReadWriteLock是什么？" class="headerlink" title="ReadWriteLock是什么？"></a>ReadWriteLock是什么？</h3><p>读写分离锁能够有效减少锁竞争。比如线程A1 A2 A3进行写操作，线程B1 B2<br>B3 进行读操作，如果使用重入锁或内部锁理论上所有的读之间、读与写之间、<br>写与写之间都是串行操作，当B1进行读时B2 B3都需要等待锁，读写锁能够使<br>多个线程同时读，但是其余操作依然需要等待。如果系统中读操作次数远远大<br>于写操作次数，则读写锁可以发挥最大功效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CountDownLatch是什么？"><a href="#CountDownLatch是什么？" class="headerlink" title="CountDownLatch是什么？"></a>CountDownLatch是什么？</h3><p>称为倒计时器，让一个线程等待直到倒计时结束再开始执行，倒计时器一个<br>典型的场景是火箭发射，发射线程必须等待检查线程执行完后才能执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*count表示这个计数器的计数个数，每当一下线程执行完计数器的值就-1</span></span><br><span class="line"><span class="comment">当计数器的值为0表示所有线程执行完毕，然后在闭锁上等待的线程就可以工作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//将count值减1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>以下例子要求两个子线程都执行完后主线程才可以继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程开始执行…… ……"</span>);</span><br><span class="line">        <span class="comment">//第一个子线程执行</span></span><br><span class="line">        ExecutorService es1 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es1.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程："</span>+Thread.currentThread().</span><br><span class="line">                    	getName()+<span class="string">"执行"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es1.shutdown();</span><br><span class="line">        <span class="comment">//第二个子线程执行</span></span><br><span class="line">        ExecutorService es2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es2.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程："</span>+Thread.currentThread().</span><br><span class="line">                	getName()+<span class="string">"执行"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es2.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"等待两个线程执行完毕…… ……"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"两个子线程都执行完毕，继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CycliBarrier是什么？"><a href="#CycliBarrier是什么？" class="headerlink" title="CycliBarrier是什么？"></a>CycliBarrier是什么？</h3><p>可以理解为循环栅栏，实现线程间的计数等待，让一组线程相互等待，当所有<br>线程都到达某个屏障点后再进行后续的操作。可以用于多线程计数数据，最后<br>合并计数结果的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//barrierAction表示当计数器一次计数完成后系统会执行的操作，parties是计数总数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties,Runnbale barrierAction)</span></span></span><br></pre></td></tr></table></figure>
<p>以下是一个实例场景，可以看到CycliBarrier可以重复使用，核心是reset功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,</span><br><span class="line">                <span class="keyword">new</span> BarrierRun(<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">7</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                        <span class="string">"\t 收集到第"</span>+ finalI +<span class="string">"颗龙珠"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"神龙吐出第"</span>+finalI+<span class="string">"颗龙珠"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag=flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"六老师召唤神龙结束，神龙走了"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"六老师召唤神龙"</span>);</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LockSupport是什么？"><a href="#LockSupport是什么？" class="headerlink" title="LockSupport是什么？"></a>LockSupport是什么？</h3><p>是一个非常方便的线程阻塞工具，可以在线程内任意位置让线程阻塞，相比<br>suspend，弥补由于resume 在前发生导致线程无法继续执行的情况，相比<br>wait方法不需要先获取某个对象的锁，也不会抛出中断异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span></span>; <span class="comment">// 暂停当前线程</span></span><br><span class="line"><span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line"><span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>; <span class="comment">// 无期限暂停当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span></span>; <span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span></span>; <span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>; <span class="comment">// 恢复当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接下来看一个实例场景，LockSupport 使用类似信号量的机制，为每一个线<br>程准备了一个许可，如果许可可用那park函数会立即返回，并消费这个许可<br>，如果许可不可用就会阻塞，unpark函数就是使得一个许可变为可用，即使<br>unpark发生在park之前也可以使下一次park操作立即返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">                System.out.println(<span class="string">"in "</span> + getName());</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"被中断了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"继续执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="comment">//t1中断之后park会立即返回不抛出异常，继续执行完剩下代码后t2就可以进入临界区</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存间交互操作有哪些？"><a href="#内存间交互操作有哪些？" class="headerlink" title="内存间交互操作有哪些？"></a>内存间交互操作有哪些？</h3><p>Java内存模型定义了以下8种操作。Java虚拟机实现时必须保证下面提及的每一种<br>操作都是原子的、不可再分的。对一个变量执行unlock操作之前，必须把此变量同<br>步回主内存中</p>
<ul>
<li>lock 作用于主内存的变量，把一个变量标识为一条线程独占的状态</li>
<li>unlock 作用于主内存的变量，把一个处于锁定状态的变量释放出来释<br>放后的变量才可以被其他线程锁定</li>
<li>read 作用于主内存的变量，把一个变量的值从主内存传输到线程的工<br>作内存，以便随后的load动作使用</li>
<li>load 作用于工作内存的变量，把read操作从主内存中得到的变量值放<br>入工作内存的变量副本中</li>
<li>use 作用于工作内存的变量，把工作内存中一个变量的值传递给执行引<br>擎，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>
<li>assign 作用于工作内存的变量，把一个从执行引擎接收到的值赋给工<br>作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个<br>操作</li>
<li>store 作用于工作内存的变量，把工作内存中一个变量的值传递到主内<br>存中，以便随后的write操作</li>
<li>write 作用于主内存的变量，把store操作从工作内存中得到的变量的<br>值放入主内存的变量中</li>
</ul>
<h3 id="Java中的volatile变量是什么？"><a href="#Java中的volatile变量是什么？" class="headerlink" title="Java中的volatile变量是什么？"></a>Java中的volatile变量是什么？</h3><p>volatile是JAVA虚拟机提供的最轻量级的同步机制，它将具有两项特性：第一项<br>是保证此变量对所有线程的可见性，第二个特点就是禁止指令重排序。核心问题在<br>于能够保证使用之前是最新的数据，但是使用过程中其他线程可能修改这个值</p>
<h3 id="volatile如何保证可见性？"><a href="#volatile如何保证可见性？" class="headerlink" title="volatile如何保证可见性？"></a>volatile如何保证可见性？</h3><p>volatile变量在各个线程的工作内存中是不存在一致性问题的（每次使用<br>前都要先刷新，执行引擎看不到不一致的情况，因此认为不存在一致性问<br>题）且JAVA内存模型对valatile的规则还有read load use必须在一起<br>assign stoere和write必须在一起</p>
<h3 id="volatile如何禁止指令重排序？"><a href="#volatile如何禁止指令重排序？" class="headerlink" title="volatile如何禁止指令重排序？"></a>volatile如何禁止指令重排序？</h3><p>禁止指令重排序的关键是多指令了一个lock指令，这个lock指令相当于一个<br>内存屏障，指重排序的时候不能把后面的指令重排序到内存屏障之前的位置<br>，lock不能配合nop使用，将本处理器的缓存写入内存并且无效化别的处理<br>器的缓存，写入内存就已经意味着所有操作都完成。不能替代锁，性能要高<br>于锁，主要的消耗就是要在指令中插入内存屏障</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处变量要用 volatile 关键字修饰，避免因指令重排序导致错误</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> isInitialized = <span class="keyword">false</span>; </span><br><span class="line"><span class="comment">// 以下方法在线程 A 中执行，在里面进行程序初始化的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 进行初始化操作 ......</span></span><br><span class="line">	isInitialized = <span class="keyword">true</span>; </span><br><span class="line">	<span class="comment">// 初始化完成之后设置初始化完成标志为 true，即表示程序初始化完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下方法在线程 B 执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!isInitialized) &#123;</span><br><span class="line">		sleep(); <span class="comment">// 继续等待初始化完成</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化完成之后开始执行任务</span></span><br><span class="line">	executeTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设如果 isInitialized 变量我们不用volatile关键字修饰的话，有<br>可能经过编译器的优化之后对指令进行重排序，使得 isInitialized=<br>true; 这条代码放在初始化操作之前调用了，也就是说程序明明还没有<br>初始化完成而 isInitialized 变量的值却变成了 true，那么如果此<br>时线程 B 得到了 CPU 资源就会执行executeTask() 方法中的代码了</p>
<h3 id="volatile能保证原子性吗？"><a href="#volatile能保证原子性吗？" class="headerlink" title="volatile能保证原子性吗？"></a>volatile能保证原子性吗？</h3><p>volatile变量的运算在并发下一样是不安全的。比如a++操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic &#x2F;&#x2F; 从静态储存区取出变量的值并且压入操作栈顶 </span><br><span class="line">iconst_1 &#x2F;&#x2F; 将整形常量 1 压入操作栈顶</span><br><span class="line">iadd &#x2F;&#x2F; 从栈中取出两个整形变量将相减的结果压入操作栈顶</span><br><span class="line">putstatic &#x2F;&#x2F; 从操作栈顶中取出变量的值并将变量值写入静态储存区</span><br></pre></td></tr></table></figure>
<p>如果一个线程（这里命名为线程 A）在进行 increase 方法累加的时候执行<br>了 iconst_1 指令了之后让出了 CPU 资源，然后另一个线程（这里命名为<br>线程 B）得到了 CPU 资源并且从主内存中读取 sum 的值（此前线程 A 并<br>没有使 sum 自增），然后进行 sum 的累加。线程 B 执行完成后让出 CPU<br>资源，之后线程 A 得到了 CPU 资源，继续执行未执行完的指令：iadd 和<br>putstatic ，但是因为此时线程工作栈内存中储存的 sum 的值仍然是在<br>线程 B 进行累加之前从主内存取得的值，即此时的数据变成了过期的数<br>据，所以线程 A 执行的 putstatic 就可能把较小的 sum 值刷新到主<br>内存中</p>
<h3 id="synchronized和volatile关键字的区别？"><a href="#synchronized和volatile关键字的区别？" class="headerlink" title="synchronized和volatile关键字的区别？"></a>synchronized和volatile关键字的区别？</h3><ol>
<li>synchronized 关键字可以完成由 volatile关键字提供的可见性的功<br>能，即可以用synchronized 关键字通过控制线程同步来实现可见性。对于<br>这个方面指的是同步块的可见性：Java 内存模型规定：在一个同步块中对<br>一个变量执行unlock操作之前，必须先把此变量从线程的工作内存刷新到<br>主内存中</li>
<li>效率比volatile关键字低，因为synchronized关键字有可能会阻塞线程</li>
</ol>
<h3 id="无锁是什么？-1"><a href="#无锁是什么？-1" class="headerlink" title="无锁是什么？"></a>无锁是什么？</h3><p>并发控制是一种悲观的策略，假设每一次的临界区操作都会产生冲突，所以会<br>牺牲性能让线程等待，无锁是一种乐观的策略，假设对资源的访问是没有冲突<br>的，如果遇到冲突会使用一种叫做比较交换的技术(CAS)来鉴别线程冲突，一<br>旦检测到冲突就会重试当前操作直到没有冲突</p>
<h3 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h3><ol>
<li>CAS 全称 =&gt; Compare-And-Set , 它是一条CPU并发源语，比较交换</li>
<li>他的功能就是判断内存某个位置的值是否为预期值，如果是则更新为新的值<br>，这个过程是原子的</li>
<li>CAS并发源语体现在Java语言中就是sun.miscUnSafe类中的各个方法，调<br>用UnSafe类中的CAS方法，JVM会帮我实现CAS汇编指令，这是一种完全依赖于<br>硬件功能，通过它实现了原子操作，再次强调，由于CAS是一种系统源语，源<br>语属于操作系统用于范畴，是由若干个指令组成，用于完成某个功能的一个<br>过程，并且源语的执行必须是连续的，在执行过程中不允许中断，也即是说<br>CAS是一条原子指令，不会造成所谓的数据不一致的问题</li>
</ol>
<h3 id="CAS算法如何实现？"><a href="#CAS算法如何实现？" class="headerlink" title="CAS算法如何实现？"></a>CAS算法如何实现？</h3><p>CAS算法的过程如下：它包含三个参数，V表示要更新的变量，E表示预期值，N<br>表示新值。仅当V等于E时才会将V的值设为N，如果V不等于E 说明已经有其他线<br>程做了更新，则当前线程什么也不做，最后CAS 会返回当前V的真实值。当多线<br>程同时使用CAS 操作一个变量时，只会有一个成功更新其余失败，失败的线程<br>不会被挂起，而是被告知失败并且允许再次尝试，也允许失败的线程放弃操作<br>，CAS操作即使没有锁也可以发现其他线程对当前线程的干扰。大部分处理器<br>已经支持原子化的CAS指令</p>
<h3 id="在Java-API中有哪些原子类？"><a href="#在Java-API中有哪些原子类？" class="headerlink" title="在Java API中有哪些原子类？"></a>在Java API中有哪些原子类？</h3><p>原子类：AtomicBoolean AtomicInteger AtomicLong AtomicReference<br>其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含<br>的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被<br>其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由<br>JVM 从等待队列中选择另一个线程进入，这只是一种逻辑上的理解</p>
<ol>
<li>AtomicInteger 是一个线程安全的Integer，对其进行修改等任何操作<br>都是用CAS指令进行的，AtomicInteger 类主要利用 CAS (compare and<br>swap)+volatile和native方法来保证原子操作，从而避免synchronized<br>的高开销，执行效率大为提升<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存一个核心字段，它就代表当前实际取值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">//实现AtomicInteger的关键，它保存value的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.value = newValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="atomic的原理？"><a href="#atomic的原理？" class="headerlink" title="atomic的原理？"></a>atomic的原理？</h3><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个<br>（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程<br>同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以<br>向自旋锁一样，继续尝试，一直等到执行成功</p>
<h3 id="CAS的原理？"><a href="#CAS的原理？" class="headerlink" title="CAS的原理？"></a>CAS的原理？</h3><p>关于incrementAndGet方法的实现，这里有一个for死循环，因为CAS操作未<br>必是成功的，对于不成功的情况就要不断尝试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前值加1，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    		<span class="keyword">int</span> current=get();</span><br><span class="line">    		<span class="keyword">int</span> next=current+<span class="number">1</span>;</span><br><span class="line">    		<span class="comment">//成功的条件就是期望是current必须是最新的当前值</span></span><br><span class="line">    		<span class="keyword">if</span>(compareAndSet(current,next))</span><br><span class="line">    			<span class="keyword">return</span> next;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中有一个compareAndSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe U = Unsafe.getUnsafe();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSetInt(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsafe类的作用？"><a href="#Unsafe类的作用？" class="headerlink" title="Unsafe类的作用？"></a>Unsafe类的作用？</h3><p>UnSafe是CAS的核心类，由于Java方法无法直接访问底层，需要通过本地<br>（native）方法来访问，UnSafe相当于一个后面，基于该类可以直接操<br>作额定的内存数据。UnSafe类在于sun.misc包中。其中内部方法可以向C<br>的指针一样直接操作内存，因为Java中CAS操作的助兴依赖于UnSafe类<br>的方法，变量value用volatile 修饰，保证了多线程之间的可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法内部是通过CAS指令来完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="CAS的缺点是什么？"><a href="#CAS的缺点是什么？" class="headerlink" title="CAS的缺点是什么？"></a>CAS的缺点是什么？</h3><ol>
<li>循环时间开销很大<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*CAS中有个do while 方法：如果CAS失败，会一直进行尝试，如果CAS长时间一直不成</span></span><br><span class="line"><span class="comment">功，会给CPU带来很大的开销*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>只能保证一个共享变量的原子性 当对一个共享变量执行操作的时候，我<br>们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，<br>循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性</li>
<li>存在ABA问题</li>
</ol>
<h3 id="AtomicReference是什么？"><a href="#AtomicReference是什么？" class="headerlink" title="AtomicReference是什么？"></a>AtomicReference是什么？</h3><p>对普通对象的封装，保证在修改对象引用时的线程安全性</p>
<h3 id="ABA问题是什么？"><a href="#ABA问题是什么？" class="headerlink" title="ABA问题是什么？"></a>ABA问题是什么？</h3><p>在一个时间差的时段内会造成数据的变化。比如说一个线程AA从内存中取走A，<br>这个时候另一个线程BB也从内存中取走A，这个时候A的值为X，然后线程BB将<br>A的值改为Y，过一会又将A的值改为X，这个时候线程AA回来进行CAS操作发现<br>内存中A的值仍然是X，因此线程AA操作成功。但是尽管线程AA的CAS操作成功<br>，但是不代表这个过程就是没问题的。在现实场景中，是否能修改对象的值，<br>不仅取决于当前值，还和对象的过程变化有关，AtomicReference无法解决<br>这个问题</p>
<h3 id="如何解决ABA问题？"><a href="#如何解决ABA问题？" class="headerlink" title="如何解决ABA问题？"></a>如何解决ABA问题？</h3><p>带有时间戳的对象引用：AtomicStampedReference。<br>AtomicReference无法解决上述问题是因为对象在修改过程中丢失了状态信息，<br>所以需要记录对象在修改过程中的状态值，就可以很好解决对象被反复修改导致<br>线程无法正确判断对象状态的问题，这个类内部不仅维护了对象值，还维护了一<br>个时间戳，这个时间戳可以用任何一个整数表示，更新数据时还要更新时间戳。<br>设置对象值时对象值与时间戳都必须满足期望值写入才会成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expectRef,V newRef, <span class="keyword">int</span> expectStamp,<span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h3><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广<br>泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸<br>如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是<br>基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自<br>己需求的同步器</p>
<h3 id="AQS的原理是什么？"><a href="#AQS的原理是什么？" class="headerlink" title="AQS的原理是什么？"></a>AQS的原理是什么？</h3><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程<br>，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要<br>一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁<br>实现的，即将暂时获取不到锁的线程加入到队列中。<br>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的<br>双向队列即不存在队列实例，仅存在节点之间的关联关系。AQS是将每一条请求<br>共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配</p>
<h3 id="AQS如何实现？"><a href="#AQS如何实现？" class="headerlink" title="AQS如何实现？"></a>AQS如何实现？</h3><p>AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资<br>源被阻塞的时候就会进入这个队列。state就是共享资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect期望值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS定义两种资源共享方式</p>
<ol>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公<br>平锁和非公平锁</li>
<li>Share（共享）：多个线程可同时执行，如Semaphore CountDownLatch。<br>Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock</li>
</ol>
<p>AQS底层使用了模板方法模式，如果需要自定义同步器一般的方式是这样</p>
<ol>
<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重<br>写方法很简单，无非是对于共享资源state的获取和释放）</li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板<br>方法会调用使用者重写的方法</li>
</ol>
<p>自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，<br>至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的<br>时候主要实现下面几种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br><span class="line"><span class="comment">/*共享方式。尝试获取资源。负数表示失败，0表示成功，但没有剩余可用资源正数表示成</span></span><br><span class="line"><span class="comment">功，且有剩余资源*/</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)</span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，<br>会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()<br>时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有<br>机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state<br>会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这<br>样才能保证state是能回到零态的。<br>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（<br>注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后<br>countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程<br>都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从<br>await()函数返回，继续后余动作。<br>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<br>tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一<br>种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<br>ReentrantReadWriteLock。</p>
<h3 id="什么是阻塞队列？阻塞队列的实现原理是什么？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？"></a>什么是阻塞队列？阻塞队列的实现原理是什么？</h3><p>阻塞队列是一个支持两个附加操作的队列。是可以使线程陷入阻塞状态的存储队列<br>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当<br>队列满时，存储元素的线程会等待队列可用。</p>
<h3 id="自定义阻塞队列如何实现生产者消费者模型？"><a href="#自定义阻塞队列如何实现生产者消费者模型？" class="headerlink" title="自定义阻塞队列如何实现生产者消费者模型？"></a>自定义阻塞队列如何实现生产者消费者模型？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition full;</span><br><span class="line">    Condition empty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockQueue</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> Object[size];</span><br><span class="line">        full=lock.newCondition();</span><br><span class="line">        empty=lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object e)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(num==array.length)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"产品已满不能生产"</span>);</span><br><span class="line">                    full.await();</span><br><span class="line">                &#125;</span><br><span class="line">                array[num++]=e;</span><br><span class="line">                <span class="comment">//此时产品至少有1个</span></span><br><span class="line">                empty.signalAll();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        <span class="string">"成功生产一个产品，总数为"</span>+num);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"没有产品不能消费"</span>);</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object obj=array[--num];</span><br><span class="line">            <span class="comment">//此时产品一定未满</span></span><br><span class="line">            full.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                    <span class="string">"成功消费一个产品，总数为"</span>+num);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再Main类中创建线程，读者可以运行一下观察结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockQueue queue=<span class="keyword">new</span> BlockQueue(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Product pro=<span class="keyword">new</span> Product(i,queue);</span><br><span class="line">            pro.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Customer cus=<span class="keyword">new</span> Customer(i,queue);</span><br><span class="line">            cus.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    BlockQueue queue;</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> i,BlockQueue queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"生产者线程"</span>+i);</span><br><span class="line">        <span class="keyword">this</span>.queue=queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">                times++;</span><br><span class="line">                queue.put(obj);</span><br><span class="line">                <span class="keyword">if</span>(times==<span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    BlockQueue queue;</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> i,BlockQueue queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"消费者线程"</span>+i);</span><br><span class="line">        <span class="keyword">this</span>.queue=queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                times++;</span><br><span class="line">                queue.take();</span><br><span class="line">                <span class="keyword">if</span>(times==<span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用的阻塞队列有哪些？"><a href="#常用的阻塞队列有哪些？" class="headerlink" title="常用的阻塞队列有哪些？"></a>常用的阻塞队列有哪些？</h3><ol>
<li>ArrayBlockingQueue ：是一个基于数组结构 的有界阻塞队列，此队列按<br>照FIFO（先进先出）规则排序</li>
<li>LinkedBlockingQueue ：是一个基于链表结构的有界阻塞队列（大小默认<br>值为Integer.MAX_VALUE），此队列按照FIFO（先进先出）对元素进行排序，<br>吞吐量通常要高于ArrayBlockingQueue</li>
<li>SynchronusQueue： 是一个不储存元素的阻塞队列，每个插入操作必须等<br>到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要<br>高于LinkedBlockingQueue</li>
<li>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ol>
<h3 id="线程池的作用是什么？"><a href="#线程池的作用是什么？" class="headerlink" title="线程池的作用是什么？"></a>线程池的作用是什么？</h3><p>对于一个服务器端的程序，对于每个用户的请求，为了提高服务器资源的利用率<br>和用户请求的响应速度，可以给每个用户都创建一个线程处理请求，如果用户访<br>问非常频繁那么频繁的创建和销毁线程会给服务器带来巨大开销，线程池可以理<br>解为一个处理任务的线程集合，在某个线程处理完任务后并不会立即销毁，而是<br>在线程池中保留一段时间，如果有新的请求那么这个线程就会继续处理任务，其<br>中的任务队列即为阻塞队列</p>
<h3 id="线程池有哪几种创建方式？"><a href="#线程池有哪几种创建方式？" class="headerlink" title="线程池有哪几种创建方式？"></a>线程池有哪几种创建方式？</h3><p>工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池</p>
<ol>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一<br>个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因<br>为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺<br>序按照任务的提交顺序执行，使用的是LinedBlockingQueue</li>
<li>newFixedThreadPool：创建一个可重用、有固定线程数的线程池，当一<br>个新任务提交时如果线程池有空闲线程则立即执行否则任务会暂时存在一个<br>任务队列中核心线程数与总线程数一样，这符合固定大小的线程池不存在线<br>程数量动态变化的情况，使用LinkedBlockingQueue可以存放无限量任务<br>（不耗尽资源的情况下）</li>
<li>newCachedThreadPool：返回一个可根据实际情况调整线程数量的线程池，<br>线程池中的线程数量不确定，如果有空闲线程可复用那么优先使用可复用的线<br>程，如果所有线程都在工作但有新任务提交则会创建新的线程，线程执行完后<br>会复用核心线程数为0，最大线程数无穷大。没有任务时线程池内无线程，当任<br>务提交时线程池会使用空闲线程，若无空闲线程，此时核心线程为0，那么就<br>会把任务加入SynchronousQueue队列，这是一种直接提交的队列，总会迫<br>使线程池增加新的线程，空闲线程60s内会被回收，适用于处理大量需要立<br>即处理并且每个任务耗时较少的任务集合</li>
</ol>
<h3 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h3><ol>
<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li>
<li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同<br>时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程<br>创建就能立即执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗<br>系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优<br>和监控。</li>
<li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.prinln(<span class="string">"xxx"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		MyTask task=<span class="keyword">new</span> MyTask();</span><br><span class="line">		ExecutorService es=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			es.submit(task);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拒绝策略有哪些？"><a href="#拒绝策略有哪些？" class="headerlink" title="拒绝策略有哪些？"></a>拒绝策略有哪些？</h3><p>等待队列已经排满，再也塞不下新的任务，而且也达到了maximumPoolSize<br>数量，无法继续为新任务服务，这个时候我们便要采取拒绝策略机制合理的<br>处理这个问题。以下内置拒绝策略均实现了RejectExecutionHandler接口</p>
<ul>
<li>AbortPolicy（默认）直接抛出RejectedException异常来阻止系统正常运行</li>
<li>CallerRunnsPolicy：“调用者运行” 一种调节机制，该策略既不会抛弃<br>任务，也不会抛出异常。线程调用运行该任务的execute本身。此策略提供<br>简单的反馈控制机制，能够减缓新任务的提交速度</li>
<li>DiscardPolicy：不执行该任务，并将该任务删除且不抛出异常，如果允<br>许任务丢失，这是最好的拒绝策略</li>
<li>DiscardOldestPolicy：丢弃队列中最近的任务，并执行当前提交的任务</li>
</ul>
<h3 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h3><ol>
<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行<br>任务的线程</li>
<li>TIDYING：所有的任务都销毁了，workCount为0，线程池的状态在转<br>换为TIDYING 状态时，会执行钩子方法terminated()</li>
<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个</li>
</ol>
<h3 id="怎么创建线程池？"><a href="#怎么创建线程池？" class="headerlink" title="怎么创建线程池？"></a>怎么创建线程池？</h3><p>ThreadPoolExecutor() 是最原始的线程池创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> corePoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">		TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">		BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">		RejectedExecutionHandler handler)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, </span><br><span class="line">        	workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor的构造参数是什么？"><a href="#ThreadPoolExecutor的构造参数是什么？" class="headerlink" title="ThreadPoolExecutor的构造参数是什么？"></a>ThreadPoolExecutor的构造参数是什么？</h3><ol>
<li>corePoolSize 线程池中的最大核心线程数，默认情况下线程池是空的，没<br>有线程，只有在有任务提交到线程池中时才会创建核心线程，即使有其他空闲<br>的核心线程可以执行新任务也会创建新的核心线程，这一点一定要注意，当核<br>心线程数等于corePoolSize的时候就不会继续创建核心线程了，如果调用线<br>程池对象的prestartAllCoreThread() 方法，那么线程池会提前创建好所<br>有的核心线程</li>
<li>maximumPoolSize 线程池中允许创建最大线程数，非核心线程数为最大线程<br>数-corePoolSize，这个参数只有在任务队列已满时才有意义。也就是说当已经<br>达到核心线程数但是队列未满时不会创建非核心线程，都添加任务到任务队列<br>满的时候才会开始创建非核心线程，如果使用无界队列则这个参数没有意义</li>
<li>keepAliveTime 线程池中非核心线程允许闲置的最长时间，超过这个时间<br>的非核心线程将会被回收，对于任务很多并且每个任务处理时间较短的的情况<br>，可以适当提升keepAliveTime参数来提高线程利用率。当设置<br>allowCoreThreadTimeOut属性为true时，keepAliveTime<br>参数也会作用到核心线程上</li>
<li>unit keepAliveTime 参数的时间单位</li>
<li>workQueue 任务队列，被提交当尚未被执行的任务，用于存放Runnnable<br>对象</li>
<li>threadFactory 创建线程的工厂，一般情况使用默认的即可</li>
<li>handler 饱和策略，即为当任务队列和线程池中线程数均达到饱和时采取的<br>应对策略，默认是AbordPolicy，表示无法处理新的任务，并在有新任务提交时<br>抛出 RejectedExecutionException 异常</li>
</ol>
<h3 id="添加一个任务时的情况？"><a href="#添加一个任务时的情况？" class="headerlink" title="添加一个任务时的情况？"></a>添加一个任务时的情况？</h3><p>以上7个参数决定了线程池执行一个任务的策略，当一个任务被添加时</p>
<ol>
<li>线程数量未达到 corePoolSize，则新建一个线程(核心线程)执行任务</li>
<li>线程数量达到了 corePools，则将任务移入队列等待</li>
<li>队列已满，新建线程(非核心线程)执行任务</li>
<li>队列已满，总线程数又达到了maximumPoolSize，执行饱和策略</li>
</ol>
<h3 id="Executor和Executors的区别？"><a href="#Executor和Executors的区别？" class="headerlink" title="Executor和Executors的区别？"></a>Executor和Executors的区别？</h3><ol>
<li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来<br>满足业务的需求</li>
<li>Executor 是一个接口，这个接口就声明了一个 execute 方法，参数<br>是一个 Runnable 对象，这个方法其实就是向线程池中提交任务的核心方<br>法，command 参数即为要执行的任务的 Runnable对象</li>
<li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了<br>更多的方法我们能获得任务执行的状态并且可以获取任务的返回值</li>
<li>使用 ThreadPoolExecutor 可以创建自定义线程池</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以<br>等待计算的完成，并可以使用get()方法获取计算的结果</li>
</ol>
<h3 id="ExecutorService是什么？"><a href="#ExecutorService是什么？" class="headerlink" title="ExecutorService是什么？"></a>ExecutorService是什么？</h3><p>ExecutorService接口继承Executor接口，有一个submit方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交新任务到线程池中，返回一个 Future 对象，这个对象封装了获取任务执行状态信息的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交新任务到线程池中，将任务执行状态信息储存在 result 对象中，</span></span><br><span class="line"><span class="comment"> * 最后返回一个 Future 对象，提供获取任务执行状态信息的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能同上，参数变成了 Runnable 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<h3 id="AbstractExecutorService是什么？"><a href="#AbstractExecutorService是什么？" class="headerlink" title="AbstractExecutorService是什么？"></a>AbstractExecutorService是什么？</h3><p>这个类实现了ExecutorService，ThreadPoolExecutor继承了这个类。<br>以下submit的重载方法，方法中先是调用newTashFor方法获取RunnableFuture<br>对象，RunnableFuture是一个接口，这个接口继承了Runnable和Future，因此<br>其对象既可以作为Runnable 对象来给execute(Runnable task) 提供参数，也<br>可以作为submit的返回值，而其实现类FutureTask则是实现了RunnableFuture<br>接口的方法，在其的run()方法中会调用创建FutureTask对象时传入的Callable<br>对象的call()方法或者是Runnable对象的run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           RunnableFuture&lt;Void&gt; ftask = <span class="keyword">this</span>.newTaskFor(task, (Object)<span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">this</span>.execute(ftask);</span><br><span class="line">           <span class="keyword">return</span> ftask;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           RunnableFuture&lt;T&gt; ftask = <span class="keyword">this</span>.newTaskFor(task);</span><br><span class="line">           <span class="keyword">this</span>.execute(ftask);</span><br><span class="line">           <span class="keyword">return</span> ftask;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor中的execute如何执行？"><a href="#ThreadPoolExecutor中的execute如何执行？" class="headerlink" title="ThreadPoolExecutor中的execute如何执行？"></a>ThreadPoolExecutor中的execute如何执行？</h3><p>两个submit方法通过execute来向线程池中提交任务AbstractExecutorService<br>并没有实现execute方法，其子类实现了execute方法，这个方法的执行逻辑可以<br>分为三步</p>
<ol>
<li>如果当前活动线程数 &lt; 指定的核心线程数，则创建并启动一个线程来执行新<br>提交的任务（此时新建的线程相当于核心线程）</li>
<li>如果当前活动线程数 &gt;= 指定的核心线程数，且缓存队列未满，则将任务添<br>加到缓存队列中</li>
<li>如果当前活动线程数 &gt;= 指定的核心线程数，且缓存队列已满，则创建并启<br>动一个线程来执行新提交的任务（此时新建的线程相当于非核心线程）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">            <span class="comment">//workerCountOf函数取得当前池线程的线程总数</span></span><br><span class="line">            <span class="comment">//如果小于核心线程数就将任务通过addWorker直接调度执行</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &lt; <span class="keyword">this</span>.corePoolSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.addWorker(command, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                c = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果大于核心线程数会进入等待队列workQueue</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) &amp;&amp; <span class="keyword">this</span>.workQueue.offer(command)) &#123;</span><br><span class="line">                <span class="keyword">int</span> recheck = <span class="keyword">this</span>.ctl.get();</span><br><span class="line">                <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; <span class="keyword">this</span>.remove(command)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.reject(command);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.addWorker((Runnable)<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">     		  <span class="comment">//如果进入队列失败，比如有界队列达到上限或使用SynchronousQueue</span></span><br><span class="line">              <span class="comment">//将任务直接提交给线程池</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.addWorker(command, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            	<span class="comment">//如果线程数达到最大线程数提交失败，此时执行拒绝策略</span></span><br><span class="line">                <span class="keyword">this</span>.reject(command);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以看出即便当前活动的线程有空闲的，只要这个活动的线程数量小<br>于设定的核心线程数，那么依旧会启动一个新线程来执行任务，execute方法<br>中多次通过addWorker方法添加线程任务</p>
<h3 id="addWorker的作用？"><a href="#addWorker的作用？" class="headerlink" title="addWorker的作用？"></a>addWorker的作用？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>添加新的线程来将firstTask任务作为第一任务执行，执行完成之后执<br>行线程池任务队列中其他任务</li>
<li>core 参数为是否添加核心线程，true就是添加核心线程</li>
<li>获取当前线程池运行状态 runStateOf</li>
<li>如果线程池已经被停止或者关闭等，那么直接返回false</li>
<li>获取线程池中线程数</li>
<li>如果线程数大于线程池最大线程或者想添加核心线程来处理firstTask但<br>是核心线程已经饱和，或者添加非核心线程来处理firstTask但是线程池总线<br>程数已达到饱和，返回false</li>
<li>如果保存线程池状态信息的变量没发生变化，证明这个过程线程池是没有<br>发生状态变化的，使得其包装的线程池工作线程数信息加一</li>
<li>添加新的工作对象来处理任务，Worker 对象为 任务–线程 的包装类，<br>创建该对象时会创建一个新的线程 new Worker(firstTask)</li>
<li>workers是工作集中添加新建的线程包装类, workers为一个HashSet<Woker><br>的对象，保存的是线程池中的所有 Worker 对象</Woker></li>
<li>启动新建的线程，执行任务</li>
</ol>
<p>到这里就应该知道线程池存储的并不是Thread对象，而是封装后的Worker<br>对象，并且每新建一个Worker对象都会吧这个对象存入workers集合中，<br>wokers集合实际是ThreadPoolExecutor的一个HashSet<Worker>集合<br>类型的成员变量</Worker></p>
<h3 id="runWorker方法的作用？"><a href="#runWorker方法的作用？" class="headerlink" title="runWorker方法的作用？"></a>runWorker方法的作用？</h3><p>创建的线程在执行时就会调用这个对象的run方法，即调用runWorker方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(ThreadPoolExecutor.Worker w)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果Worker对象的firstTask不为空，则先执行第一个任务，即创建<br>Worker对象传入的Runnable参数<br>2, 从线程池的任务阻塞队列中取出任务，如果任务队列为空则会使线程<br>陷入阻塞，线程怎么通过 getTask() 方法从任务队列中取出任务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(task != <span class="keyword">null</span> || (task = <span class="keyword">this</span>.getTask()) != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></li>
<li>在这个方法中线程会不断从线程池的任务队列中取任务并执行执行任务<br>，直到取出的任务对象为null，此时证明线程池已经关闭或者任务队列为<br>空，这样的话证明当前线程可以被尝试回收，接下来就会跳出 while循环<br>进入 finally 语句块中执行来尝试回收线程</li>
</ol>
<h3 id="ThreadFactory是什么？"><a href="#ThreadFactory是什么？" class="headerlink" title="ThreadFactory是什么？"></a>ThreadFactory是什么？</h3><p>线程池的主要作用是为了线程复用，最开始的线程是通过ThreadFactory产生，<br>ThreadFactory是一个接口，它只有一个方法，就是用来创建线程，重写该方法<br>可以更加自由设置池子中所有线程的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="线程池中submit-和execute-方法有什么区别？"><a href="#线程池中submit-和execute-方法有什么区别？" class="headerlink" title="线程池中submit()和execute()方法有什么区别？"></a>线程池中submit()和execute()方法有什么区别？</h3><p>一个线程池可以接受任务类型有Runnable和Callable，分别对应了execute<br>和submit方法</p>
<ol>
<li>接收参数：execute()只能执行 Runnable 类型的任务。submit()可<br>以执行Runnable 和 Callable 类型的任务</li>
<li>返回值：submit()方法可以返回持有计算结果的 Future 对象，而<br>execute()没有</li>
<li>异常处理：submit()方便Exception处理，Future 表示异步计算的结<br>果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用<br>get()方法获取计算的结果</li>
</ol>
<h3 id="Executors和ThreaPoolExecutor创建线程池的区别？"><a href="#Executors和ThreaPoolExecutor创建线程池的区别？" class="headerlink" title="Executors和ThreaPoolExecutor创建线程池的区别？"></a>Executors和ThreaPoolExecutor创建线程池的区别？</h3><p>不允许使用 Executors 去创建，而是通过ThreadPoolExecutor的方式，<br>这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的<br>风险。Executors 各个方法的弊端：</p>
<ul>
<li>newFixedThreadPool 和 newSingleThreadExecutor:主要问题是堆积<br>的请求处理队列可能会耗费非常大的内存，甚至 OOM。</li>
<li>newCachedThreadPool 和 newScheduledThreadPool:主要问题是线程<br>数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM</li>
</ul>
<h3 id="如何合理配置线程池？"><a href="#如何合理配置线程池？" class="headerlink" title="如何合理配置线程池？"></a>如何合理配置线程池？</h3><p>CPU密集型</p>
<ol>
<li>查看本机CPU核数：Runtime.getRuntime().availableProcessors()</li>
<li>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU需一直全速运行</li>
<li>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</li>
<li>CPU密集型任务配置尽可能少的线程数量=&gt;公式：CPU核数+1个线程的线程池</li>
</ol>
<p>IO密集型</p>
<ol>
<li>由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，<br>如CPU核数 * 2</li>
<li>IO密集型，是说明该任务需要大量的IO，即大量的阻塞。所以在单线程上运行<br>IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待上，所以要使用多线<br>程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪<br>费掉的阻塞时间</li>
<li>配置线程公式：CPU核数 / 1-阻塞系数（0.8~0.9） =&gt; 如8核CPU：<br>8 / (1 - 0.9) = 80个线程数</li>
</ol>
<h3 id="线程组是什么？"><a href="#线程组是什么？" class="headerlink" title="线程组是什么？"></a>线程组是什么？</h3><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线<br>程对象，也可以有线程组，组中还可以有线程。一个线程只有调用start方<br>法后才会被加入线程组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新线程组，以调用这个构造方法的线程所在线程组为父线程组</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建一个新线程组，parent为指定的父线程组</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//返回在当前线程组和子线程组中活跃的线程数量（估计值）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activeCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   <span class="comment">//清除当前线程组和子线程组，需要保证当前线程组和子线程组所有线程都停止</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   <span class="comment">//中断线程组中所有的线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="线程池和线程组的区别？"><a href="#线程池和线程组的区别？" class="headerlink" title="线程池和线程组的区别？"></a>线程池和线程组的区别？</h3><p>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便<br>线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线<br>程的开销</p>
<h3 id="线程组为什么不推荐使用？"><a href="#线程组为什么不推荐使用？" class="headerlink" title="线程组为什么不推荐使用？"></a>线程组为什么不推荐使用？</h3><p>线程组ThreadGroup对象中的stop，resume，suspend会导致安全问题，主要<br>是死锁问题，已经被官方废弃</p>
<h3 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h3><p>使用场合主要解决多线程中数据数据因并发产生不一致问题。ThreadLocal为每个线<br>程的中并发访问的数据提供一个副本，通过访问副本来运行业务，在每个线程中都<br>创建了一个ThreadLocalMap对象，简单说ThreadLocal就是一种以空间换时间的<br>做法，每个线程可以访问自己内部 ThreadLocalMap 对象内的value。通过这种<br>方式，避免资源在多线程间共享这样的结果是耗费了内存，减少了线程同步所带<br>来性能消耗，也减少了线程并发控制的复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 新建一个 ThreadLocal 对象</span></span><br><span class="line">	<span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 新建 5 个子线程，run 方法中调用新建的 ThreadLocal 对象 value 的 </span></span><br><span class="line">		<span class="comment">//get/set 方法来获取/设置对应值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">// 当当前线程中 value 值不大于 5 时候继续循环</span></span><br><span class="line">					<span class="keyword">while</span> (value.get() &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">						System.out.println(Thread.currentThread().getName() + </span><br><span class="line">							<span class="string">" 的 value 值："</span> + value.get());</span><br><span class="line">						<span class="comment">// 当前线程的 value 自增一</span></span><br><span class="line">						value.set(value.get() + <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;, <span class="string">"线程 "</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序会报空指针异常，可是value是新建的一个对象，是否是没有<br>赋初始值，如果在startTest开头加value.set(0)依然报空指针异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//通过当前线程得到ThreadLocalMap</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap map = <span class="keyword">this</span>.getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                T result = e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对象为空调用这个设置初始值的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.<span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//返回threadLocals</span></span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Thread中定义了这个变量，Thread的构造方法中并未对这个变量赋值</span></span><br><span class="line">    ThreadLocalMap threadLocals;</span><br><span class="line">    <span class="comment">//threadLocals默认为null，所以会调用以下方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//获取initialValue的返回值</span></span><br><span class="line">        T value = <span class="keyword">this</span>.initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocal.ThreadLocalMap map = <span class="keyword">this</span>.getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">            TerminatingThreadLocal.register((TerminatingThreadLocal)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回null，到这里可知get为什么返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setInitialValue方法中也会给threadLocals创建一个新的对象</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap类似一个映射表，键就是当前ThreadLocal对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说多个线程中的ThreadLocalMap字段对象将对应的同一个ThreadLocal<br>对象作为 ThreadLocalMap 字段对象的键，而对应储存的值却互相独立。即同<br>一个ThreadLocal对象作为多个线程中的ThreadLocalMap对象中的键。通过这<br>种机制来完成每个线程中储存一个对应变量的值，不同线程之间这个值相互独立。</p>
<p>创建ThreadLocal对象时重写initialValue方法并返回一个非null的默认值<br>作为每个线程存储的变量的默认值，调用get方法时就不会返回null值。<br>除了在创建ThreadLocal的时候重写initialValue方法赋初始值，也可以使<br>用set方法赋初始值然后使用get得到，不过这种方法对每个线程来说都要先<br>使用set赋初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">		<span class="comment">// 重写 initialValue 方法，提供给每个线程保存的对象一个默认的值</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap是什么？"><a href="#ThreadLocalMap是什么？" class="headerlink" title="ThreadLocalMap是什么？"></a>ThreadLocalMap是什么？</h3><p>这个类很像HashMap，是ThreadLocal的静态子类，键是一个ThreadLocal对象<br>调用ThradLocal的get方法时，首先会获取当前线程的ThreadLocalMap对象，<br>如果这个对象不为空，那么就会获取这个ThreadLocalMap对象的Entry对象，<br>并获取Entry对象的value返回值，如果为空就会创建ThreadLocalMap对象，<br>value值就是initialVlaue中的返回值</p>
<h3 id="锁优化有几种方式？"><a href="#锁优化有几种方式？" class="headerlink" title="锁优化有几种方式？"></a>锁优化有几种方式？</h3><ol>
<li>减小持有锁的时间 如果线程持有锁的时间越长锁的竞争也会越激烈，<br>只在必要时进行同步</li>
<li>减小锁粒度 对于HashMap来说最重要的就是get()和put()方法，一种方式就<br>是对整个HashMap加锁，但这样加锁粒度太大，对于ConcurrentHashMap，其内<br>部进一步细分成若干HashMap ，称之为段(SEGMENT)，默认情况细分为16个段。<br>如果需要在该对象中加一个新的表项，并不是给整个对象加锁，而是根据hashcode<br>得到该表项应被存到哪个段中，然后对该段加锁，并完成put操作，多线程环境<br>如果多个线程同时进行put操作，是有可能同时接受16个线程的put操作。<br>减少锁粒度的核心就是缩小锁定对象的范围，从而减少锁冲突的可能</li>
<li>读写分离锁来替换独占锁 如果之前减少锁粒度是通过分割数据结构来实现，<br>那么读写锁是对系统功能点的分割，在读多写少的情况下使用读写锁较好</li>
<li>锁分离 读写锁根据读写操作功能上的不同进行有效分离，依据应用程序的功能<br>特点使用类似的分离思想也可以对独占锁进行分离，比如LinkedBlockingQueue<br>的实现，该类中take和put分别实现从队列中取数据和增加数据的功能，这两个<br>操作一个是在链表的前端一个是在末尾，理论上并不会冲突，该阻塞队列就是<br>用到了锁分离</li>
<li>锁粗化 通常情况为了保证多线程的有效并发，会要求每个线程持有锁的时<br>间尽量短，即完成操作后立即释放锁，但是如果对一个锁频繁进行请求、同步<br>的释放本身也会消耗系统资源，为此虚拟机在遇到一连串连续对同一个锁进<br>行请求的释放的操作时，会将所有的锁操作整合成一次对锁的请求，从而减<br>少锁的同步请求次数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在循环时应注意锁的粗化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="JVM如何优化锁？"><a href="#JVM如何优化锁？" class="headerlink" title="JVM如何优化锁？"></a>JVM如何优化锁？</h3><ol>
<li>锁偏向 如果一个线程获得了锁那么锁就进入偏向模式，当这个线程再次请求<br>锁的时候无需再做任何同步操作，在几乎没有锁竞争的场合偏向锁比较好，如果<br>每次都是不同线程来请求锁那么偏向模式会失效，以下参数可以开启偏向锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking</span><br></pre></td></tr></table></figure></li>
<li>轻量级锁 如果偏向锁失败，虚拟机并不会立即挂起线程，还会使用一种叫轻<br>量级锁的优化手段，它只是简单将对象头部作为指针，指向持有锁的线程堆栈的<br>内部，来判断一个线程是否持有对象锁，如果线程获得轻量级锁成功则会顺利进<br>入临界区。如果失败当前线程锁请求会膨胀为重量级锁</li>
<li>重量级锁 内置锁是JVM提供的最便捷的线程同步工具，在代码块或方法声明<br>synchronized关机子即可使用内置锁，内置锁在JAVA中被抽象为监视器monitor<br>，JDK1.6以前监视器可以直接认为对应底层操作系统中的互斥量mutex，这也就<br>是重量级锁</li>
<li>自旋锁 由于当前线程暂时无法获取锁，但是没有必要直接挂起，还会做最后<br>的努力。因此会让该线程先做几个空循环，如果还不能获取锁就在操作系统层面<br>挂起，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。CAS<br>问题中的unsafe 用到的就是自旋锁</li>
<li>锁消除 JVM在JIT 编译时会对运行上下文进行扫描，通过对运行上下文的扫<br>描，去除不可能存在资源竞争锁，比如在使用JDK内置的API时，StringBuffer<br>Vector，很可能在一个不可能存在并发竞争的场合使用Vector，比如在函数内<br>部创建一个Vector对象，所以JVM会将这些无用的锁去除</li>
</ol>
<h3 id="synchronized锁升级的原理是什么？"><a href="#synchronized锁升级的原理是什么？" class="headerlink" title="synchronized锁升级的原理是什么？"></a>synchronized锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid字段，在<br>第一次访问的时候threadid 为空，jvm让其持有偏向锁，并将threadid设置为<br>其线程id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果<br>一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自<br>旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用<br>的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了<br>synchronized锁的升级</p>
<h3 id="死锁是什么？"><a href="#死锁是什么？" class="headerlink" title="死锁是什么？"></a>死锁是什么？</h3><p>死锁就是两个或多个线程相互占用对方需要的资源，而都不进行释放，导致彼此<br>之间都相互等待对方释放资源，产生无限制等待的线程。注意参于死锁的线程不<br>占用CPU</p>
<h3 id="死锁的四个必要条件是什么？"><a href="#死锁的四个必要条件是什么？" class="headerlink" title="死锁的四个必要条件是什么？"></a>死锁的四个必要条件是什么？</h3><ol>
<li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被<br>一个线程(进程)占用，直到被该线程(进程)释放</li>
<li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获<br>得的资源保持不放。不剥夺条件：线程(进程)</li>
<li>已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕<br>后才释放资源</li>
<li>循环等待条件：当发生死锁时，所等待的线程（进程）必定会形成一个环路<br>（类似于死循环），造成永久阻塞</li>
</ol>
<h3 id="如何定位死锁？"><a href="#如何定位死锁？" class="headerlink" title="如何定位死锁？"></a>如何定位死锁？</h3><ol>
<li>jps 命令定位进程编号</li>
<li>jstack 找到死锁查看</li>
</ol>
<h3 id="如何解决死锁？"><a href="#如何解决死锁？" class="headerlink" title="如何解决死锁？"></a>如何解决死锁？</h3><p>采用无锁的函数，或者重入锁的中断或者限时等待。破坏循环等待条件，靠按序<br>申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件</p>
<h3 id="不变模式是什么？"><a href="#不变模式是什么？" class="headerlink" title="不变模式是什么？"></a>不变模式是什么？</h3><p>不变模式的核心思想是一个对象一旦被创建，则它的内部状态将永远不会被<br>改变，所以没有一个线程可以修改其内部状态和数据，同时其内部状态也不<br>会自行发生改变。不变模式的主要使用场景需要满足两个条件</p>
<ol>
<li>当对象创建后，其内部状态和数据不再发生任何变化</li>
<li>对象需要被共享，被多线程频繁访问</li>
</ol>
<p>由于基本数据类型和String类型在实际开发中引用极其广泛，使用不变模式<br>后所有的实例方法均不需要进行同步操作</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/31/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>2020年度总结</span></a></div><div class="next-post pull-right"><a href="/2020/12/25/Java%E5%B9%B6%E5%8F%912/"><span>Java并发2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2020/12/27/Java并发总结/';
  this.page.title = 'Java并发总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>