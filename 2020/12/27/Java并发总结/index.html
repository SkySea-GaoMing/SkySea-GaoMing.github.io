<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java并发总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java并发总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题总结"><span class="toc-number">2.</span> <span class="toc-text">面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发编程三要素是什么？"><span class="toc-number">2.1.</span> <span class="toc-text">并发编程三要素是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全问题有哪些？如何解决？"><span class="toc-number">2.2.</span> <span class="toc-text">线程安全问题有哪些？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程和进程？"><span class="toc-number">2.3.</span> <span class="toc-text">什么是线程和进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程和进程有什么区别？"><span class="toc-number">2.4.</span> <span class="toc-text">线程和进程有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步的区别？"><span class="toc-number">2.5.</span> <span class="toc-text">同步和异步的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行和并发？"><span class="toc-number">2.6.</span> <span class="toc-text">并行和并发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区是什么？"><span class="toc-number">2.7.</span> <span class="toc-text">临界区是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是多线程，多线程的优劣？"><span class="toc-number">2.8.</span> <span class="toc-text">什么是多线程，多线程的优劣？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用多线程呢？"><span class="toc-number">2.9.</span> <span class="toc-text">为什么要使用多线程呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是上下文切换？"><span class="toc-number">2.10.</span> <span class="toc-text">什么是上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程和用户线程有什么区别？"><span class="toc-number">2.11.</span> <span class="toc-text">守护线程和用户线程有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中活锁和死锁有什么区别？"><span class="toc-number">2.12.</span> <span class="toc-text">Java中活锁和死锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么检测一个线程是否拥有锁？"><span class="toc-number">2.13.</span> <span class="toc-text">怎么检测一个线程是否拥有锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中死锁、活锁和饥饿有什么区别？"><span class="toc-number">2.14.</span> <span class="toc-text">Java中死锁、活锁和饥饿有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发级别分为几类？"><span class="toc-number">2.15.</span> <span class="toc-text">并发级别分为几类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无障碍是什么？"><span class="toc-number">2.16.</span> <span class="toc-text">无障碍是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无锁是什么？"><span class="toc-number">2.17.</span> <span class="toc-text">无锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无等待是什么？"><span class="toc-number">2.18.</span> <span class="toc-text">无等待是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程有哪几种方式？"><span class="toc-number">2.19.</span> <span class="toc-text">创建线程有哪几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程的三种方式的对比？"><span class="toc-number">2.20.</span> <span class="toc-text">创建线程的三种方式的对比？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable和callable有什么区别？"><span class="toc-number">2.21.</span> <span class="toc-text">runnable和callable有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runnable和Callable能相互转换吗？"><span class="toc-number">2.22.</span> <span class="toc-text">Runnable和Callable能相互转换吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的run-和start-有什么区别？"><span class="toc-number">2.23.</span> <span class="toc-text">线程的run()和start()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Callable和Future？"><span class="toc-number">2.24.</span> <span class="toc-text">什么是Callable和Future？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable接口的具体内容是什么？"><span class="toc-number">2.25.</span> <span class="toc-text">Callable接口的具体内容是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future接口的具体内容？"><span class="toc-number">2.26.</span> <span class="toc-text">Future接口的具体内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask是什么？"><span class="toc-number">2.27.</span> <span class="toc-text">FutureTask是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用Runnable还是Thread？"><span class="toc-number">2.28.</span> <span class="toc-text">用Runnable还是Thread？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的生命周期是怎样的？"><span class="toc-number">2.29.</span> <span class="toc-text">线程的生命周期是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中用到的线程调度算法是什么？"><span class="toc-number">2.30.</span> <span class="toc-text">Java中用到的线程调度算法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的调度策略是什么？"><span class="toc-number">2.31.</span> <span class="toc-text">线程的调度策略是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程调度器和时间分片？"><span class="toc-number">2.32.</span> <span class="toc-text">什么是线程调度器和时间分片？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何停止一个正在运行的线程？"><span class="toc-number">2.33.</span> <span class="toc-text">如何停止一个正在运行的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义标志与中断标志的区别？"><span class="toc-number">2.34.</span> <span class="toc-text">自定义标志与中断标志的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目标线程与当前线程的区别？"><span class="toc-number">2.35.</span> <span class="toc-text">目标线程与当前线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中interrupted和isInterrupted方法的区别？"><span class="toc-number">2.36.</span> <span class="toc-text">Java中interrupted和isInterrupted方法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存一致性问题是什么？"><span class="toc-number">2.37.</span> <span class="toc-text">缓存一致性问题是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存不一致的根源是什么？"><span class="toc-number">2.38.</span> <span class="toc-text">缓存不一致的根源是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存一致性协议是什么？"><span class="toc-number">2.39.</span> <span class="toc-text">缓存一致性协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存一致性协议有哪些？"><span class="toc-number">2.40.</span> <span class="toc-text">缓存一致性协议有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存模型的具体内容？"><span class="toc-number">2.41.</span> <span class="toc-text">Java内存模型的具体内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性是什么？"><span class="toc-number">2.42.</span> <span class="toc-text">原子性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性是什么？"><span class="toc-number">2.43.</span> <span class="toc-text">可见性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序性是什么？"><span class="toc-number">2.44.</span> <span class="toc-text">有序性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令重排的规则是什么？"><span class="toc-number">2.45.</span> <span class="toc-text">指令重排的规则是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程同步？"><span class="toc-number">2.46.</span> <span class="toc-text">什么是线程同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步的实现有哪些方式？"><span class="toc-number">2.47.</span> <span class="toc-text">同步的实现有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock是什么？"><span class="toc-number">2.48.</span> <span class="toc-text">ReentrantLock是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重入锁的中断响应是什么？"><span class="toc-number">2.49.</span> <span class="toc-text">重入锁的中断响应是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重入锁申请等待限时机制？"><span class="toc-number">2.50.</span> <span class="toc-text">重入锁申请等待限时机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized是什么？"><span class="toc-number">2.51.</span> <span class="toc-text">synchronized是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与线程同步以及线程调度相关的方法有哪些？"><span class="toc-number">2.52.</span> <span class="toc-text">与线程同步以及线程调度相关的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平锁与非公平锁的区别？"><span class="toc-number">2.53.</span> <span class="toc-text">公平锁与非公平锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition是什么？"><span class="toc-number">2.54.</span> <span class="toc-text">Condition是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java多线程中调用wait-和sleep-方法有什么不同？"><span class="toc-number">2.55.</span> <span class="toc-text">Java多线程中调用wait()和sleep()方法有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么wait方法要在循环中调用？"><span class="toc-number">2.56.</span> <span class="toc-text">为什么wait方法要在循环中调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么wait和notify方法要在同步块中调用？"><span class="toc-number">2.57.</span> <span class="toc-text">为什么wait和notify方法要在同步块中调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么wait-notify和notifyAll这些方法不在thread类里面？"><span class="toc-number">2.58.</span> <span class="toc-text">为什么wait, notify和notifyAll这些方法不在thread类里面？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread类中的yield方法有什么作用？"><span class="toc-number">2.59.</span> <span class="toc-text">Thread类中的yield方法有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的fork-join框架是什么？"><span class="toc-number">2.60.</span> <span class="toc-text">Java中的fork join框架是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join和yield的区别？"><span class="toc-number">2.61.</span> <span class="toc-text">join和yield的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread类中的start-和run-方法有什么区别？"><span class="toc-number">2.62.</span> <span class="toc-text">Thread类中的start()和run()方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步和线程互斥的区别？"><span class="toc-number">2.63.</span> <span class="toc-text">线程同步和线程互斥的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监视器-Monitor-内部，是如何做线程同步的？"><span class="toc-number">2.64.</span> <span class="toc-text">监视器(Monitor)内部，是如何做线程同步的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#as-if-serial规则和happens-before规则的区别？"><span class="toc-number">2.65.</span> <span class="toc-text">as-if-serial规则和happens-before规则的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发工具有哪些？"><span class="toc-number">2.66.</span> <span class="toc-text">并发工具有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore是什么？"><span class="toc-number">2.67.</span> <span class="toc-text">Semaphore是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadWriteLock是什么？"><span class="toc-number">2.68.</span> <span class="toc-text">ReadWriteLock是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch是什么？"><span class="toc-number">2.69.</span> <span class="toc-text">CountDownLatch是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CycliBarrier是什么？"><span class="toc-number">2.70.</span> <span class="toc-text">CycliBarrier是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LockSupport是什么？"><span class="toc-number">2.71.</span> <span class="toc-text">LockSupport是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存间交互操作有哪些？"><span class="toc-number">2.72.</span> <span class="toc-text">内存间交互操作有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的volatile变量是什么？"><span class="toc-number">2.73.</span> <span class="toc-text">Java中的volatile变量是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile如何保证可见性？"><span class="toc-number">2.74.</span> <span class="toc-text">volatile如何保证可见性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile的原理？"><span class="toc-number">2.75.</span> <span class="toc-text">volatile的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile能保证原子性吗？"><span class="toc-number">2.76.</span> <span class="toc-text">volatile能保证原子性吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized和volatile关键字的区别？"><span class="toc-number">2.77.</span> <span class="toc-text">synchronized和volatile关键字的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重入锁的实现原理？"><span class="toc-number">2.78.</span> <span class="toc-text">可重入锁的实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized和ReentrantLock-的区别？"><span class="toc-number">2.79.</span> <span class="toc-text">synchronized和ReentrantLock 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无锁是什么？-1"><span class="toc-number">2.80.</span> <span class="toc-text">无锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS是什么？"><span class="toc-number">2.81.</span> <span class="toc-text">CAS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS算法如何实现？"><span class="toc-number">2.82.</span> <span class="toc-text">CAS算法如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在Java-API中有哪些原子类？"><span class="toc-number">2.83.</span> <span class="toc-text">在Java API中有哪些原子类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomic的原理？"><span class="toc-number">2.84.</span> <span class="toc-text">atomic的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS的原理？"><span class="toc-number">2.85.</span> <span class="toc-text">CAS的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe类的作用？"><span class="toc-number">2.86.</span> <span class="toc-text">Unsafe类的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS的缺点是什么？"><span class="toc-number">2.87.</span> <span class="toc-text">CAS的缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicReference是什么？"><span class="toc-number">2.88.</span> <span class="toc-text">AtomicReference是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA问题是什么？"><span class="toc-number">2.89.</span> <span class="toc-text">ABA问题是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决ABA问题？"><span class="toc-number">2.90.</span> <span class="toc-text">如何解决ABA问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS是什么？"><span class="toc-number">2.91.</span> <span class="toc-text">AQS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-锁类型有哪些？"><span class="toc-number">2.92.</span> <span class="toc-text">AQS 锁类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-的原理是什么？"><span class="toc-number">2.93.</span> <span class="toc-text">AQS 的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLH-是什么？"><span class="toc-number">2.94.</span> <span class="toc-text">CLH 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS如何实现？"><span class="toc-number">2.95.</span> <span class="toc-text">AQS如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-的数据结构？"><span class="toc-number">2.96.</span> <span class="toc-text">AQS 的数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waitStatus-的取值情况？"><span class="toc-number">2.97.</span> <span class="toc-text">waitStatus 的取值情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步状态State-是什么？"><span class="toc-number">2.98.</span> <span class="toc-text">同步状态State 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程加入等待队列的底层原理？"><span class="toc-number">2.99.</span> <span class="toc-text">线程加入等待队列的底层原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS的设计模式"><span class="toc-number">2.100.</span> <span class="toc-text">AQS的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步锁如何唤醒后继节点？"><span class="toc-number">2.101.</span> <span class="toc-text">同步锁如何唤醒后继节点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板方法有哪些？"><span class="toc-number">2.102.</span> <span class="toc-text">模板方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义同步器的实现？"><span class="toc-number">2.103.</span> <span class="toc-text">自定义同步器的实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#某个线程获取锁失败的后续流程是什么？"><span class="toc-number">2.104.</span> <span class="toc-text">某个线程获取锁失败的后续流程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列是什么数据结构？"><span class="toc-number">2.105.</span> <span class="toc-text">队列是什么数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排队等候机制中的线程，什么时候有机会获取锁？"><span class="toc-number">2.106.</span> <span class="toc-text">排队等候机制中的线程，什么时候有机会获取锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处于排队等候机制中的线程一直无法获取锁？"><span class="toc-number">2.107.</span> <span class="toc-text">处于排队等候机制中的线程一直无法获取锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock函数通过Acquire方法进行加锁，如何实现？"><span class="toc-number">2.108.</span> <span class="toc-text">Lock函数通过Acquire方法进行加锁，如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS如何实现非公平锁和共享锁？"><span class="toc-number">2.109.</span> <span class="toc-text">AQS如何实现非公平锁和共享锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义阻塞队列如何实现生产者消费者模型？"><span class="toc-number">2.110.</span> <span class="toc-text">自定义阻塞队列如何实现生产者消费者模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的作用是什么？"><span class="toc-number">2.111.</span> <span class="toc-text">线程池的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池有哪几种创建方式？"><span class="toc-number">2.112.</span> <span class="toc-text">线程池有哪几种创建方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池为什么不用Executors的静态方法？"><span class="toc-number">2.113.</span> <span class="toc-text">线程池为什么不用Executors的静态方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池有什么优点？"><span class="toc-number">2.114.</span> <span class="toc-text">线程池有什么优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拒绝策略有哪些？"><span class="toc-number">2.115.</span> <span class="toc-text">拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池都有哪些状态？"><span class="toc-number">2.116.</span> <span class="toc-text">线程池都有哪些状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown-和shutdownNow-的区别？"><span class="toc-number">2.117.</span> <span class="toc-text">shutdown()和shutdownNow()的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isTerminated-和isShutdown-的区别？"><span class="toc-number">2.118.</span> <span class="toc-text">isTerminated()和isShutdown()的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的生命周期？"><span class="toc-number">2.119.</span> <span class="toc-text">线程池的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池核心如何设计？"><span class="toc-number">2.120.</span> <span class="toc-text">线程池核心如何设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunnableFuture-对象的作用？"><span class="toc-number">2.121.</span> <span class="toc-text">RunnableFuture 对象的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的直接父类和间接父类的作用？"><span class="toc-number">2.122.</span> <span class="toc-text">线程池的直接父类和间接父类的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute-具体如何实现？"><span class="toc-number">2.123.</span> <span class="toc-text">execute 具体如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker-是什么？"><span class="toc-number">2.124.</span> <span class="toc-text">Worker 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadFactory是什么？"><span class="toc-number">2.125.</span> <span class="toc-text">ThreadFactory是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runWorker-方法具体实现？"><span class="toc-number">2.126.</span> <span class="toc-text">runWorker 方法具体实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addWorker-方法的作用？"><span class="toc-number">2.127.</span> <span class="toc-text">addWorker 方法的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor的运行机制？"><span class="toc-number">2.128.</span> <span class="toc-text">ThreadPoolExecutor的运行机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor和Executors的区别？"><span class="toc-number">2.129.</span> <span class="toc-text">Executor和Executors的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池参数如何设置？"><span class="toc-number">2.130.</span> <span class="toc-text">线程池参数如何设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么创建线程池？"><span class="toc-number">2.131.</span> <span class="toc-text">怎么创建线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker-线程如何回收？"><span class="toc-number">2.132.</span> <span class="toc-text">Worker 线程如何回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心线程如何保证不被销毁？"><span class="toc-number">2.133.</span> <span class="toc-text">核心线程如何保证不被销毁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务执行机制是什么样的？"><span class="toc-number">2.134.</span> <span class="toc-text">任务执行机制是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务缓冲是什么？"><span class="toc-number">2.135.</span> <span class="toc-text">任务缓冲是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞队列是什么？"><span class="toc-number">2.136.</span> <span class="toc-text">阻塞队列是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的阻塞队列有哪些？"><span class="toc-number">2.137.</span> <span class="toc-text">常用的阻塞队列有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池如何设计？"><span class="toc-number">2.138.</span> <span class="toc-text">线程池如何设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池中submit-和execute-方法有什么区别？"><span class="toc-number">2.139.</span> <span class="toc-text">线程池中submit()和execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executors和ThreaPoolExecutor创建线程池的区别？"><span class="toc-number">2.140.</span> <span class="toc-text">Executors和ThreaPoolExecutor创建线程池的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池被创建后里面有线程吗？"><span class="toc-number">2.141.</span> <span class="toc-text">线程池被创建后里面有线程吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心线程数会被回收吗？"><span class="toc-number">2.142.</span> <span class="toc-text">核心线程数会被回收吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程组是什么？"><span class="toc-number">2.143.</span> <span class="toc-text">线程组是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池和线程组的区别？"><span class="toc-number">2.144.</span> <span class="toc-text">线程池和线程组的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程组为什么不推荐使用？"><span class="toc-number">2.145.</span> <span class="toc-text">线程组为什么不推荐使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ThreadLocal变量？"><span class="toc-number">2.146.</span> <span class="toc-text">什么是ThreadLocal变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocalMap是什么？"><span class="toc-number">2.147.</span> <span class="toc-text">ThreadLocalMap是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁优化有几种方式？"><span class="toc-number">2.148.</span> <span class="toc-text">锁优化有几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM如何优化锁？"><span class="toc-number">2.149.</span> <span class="toc-text">JVM如何优化锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized锁升级的原理是什么？"><span class="toc-number">2.150.</span> <span class="toc-text">synchronized锁升级的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程死锁？"><span class="toc-number">2.151.</span> <span class="toc-text">什么是线程死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何定位死锁？"><span class="toc-number">2.152.</span> <span class="toc-text">如何定位死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不变模式是什么？"><span class="toc-number">2.153.</span> <span class="toc-text">不变模式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-如果一直自旋有什么问题？怎么解决？"><span class="toc-number">2.154.</span> <span class="toc-text">CAS 如果一直自旋有什么问题？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么cpu密集设置cpu核数-1而不是-1？"><span class="toc-number">2.155.</span> <span class="toc-text">为什么cpu密集设置cpu核数+1而不是-1？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronize的实现原理说下？字节码和对象头？"><span class="toc-number">2.156.</span> <span class="toc-text">synchronize的实现原理说下？字节码和对象头？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java并发总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/12/27/Java并发总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xiaowangbangzhu&#x2F;p&#x2F;10443289.html</span><br><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;71355?type&#x3D;post&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;1</span><br><span class="line">&amp;channel&#x3D;-1&amp;source_id&#x3D;search_post_nctrack</span><br><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;334?type&#x3D;all&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;1&amp;</span><br><span class="line">channel&#x3D;-1&amp;source_id&#x3D;search_all_nctrack</span><br></pre></td></tr></table></figure>
<h2 id="面试题总结"><a href="#面试题总结" class="headerlink" title="面试题总结"></a>面试题总结</h2><h3 id="并发编程三要素是什么？"><a href="#并发编程三要素是什么？" class="headerlink" title="并发编程三要素是什么？"></a>并发编程三要素是什么？</h3><ol>
<li>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作<br>要么全部执行成功要么全部执行失败</li>
<li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到<br>（synchronized,volatile）</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令<br>进行重排序）</li>
</ol>
<h3 id="线程安全问题有哪些？如何解决？"><a href="#线程安全问题有哪些？如何解决？" class="headerlink" title="线程安全问题有哪些？如何解决？"></a>线程安全问题有哪些？如何解决？</h3><ol>
<li>线程切换带来的原子性问题 JDK Atomic开头的原子类、synchronized、LOCK</li>
<li>缓存导致的可见性问题 synchronized、volatile、LOCK</li>
<li>编译优化带来的有序性问题 Happens-Before规则、as-if-serial规则<br>和内存屏障</li>
</ol>
<h3 id="什么是线程和进程？"><a href="#什么是线程和进程？" class="headerlink" title="什么是线程和进程？"></a>什么是线程和进程？</h3><ol>
<li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是<br>进程中的实际运作单位</li>
<li>进程是一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空<br>间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就<br>是一个进程</li>
</ol>
<h3 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h3><ol>
<li>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调<br>度和执行的基本单位</li>
<li>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之<br>间的切换会有较大的开销，线程可以看做轻量级的进程，同一类线程共享代<br>码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线<br>程之间切换的开销小</li>
<li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是<br>多条线（线程）共同完成的</li>
<li>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的<br>地址空间和资源是相互独立的</li>
<li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但<br>是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮</li>
<li>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。<br>但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程<br>执行控制，两者均可并发执行</li>
</ol>
<h3 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h3><p>同步和异步通常用来形容一次方法调用。同步方法一旦开始，调用者必须等<br>到方法调用返回后才能继续后面的操作。异步方法更像一个消息传递，一旦<br>开始就会立即返回，调用者就会执行后面的操作</p>
<h3 id="并行和并发？"><a href="#并行和并发？" class="headerlink" title="并行和并发？"></a>并行和并发？</h3><ol>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，<br>从逻辑上来看那些任务是同时执行</li>
<li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真<br>正意义上的“同时进行”</li>
<li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线<br>程执行所以不存在线程不安全情况，也就不存在临界区的问题</li>
</ol>
<h3 id="临界区是什么？"><a href="#临界区是什么？" class="headerlink" title="临界区是什么？"></a>临界区是什么？</h3><p>临界区用来表示一种公共资源或者说是共享资源，多个线程都可以使用这个<br>资源，但是在一个时刻只有一个线程能够使用这个资源，其余线程都要等待</p>
<h3 id="什么是多线程，多线程的优劣？"><a href="#什么是多线程，多线程的优劣？" class="headerlink" title="什么是多线程，多线程的优劣？"></a>什么是多线程，多线程的优劣？</h3><p>多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同<br>的线程来执行不同的任务</p>
<ol>
<li>优势 可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的<br>时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效<br>率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</li>
<li>劣势 线程也是程序，所以线程需要占用内存，线程越多占用内存也越<br>多，多线程需要协调和管理，所以需要 CPU 时间跟踪线程，线程之间对<br>共享资源的访问会相互影响，必须解决竞用共享资源的问题</li>
</ol>
<h3 id="为什么要使用多线程呢？"><a href="#为什么要使用多线程呢？" class="headerlink" title="为什么要使用多线程呢？"></a>为什么要使用多线程呢？</h3><ol>
<li>从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最<br>小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU 时代<br>意味着多个线程可以同时运行，这减少了线程上下文切换的开销</li>
<li>从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千<br>万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多<br>线程机制可以大大提高系统整体的并发能力以及性能</li>
</ol>
<p>从计算机底层来说</p>
<ol>
<li>单核时代： 在单核时代多线程主要是为了提高CPU 和IO 设备的综合<br>利用率。举个例子：当只有一个线程的时候会导致CPU 计算时，IO 设备<br>空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率<br>目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程<br>执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用<br>率就可以在理想情况下达到 100%了</li>
<li>多核时代:多核时代多线程主要是为了提高CPU 利用率。举个例子：<br>假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会<br>一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心<br>被利用到，这样就提高了 CPU 的利用率</li>
</ol>
<h3 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h3><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态<br>，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存<br>到再加载的过程就是一次上下文切换</p>
<h3 id="守护线程和用户线程有什么区别？"><a href="#守护线程和用户线程有什么区别？" class="headerlink" title="守护线程和用户线程有什么区别？"></a>守护线程和用户线程有什么区别？</h3><ol>
<li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、<br>连接网络的子线程等都是用户线程</li>
<li>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守<br>护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，<br>守护线程会随 JVM 一起结束工作</li>
</ol>
<p>注意如下</p>
<ol>
<li>setDaemon(true)必须在start()方法前执行，否则会抛出异常</li>
<li>在守护线程中产生的新线程也是守护线程</li>
<li>不要把重要的任务放在守护线程，比如读写操作或者计算逻辑</li>
</ol>
<h3 id="Java中活锁和死锁有什么区别？"><a href="#Java中活锁和死锁有什么区别？" class="headerlink" title="Java中活锁和死锁有什么区别？"></a>Java中活锁和死锁有什么区别？</h3><p>不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种<br>特殊的饥饿，活锁和死锁的主要区别是前者 进程的状态可以改变但是却不能继<br>续执行</p>
<h3 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h3><p>在java.lang.Thread中有一个方法叫holdsLock()，它返回true当且仅当当前线程<br>拥有某个具体对象的锁</p>
<h3 id="Java中死锁、活锁和饥饿有什么区别？"><a href="#Java中死锁、活锁和饥饿有什么区别？" class="headerlink" title="Java中死锁、活锁和饥饿有什么区别？"></a>Java中死锁、活锁和饥饿有什么区别？</h3><p>死锁就是多个线程相互竞争资源而造成的彼此阻塞，饥饿是指一个或多个线<br>程因为种种原因无法获得所需资源，活锁就是获得资源但还未加上锁时就又<br>将资源释放</p>
<h3 id="并发级别分为几类？"><a href="#并发级别分为几类？" class="headerlink" title="并发级别分为几类？"></a>并发级别分为几类？</h3><ol>
<li>阻塞</li>
<li>无饥饿</li>
<li>无障碍</li>
<li>无锁</li>
<li>无等待 </li>
</ol>
<h3 id="无障碍是什么？"><a href="#无障碍是什么？" class="headerlink" title="无障碍是什么？"></a>无障碍是什么？</h3><p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍执行，那么不会因<br>为临界区的问题导致一方被挂起，也就是可以共同修改数据，可是这样的<br>话数据就可能出问题，对于无障碍线程来说一旦出现这种情况就会对所做<br>的修改进行回滚，确保数据安全，如果没有数据竞争发生那么就很顺利。<br>如果说阻塞的控制方式是悲观策略，系统认为两个线程有可能发生冲突因<br>此以保护数据为第一优先级，那么非阻塞调度就是乐观策略，认为两个线<br>程不会发生冲突，但是一旦检测到冲突就会回滚。一种可行的无障碍实现<br>可以依赖一个一致性标记来实现，线程在操作之前先读取这个标记，在操<br>作完成后再次读取这个标记，如果两者一致说明资源访问没有冲突，如果<br>不一致说明则需要重试操作</p>
<h3 id="无锁是什么？"><a href="#无锁是什么？" class="headerlink" title="无锁是什么？"></a>无锁是什么？</h3><p>无锁的并行都是无障碍的，在无锁的情况下每个线程都尝试对临界区进行<br>访问，但是无锁的并发保证必然有一个线程能够在有限步完成操作离开临<br>界区。实际上每个线程都会读取一个数据副本互不干涉</p>
<h3 id="无等待是什么？"><a href="#无等待是什么？" class="headerlink" title="无等待是什么？"></a>无等待是什么？</h3><p>无锁只要求有一个线程在有限步内完成操作，而无等待在无锁的基础上更<br>进一步扩展，要求所有线程都要在有限步内完成。一种无等待结构是RCU，<br>基本思想是对数据的读不加控制，所有的读线程都是无等待的，在写数据<br>的时候先取得数据的副本，然后只修改副本，修改完成后回写数据。这里<br>我觉得应该没有用到一致性标记</p>
<h3 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h3><p>创建线程有四种方式</p>
<ol>
<li>继承Thread类 这个子类需要重写run方法，一个子类的实例可以被分配<br>空间并执行start方法</li>
<li>实现Runnable接口 这个类中实现run方法。创建这个类的实例并作为参数传<br>递给Thread类然后Thread类执行start方法</li>
<li>实现Callable接口 但是Thread的构造方法中并没有提供Thread<br>(Callable callabe) 类型的方法，需要借助另一个类FutureTask<br>类，这个类实现了RunnableFuture 接口，而这个RunnableFuture<br>接口继承了Runnable 接口和Future 接口，所以这个 FutureTask<br>类的对象是可以作为参数作为 Thread(Runnable runnable) 构造<br>方法的参数的。而FutureTask的构造方法又提供通过传入Callable<br>对象作为参数的形式：FutureTask(Callable callable) 。而其<br>run 方法会调用传入的 Callable对象的 call 方法，其本质上<br>还是通过new Thread(Runnable runnable)</li>
</ol>
<ul>
<li>创建实现Callable接口的类myCallable</li>
<li>以myCallable为参数创建FutureTask对象</li>
<li>将FutureTask作为参数创建Thread对象</li>
<li>调用线程对象的start()方法</li>
</ul>
<ol start="4">
<li>使用Executors工具类创建线程池</li>
</ol>
<h3 id="创建线程的三种方式的对比？"><a href="#创建线程的三种方式的对比？" class="headerlink" title="创建线程的三种方式的对比？"></a>创建线程的三种方式的对比？</h3><ol>
<li>采用实现Runnable、Callable接口的方式创建多线程</li>
</ol>
<ul>
<li>优点 线程类只是实现了Runnable接口或Callable接口，还可以继承<br>其他类。在这种方式下，多个线程可以共享同一个target 对象，所以非<br>常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和<br>数据分开，形成清晰的模型，较好地体现了面向对象的思想</li>
<li>缺点 编程稍微复杂，如果要访问当前线程，则必须使用Thread.<br>currentThread()方法</li>
</ul>
<ol start="2">
<li>使用继承Thread类的方式创建多线程</li>
</ol>
<ul>
<li>优点 编写简单，如果需要访问当前线程，则无需使用Thread.<br>currentThread()方法，直接使用this即可获得当前线程</li>
<li>缺点 线程类已经继承了Thread类，所以不能再继承其他父类</li>
</ul>
<h3 id="runnable和callable有什么区别？"><a href="#runnable和callable有什么区别？" class="headerlink" title="runnable和callable有什么区别？"></a>runnable和callable有什么区别？</h3><ol>
<li>相同点 都是接口，都可以编写多线程程序，都采用start()启动线程</li>
<li>Runnable接口run方法无返回值，Callable接口call方法有返回值，<br>是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li>
<li>Runnable接口不能抛出检查型异常，Callable接口call方法允许通<br>过throws抛出检查型异常，可以获取异常信息，注意运行时异常可以不<br>处理</li>
<li>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得<br>到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。运行<br>Callable任务可以拿到一个Future对象，表示异步计算的结果。它提<br>供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结<br>果。通过Future对象可以了解任务执行情况，可取消任务的执行，还<br>可获取执行结果</li>
</ol>
<h3 id="Runnable和Callable能相互转换吗？"><a href="#Runnable和Callable能相互转换吗？" class="headerlink" title="Runnable和Callable能相互转换吗？"></a>Runnable和Callable能相互转换吗？</h3><p>工具类Executors 可以实现Runnable 对象和Callable 对象之间的相<br>互转换。（Executors.callable（Runnable task）或 Executors.<br>callable（Runnable task，Object resule））</p>
<h3 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h3><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。<br>run() 可以重复调用，而 start() 只能调用一次</p>
<h3 id="什么是Callable和Future？"><a href="#什么是Callable和Future？" class="headerlink" title="什么是Callable和Future？"></a>什么是Callable和Future？</h3><ol>
<li>Callable 接口类似于Runnable，但是Runnable不会返回结果，并且<br>无法抛出返回结果的异常，而Callable被线程执行后，可以返回值，这个<br>返回值可以被Future拿到，Future可以拿到异步执行任务的返回值</li>
<li>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果<br>。所以说 Callable用于产生结果，Future用于获取结果</li>
</ol>
<h3 id="Callable接口的具体内容是什么？"><a href="#Callable接口的具体内容是什么？" class="headerlink" title="Callable接口的具体内容是什么？"></a>Callable接口的具体内容是什么？</h3><p>这个接口提供了一个call方法，并且这个方法提供了一个返回值作为任务<br>的执行结果</p>
<h3 id="Future接口的具体内容？"><a href="#Future接口的具体内容？" class="headerlink" title="Future接口的具体内容？"></a>Future接口的具体内容？</h3><p>Future接口提供了一些方法来获取向线程池提交的任务的执行状态和结果<br>的信息</p>
<ol>
<li>cancel 尝试取消执行提交的对应任务，如果对应任务已经执行完成或<br>者已经被取消或者是其他原因不能被取消</li>
<li>isCancelled 如果提交的对应任务还没有完全执行完成之前就被取消<br>了，那么方法会返回true，否则返回false</li>
<li>isDone 返回任务是否完成：包括下面几种情况</li>
</ol>
<ul>
<li>任务正常执行完成</li>
<li>执行过程发生异常</li>
<li>任务被取消</li>
<li>上面几种情况发生，方法均会返回 true，</li>
<li>如果任务正在执行，或者还未执行，那么方法返回 false</li>
</ul>
<ol start="4">
<li>get 阻塞调用该方法的线程，直到提交的对应任务执行完成之后，如果<br>在调用线程阻塞的过程中发生了中断，那么方法抛出中断异常</li>
</ol>
<h3 id="FutureTask是什么？"><a href="#FutureTask是什么？" class="headerlink" title="FutureTask是什么？"></a>FutureTask是什么？</h3><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个<br>Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获<br>取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才<br>能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask对<br>象可以对调用了 Callable 和 Runnable 的对象进行包装，由于<br>FutureTask 也是Runnable 接口的实现类，所以 FutureTask<br>也可以放入线程池中</p>
<h3 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h3><p>Java 不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他<br>类，当然是调用 Runnable接口。注意一点，有些博客会说Runnable更容易<br>实现资源共享，能多个线程同时处理一个资源，事实上忽视Thread本身也<br>可以当成一个Runnable对象作为参数传给Thread，只是一般不这样写</p>
<h3 id="线程的生命周期是怎样的？"><a href="#线程的生命周期是怎样的？" class="headerlink" title="线程的生命周期是怎样的？"></a>线程的生命周期是怎样的？</h3><ol>
<li>新建（NEW）：当线程对象对创建后，即进入了新建状态</li>
<li>就绪状态（Runnable）：当调用线程对象的start()方法，线程即进入<br>就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等<br>待CPU调度执行，并不是说执行了t.start()此线程立即就会执行</li>
<li>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线<br>程才得以真正执行，即进入到运行状态。就绪状态是进入到运行状态的唯一<br>入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中</li>
<li>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放<br>弃对CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状<br>态，才有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同<br>，阻塞状态又可以分为三种：</li>
</ol>
<ul>
<li>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻<br>塞状态</li>
<li>同步阻塞：线程在获取synchronized同步锁失败(因为锁被其它线程所<br>占用)，它会进入同步阻塞状态</li>
<li>其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线<br>程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超<br>时、或者I/O处理完毕时，线程重新转入就绪状态</li>
</ul>
<ol start="5">
<li>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线<br>程结束生命周期，直接调用线程的stop方法来结束一个线程，一般不用</li>
</ol>
<h3 id="Java中用到的线程调度算法是什么？"><a href="#Java中用到的线程调度算法是什么？" class="headerlink" title="Java中用到的线程调度算法是什么？"></a>Java中用到的线程调度算法是什么？</h3><p>分时调度模型和抢占式调度模型</p>
<ol>
<li>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每<br>个线程占用的 CPU 的时间片这个也比较好理解</li>
<li>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线<br>程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程<br>，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU<br>。Thread类提供的setPriority(int newPriority) 方法来设置线程<br>的优先级，线程的优先级越高，其越容易得到 CPU 资源</li>
</ol>
<h3 id="线程的调度策略是什么？"><a href="#线程的调度策略是什么？" class="headerlink" title="线程的调度策略是什么？"></a>线程的调度策略是什么？</h3><p>线程调度器选择优先级最高的线程运行，但是如果发生以下情况，就会终止线<br>程的运行</p>
<ol>
<li>线程体中调用了 yield 方法让出了对 cpu 的占用权利</li>
<li>线程体中调用了 sleep 方法使线程进入睡眠状态</li>
<li>线程由于 IO 操作受到阻塞</li>
<li>另外一个更高优先级线程出现</li>
<li>在支持时间片的系统中，该线程的时间片用完</li>
</ol>
<h3 id="什么是线程调度器和时间分片？"><a href="#什么是线程调度器和时间分片？" class="headerlink" title="什么是线程调度器和时间分片？"></a>什么是线程调度器和时间分片？</h3><ol>
<li>线程调度器是一个操作系统服务，它负责为 Runnable状态的线程分配CPU<br>时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现</li>
<li>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分<br>配 CPU 时间可以基于线程优先级或者线程等待的时间</li>
</ol>
<h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><ol>
<li>使用退出标志，使线程正常退出，也就是run方法正常结束<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span>(done)</span><br><span class="line">		&#123;</span><br><span class="line">			...</span><br><span class="line">			flag=<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stop方法强行终止，但是不推荐这个方法</li>
<li>使用interrupt方法中断线程</li>
</ol>
<ul>
<li>Thread.interrupt() 实例方法，设置当前中断标记为true</li>
<li>Thread.isInterrupted() 实例方法，检测当前的中断标记</li>
<li>Thread.interrupted() 静态方法，检测当前的中断标记，然后重置中断标记为false</li>
<li>Thread.currentThread() 静态方法，返回执行当前代码的线程对象引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Thread.currentThread().isInterrupted() == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*任务完成*/</span>) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// do something ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="自定义标志与中断标志的区别？"><a href="#自定义标志与中断标志的区别？" class="headerlink" title="自定义标志与中断标志的区别？"></a>自定义标志与中断标志的区别？</h3><p>调用innterrupt 仅仅在线程中打一个标记，并不会立刻停止线程，本质还是<br>通过boolean 标志来控制线程的结束。不过要注意，当调用Object类的wait<br>方法或者线程类的 join sleep 等方法时，如果当前线程已经中断（中断标<br>志标记为true），调用以上那些方法时将会抛出一个异常，同时清除线程的<br>中断标志，抛出InterruptedException异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; Thread.currentThread().isInterrupted() == <span class="keyword">false</span>; </span><br><span class="line">            	i++) &#123;</span><br><span class="line">                <span class="comment">// 如果 i 大于 5 则设置当前线程中断标志为 true，</span></span><br><span class="line">                <span class="comment">// 在此之后 Thread.currentThread().isInterrupted() 方法返回 true</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"i: "</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 在抛出异常的时候会设置当前线程中断标志为 false，</span></span><br><span class="line">                <span class="comment">// 在此之后 Thread.currentThread().isInterrupted() 方法返回 false</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> ; <span class="comment">// 防止死循环，在捕货异常时直接返回结束 run 方法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="目标线程与当前线程的区别？"><a href="#目标线程与当前线程的区别？" class="headerlink" title="目标线程与当前线程的区别？"></a>目标线程与当前线程的区别？</h3><p>目标线程是调用该方法的线程对象所对应的线程，这个线程有可能并不是当<br>前线程，比如在线程A中调用线程B的方法，这个时候线程A就是当前线程，<br>线程B就是目标线程</p>
<h3 id="Java中interrupted和isInterrupted方法的区别？"><a href="#Java中interrupted和isInterrupted方法的区别？" class="headerlink" title="Java中interrupted和isInterrupted方法的区别？"></a>Java中interrupted和isInterrupted方法的区别？</h3><ol>
<li>前者会将中断状态清除而后者不会。 Java多线程的中断机制是用内部标识<br>来实现的</li>
<li>调用实例方法interrupt()中断一个目标线程就会设置中断标识为true，<br>调用静态方法interrupted()来检查当前线程中断状态时，中断状态会被清<br>零</li>
<li>非静态方法isInterrupted()用来查询目标线程中断状态并且不会改变<br>中断状态标识。简单的说就是任何抛出InterruptedException异常的方法<br>都会将中断状态清零。无论如何，一个线程的中断状态有可能被其它线程调<br>用中断来改变，比如调用sleep wait join方法时如果中断了就会抛出异<br>常并清除中断</li>
</ol>
<h3 id="缓存一致性问题是什么？"><a href="#缓存一致性问题是什么？" class="headerlink" title="缓存一致性问题是什么？"></a>缓存一致性问题是什么？</h3><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以使用<br>高速缓存作为缓冲：将运算需要的数据复制到缓存中，让运算快速进行，运<br>算结束后再从缓存同步到内存之中。当高速缓存引入了一个问题：缓存一致<br>性。在多路处理器系统中每个处理器都有自己的高速缓存，而它们又共享同<br>一主内存，这种系统称为共享内存多核系统，当多个处理器的运算任务都<br>涉及同一块主内存区域时，将可能导致各自的内存数据不一致</p>
<h3 id="缓存不一致的根源是什么？"><a href="#缓存不一致的根源是什么？" class="headerlink" title="缓存不一致的根源是什么？"></a>缓存不一致的根源是什么？</h3><p>问题的根源不在于多个核，而是多个缓存，以及缓存的写操作。<br>缓存中存储数据，缓存不一致就意味着相同的数据在不同的缓存中呈现着不同<br>的表现。对于存储的数据，CPU有读操作和写操作，读操作不会影响数据的存<br>储状态，写操作是导致不一致的根源。但是缓存不一致的问题并不是因为我<br>们采用了多核CPU，而是因为我们采用了多个缓存。如果多核CPU共享一个<br>缓存，那么不一致问题也不复存在，在每个时钟周期，几个核通过某种方<br>式竞争使用缓存，每个时刻只允许一个核对缓存进行读写操作，其他的核<br>都需排队等候，这样缓存永远是一致的，但是这种方式会导致CPU计算资<br>源的极大浪费，同时效率极低。采用每个核一个缓存的方式，多核可以同<br>时工作，但是也带来了缓存不一致的问题</p>
<h3 id="缓存一致性协议是什么？"><a href="#缓存一致性协议是什么？" class="headerlink" title="缓存一致性协议是什么？"></a>缓存一致性协议是什么？</h3><p>为了解决缓存不一致的问题，我们需要一种机制来约束各个核，也就是缓存<br>一致性协议。我们常用的缓存一致性协议都是属于“snooping(窥探)”协议，<br>各个核能够时刻监控自己和其他核的状态，从而统一管理协调。窥探的思想<br>是：CPU的各个缓存是独立的，但是内存却是共享的，所有缓存的数据最终<br>都通过总线写入同一个内存，因此CPU各个核都能“看见”总线，即各个缓存<br>不仅在进行内存数据交换的时候访问总线，还可以时刻“窥探”总线，监控<br>其他缓存在干什么。因此当一个缓存在往内存中写数据时，其他缓存也都<br>能“窥探”到，从而按照一致性协议保证缓存间的同步</p>
<h3 id="缓存一致性协议有哪些？"><a href="#缓存一致性协议有哪些？" class="headerlink" title="缓存一致性协议有哪些？"></a>缓存一致性协议有哪些？</h3><p><a href="https://www.cnblogs.com/zhengshuangxi/p/11180610.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengshuangxi/p/11180610.html</a></p>
<ol>
<li>EMSI协议 它通过定义一个状态机来保证缓存的一致性。在MESI协议中有<br>四种状态，这些状态都是针对缓存行（缓存由多个缓存行组成，缓存行的大<br>小单位与机器的位数相关）</li>
</ol>
<ul>
<li>Invalid状态：缓存行无效状态。要么该缓存行数据已经过时，要么缓存<br>行数据已经不在缓存中。对于无效状态，可直接认为缓存行未加载进缓存</li>
<li>Shared状态：缓存行共享状态。缓存行数据与内存中对应数据保持一致，<br>多个缓存中的相应缓存行都是共享状态。该状态下的缓存行只允许读取，不<br>允许写</li>
<li>Exclusive状态：缓存行独有状态。该缓存行中的数据与内存中对应数据<br>保持一致，当某缓存行是独有状态，其他缓存对应的缓存行都必须为无效<br>状态</li>
<li>Modified状态：缓存行已修改状态。缓存行中的数据为脏数据，与内存中<br>的对应数据不一致。如果一个缓存行为已修改状态，那么其他缓存中对应缓<br>存行都必须为无效状态。另外，如果该状态下的缓存行状态被修改为无效，<br>那么脏段必须先回写入内存中</li>
</ul>
<p>MESI协议的定律：所有M状态下的缓存行（脏数据）回写后，任意缓存级别<br>中的缓存行的数据都与内存保持一致。另外如果某个缓存行处于E状态，那<br>么在其他的缓存中就不会存在该缓存行</p>
<h3 id="Java内存模型的具体内容？"><a href="#Java内存模型的具体内容？" class="headerlink" title="Java内存模型的具体内容？"></a>Java内存模型的具体内容？</h3><p>从Java线程角度，我们把Java内存模型分为主内存和每条线程私有的工作内<br>存（可以与处理器高速缓存类比）</p>
<ol>
<li>Java 线程只能直接对其的私有工作内存进行读取和写入数据操作，而不<br>能对主内存直接进行读取和写入操作</li>
<li>主内存对所有的 Java 线程都可见，即所有的Java线程都可以通过其工<br>作内存来间接的修改主内存中的数据</li>
<li>线程的工作内存只对其对应的 Java 线程可见，不同的Java线程不共享<br>其工作内存</li>
</ol>
<h3 id="原子性是什么？"><a href="#原子性是什么？" class="headerlink" title="原子性是什么？"></a>原子性是什么？</h3><p>对于一个操作来说，如果执行它，那么在执行过程中不会被其他因素打断直到<br>完成这个操作，否则这个操作就不执行。我们称这个操作具有原子性。Java中<br>常用的a = 1; 操作通常是具有原子性的，而类似于 a += 1; 和 a++; 等<br>操作就不具有原子性</p>
<ul>
<li>getstatic 指令为从静态储存区取出变量的值并且压入操作栈顶</li>
<li>iconst_1 指令为将整形常量 1 压入操作栈顶</li>
<li>isub 指令为从栈中取出两个整形变量将相减的结果压入操作栈顶</li>
<li>putstatic 指令为从操作栈顶中取出变量的值并将变量值写入主内存中</li>
<li>iload_0 指令为将局部变量压入到操作栈顶</li>
<li>ireturn 指令为方法结束并返回从操作栈顶取出的 int 类型值</li>
<li>return 即为方法的结束返回指令</li>
</ul>
<p>对变量 a 进行改变的字节码只有 putstatic，所以可以理解为原子性，<br>a– 的字节码指令有多条</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic</span><br><span class="line">iconst_1</span><br><span class="line">isub</span><br><span class="line">putstatic</span><br></pre></td></tr></table></figure>
<h3 id="可见性是什么？"><a href="#可见性是什么？" class="headerlink" title="可见性是什么？"></a>可见性是什么？</h3><p>可见性是指一个线程修改了某一共享变量的值，其他线程是否能够立即知道这个<br>修改。对于串行程序来说可见性问题不存在，并行程序中缓存优化、硬件优化或<br>指令重排以及编译器优化都可能产生可见性问题</p>
<h3 id="有序性是什么？"><a href="#有序性是什么？" class="headerlink" title="有序性是什么？"></a>有序性是什么？</h3><p>有序性问题的原因是因为程序在执行时可能会进行指令重排，重排后的指令与原<br>指令的顺序未必一致，但是一定可以保证串行语义的一致性</p>
<h3 id="指令重排的规则是什么？"><a href="#指令重排的规则是什么？" class="headerlink" title="指令重排的规则是什么？"></a>指令重排的规则是什么？</h3><p>以下原则是指令重排不能违背的<br>顺序执行原则：一个线程内保证语义的串行性</p>
<ol>
<li>volatile规则：volatile变量的写，先发生于读</li>
<li>锁规则：解锁(unlock)必然发生在随后的加锁(lock)前</li>
<li>传递性：A先于B，B先于C，那么A必先于C</li>
<li>线程的start方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结(Thread.join())</li>
<li>线程的中断(interrupt())先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法</li>
<li>顺序执行原则：一个线程内保证语义的串行性</li>
</ol>
<h3 id="什么是线程同步？"><a href="#什么是线程同步？" class="headerlink" title="什么是线程同步？"></a>什么是线程同步？</h3><p>线程的同步是指一个线程对内存进行操作时，其他线程都不可以对这个内存<br>地址进行操作，直到该线程完成操作，其他线程才可以对内存地址进行操作</p>
<h3 id="同步的实现有哪些方式？"><a href="#同步的实现有哪些方式？" class="headerlink" title="同步的实现有哪些方式？"></a>同步的实现有哪些方式？</h3><ol>
<li>同步代码方法：sychronized 关键字修饰的方法，给当前实例加锁</li>
<li>同步代码块：sychronized 关键字修饰的代码块，给给定对象加锁</li>
<li>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的<br>访问提供了一种免锁机制</li>
<li>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了<br>lock接口的锁他与sychronized方法具有相同的基本行为和语义</li>
</ol>
<h3 id="ReentrantLock是什么？"><a href="#ReentrantLock是什么？" class="headerlink" title="ReentrantLock是什么？"></a>ReentrantLock是什么？</h3><p>重入锁ReentrantLock由上次成功锁定并且尚未解锁的线程拥有，是一个<br>可重入且独占式的锁。与synchronized 关键字相比更加灵活强大，重入<br>锁的意思就是这种锁能反复进入，但是只限于一个线程。注意<br>ReentrantLock锁的并不是Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁定几个就要释放几个</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	lock.lock();	</span><br><span class="line">	lock.lock();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重入锁的常用处理框架如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  </span><br><span class="line">     <span class="comment">// 当前执行代码的线程尝试获取锁对象，如果当前锁对象被其他线程获取，则陷入阻塞状态</span></span><br><span class="line">	 <span class="comment">// 保证了在同一时刻只能有一个线程进入 try 代码块中执行代码，即实现线程同步</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// do something...</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock() <span class="comment">// 最后一定记得释放锁对象，不然可能导致死锁</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重入锁的中断响应是什么？"><a href="#重入锁的中断响应是什么？" class="headerlink" title="重入锁的中断响应是什么？"></a>重入锁的中断响应是什么？</h3><p>在等待锁的过程中，程序可以根据需要取消对锁的请求。比如两个线程使<br>用lockInterruptibly()方法加锁造成死锁时，如果其中一个线程调用<br>interrupt方法将导致线程中断，此时该线程会停止申请锁并释放已经<br>获得的锁然后抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lockInterruptibly()</span><br></pre></td></tr></table></figure>
<h3 id="重入锁申请等待限时机制？"><a href="#重入锁申请等待限时机制？" class="headerlink" title="重入锁申请等待限时机制？"></a>重入锁申请等待限时机制？</h3><p>除了等待外部通知，还有一种避免死锁的方式就是限时等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>	isLocked​() <span class="comment">// 查询当前锁对象是否被任意一个线程所持有</span></span><br><span class="line"><span class="keyword">boolean</span>	isHeldByCurrentThread​() <span class="comment">// 查询当前锁对象是否被当前执行代码的线程所拥有</span></span><br><span class="line"><span class="comment">//当前执行代码的线程尝试获取锁，如果获取失败（当前锁已经被其他线程所拥有），</span></span><br><span class="line"><span class="comment">//那么当前执行代码的线程会陷入阻塞，直到这个锁对象被其所拥有的线程释放才会从阻塞状态唤醒</span></span><br><span class="line"><span class="keyword">void</span> lock​() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程尝试获取当前锁，如果获取成功，那么返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment">// 和 lock 方法的区别在于当前线程获取锁失败时不会陷入阻塞状态</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock​()</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> tryLock​(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException </span><br><span class="line"><span class="keyword">void</span> unlock​() <span class="comment">// 释放当前执行代码的线程拥有的锁对象</span></span><br></pre></td></tr></table></figure>

<h3 id="synchronized是什么？"><a href="#synchronized是什么？" class="headerlink" title="synchronized是什么？"></a>synchronized是什么？</h3><p>synchronized可以修饰方法、代码块，但是不能修饰变量和构造器，默认实现锁<br>机制，线程获取锁资源和线程释放锁资源），同步方法的同步监视器是this，而<br>this总代表调用该方法的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于实例方法锁住的是对象，对于静态方法锁住的是类，类和对象不冲突</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当线程执行到这里的时候会检查调用该方法的对象是否已经被锁住</span></span><br><span class="line"><span class="comment">如果被锁住则等待锁的释放</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//obj就表示当前对象</span></span><br><span class="line">	<span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与线程同步以及线程调度相关的方法有哪些？"><a href="#与线程同步以及线程调度相关的方法有哪些？" class="headerlink" title="与线程同步以及线程调度相关的方法有哪些？"></a>与线程同步以及线程调度相关的方法有哪些？</h3><ol>
<li>Object.wait() 使一个线程处于等待（阻塞）状态，并且释放所持有的<br>对象的锁，注意这个方法只能在 synchronized关键字修饰的代码块中调用</li>
<li>Thread.sleep(long millis) 使一个正在运行的线程处于睡眠状态，<br>是一个静态方法，可以指定一个时间参数，单位是毫秒，调用此方法要处理<br>InterruptedException异常</li>
<li>Object.notify() 唤醒一个因调用当前对象的 wait()方法而陷入等待<br>状态的线程，具体哪个线程未知。这个方法也只能在 synchronized关键字<br>修饰的代码块中执行</li>
<li>Object.notifyAll() 唤醒所有因调用当前对象的 wait()方法而陷入等<br>待状态的线程。同样这个方法也只能在 synchronized关键字修饰的代码块中<br>执行该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的<br>线程才能进入就绪状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> </span></span></span><br><span class="line"><span class="function"><span class="params">		money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (money &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 此处应做特殊处理</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"账户"</span> + fromIndex + <span class="string">"想向"</span> + toIndex + <span class="string">"账户转账"</span> </span><br><span class="line">			+ money + <span class="string">"元"</span>);</span><br><span class="line">		<span class="comment">/* 如果转账方账户余额不足，那么调用当前对象的 </span></span><br><span class="line"><span class="comment">		wait 方法使得当前线程释放对象锁陷入无限等待，</span></span><br><span class="line"><span class="comment">		直到其它线程调用了 notify 或者 notifyAll 方法，*/</span></span><br><span class="line">		<span class="keyword">while</span> (accountBalance[fromIndex] &lt; money) &#123;</span><br><span class="line">			System.out.println(<span class="string">"账户余额不足，无法转账！"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 账户余额变更</span></span><br><span class="line">		accountBalance[fromIndex] -= money;</span><br><span class="line">		accountBalance[toIndex] += money;</span><br><span class="line">		System.out.println(<span class="string">"转账成功"</span>);</span><br><span class="line">		notifyAll(); <span class="comment">// 唤醒所有因调用了当前对象的 wait 方法而陷入等待的线程</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>Thread.join() 在线程执行过程中插入另外一个线程，并且直到这个插<br>入的线程执行完成之后再继续执行原来的线程。当在某个执行流中调用其他<br>线程的join方法时，调用线程将被阻塞。<br>在main线程中调用jt.join()，main线程会获取线程对象jt的锁，调用到wait<br>方法时当前线程就会一直等待同时释放jt对象的锁，而jt中的线程可以执行，<br>执行完死亡时会调用自己的notifyAll方法，这时主线程就可以继续执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> JoinThread(<span class="string">"新线程"</span>).start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				JoinThread jt=<span class="keyword">new</span> JoinThread(<span class="string">"被join的线程"</span>);</span><br><span class="line">				jt.start();</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 		在main线程的执行流中调用了join方法，所以</span></span><br><span class="line"><span class="comment">			 		main线程被停止，只有两个子线程在执行，当</span></span><br><span class="line"><span class="comment">			 		jt线程执行完后主线程才会继续执行，join方</span></span><br><span class="line"><span class="comment">			 		法也可以加时间参数，过了这个时间方法失效</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				jt.join();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li>Thread.yield() yield()也是一个静态方法，可以让正在执行的线程暂<br>停但是不会阻塞该线程，只是将线程转入就绪状态，让系统线程调度器重新<br>调度一次，很有可能该线程又重新执行</li>
</ol>
<h3 id="公平锁与非公平锁的区别？"><a href="#公平锁与非公平锁的区别？" class="headerlink" title="公平锁与非公平锁的区别？"></a>公平锁与非公平锁的区别？</h3><p>公平锁按照线程申请锁的先后顺序被获取，不会产生饥饿现象，synchronized<br>产生的锁是非公平的，会根据优先级挑选，具有随机性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Condition是什么？"><a href="#Condition是什么？" class="headerlink" title="Condition是什么？"></a>Condition是什么？</h3><p>ReentrantLock类中提供了一个方法newCondition()来获取Condition实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//与Object的wait方法相同，直到其他线程调用Condition的signal或signalAll</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">   <span class="comment">/*唤醒在Lock对象上等待的线程，如果所有线程都在该Lock对象上等待，</span></span><br><span class="line"><span class="comment">    则会选择唤醒其中一个线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">//唤醒所有等待的线程</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上这些方法需要在获取ReentrantLock锁资源的情况下才能使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 创建锁对象</span></span><br><span class="line">Condition con = lock.newCondition();</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当前线程尝试获取锁资源</span></span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (money &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 此处应做特殊处理</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"账户"</span> + fromIndex + <span class="string">"想向"</span> + toIndex + </span><br><span class="line">			<span class="string">"账户转账"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">		<span class="comment">/* 如果转账方账户余额不足，那么调用 con 对象的 </span></span><br><span class="line"><span class="comment">		await 方法使得当前线程释放对象锁陷入无限等待，</span></span><br><span class="line"><span class="comment">		 直到其它线程调用了 con 对象的 signal 或者 signalAll 方法，*/</span></span><br><span class="line">		<span class="keyword">while</span> (accountBalance[fromIndex] &lt; money) &#123;</span><br><span class="line">			System.out.println(<span class="string">"账户余额不足，无法转账！"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				con.await();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 账户余额变更</span></span><br><span class="line">		accountBalance[fromIndex] -= money;</span><br><span class="line">		accountBalance[toIndex] += money;</span><br><span class="line">		System.out.println(<span class="string">"转账成功"</span>);</span><br><span class="line">		con.signalAll(); </span><br><span class="line">		<span class="comment">// 唤醒所有因调用了 con 对象的 await 方法而陷入等待的线程</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock(); <span class="comment">// 当前线程释放锁资源</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java多线程中调用wait-和sleep-方法有什么不同？"><a href="#Java多线程中调用wait-和sleep-方法有什么不同？" class="headerlink" title="Java多线程中调用wait()和sleep()方法有什么不同？"></a>Java多线程中调用wait()和sleep()方法有什么不同？</h3><p>两者都可以暂停线程的执行</p>
<ol>
<li>类的不同：sleep()是Thread线程类的静态方法，wait()是Object类的方法</li>
<li>是否释放锁：sleep() 不释放锁；wait() 释放锁</li>
<li>用途不同：Wait 通常被用于线程间交互/通信，sleep通常被用于暂停执行</li>
<li>用法不同：wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同<br>一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程<br>会自动苏醒</li>
</ol>
<h3 id="为什么wait方法要在循环中调用？"><a href="#为什么wait方法要在循环中调用？" class="headerlink" title="为什么wait方法要在循环中调用？"></a>为什么wait方法要在循环中调用？</h3><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条<br>件，程序就会在没有满足结束条件的情况下退出</p>
<h3 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h3><p>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的<br>锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象<br>上的notify()方法。同样的，当一个线程需要调用对象的 notify() 方法<br>时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象<br>锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步<br>来实现，所以他们只能在同步方法或者同步块中被调用</p>
<h3 id="为什么wait-notify和notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify和notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify和notifyAll这些方法不在thread类里面？"></a>为什么wait, notify和notifyAll这些方法不在thread类里面？</h3><p>JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。<br>如果线程需要等待某些锁那么调用对象中的wait() 方法就有意义了。如果<br>wait() 方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。<br>简单的说由于wait，notify和notifyAll都是锁级别的操作，所以把他<br>们定义在Object类中因为锁属于对象</p>
<h3 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h3><p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执<br>行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线<br>程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又<br>被执行</p>
<h3 id="Java中的fork-join框架是什么？"><a href="#Java中的fork-join框架是什么？" class="headerlink" title="Java中的fork join框架是什么？"></a>Java中的fork join框架是什么？</h3><p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充<br>分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模<br>块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框<br>架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程<br>可以从其它线程中窃取任务来执行</p>
<h3 id="join和yield的区别？"><a href="#join和yield的区别？" class="headerlink" title="join和yield的区别？"></a>join和yield的区别？</h3><p>join是阻塞当前线程，直到目标线程执行完毕。yield是一个静态方法，一旦<br>执行就会让出CPU，但是还可以进行CPU资源的争夺，注意yield不会释放锁<br>资源</p>
<h3 id="Thread类中的start-和run-方法有什么区别？"><a href="#Thread类中的start-和run-方法有什么区别？" class="headerlink" title="Thread类中的start()和run()方法有什么区别？"></a>Thread类中的start()和run()方法有什么区别？</h3><p>start() 方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这<br>和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的<br>线程中调用，没有新的线程启动，start()方法才会启动新线程</p>
<h3 id="线程同步和线程互斥的区别？"><a href="#线程同步和线程互斥的区别？" class="headerlink" title="线程同步和线程互斥的区别？"></a>线程同步和线程互斥的区别？</h3><ol>
<li>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。<br>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去<br>使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线<br>程互斥可以看成是一种特殊的线程同步</li>
<li>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内<br>核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核<br>态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。<br>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内<br>核模式下的方法有：事件，信号量，互斥量</li>
</ol>
<h3 id="监视器-Monitor-内部，是如何做线程同步的？"><a href="#监视器-Monitor-内部，是如何做线程同步的？" class="headerlink" title="监视器(Monitor)内部，是如何做线程同步的？"></a>监视器(Monitor)内部，是如何做线程同步的？</h3><p>在java虚拟机中，每个对象(Object 和 class)通过某种逻辑关联监视器，每<br>个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关<br>联着一把锁。java提供了显式监视器(Lock)和隐式监视器(synchronized)两<br>种锁方案</p>
<h3 id="as-if-serial规则和happens-before规则的区别？"><a href="#as-if-serial规则和happens-before规则的区别？" class="headerlink" title="as-if-serial规则和happens-before规则的区别？"></a>as-if-serial规则和happens-before规则的区别？</h3><ol>
<li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before<br>关系保证正确同步的多线程程序的执行结果不被改变</li>
<li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程<br>程序是按程序的顺序来执行的。happens-before 关系给编写正确同步的多<br>线程程序的程序员创造了一个幻境：正确同步的多线程程序是按<br>happens-before指定的顺序来执行的</li>
<li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变<br>程序执行结果的前提下，尽可能地提高程序执行的并行度</li>
</ol>
<h3 id="并发工具有哪些？"><a href="#并发工具有哪些？" class="headerlink" title="并发工具有哪些？"></a>并发工具有哪些？</h3><p>Semaphore ReadWriteLock CountDownLatch CycliBarrier LockSupport<br><img src="/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<h3 id="Semaphore是什么？"><a href="#Semaphore是什么？" class="headerlink" title="Semaphore是什么？"></a>Semaphore是什么？</h3><p>信号量是为多线程协作提供更强大的控制方法，内部锁synchronized和重入锁<br>ReentrantLock一次都只允许一个线程访问一个资源，信号量可以指定多个线<br>程同时访问一个资源，可以用于数据库连接，同时进行连接的线程有数量限制<br>，还可以用在停车场车位限制场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Semaphore.Sync sync;</span><br><span class="line">    <span class="comment">//指定多少个许可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Semaphore.NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二个参数指定是否公平</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = (Semaphore.Sync)(fair ? <span class="keyword">new</span> Semaphore.FairSync(permits) : </span><br><span class="line">        	<span class="keyword">new</span> Semaphore.NonfairSync(permits));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从此信号量获取一个许可，在提供一个许可前一直将线程阻塞或当前线程被中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放一个许可，将其返回给信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来模拟一下停车场景，停车场容量10个车位，一个车走显示屏车位加1，<br>一个车进显示屏车位减一，如果减为0则车等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停车场同时容纳的车辆10</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟100辆车进入停车场</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"===="</span>+</span><br><span class="line">                        	Thread.currentThread().getName()+<span class="string">"来到停车场"</span>);</span><br><span class="line">                        <span class="keyword">if</span>(semaphore.availablePermits()==<span class="number">0</span>)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"车位不足，请耐心等待"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        semaphore.acquire();<span class="comment">//获取令牌尝试进入停车场</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        	<span class="string">"成功进入停车场"</span>);</span><br><span class="line">                        <span class="comment">//模拟车辆在停车场停留的时间</span></span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        	<span class="string">"驶出停车场"</span>);</span><br><span class="line">                        semaphore.release();<span class="comment">//释放令牌，腾出停车场车位</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+<span class="string">"号车"</span>);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReadWriteLock是什么？"><a href="#ReadWriteLock是什么？" class="headerlink" title="ReadWriteLock是什么？"></a>ReadWriteLock是什么？</h3><p>读写分离锁能够有效减少锁竞争。比如线程A1 A2 A3进行写操作，线程B1 B2<br>B3 进行读操作，如果使用重入锁或内部锁理论上所有的读之间、读与写之间、<br>写与写之间都是串行操作，当B1进行读时B2 B3都需要等待锁，读写锁能够使<br>多个线程同时读，但是其余操作依然需要等待。如果系统中读操作次数远远大<br>于写操作次数，则读写锁可以发挥最大功效，只允许一个线程写共享变量，<br>当写共享变量的时候也会阻塞读的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CountDownLatch是什么？"><a href="#CountDownLatch是什么？" class="headerlink" title="CountDownLatch是什么？"></a>CountDownLatch是什么？</h3><p>称为倒计时器，让一个线程等待直到倒计时结束再开始执行，倒计时器一个<br>典型的场景是火箭发射，发射线程必须等待检查线程执行完后才能执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*count表示这个计数器的计数个数，每当一下线程执行完计数器的值就-1</span></span><br><span class="line"><span class="comment">当计数器的值为0表示所有线程执行完毕，然后在闭锁上等待的线程就可以工作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//将count值减1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>以下例子要求两个子线程都执行完后主线程才可以继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程开始执行…… ……"</span>);</span><br><span class="line">        <span class="comment">//第一个子线程执行</span></span><br><span class="line">        ExecutorService es1 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es1.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程："</span>+Thread.currentThread().</span><br><span class="line">                    	getName()+<span class="string">"执行"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es1.shutdown();</span><br><span class="line">        <span class="comment">//第二个子线程执行</span></span><br><span class="line">        ExecutorService es2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es2.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程："</span>+Thread.currentThread().</span><br><span class="line">                	getName()+<span class="string">"执行"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es2.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"等待两个线程执行完毕…… ……"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"两个子线程都执行完毕，继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CycliBarrier是什么？"><a href="#CycliBarrier是什么？" class="headerlink" title="CycliBarrier是什么？"></a>CycliBarrier是什么？</h3><p>可以理解为循环栅栏，实现线程间的计数等待，让一组线程相互等待，当所有<br>线程都到达某个屏障点后再进行后续的操作。可以用于多线程计数数据，最后<br>合并计数结果的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//barrierAction表示当计数器一次计数完成后系统会执行的操作，parties是计数总数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties,Runnbale barrierAction)</span></span></span><br></pre></td></tr></table></figure>
<p>以下是一个实例场景，可以看到CycliBarrier可以重复使用，核心是reset功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,</span><br><span class="line">                <span class="keyword">new</span> BarrierRun(<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">7</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                        <span class="string">"\t 收集到第"</span>+ finalI +<span class="string">"颗龙珠"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"神龙吐出第"</span>+finalI+<span class="string">"颗龙珠"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag=flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"六老师召唤神龙结束，神龙走了"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"六老师召唤神龙"</span>);</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LockSupport是什么？"><a href="#LockSupport是什么？" class="headerlink" title="LockSupport是什么？"></a>LockSupport是什么？</h3><p>是一个非常方便的线程阻塞工具，可以在线程内任意位置让线程阻塞，相比<br>suspend，弥补由于resume 在前发生导致线程无法继续执行的情况，相比<br>wait方法不需要先获取某个对象的锁，也不会抛出中断异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span></span>; <span class="comment">// 暂停当前线程</span></span><br><span class="line"><span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line"><span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>; <span class="comment">// 无期限暂停当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span></span>; <span class="comment">// 暂停当前线程，不过有超时时间的限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span></span>; <span class="comment">// 暂停当前线程，直到某个时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>; <span class="comment">// 恢复当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接下来看一个实例场景，LockSupport 使用类似信号量的机制，为每一个线<br>程准备了一个许可，如果许可可用那park函数会立即返回，并消费这个许可<br>，如果许可不可用就会阻塞，unpark函数就是使得一个许可变为可用，即使<br>unpark发生在park之前也可以使下一次park操作立即返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object u = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t1 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">static</span> ChangeObjectThread t2 = <span class="keyword">new</span> ChangeObjectThread(<span class="string">"t2"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChangeObjectThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (u) &#123;</span><br><span class="line">                System.out.println(<span class="string">"in "</span> + getName());</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"被中断了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"继续执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="comment">//t1中断之后park会立即返回不抛出异常，继续执行完剩下代码后t2就可以进入临界区</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存间交互操作有哪些？"><a href="#内存间交互操作有哪些？" class="headerlink" title="内存间交互操作有哪些？"></a>内存间交互操作有哪些？</h3><p>Java内存模型定义了以下8种操作。Java虚拟机实现时必须保证下面提及的每一种<br>操作都是原子的、不可再分的。对一个变量执行unlock操作之前，必须把此变量同<br>步回主内存中</p>
<ul>
<li>lock 作用于主内存的变量，把一个变量标识为一条线程独占的状态</li>
<li>unlock 作用于主内存的变量，把一个处于锁定状态的变量释放出来释<br>放后的变量才可以被其他线程锁定</li>
<li>read 作用于主内存的变量，把一个变量的值从主内存传输到线程的工<br>作内存，以便随后的load动作使用</li>
<li>load 作用于工作内存的变量，把read操作从主内存中得到的变量值放<br>入工作内存的变量副本中</li>
<li>use 作用于工作内存的变量，把工作内存中一个变量的值传递给执行引<br>擎，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>
<li>assign 作用于工作内存的变量，把一个从执行引擎接收到的值赋给工<br>作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个<br>操作</li>
<li>store 作用于工作内存的变量，把工作内存中一个变量的值传递到主内<br>存中，以便随后的write操作</li>
<li>write 作用于主内存的变量，把store操作从工作内存中得到的变量的<br>值放入主内存的变量中</li>
</ul>
<h3 id="Java中的volatile变量是什么？"><a href="#Java中的volatile变量是什么？" class="headerlink" title="Java中的volatile变量是什么？"></a>Java中的volatile变量是什么？</h3><p>volatile是JAVA虚拟机提供的最轻量级的同步机制，它将具有两项特性</p>
<ol>
<li>volatile保证变量对所有线程的可见性：当volatile变量被修改，<br>新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修<br>饰的变量的值一定是最新的</li>
<li>jdk1.5以后volatile完全避免了指令重排优化，实现了有序性</li>
</ol>
<h3 id="volatile如何保证可见性？"><a href="#volatile如何保证可见性？" class="headerlink" title="volatile如何保证可见性？"></a>volatile如何保证可见性？</h3><p>volatile变量在各个线程的工作内存中是不存在一致性问题的（每次使用<br>前都要先刷新，执行引擎看不到不一致的情况，因此认为不存在一致性问<br>题）且JAVA内存模型对valatile的规则还有read load use必须在一起<br>assign stoere和write必须在一起</p>
<h3 id="volatile的原理？"><a href="#volatile的原理？" class="headerlink" title="volatile的原理？"></a>volatile的原理？</h3><p>不能替代锁，性能要高于锁，主要的消耗就是要在指令中插入内存屏障</p>
<ol>
<li>获取JIT（即时Java编译器，把字节码解释为机器语言发送给处理器）<br>的汇编代码，发现volatile多加了lock addl指令，这个操作相当于一个<br>内存屏障，使得lock指令后的指令不能重排序到内存屏障前的位置。这也<br>是为什么JDK1.5以后可以使用双锁检测实现单例模式</li>
<li>lock前缀的另一层意义是使得本线程工作内存中的volatile变量值立<br>即写入到主内存中，并且使得其他线程共享的该volatile变量无效化，<br>这样其他线程必须重新从主内存中读取变量值</li>
</ol>
<h3 id="volatile能保证原子性吗？"><a href="#volatile能保证原子性吗？" class="headerlink" title="volatile能保证原子性吗？"></a>volatile能保证原子性吗？</h3><p>volatile变量的运算在并发下一样是不安全的。比如a++操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic &#x2F;&#x2F; 从静态储存区取出变量的值并且压入操作栈顶 </span><br><span class="line">iconst_1 &#x2F;&#x2F; 将整形常量 1 压入操作栈顶</span><br><span class="line">iadd &#x2F;&#x2F; 从栈中取出两个整形变量将相减的结果压入操作栈顶</span><br><span class="line">putstatic &#x2F;&#x2F; 从操作栈顶中取出变量的值并将变量值写入静态储存区</span><br></pre></td></tr></table></figure>
<p>如果一个线程（这里命名为线程 A）在进行 increase 方法累加的时候执行<br>了 iconst_1 指令了之后让出了 CPU 资源，然后另一个线程（这里命名为<br>线程 B）得到了 CPU 资源并且从主内存中读取 sum 的值（此前线程 A 并<br>没有使 sum 自增），然后进行 sum 的累加。线程 B 执行完成后让出 CPU<br>资源，之后线程 A 得到了 CPU 资源，继续执行未执行完的指令：iadd 和<br>putstatic ，但是因为此时线程工作栈内存中储存的 sum 的值仍然是在<br>线程 B 进行累加之前从主内存取得的值，即此时的数据变成了过期的数<br>据，所以线程 A 执行的 putstatic 就可能把较小的 sum 值刷新到主<br>内存中</p>
<h3 id="synchronized和volatile关键字的区别？"><a href="#synchronized和volatile关键字的区别？" class="headerlink" title="synchronized和volatile关键字的区别？"></a>synchronized和volatile关键字的区别？</h3><ol>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比<br>synchronized关键字要好</li>
<li>volatile关键字只能用于变量而synchronized关键字可以修饰方法以<br>及代码块。实际开发中使用synchronized 关键字的场景还是更多一些</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可<br>能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。<br>synchronized关键字两者都能保证</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized<br>关键字解决的是多个线程之间访问资源的同步性</li>
</ol>
<h3 id="可重入锁的实现原理？"><a href="#可重入锁的实现原理？" class="headerlink" title="可重入锁的实现原理？"></a>可重入锁的实现原理？</h3><p>重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器<br>，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获<br>得该锁而调用相应的方法，当某一线程请求成功后，JVM会记下锁的持有线<br>程，并且将计数器置为 1，此时其它线程请求该锁，则必须等待，而该持<br>有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会<br>递增，当线程退出同步代码块时，计数器会递减，如果计数器为 0，则<br>释放该锁</p>
<h3 id="synchronized和ReentrantLock-的区别？"><a href="#synchronized和ReentrantLock-的区别？" class="headerlink" title="synchronized和ReentrantLock 的区别？"></a>synchronized和ReentrantLock 的区别？</h3><ol>
<li>两者都是可重入锁 可重入锁：重入锁，也叫做递归锁，可重入锁指的是<br>在一个线程中可以多次获取同一把锁，比如： 一个线程在执行一个带锁的<br>方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执<br>行调用的方法，而无需重新获得锁，两者都是同一个线程每进入一次，锁<br>的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁</li>
<li>synchronized 依赖于JVM 而ReentrantLock 依赖于API</li>
</ol>
<ul>
<li>synchronized 是依赖于JVM 实现的，前面我们也讲到了虚拟机团队在<br>JDK1.6 为synchronized 关键字进行了很多优化，但是这些优化都是在<br>虚拟机层面实现的</li>
<li>ReentrantLock 是JDK 层面实现的（也就是API 层面，需要lock() 和<br>unlock() 方法配合try/finally 语句块来完成）</li>
</ul>
<ol start="3">
<li>ReentrantLock 比synchronized 增加了一些高级功能</li>
</ol>
<ul>
<li>等待可中断 通过lock.lockInterruptibly()来实现这个机制。也就是说<br>正在等待的线程可以选择放弃等待，改为处理其他事情</li>
<li>可实现公平锁 可以指定是公平锁还是非公平锁。而synchronized只能是<br>非公平锁。所谓的公平锁就是先等待的线程先获得锁</li>
<li>可实现选择性通知 ReentrantLock类线程对象可以注册在指定的Condition<br>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。在使用<br>notify()/notifyAll()方法进行通知时，被通知的线程是由JVM选择的<br>，用ReentrantLock类结合Condition实例可以实现“选择性通知”</li>
</ul>
<ol start="4">
<li>使用选择</li>
</ol>
<ul>
<li>除非需要使用 ReentrantLock 的高级功能，否则优先使用synchronized</li>
<li>synchronized 是JVM 实现的一种锁机制，JVM 原生地支持它，而<br>ReentrantLock 不是所有的JDK版本都支持。并且使用synchronized<br>不用担心没有释放锁而导致死锁问题，因为JVM 会确保锁的释放</li>
</ul>
<h3 id="无锁是什么？-1"><a href="#无锁是什么？-1" class="headerlink" title="无锁是什么？"></a>无锁是什么？</h3><p>并发控制是一种悲观的策略，假设每一次的临界区操作都会产生冲突，所以会<br>牺牲性能让线程等待，无锁是一种乐观的策略，假设对资源的访问是没有冲突<br>的，如果遇到冲突会使用一种叫做比较交换的技术(CAS)来鉴别线程冲突，一<br>旦检测到冲突就会重试当前操作直到没有冲突</p>
<h3 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h3><ol>
<li>CAS 全称 =&gt; Compare-And-Set , 它是一条CPU并发源语，比较交换</li>
<li>他的功能就是判断内存某个位置的值是否为预期值，如果是则更新为新的值<br>，这个过程是原子的</li>
<li>CAS并发源语体现在Java语言中就是sun.miscUnSafe类中的各个方法，<br>调用UnSafe类中的CAS方法，JVM会帮我实现CAS汇编指令，这是一种完全<br>依赖于硬件功能，通过它实现了原子操作，再次强调，由于CAS是一种系<br>统源语，源语属于操作系统用于范畴，是由若干个指令组成，用于完成<br>某个功能的一个过程，并且源语的执行必须是连续的，在执行过程中不<br>允许中断，也即是说CAS是一条原子指令，不会造成所谓的数据不一致<br>的问题</li>
</ol>
<h3 id="CAS算法如何实现？"><a href="#CAS算法如何实现？" class="headerlink" title="CAS算法如何实现？"></a>CAS算法如何实现？</h3><p>CAS算法的过程如下：它包含三个参数，V表示要更新的变量，E表示预期值，N<br>表示新值。仅当V等于E时才会将V的值设为N，如果V不等于E 说明已经有其他线<br>程做了更新，则当前线程什么也不做，最后CAS 会返回当前V的真实值。当多线<br>程同时使用CAS 操作一个变量时，只会有一个成功更新其余失败，失败的线程<br>不会被挂起，而是被告知失败并且允许再次尝试，也允许失败的线程放弃操作<br>，CAS操作即使没有锁也可以发现其他线程对当前线程的干扰。大部分处理器<br>已经支持原子化的CAS指令</p>
<h3 id="在Java-API中有哪些原子类？"><a href="#在Java-API中有哪些原子类？" class="headerlink" title="在Java API中有哪些原子类？"></a>在Java API中有哪些原子类？</h3><p>原子类：AtomicBoolean AtomicInteger AtomicLong AtomicReference<br>其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含<br>的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被<br>其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由<br>JVM 从等待队列中选择另一个线程进入，这只是一种逻辑上的理解</p>
<ol>
<li>AtomicInteger 是一个线程安全的Integer，对其进行修改等任何操作<br>都是用CAS指令进行的，AtomicInteger 类主要利用 CAS (compare and<br>swap)+volatile和native方法来保证原子操作，从而避免synchronized<br>的高开销，执行效率大为提升<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存一个核心字段，它就代表当前实际取值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">//实现AtomicInteger的关键，它保存value的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.value = newValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="atomic的原理？"><a href="#atomic的原理？" class="headerlink" title="atomic的原理？"></a>atomic的原理？</h3><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个<br>（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程<br>同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以<br>向自旋锁一样，继续尝试，一直等到执行成功</p>
<h3 id="CAS的原理？"><a href="#CAS的原理？" class="headerlink" title="CAS的原理？"></a>CAS的原理？</h3><p>关于incrementAndGet方法的实现，这里有一个for死循环，因为CAS操作未<br>必是成功的，对于不成功的情况就要不断尝试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前值加1，返回新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    		<span class="keyword">int</span> current=get();</span><br><span class="line">    		<span class="keyword">int</span> next=current+<span class="number">1</span>;</span><br><span class="line">    		<span class="comment">//成功的条件就是期望是current必须是最新的当前值</span></span><br><span class="line">    		<span class="keyword">if</span>(compareAndSet(current,next))</span><br><span class="line">    			<span class="keyword">return</span> next;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中有一个compareAndSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe U = Unsafe.getUnsafe();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSetInt(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsafe类的作用？"><a href="#Unsafe类的作用？" class="headerlink" title="Unsafe类的作用？"></a>Unsafe类的作用？</h3><p>UnSafe是CAS的核心类，由于Java方法无法直接访问底层，需要通过本地<br>（native）方法来访问，UnSafe相当于一个后面，基于该类可以直接操<br>作额定的内存数据。UnSafe类在于sun.misc包中。其中内部方法可以向C<br>的指针一样直接操作内存，因为Java中CAS操作的助兴依赖于UnSafe类<br>的方法，变量value用volatile 修饰，保证了多线程之间的可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法内部是通过CAS指令来完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="CAS的缺点是什么？"><a href="#CAS的缺点是什么？" class="headerlink" title="CAS的缺点是什么？"></a>CAS的缺点是什么？</h3><ol>
<li>循环时间开销很大<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*CAS中有个do while 方法：如果CAS失败，会一直进行尝试，如果CAS长时间一直不成</span></span><br><span class="line"><span class="comment">功，会给CPU带来很大的开销*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>只能保证一个共享变量的原子性 当对一个共享变量执行操作的时候，我<br>们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，<br>循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性</li>
<li>存在ABA问题</li>
</ol>
<h3 id="AtomicReference是什么？"><a href="#AtomicReference是什么？" class="headerlink" title="AtomicReference是什么？"></a>AtomicReference是什么？</h3><p>对普通对象的封装，保证在修改对象引用时的线程安全性</p>
<h3 id="ABA问题是什么？"><a href="#ABA问题是什么？" class="headerlink" title="ABA问题是什么？"></a>ABA问题是什么？</h3><p>在一个时间差的时段内会造成数据的变化。比如说一个线程AA从内存中取走A，<br>这个时候另一个线程BB也从内存中取走A，这个时候A的值为X，然后线程BB将<br>A的值改为Y，过一会又将A的值改为X，这个时候线程AA回来进行CAS操作发现<br>内存中A的值仍然是X，因此线程AA操作成功。但是尽管线程AA的CAS操作成功<br>，但是不代表这个过程就是没问题的。在现实场景中，是否能修改对象的值，<br>不仅取决于当前值，还和对象的过程变化有关，AtomicReference无法解决<br>这个问题</p>
<h3 id="如何解决ABA问题？"><a href="#如何解决ABA问题？" class="headerlink" title="如何解决ABA问题？"></a>如何解决ABA问题？</h3><p>带有时间戳的对象引用：AtomicStampedReference。<br>AtomicReference无法解决上述问题是因为对象在修改过程中丢失了状态信息，<br>所以需要记录对象在修改过程中的状态值，就可以很好解决对象被反复修改导致<br>线程无法正确判断对象状态的问题，这个类内部不仅维护了对象值，还维护了一<br>个时间戳，这个时间戳可以用任何一个整数表示，更新数据时还要更新时间戳。<br>设置对象值时对象值与时间戳都必须满足期望值写入才会成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expectRef,V newRef, <span class="keyword">int</span> expectStamp,<span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h3><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于<br>AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了<br>原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架</p>
<h3 id="AQS-锁类型有哪些？"><a href="#AQS-锁类型有哪些？" class="headerlink" title="AQS 锁类型有哪些？"></a>AQS 锁类型有哪些？</h3><p>锁类型有两种：分别是 Exclusive(独占锁) 和 Share(共享锁)</p>
<ul>
<li>独占锁 每次都只有一个线程运行 ReentrantLock</li>
<li>共享锁 同时可以多个线程运行 Semaphore、 CountDownLatch<br>ReentrantReadWriteLock</li>
</ul>
<h3 id="AQS-的原理是什么？"><a href="#AQS-的原理是什么？" class="headerlink" title="AQS 的原理是什么？"></a>AQS 的原理是什么？</h3><p>AQS核心思想是如下</p>
<ol>
<li>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效<br>的工作线程，将共享资源设置为锁定状态</li>
<li>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配，<br>这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队<br>列中</li>
</ol>
<h3 id="CLH-是什么？"><a href="#CLH-是什么？" class="headerlink" title="CLH 是什么？"></a>CLH 是什么？</h3><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是<br>CLH变体的虚拟双向队列（FIFO），虚拟的双向队列即不存在队列实例，<br>AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配</p>
<h3 id="AQS如何实现？"><a href="#AQS如何实现？" class="headerlink" title="AQS如何实现？"></a>AQS如何实现？</h3><ol>
<li>AQS使用一个Volatile 的int 类型的成员变量来表示同步状态，通过内<br>置的FIFO队列来完成资源获取的排队工作，通过CAS 完成对State值的修改</li>
<li>在FIFO队列中，头节点占有锁，也就是头节点才是锁的持有者，尾节点<br>指向队列的最后一个等待线程节点，除了头节点和尾节点，节点之间都有<br>前驱指针和后继指针</li>
<li>在AQS中维护了一个共享变量 state，标识当前的资源是否被线程持有，<br>多线程竞争的时候，会去判断state是否为0，尝试的去把state修改为1</li>
</ol>
<h3 id="AQS-的数据结构？"><a href="#AQS-的数据结构？" class="headerlink" title="AQS 的数据结构？"></a>AQS 的数据结构？</h3><p>AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点，<br>这个节点有几个属性值</p>
<ol>
<li>waitStatus 当前节点在队列中的状态</li>
<li>thread 表示处于该节点的线程</li>
<li>prev    前驱指针</li>
<li>next    后继指针</li>
</ol>
<p>线程有两种锁模式</p>
<ol>
<li>SHARED 表示线程以共享的模式等待锁</li>
<li>EXCLUSIVE 表示线程正在以独占的方式等待锁</li>
</ol>
<h3 id="waitStatus-的取值情况？"><a href="#waitStatus-的取值情况？" class="headerlink" title="waitStatus 的取值情况？"></a>waitStatus 的取值情况？</h3><p>waitStatus有下面几个枚举值</p>
<ol>
<li>0 当一个Node被初始化的时候的默认值</li>
<li>CANCELLED 为1，表示线程获取锁的请求已经取消了</li>
<li>CONDITION 为-2，表示节点在等待队列中，节点线程等待唤醒</li>
<li>PROPAGATE 为-3，当前线程处在SHARED情况下，该字段才会使用</li>
<li>SIGNAL 为-1，表示线程已经准备好了，就等资源释放了</li>
</ol>
<h3 id="同步状态State-是什么？"><a href="#同步状态State-是什么？" class="headerlink" title="同步状态State 是什么？"></a>同步状态State 是什么？</h3><p>AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状<br>态，是由Volatile修饰的，用于展示当前临界资源的获锁情况，有几个访<br>问这个字段的方法</p>
<ol>
<li>getState 获取State的值</li>
<li>setState 设置State的值</li>
<li>compareAndSetState 使用CAS方式更新State</li>
</ol>
<p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改<br>State字段表示的同步状态来实现多线程的独占模式和共享模式</p>
<h3 id="线程加入等待队列的底层原理？"><a href="#线程加入等待队列的底层原理？" class="headerlink" title="线程加入等待队列的底层原理？"></a>线程加入等待队列的底层原理？</h3><p>以非公平锁为例</p>
<ol>
<li>使用lock进行加锁 如果成功通过CAS修改了state，指定当前线程为该锁<br>的独占线程，标志自己成功获取锁</li>
<li>如果CAS 失败的话，调用acquire()</li>
<li>acquire 方法中首先会调用 tryAcquire(arg) 方法，会尝试再次通过<br>CAS修改state为1，如果失败而且发现锁是被当前线程占用的，就执行重入<br>（state++），返回 true 表示获取成功也就正常退出了。如果锁是被其他<br>线程占有，那么当前线程执行tryAcquire返回失败，并且执行addWaiter()<br>加入到同步队列的尾部，最后调用acquireQueued(final Node node, int<br>arg) 通过 “死循环”的方式获取同步状态，如果获取不到则阻塞节点中对应<br>的线程，而被阻塞后的唤醒只能依靠前驱节点出队或者阻塞线程被中断来实<br>现</li>
<li>addWaiter() 当前的线程和锁模式新建一个节点，Pred指针指向尾节点<br>Tail，将New中Node的Prev指针指向Pred，通过compareAndSetTail方法<br>，完成尾节点的设置</li>
</ol>
<h3 id="AQS的设计模式"><a href="#AQS的设计模式" class="headerlink" title="AQS的设计模式"></a>AQS的设计模式</h3><p>AQS底层使用了模板方法模式，子类通过继承的方式，实现它的抽象方法来管理<br>同步状态。AQS提供了大量的模板方法来实现同步，主要是分为三类：独占式获<br>取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情<br>况。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。<br>如果需要自定义同步器一般的方式是这样</p>
<ol>
<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重<br>写方法很简单，无非是对于共享资源state的获取和释放）</li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板<br>方法会调用使用者重写的方法</li>
</ol>
<h3 id="同步锁如何唤醒后继节点？"><a href="#同步锁如何唤醒后继节点？" class="headerlink" title="同步锁如何唤醒后继节点？"></a>同步锁如何唤醒后继节点？</h3><p>在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入<br>到这个CLH同步队列的对尾并一直保持着自旋。在CLH 同步队列中的线程在自<br>旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状<br>态，获取成功则退出CLH 同步队列。当线程执行完逻辑后，会释放同步状态<br>，释放后会唤醒其后继节点</p>
<h3 id="模板方法有哪些？"><a href="#模板方法有哪些？" class="headerlink" title="模板方法有哪些？"></a>模板方法有哪些？</h3><ol>
<li>独占式同步状态获取 acquire(int arg) 该方法对中断不敏感，也就是<br>说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断<br>操作时，线程不会从同步队列中移除</li>
<li>独占式同步状态释放 release(int arg) 当线程获取同步状态后，执行完<br>相应逻辑后就需要释放同步状态，释放成功后，唤醒后继节点</li>
<li>共享式同步状态获取 acquireShared(int arg) 如果获取失败，自旋获取<br>同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功</li>
<li>共享式同步状态释放 releaseShared(int arg) 可能会存在多个线程同时<br>进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通<br>过CAS和循环来完成的</li>
</ol>
<h3 id="自定义同步器的实现？"><a href="#自定义同步器的实现？" class="headerlink" title="自定义同步器的实现？"></a>自定义同步器的实现？</h3><p>自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，<br>至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的<br>时候主要实现下面几种方法</p>
<ol>
<li>tryAcquire(int) 独占方式，尝试获取资源</li>
<li>tryRelease(int) 独占方式。尝试释放资源</li>
<li>tryAcquireShared(int) 负数表示失败，0表示成功，但没有剩余可用资源<br>正数表示成功，且有剩余资源</li>
<li>tryReleaseShared(int) 共享方式，尝试释放资源，成功则返回true，<br>失败则返回false</li>
</ol>
<h3 id="某个线程获取锁失败的后续流程是什么？"><a href="#某个线程获取锁失败的后续流程是什么？" class="headerlink" title="某个线程获取锁失败的后续流程是什么？"></a>某个线程获取锁失败的后续流程是什么？</h3><p>存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流<br>程仍在继续</p>
<h3 id="队列是什么数据结构？"><a href="#队列是什么数据结构？" class="headerlink" title="队列是什么数据结构？"></a>队列是什么数据结构？</h3><p>是CLH变体的FIFO双端队列</p>
<h3 id="排队等候机制中的线程，什么时候有机会获取锁？"><a href="#排队等候机制中的线程，什么时候有机会获取锁？" class="headerlink" title="排队等候机制中的线程，什么时候有机会获取锁？"></a>排队等候机制中的线程，什么时候有机会获取锁？</h3><p>前驱结点是头结点，并且当前线程获取锁成功</p>
<h3 id="处于排队等候机制中的线程一直无法获取锁？"><a href="#处于排队等候机制中的线程一直无法获取锁？" class="headerlink" title="处于排队等候机制中的线程一直无法获取锁？"></a>处于排队等候机制中的线程一直无法获取锁？</h3><p>线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放</p>
<h3 id="Lock函数通过Acquire方法进行加锁，如何实现？"><a href="#Lock函数通过Acquire方法进行加锁，如何实现？" class="headerlink" title="Lock函数通过Acquire方法进行加锁，如何实现？"></a>Lock函数通过Acquire方法进行加锁，如何实现？</h3><p>AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现<br>，通过tryAcquire完成加锁过程</p>
<h3 id="AQS如何实现非公平锁和共享锁？"><a href="#AQS如何实现非公平锁和共享锁？" class="headerlink" title="AQS如何实现非公平锁和共享锁？"></a>AQS如何实现非公平锁和共享锁？</h3><ol>
<li>独占且公平的锁很明显获取访问权的方式是通过FIFO队列的顺序，即请求<br>访问共享资源的顺序，而共享锁也是一样，只是可以获取访问权的线程数多<br>了些</li>
<li>非公平锁就是舍弃队列的FIFO特性，只要持有共享资源的线程释放了锁，<br>所有的在同步队列中的线程都会通过CAS操作去竞争锁</li>
</ol>
<h3 id="自定义阻塞队列如何实现生产者消费者模型？"><a href="#自定义阻塞队列如何实现生产者消费者模型？" class="headerlink" title="自定义阻塞队列如何实现生产者消费者模型？"></a>自定义阻塞队列如何实现生产者消费者模型？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition full;</span><br><span class="line">    Condition empty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockQueue</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        array=<span class="keyword">new</span> Object[size];</span><br><span class="line">        full=lock.newCondition();</span><br><span class="line">        empty=lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object e)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(num==array.length)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"产品已满不能生产"</span>);</span><br><span class="line">                    full.await();</span><br><span class="line">                &#125;</span><br><span class="line">                array[num++]=e;</span><br><span class="line">                <span class="comment">//此时产品至少有1个</span></span><br><span class="line">                empty.signalAll();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                        <span class="string">"成功生产一个产品，总数为"</span>+num);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"没有产品不能消费"</span>);</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object obj=array[--num];</span><br><span class="line">            <span class="comment">//此时产品一定未满</span></span><br><span class="line">            full.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+</span><br><span class="line">                    <span class="string">"成功消费一个产品，总数为"</span>+num);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再Main类中创建线程，读者可以运行一下观察结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockQueue queue=<span class="keyword">new</span> BlockQueue(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Product pro=<span class="keyword">new</span> Product(i,queue);</span><br><span class="line">            pro.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Customer cus=<span class="keyword">new</span> Customer(i,queue);</span><br><span class="line">            cus.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    BlockQueue queue;</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> i,BlockQueue queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"生产者线程"</span>+i);</span><br><span class="line">        <span class="keyword">this</span>.queue=queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">                times++;</span><br><span class="line">                queue.put(obj);</span><br><span class="line">                <span class="keyword">if</span>(times==<span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    BlockQueue queue;</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(<span class="keyword">int</span> i,BlockQueue queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"消费者线程"</span>+i);</span><br><span class="line">        <span class="keyword">this</span>.queue=queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                times++;</span><br><span class="line">                queue.take();</span><br><span class="line">                <span class="keyword">if</span>(times==<span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的作用是什么？"><a href="#线程池的作用是什么？" class="headerlink" title="线程池的作用是什么？"></a>线程池的作用是什么？</h3><p>对于一个服务器端的程序，对于每个用户的请求，为了提高服务器资源的利用率<br>和用户请求的响应速度，可以给每个用户都创建一个线程处理请求，如果用户访<br>问非常频繁那么频繁的创建和销毁线程会给服务器带来巨大开销，线程池可以理<br>解为一个处理任务的线程集合，在某个线程处理完任务后并不会立即销毁，而是<br>在线程池中保留一段时间，如果有新的请求那么这个线程就会继续处理任务，其<br>中的任务队列即为阻塞队列</p>
<h3 id="线程池有哪几种创建方式？"><a href="#线程池有哪几种创建方式？" class="headerlink" title="线程池有哪几种创建方式？"></a>线程池有哪几种创建方式？</h3><p>工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池</p>
<ol>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只<br>有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一<br>的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有<br>任务的执行顺序按照任务提交顺序执行，使用的是LinedBlockingQueue</li>
<li>newFixedThreadPool：创建一个可重用、有固定线程数的线程池，当一<br>个新任务提交时如果线程池有空闲线程则立即执行否则任务会暂时存在一个<br>任务队列中核心线程数与总线程数一样，这符合固定大小的线程池不存在线<br>程数量动态变化的情况，使用LinkedBlockingQueue可以存放无限量任务<br>（不耗尽资源的情况下）</li>
<li>newCachedThreadPool：返回一个可根据实际情况调整线程数量的线程<br>池，线程池中的线程数量不确定，如果有空闲线程可复用那么优先使用可复<br>用的线程，如果所有线程都在工作但有新任务提交则会创建新的线程，线<br>程执行完后会复用核心线程数为0，最大线程数无穷大。没有任务时线程<br>池内无线程，当任务提交时线程池会使用空闲线程，若无空闲线程，此<br>时核心线程为0，那么就会把任务加入SynchronousQueue队列，这是<br>一种直接提交的队列，总会迫使线程池增加新的线程，空闲线程60s<br>内会被回收，适用于处理大量需要立即处理并且每个任务耗时较少<br>的任务集合</li>
</ol>
<h3 id="线程池为什么不用Executors的静态方法？"><a href="#线程池为什么不用Executors的静态方法？" class="headerlink" title="线程池为什么不用Executors的静态方法？"></a>线程池为什么不用Executors的静态方法？</h3><p>因为Excutors提供的创建线程池的方法，使用了默认的构造参数，容易导<br>致OOM的错误，FixedThreadPool和SingleThreadPool使用了无界队列<br>，会出现OOM，CachedThreadPool和ScheduledThreadPool的最大线<br>程池数设置为Integer.MAX_VALUE，也会出现OOM</p>
<h3 id="线程池有什么优点？"><a href="#线程池有什么优点？" class="headerlink" title="线程池有什么优点？"></a>线程池有什么优点？</h3><ol>
<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li>
<li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，<br>同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到<br>线程创建就能立即执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗<br>系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优<br>和监控。</li>
<li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.prinln(<span class="string">"xxx"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		MyTask task=<span class="keyword">new</span> MyTask();</span><br><span class="line">		ExecutorService es=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			es.submit(task);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拒绝策略有哪些？"><a href="#拒绝策略有哪些？" class="headerlink" title="拒绝策略有哪些？"></a>拒绝策略有哪些？</h3><p>等待队列已经排满，再也塞不下新的任务，而且也达到了maximumPoolSize<br>数量，无法继续为新任务服务，这个时候我们便要采取拒绝策略机制合理的<br>处理这个问题。以下内置拒绝策略均实现了RejectExecutionHandler接口</p>
<ul>
<li>AbortPolicy（默认）直接抛出RejectedException异常来阻止系统正常运行</li>
<li>CallerRunnsPolicy：“调用者运行” 一种调节机制，该策略既不会抛弃<br>任务，也不会抛出异常。线程调用运行该任务的execute本身。此策略提供<br>简单的反馈控制机制，能够减缓新任务的提交速度</li>
<li>DiscardPolicy：不执行该任务，并将该任务删除且不抛出异常，如果允<br>许任务丢失，这是最好的拒绝策略</li>
<li>DiscardOldestPolicy：丢弃队列中最近的任务，并执行当前提交的任务</li>
</ul>
<h3 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h3><ol>
<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行<br>任务的线程</li>
<li>TIDYING：所有的任务都销毁了，workCount为0，线程池的状态在转<br>换为TIDYING 状态时，会执行钩子方法terminated()</li>
<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个</li>
</ol>
<h3 id="shutdown-和shutdownNow-的区别？"><a href="#shutdown-和shutdownNow-的区别？" class="headerlink" title="shutdown()和shutdownNow()的区别？"></a>shutdown()和shutdownNow()的区别？</h3><ol>
<li>shutdown() :关闭线程池，线程池的状态变为SHUTDOWN。线程池不再接<br>受新任务了，但是队列里的任务和正在执行的任务得执行完毕</li>
<li>shutdownNow() :关闭线程池，线程的状态变为STOP。线程池会终止当<br>前正在运行的任务，并停止处理排队的任务并返回正在等待执行的List。<br>shutdownNow 的原理是遍历线程池中的工作线程，然后逐个调用线程的<br>interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</li>
</ol>
<h3 id="isTerminated-和isShutdown-的区别？"><a href="#isTerminated-和isShutdown-的区别？" class="headerlink" title="isTerminated()和isShutdown()的区别？"></a>isTerminated()和isShutdown()的区别？</h3><ol>
<li>isShutDown 当调用 shutdown() 方法后返回为 true</li>
<li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完<br>成后返回为true</li>
</ol>
<h3 id="线程池的生命周期？"><a href="#线程池的生命周期？" class="headerlink" title="线程池的生命周期？"></a>线程池的生命周期？</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由<br>内部来维护。线程池内部使用一个变量维护两个值：运行状态（runState）<br>和线程数量 (workerCount)。有5种状态</p>
<ol>
<li>RUNNING 能接受新提交的任务，并且能够处理阻塞队列中的任务，当<br>调用shutdown()方法进入SHUTDOWN，调用shutdownNow()方法进入STOP</li>
<li>SHUTDOWN 关闭状态，不再接受新提交的任务，但是可以继续处理阻塞<br>队列中已保存的任务</li>
<li>STOP 不能接受新任务，也不处理队列中的任务，会中断正在处理的<br>任务线程</li>
<li>TIDYING 所有任务都终止，有效线程数量 (workerCount)为0</li>
<li>TERMINATED 在terminated()方法执行完进入该状态</li>
</ol>
<h3 id="线程池核心如何设计？"><a href="#线程池核心如何设计？" class="headerlink" title="线程池核心如何设计？"></a>线程池核心如何设计？</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor</p>
<ol>
<li>ThreadPoolExecutor继承AbstractExecutorService类</li>
<li>AbstractExecutorService类实现ExecutorService接口</li>
<li>ExecutorService接口继承Executor接口</li>
<li>Executor接口有一个execute 方法</li>
</ol>
<p>ThreadPoolExecutor 实现的顶层接口是Executor，顶层接口Executor<br>提供了一种思想： 将任务提交和任务执行进行解耦。用户无需关注如何创<br>建线程，如何调度线程来执行任务，用户只需提供Runnable 对象，将任<br>务的运行逻辑提交到执行器(Executor)中，由Executor 框架完成线程<br>的调配和任务的执行部分。ThreadPoolExecutor 将会一方面维护自身<br>的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执<br>行并行任务</p>
<h3 id="RunnableFuture-对象的作用？"><a href="#RunnableFuture-对象的作用？" class="headerlink" title="RunnableFuture 对象的作用？"></a>RunnableFuture 对象的作用？</h3><ol>
<li>RunnableFuture接口，这个对象继承了Runnable接口和Future接口</li>
<li>既可以作为 Runnable 对象来给 execute(Runnable task) 提供<br>参数，也可以作为 submit 的返回值</li>
<li>事实上这个接口对象封装了两个对象，分别是要执行的任务对象<br>（Runnable）和保存任务的执行状态信息对象（Future）</li>
<li>这个接口的实现类FutureTask 则是实现了RunnableFuture 接口中<br>的方法，在其的run() 方法中会调用创建 FutureTask 对象时传入的<br>Callable 对象的call() 方法或者是Runnable 对象的run() 方法</li>
</ol>
<h3 id="线程池的直接父类和间接父类的作用？"><a href="#线程池的直接父类和间接父类的作用？" class="headerlink" title="线程池的直接父类和间接父类的作用？"></a>线程池的直接父类和间接父类的作用？</h3><ol>
<li>Executor接口 这个接口声明一个execute 方法，这个方法其实就是向线<br>程池提交任务的核心方法，command参数即为要执行的任务的Runnable对象</li>
<li>ExecutorService接口 </li>
</ol>
<ul>
<li>shutdown()和shutdownNow()，isTerminated()和isShutdown()都是<br>在这个接口声明但是没有提供实现。</li>
<li>submit(Callable)和submit(Runnable task, T result)和submit<br>(Runnable task)都是在这个接口声明但没提供实现，都是提交新任务到<br>线程池都没有提供实现，都是返回一个Future对象，封装了获取任务执行<br>状态信息的方法</li>
</ul>
<ol start="3">
<li>AbstractExecutorService抽象类 </li>
</ol>
<ul>
<li>实现newTaskFor(Runnable/Callabel) 返回一个RunnableFuture对象<br>，本质是new FutureTask</li>
<li>实现submit 方法 先调用了newTaskFor(task) 方法来得到一个<br>RunnableFuture 对象，两个 submit 方法都通过 execute 方法<br>来向线程池中提交任务，但是该类没有实现execute方法</li>
</ul>
<ol start="4">
<li>ThreadPoolExecutor类</li>
</ol>
<ul>
<li>实现execute 方法 两个submit方法本质是通过execute来向线程池中提<br>交任务</li>
</ul>
<h3 id="execute-具体如何实现？"><a href="#execute-具体如何实现？" class="headerlink" title="execute 具体如何实现？"></a>execute 具体如何实现？</h3><ol>
<li>如果当前活动线程数 &lt; 指定的核心线程数，则创建并启动一个核心线程来<br>执行新提交的任务</li>
<li>如果当前活动线程数 &gt;= 指定的核心线程数，且任务队列未满以及线程池<br>处于运行状态，则将任务添加到缓存队列中</li>
<li>如果当前活动线程数 &gt;= 指定的核心线程数，且缓存队列已满，则创建并启<br>动一个非核心线程来执行新提交的任务，否则执行拒绝策略</li>
</ol>
<h3 id="Worker-是什么？"><a href="#Worker-是什么？" class="headerlink" title="Worker 是什么？"></a>Worker 是什么？</h3><ol>
<li>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工<br>作线程Worker</li>
<li>Worker 这个工作线程，实现了Runnable 接口，并持有一个线程thread<br>，一个初始化的任务firstTask</li>
<li>thread是在调用构造方法时通过ThreadFactory 来创建的线程，可以用来<br>执行任务，firstTask 用它来保存传入的第一个任务</li>
<li>这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动<br>初期立即执行这个任务，也就对应核心线程创建时的情况，如果这个值是null<br>，说明创建的是一个非核心线程去执行任务列表中的任务</li>
<li>创建的线程在执行时就会调用这个对象的run方法，即调用runWorker方法</li>
</ol>
<h3 id="ThreadFactory是什么？"><a href="#ThreadFactory是什么？" class="headerlink" title="ThreadFactory是什么？"></a>ThreadFactory是什么？</h3><p>线程池的主要作用是为了线程复用，最开始的线程是通过ThreadFactory 产<br>生，ThreadFactory 是一个接口，它只有一个方法，就是用来创建线程，重<br>写该方法可以更加自由设置线程池中所有线程的状态</p>
<h3 id="runWorker-方法具体实现？"><a href="#runWorker-方法具体实现？" class="headerlink" title="runWorker 方法具体实现？"></a>runWorker 方法具体实现？</h3><ol>
<li>如果Worker 对象的firstTask 不为空，则先执行第一个任务</li>
<li>while 循环不断地通过getTask() 方法从阻塞队列中获取任务</li>
<li>申请重入锁执行任务，任务执行完释放重入锁</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前<br>线程不是中断状态</li>
<li>如果getTask 结果为null 说明线程池已经关闭或者任务队列为空则跳出<br>循环，执行processWorkerExit()方法，回收线程</li>
</ol>
<h3 id="addWorker-方法的作用？"><a href="#addWorker-方法的作用？" class="headerlink" title="addWorker 方法的作用？"></a>addWorker 方法的作用？</h3><p>execute 方法中多次通过addWorker 方法添加线程任务</p>
<ol>
<li>添加新的线程来将firstTask 任务作为第一任务执行，执行完成之后执<br>行线程池任务队列中其他任务，core 参数为是否添加核心线程</li>
<li>首先判断线程池的运行状态，如果线程池已经被停止或者关闭等，那么直<br>接返回false</li>
<li>如果线程数大于线程池最大线程或者想添加核心线程来处理firstTask但<br>是核心线程已经饱和，或者添加非核心线程来处理firstTask但是线程池总线<br>程数已达到饱和，返回false</li>
<li>如果保存线程池状态信息的变量没发生变化，证明这个过程线程池是没有<br>发生状态变化的，使得其包装的线程池工作线程数信息加一</li>
<li>添加新的工作对象来处理任务，Worker 对象为 任务-线程 的包装类，<br>创建该对象时会创建一个新的线程</li>
<li>工作集workers 中添加新建的Worker，workers为一个HashSet<Woker><br>对象，保存的是线程池中的所有Worker</Woker></li>
<li>如果添加Worker 成功，启动新建的线程，执行任务</li>
</ol>
<p>到这里就应该知道线程池存储的并不是Thread对象，而是封装后的Worker<br>对象，并且每新建一个Worker对象都会吧这个对象存入workers集合中，<br>wokers集合实际是ThreadPoolExecutor的一个HashSet<Worker>集合<br>类型的成员变量</Worker></p>
<h3 id="ThreadPoolExecutor的运行机制？"><a href="#ThreadPoolExecutor的运行机制？" class="headerlink" title="ThreadPoolExecutor的运行机制？"></a>ThreadPoolExecutor的运行机制？</h3><p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解<br>耦，并不直接关联，从而良好的缓冲任务，复用线程。<br>线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生<br>产者的角色，当任务提交后，线程池会判断该任务后续的流转：</p>
<ol>
<li>直接申请线程执行该任务</li>
<li>缓冲到队列中等待线程执行</li>
<li>拒绝该任务<br>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线<br>程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程<br>获取不到任务的时候，线程就会被回收</li>
</ol>
<h3 id="Executor和Executors的区别？"><a href="#Executor和Executors的区别？" class="headerlink" title="Executor和Executors的区别？"></a>Executor和Executors的区别？</h3><ol>
<li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来<br>满足业务的需求</li>
<li>Executor 是一个接口，这个接口就声明了一个 execute 方法，参数<br>是一个 Runnable 对象，这个方法其实就是向线程池中提交任务的核心方<br>法，command 参数即为要执行的任务的 Runnable对象</li>
<li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了<br>更多的方法我们能获得任务执行的状态并且可以获取任务的返回值</li>
<li>使用 ThreadPoolExecutor 可以创建自定义线程池</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以<br>等待计算的完成，并可以使用get()方法获取计算的结果</li>
</ol>
<h3 id="线程池参数如何设置？"><a href="#线程池参数如何设置？" class="headerlink" title="线程池参数如何设置？"></a>线程池参数如何设置？</h3><ol>
<li>常规设置 分IO 密集型任务或者分CPU 密集型任务</li>
</ol>
<ul>
<li>CPU 密集型任务 CPU密集型也叫计算密集型，指的是系统的硬盘、内存性<br>能相对CPU要好很多，此时系统运作大部分的状况是CPU Loading 100%，<br>CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有<br>许多运算要处理，CPU Loading 很高。corePoolSize = CPU核数 + 1</li>
<li>IO 密集型任务 系统大部分时间在跟I/O交互，而这个时间线程不会占用<br>CPU来处理，即在这个时间范围内，可以由其他线程来使用CPU，因而可以<br>多配置一些线程。CPU核数 * 2</li>
</ul>
<h3 id="怎么创建线程池？"><a href="#怎么创建线程池？" class="headerlink" title="怎么创建线程池？"></a>怎么创建线程池？</h3><p>通过new ThreadPoolExecutor() 创建一个线程池，需要提供六个参数</p>
<ol>
<li>corePoolSize 线程池中的最大核心线程数，默认情况下线程池是空的，<br>没有线程，当核心线程数等于corePoolSize的时候就不会继续创建核心线程<br>了，如果调用线程池对象的prestartAllCoreThread() 方法，那么线程池<br>会提前创建好所有的核心线程</li>
<li>maximumPoolSize 线程池中允许创建最大线程数，，这个参数只有在任<br>务队列已满时才有意义。也就是说当已经达到核心线程数但是队列未满时不<br>会创建非核心线程，都添加任务到任务队列满的时候才会开始创建非核心<br>线程，如果使用无界队列则这个参数没有意义</li>
<li>keepAliveTime 线程池中非核心线程允许闲置的最长时间，超过这个时<br>间的非核心线程将会被回收，对于任务很多并且每个任务处理时间较短的的<br>情况，可以适当提升keepAliveTime参数来提高线程利用率。当设置允许核<br>心线程的回收属性为true时，keepAliveTime 参数也会作用到核心线程上</li>
<li>unit keepAliveTime 参数的时间单位</li>
<li>workQueue 任务队列，被提交但尚未被执行的任务，用于存放Runnnable<br>对象</li>
<li>threadFactory 创建线程的工厂，一般情况使用默认的即可</li>
<li>handler 饱和策略，即为当任务队列和线程池中线程数均达到饱和时采取<br>的应对策略，默认是AbordPolicy，表示无法处理新的任务，并在有新任务<br>提交时抛出异常</li>
</ol>
<h3 id="Worker-线程如何回收？"><a href="#Worker-线程如何回收？" class="headerlink" title="Worker 线程如何回收？"></a>Worker 线程如何回收？</h3><p>线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这<br>样的操作来控制线程的生命周期，Worker是通过继承AQS，使用AQS来实现独占<br>锁这个功能</p>
<ol>
<li>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程<br>池的状态维护一定数量的线程引用，防止这部分线程被JVM回收</li>
<li>当线程池决定哪些线程需要回收时，只需要将其引用消除即可</li>
<li>Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线<br>程可以无限等待获取任务，非核心线程要限时获取任务</li>
<li>当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker<br>会主动消除自身在线程池内的引用</li>
</ol>
<h3 id="核心线程如何保证不被销毁？"><a href="#核心线程如何保证不被销毁？" class="headerlink" title="核心线程如何保证不被销毁？"></a>核心线程如何保证不被销毁？</h3><ol>
<li>核心线程与非核心线程，在线程池的数据结构中并没有明确区分</li>
<li>只要线程池剩余的线程数小于等于corePoolSize，那么剩下的线程都可以称<br>为核心线程</li>
<li>一旦线程池的线程个数小于等于corePoolSize，getTask() 是不会返<br>回null，而是等待获取任务</li>
<li>线程数大于corePoolSize，非核心线程的空闲时间，大于keepalivetime<br>，此线程才会被销毁</li>
</ol>
<h3 id="任务执行机制是什么样的？"><a href="#任务执行机制是什么样的？" class="headerlink" title="任务执行机制是什么样的？"></a>任务执行机制是什么样的？</h3><p>所有任务的调度都是由execute 方法完成的，这部分完成的工作是：检查现<br>在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直<br>接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保<br>证在RUNNING 的状态下执行任务</li>
<li>线程数量未达到corePoolSize，则新建一个核心线程执行任务</li>
<li>线程数量达到了corePoolSize，则将任务移入队列等待</li>
<li>队列已满，新建非核心线程执行任务</li>
<li>队列已满，总线程数又达到了maximumPoolSize，执行拒绝策略，默认的<br>处理方式是直接抛异常</li>
</ol>
<h3 id="任务缓冲是什么？"><a href="#任务缓冲是什么？" class="headerlink" title="任务缓冲是什么？"></a>任务缓冲是什么？</h3><p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和<br>线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不<br>让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者<br>模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻<br>塞队列中获取任务。</p>
<h3 id="阻塞队列是什么？"><a href="#阻塞队列是什么？" class="headerlink" title="阻塞队列是什么？"></a>阻塞队列是什么？</h3><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的<br>操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时<br>，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景<br>，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<br>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素</p>
<h3 id="常用的阻塞队列有哪些？"><a href="#常用的阻塞队列有哪些？" class="headerlink" title="常用的阻塞队列有哪些？"></a>常用的阻塞队列有哪些？</h3><ol>
<li>ArrayBlockingQueue ：是一个基于数组结构的有界阻塞队列，此队列按<br>照FIFO（先进先出）规则排序，支持公平锁和非公平锁</li>
<li>LinkedBlockingQueue ：是一个基于链表结构的有界阻塞队列（大小默认<br>值为Integer.MAX_VALUE），此队列按照FIFO（先进先出）对元素进行排序，<br>吞吐量通常要高于ArrayBlockingQueue</li>
<li>SynchronusQueue： 是一个不储存元素的阻塞队列，每个插入操作必须等<br>到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要<br>高于LinkedBlockingQueue</li>
<li>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ol>
<h3 id="线程池如何设计？"><a href="#线程池如何设计？" class="headerlink" title="线程池如何设计？"></a>线程池如何设计？</h3><ol>
<li>并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什<br>么任务应该被缓存下来，而是应该立即执行</li>
<li>并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用<br>队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积</li>
</ol>
<h3 id="线程池中submit-和execute-方法有什么区别？"><a href="#线程池中submit-和execute-方法有什么区别？" class="headerlink" title="线程池中submit()和execute()方法有什么区别？"></a>线程池中submit()和execute()方法有什么区别？</h3><p>一个线程池可以接受任务类型有Runnable和Callable，分别对应了execute<br>和submit方法</p>
<ol>
<li>接收参数：execute()只能执行 Runnable 类型的任务。submit()可<br>以执行Runnable 和 Callable 类型的任务</li>
<li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否<br>被线程池执行成功与否</li>
<li>submit()方法用于提交需要返回值的任务。线程池会返回一个Future<br>类型的对象，通过这个 Future 对象可以判断任务是否执行成功（可以<br>通过Future 的get()方法来获取返回值，get()方法会阻塞当前线程直<br>到任务完成，而使用 get（long timeout，TimeUnit unit）方法则<br>会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。）</li>
<li>异常处理：submit()方便Exception处理，Future 表示异步计算的结<br>果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用<br>get()方法获取计算的结果</li>
<li>execute会直接打印异常信息，但不会给其他线程造成影响</li>
<li>submit()执行出现异常时，异常信息存储在返回future对象里，只有<br>get的时候，才会出现异常信息，调用者能够感知这些exception并做出<br>及时的处理，如果不使用get 那么不会打印异常信息</li>
</ol>
<h3 id="Executors和ThreaPoolExecutor创建线程池的区别？"><a href="#Executors和ThreaPoolExecutor创建线程池的区别？" class="headerlink" title="Executors和ThreaPoolExecutor创建线程池的区别？"></a>Executors和ThreaPoolExecutor创建线程池的区别？</h3><p>不允许使用 Executors 去创建，而是通过ThreadPoolExecutor的方式，<br>这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的<br>风险。Executors 各个方法的弊端：</p>
<ul>
<li>newFixedThreadPool 和 newSingleThreadExecutor:主要问题是堆积<br>的请求处理队列可能会耗费非常大的内存，甚至 OOM。</li>
<li>newCachedThreadPool 和 newScheduledThreadPool:主要问题是线程<br>数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM</li>
</ul>
<h3 id="线程池被创建后里面有线程吗？"><a href="#线程池被创建后里面有线程吗？" class="headerlink" title="线程池被创建后里面有线程吗？"></a>线程池被创建后里面有线程吗？</h3><p>线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热可<br>以调用如下两个方法</p>
<ol>
<li>prestartAllcoreThreads 启动全部核心线程</li>
<li>prestartCoreThread 仅启动一个核心线程</li>
</ol>
<h3 id="核心线程数会被回收吗？"><a href="#核心线程数会被回收吗？" class="headerlink" title="核心线程数会被回收吗？"></a>核心线程数会被回收吗？</h3><p>核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面<br>的方法 allowCoreThreadTimeOut，传入参数true</p>
<h3 id="线程组是什么？"><a href="#线程组是什么？" class="headerlink" title="线程组是什么？"></a>线程组是什么？</h3><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线<br>程对象，也可以有线程组，组中还可以有线程。一个线程只有调用start方<br>法后才会被加入线程组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新线程组，以调用这个构造方法的线程所在线程组为父线程组</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建一个新线程组，parent为指定的父线程组</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//返回在当前线程组和子线程组中活跃的线程数量（估计值）</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activeCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   <span class="comment">//清除当前线程组和子线程组，需要保证当前线程组和子线程组所有线程都停止</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   <span class="comment">//中断线程组中所有的线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="线程池和线程组的区别？"><a href="#线程池和线程组的区别？" class="headerlink" title="线程池和线程组的区别？"></a>线程池和线程组的区别？</h3><p>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便<br>线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线<br>程的开销</p>
<h3 id="线程组为什么不推荐使用？"><a href="#线程组为什么不推荐使用？" class="headerlink" title="线程组为什么不推荐使用？"></a>线程组为什么不推荐使用？</h3><p>线程组ThreadGroup对象中的stop，resume，suspend会导致安全问题，主要<br>是死锁问题，已经被官方废弃</p>
<h3 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h3><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程<br>存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景<br>下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操<br>作的场景。<br>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了<br>一个以开地址法实现的ThreadLocal.ThreadLocalMap，每个线程可以访问自<br>己内部ThreadLocalMap 对象内的value，把数据进行隔离，数据不共享，自<br>然就没有线程安全方面的问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 新建一个 ThreadLocal 对象</span></span><br><span class="line">	<span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 新建 5 个子线程，run 方法中调用新建的 ThreadLocal 对象 value 的 </span></span><br><span class="line">		<span class="comment">//get/set 方法来获取/设置对应值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">// 当当前线程中 value 值不大于 5 时候继续循环</span></span><br><span class="line">					<span class="keyword">while</span> (value.get() &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">						System.out.println(Thread.currentThread().getName() + </span><br><span class="line">							<span class="string">" 的 value 值："</span> + value.get());</span><br><span class="line">						<span class="comment">// 当前线程的 value 自增一</span></span><br><span class="line">						value.set(value.get() + <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;, <span class="string">"线程 "</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序会报空指针异常，可是value是新建的一个对象，是否是没有<br>赋初始值，如果在startTest开头加value.set(0)依然报空指针异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//通过当前线程得到ThreadLocalMap</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap map = <span class="keyword">this</span>.getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                T result = e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对象为空调用这个设置初始值的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.<span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//返回threadLocals</span></span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Thread中定义了这个变量，Thread的构造方法中并未对这个变量赋值</span></span><br><span class="line">    ThreadLocalMap threadLocals;</span><br><span class="line">    <span class="comment">//threadLocals默认为null，所以会调用以下方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//获取initialValue的返回值</span></span><br><span class="line">        T value = <span class="keyword">this</span>.initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocal.ThreadLocalMap map = <span class="keyword">this</span>.getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">            TerminatingThreadLocal.register((TerminatingThreadLocal)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回null，到这里可知get为什么返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setInitialValue方法中也会给threadLocals创建一个新的对象</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap类似一个映射表，键就是当前ThreadLocal对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说多个线程中的ThreadLocalMap字段对象将对应的同一个ThreadLocal<br>对象作为 ThreadLocalMap 字段对象的键，而对应储存的值却互相独立。即同<br>一个ThreadLocal对象作为多个线程中的ThreadLocalMap对象中的键。通过这<br>种机制来完成每个线程中储存一个对应变量的值，不同线程之间这个值相互独立。</p>
<p>创建ThreadLocal对象时重写initialValue方法并返回一个非null的默认值<br>作为每个线程存储的变量的默认值，调用get方法时就不会返回null值。<br>除了在创建ThreadLocal的时候重写initialValue方法赋初始值，也可以使<br>用set方法赋初始值然后使用get得到，不过这种方法对每个线程来说都要先<br>使用set赋初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">		<span class="comment">// 重写 initialValue 方法，提供给每个线程保存的对象一个默认的值</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocalMap是什么？"><a href="#ThreadLocalMap是什么？" class="headerlink" title="ThreadLocalMap是什么？"></a>ThreadLocalMap是什么？</h3><p>这个类很像HashMap，是ThreadLocal的静态子类，键是一个ThreadLocal对象<br>调用ThradLocal的get方法时，首先会获取当前线程的ThreadLocalMap对象，<br>如果这个对象不为空，那么就会获取这个ThreadLocalMap对象的Entry对象，<br>并获取Entry对象的value返回值，如果为空就会创建ThreadLocalMap对象，<br>value值就是initialVlaue中的返回值</p>
<h3 id="锁优化有几种方式？"><a href="#锁优化有几种方式？" class="headerlink" title="锁优化有几种方式？"></a>锁优化有几种方式？</h3><ol>
<li>减小持有锁的时间 如果线程持有锁的时间越长锁的竞争也会越激烈，<br>只在必要时进行同步</li>
<li>减小锁粒度 对于HashMap 来说最重要的就是get()和put()方法，一种<br>方式就是对整个HashMap加锁，加锁粒度太大，对于ConcurrentHashMap<br>其内部进一步细分成若干HashMap ，称之为段(SEGMENT)，默认情况细<br>分为16 个段。如果需要在该对象中加一个新的表项，并不是给整个对象<br>加锁，而是根据hashcode 得到该表项应被存到哪个段中，然后对该段<br>加锁，并完成put操作，多线程环境如果多个线程同时进行put操作，<br>是有可能同时接受16个线程的put操作。减少锁粒度的核心就是缩小<br>锁定对象的范围，从而减少锁冲突的可能</li>
<li>读写分离锁来替换独占锁 如果之前减少锁粒度是通过分割数据结构来<br>实现，那么读写锁是对系统功能点的分割，在读多写少的情况下使用读写<br>锁较好</li>
<li>锁分离 读写锁根据读写操作功能上的不同进行有效分离，依据应用程序<br>的功能特点也可以对独占锁进行分离，比如LinkedBlockingQueue 的实<br>现，该类中take和put分别实现从队列中取数据和增加数据的功能，这两<br>个操作一个是在链表的前端一个是在末尾，理论上并不会冲突，该阻塞<br>队列就是用到了锁分离</li>
<li>锁粗化 通常情况为了保证多线程的有效并发，会要求每个线程持有锁<br>的时间尽量短，即完成操作后立即释放锁，但是如果对一个锁频繁进行请<br>求、同步的释放本身也会消耗系统资源，为此虚拟机在遇到一连串连续对<br>同一个锁进行请求的释放的操作时，会将所有的锁操作整合成一次对锁<br>的请求，从而减少锁的同步请求次数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在循环时应注意锁的粗化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="JVM如何优化锁？"><a href="#JVM如何优化锁？" class="headerlink" title="JVM如何优化锁？"></a>JVM如何优化锁？</h3><ol>
<li>锁偏向 如果一个线程获得了锁那么锁就进入偏向模式，当这个线程再次<br>请求锁的时候无需再做任何同步操作，在几乎没有锁竞争的场合偏向锁比较<br>好，如果每次都是不同线程来请求锁那么偏向模式会失效，以下参数可以开<br>启偏向锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking</span><br></pre></td></tr></table></figure></li>
<li>轻量级锁 如果偏向锁失败，虚拟机并不会立即挂起线程，还会使用一种<br>叫轻量级锁的优化手段，它只是简单将对象头部作为指针，指向持有锁的线<br>程堆栈的内部，来判断一个线程是否持有对象锁，如果线程获得轻量级锁成<br>功则会顺利进入临界区。如果失败当前线程锁请求会膨胀为重量级锁</li>
<li>重量级锁 内置锁是JVM提供的最便捷的线程同步工具，在代码块或方法<br>声明synchronized关机子即可使用内置锁，内置锁在JAVA中被抽象为监视<br>器monitor，JDK1.6以前监视器可以直接认为对应底层操作系统中的互斥<br>量mutex，这也就是重量级锁</li>
<li>自旋锁 由于当前线程暂时无法获取锁，但是没有必要直接挂起，还会做<br>最后的努力。因此会让该线程先做几个空循环，如果还不能获取锁就在操作<br>系统层面挂起，这样的好处是减少线程上下文切换的消耗，缺点是循环会<br>消耗CPU。CAS问题中的unsafe 用到的就是自旋锁</li>
<li>锁消除 JVM在JIT 编译时会对运行上下文进行扫描，通过对运行上下文的扫<br>描，去除不可能存在资源竞争锁，比如在使用JDK内置的API时，StringBuffer<br>Vector，很可能在一个不可能存在并发竞争的场合使用Vector，比如在函数内<br>部创建一个Vector对象，所以JVM会将这些无用的锁去除</li>
</ol>
<h3 id="synchronized锁升级的原理是什么？"><a href="#synchronized锁升级的原理是什么？" class="headerlink" title="synchronized锁升级的原理是什么？"></a>synchronized锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid字段，在<br>第一次访问的时候threadid 为空，jvm让其持有偏向锁，并将threadid设置为<br>其线程id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果<br>一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自<br>旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用<br>的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了<br>synchronized锁的升级</p>
<h3 id="什么是线程死锁？"><a href="#什么是线程死锁？" class="headerlink" title="什么是线程死锁？"></a>什么是线程死锁？</h3><p>死锁就是两个或多个线程相互占用对方需要的资源，而都不进行释放，导致彼此<br>之间都相互等待对方释放资源，产生无限制等待的线程。注意参于死锁的线程不<br>占用CPU</p>
<h3 id="如何定位死锁？"><a href="#如何定位死锁？" class="headerlink" title="如何定位死锁？"></a>如何定位死锁？</h3><ol>
<li>jps 命令定位进程编号</li>
<li>jstack 找到死锁查看</li>
</ol>
<h3 id="不变模式是什么？"><a href="#不变模式是什么？" class="headerlink" title="不变模式是什么？"></a>不变模式是什么？</h3><p>不变模式的核心思想是一个对象一旦被创建，则它的内部状态将永远不会被<br>改变，所以没有一个线程可以修改其内部状态和数据，同时其内部状态也不<br>会自行发生改变。不变模式的主要使用场景需要满足两个条件</p>
<ol>
<li>当对象创建后，其内部状态和数据不再发生任何变化</li>
<li>对象需要被共享，被多线程频繁访问</li>
</ol>
<p>由于基本数据类型和String类型在实际开发中引用极其广泛，使用不变模式<br>后所有的实例方法均不需要进行同步操作</p>
<h3 id="CAS-如果一直自旋有什么问题？怎么解决？"><a href="#CAS-如果一直自旋有什么问题？怎么解决？" class="headerlink" title="CAS 如果一直自旋有什么问题？怎么解决？"></a>CAS 如果一直自旋有什么问题？怎么解决？</h3><p>可以使用java8中的LongAdder，分段CAS和自动分段迁移，是一个多线程高并<br>发时使用的自增计数器，它的设计思想就是以空间换时间</p>
<ol>
<li>无竞争只更新base 的值</li>
<li>有竞争时，采用分段思想，每个线程都映射到不同的Cell中去更新，使用<br>Cell 来帮助计数最终，结果是base+各个子cell的值</li>
</ol>
<h3 id="为什么cpu密集设置cpu核数-1而不是-1？"><a href="#为什么cpu密集设置cpu核数-1而不是-1？" class="headerlink" title="为什么cpu密集设置cpu核数+1而不是-1？"></a>为什么cpu密集设置cpu核数+1而不是-1？</h3><ol>
<li>如果是CPU密集型应用，则线程池大小设置为N+1</li>
<li>如果是IO密集型应用，则线程池大小设置为2N+1</li>
<li>因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上<br>下文切换的次数，因此会带来额外的开销，但是再怎么计算密集，总有一些<br>IO吧，所以再加一个线程来把等待IO的CPU时间利用起来</li>
</ol>
<h3 id="synchronize的实现原理说下？字节码和对象头？"><a href="#synchronize的实现原理说下？字节码和对象头？" class="headerlink" title="synchronize的实现原理说下？字节码和对象头？"></a>synchronize的实现原理说下？字节码和对象头？</h3><ol>
<li>锁实际上是加在对象上的，那么被加了锁的对象我们称之为锁对象，在<br>java中，任何一个对象都能成为锁对象</li>
<li>java对象在内存中的存储结构主要有一下三个部分：对象头，实例数据<br>，填充数据。对象头中保存了锁信息和指向对象类型数据的指针</li>
<li>当创建一个对象时，偏向锁的标志位是“01”，状态是“0”，表示该对象<br>还没有被加上偏向锁。（“1”是表示被加上偏向锁）。该对象被创建出来的<br>那一刻，就有了偏向锁的标志位，这也说明了所有对象都是可偏向的，但<br>所有对象的状态都为“0”，也同时说明所有被创建的对象的偏向锁并没有<br>生效</li>
<li>当线程执行到临界区，此时会利用CAS操作，将线程ID插入到Markword<br>中，同时修改偏向锁的标志位，此时偏向锁的状态为“1”，说明对象的偏向<br>锁生效了</li>
<li>偏向锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该<br>锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的<br>线程将永远不需要进行同步操作</li>
<li>当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨<br>胀，升级为轻量级锁。这也是我们经常所说的锁膨胀</li>
<li>轻量级锁主要有两种：自旋锁，自适应自旋锁</li>
<li>所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循<br>环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这<br>个线程就可以马上获得锁的，锁在原地循环的时候，是会消耗cpu的，就<br>相当于在执行一个啥也没有的for循环。轻量级锁适用于那些同步代码块<br>执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁<br>了</li>
<li>自旋锁的问题是如果同步代码块执行的很慢，需要消耗大量的时间，那<br>么这个时侯，其他线程在原地等待空消耗cpu，本来一个线程把锁释放之后<br>，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这<br>个锁的话，那么有可能当前线程会获取不到锁，默认情况下，自旋的次数<br>为10次，可以通过-XX:PreBlockSpin来进行更改，当线程超过了这个次<br>数锁会再次膨胀，升级为重量级锁</li>
<li>所谓自适应自旋锁就是线程空循环等待的自旋次数并非是固定的，而是<br>会动态着根据实际情况来改变自旋等待的次数。假如一个线程1刚刚成功获得<br>一个锁，当它把锁释放了之后，线程2获得该锁，并且线程2在运行的过程中<br>，此时线程1又想来获得该锁了，但线程2还没有释放该锁，所以线程1只能<br>自旋等待，但是虚拟机认为，由于线程1刚刚获得过该锁，那么虚拟机觉得<br>线程1这次自旋也是很有可能能够再次成功获得该锁的，所以会延长线程1<br>自旋的次数</li>
<li>另外，如果对于某一个锁，一个线程自旋之后，很少成功获得该锁，那<br>么以后这个线程要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为<br>重量级锁的，以免空循环等待浪费资源</li>
<li>轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻<br>塞挂起，而是让线程空循环等待，串行执行</li>
<li>轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的<br>monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来<br>实现的，所以重量级锁也被成为互斥锁</li>
<li>当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞<br>，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系<br>统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时<br>间的，有可能比用户执行代码的时间还要长</li>
<li>互斥锁(重量级锁)也称为阻塞同步、悲观锁</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/12/31/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>2020年度总结</span></a></div><div class="next-post pull-right"><a href="/2020/12/25/Java%E5%B9%B6%E5%8F%912/"><span>Java并发2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/12/27/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2020/12/27/Java并发总结/';
  this.page.title = 'Java并发总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>