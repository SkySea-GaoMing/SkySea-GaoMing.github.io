<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入JVM"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>深入JVM | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#走进Java"><span class="toc-number">2.</span> <span class="toc-text">走进Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM架构"><span class="toc-number">2.1.</span> <span class="toc-text">JVM架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM的生命周期"><span class="toc-number">2.2.</span> <span class="toc-text">JVM的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类文件结构"><span class="toc-number">3.</span> <span class="toc-text">类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class类文件的结构"><span class="toc-number">3.1.</span> <span class="toc-text">Class类文件的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">3.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#魔数与Class文件的版本"><span class="toc-number">3.3.</span> <span class="toc-text">魔数与Class文件的版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#魔数0xCAFEBABE"><span class="toc-number">3.3.1.</span> <span class="toc-text">魔数0xCAFEBABE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#版本号"><span class="toc-number">3.3.2.</span> <span class="toc-text">版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常量池"><span class="toc-number">3.3.3.</span> <span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常量类型"><span class="toc-number">3.3.4.</span> <span class="toc-text">常量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常量池17中数据类型结构总表"><span class="toc-number">3.3.5.</span> <span class="toc-text">常量池17中数据类型结构总表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问标志"><span class="toc-number">3.3.6.</span> <span class="toc-text">访问标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类索引、父类索引与接口索引集合"><span class="toc-number">3.3.7.</span> <span class="toc-text">类索引、父类索引与接口索引集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字段表集合"><span class="toc-number">3.3.8.</span> <span class="toc-text">字段表集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法表集合"><span class="toc-number">3.3.9.</span> <span class="toc-text">方法表集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性表集合"><span class="toc-number">3.3.10.</span> <span class="toc-text">属性表集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节码指令简介"><span class="toc-number">3.4.</span> <span class="toc-text">字节码指令简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字节码与数据类型"><span class="toc-number">3.4.1.</span> <span class="toc-text">字节码与数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载和存储指令"><span class="toc-number">3.4.2.</span> <span class="toc-text">加载和存储指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运算指令"><span class="toc-number">3.4.3.</span> <span class="toc-text">运算指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型转换指令"><span class="toc-number">3.4.4.</span> <span class="toc-text">类型转换指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象创建与访问指令"><span class="toc-number">3.4.5.</span> <span class="toc-text">对象创建与访问指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈管理指令"><span class="toc-number">3.4.6.</span> <span class="toc-text">操作数栈管理指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#控制转移指令"><span class="toc-number">3.4.7.</span> <span class="toc-text">控制转移指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法调用和返回指令"><span class="toc-number">3.4.8.</span> <span class="toc-text">方法调用和返回指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常处理指令"><span class="toc-number">3.4.9.</span> <span class="toc-text">异常处理指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步指令"><span class="toc-number">3.4.10.</span> <span class="toc-text">同步指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器与类加载过程"><span class="toc-number">4.</span> <span class="toc-text">类加载器与类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载"><span class="toc-number">4.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接"><span class="toc-number">4.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#验证"><span class="toc-number">4.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#准备"><span class="toc-number">4.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解析"><span class="toc-number">4.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">4.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器分类"><span class="toc-number">4.4.</span> <span class="toc-text">类加载器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">4.5.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#沙箱安全机制"><span class="toc-number">4.6.</span> <span class="toc-text">沙箱安全机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">4.7.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时数据区内部结构"><span class="toc-number">5.</span> <span class="toc-text">运行时数据区内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存"><span class="toc-number">5.1.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">5.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序计数器介绍"><span class="toc-number">5.3.</span> <span class="toc-text">程序计数器介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#作用"><span class="toc-number">5.3.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子"><span class="toc-number">5.3.2.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个常见问题"><span class="toc-number">5.3.3.</span> <span class="toc-text">两个常见问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU时间片"><span class="toc-number">5.3.4.</span> <span class="toc-text">CPU时间片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机栈"><span class="toc-number">5.4.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟机栈的概述"><span class="toc-number">5.4.1.</span> <span class="toc-text">虚拟机栈的概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈帧的粗略描述"><span class="toc-number">5.4.2.</span> <span class="toc-text">栈帧的粗略描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的优点"><span class="toc-number">5.4.3.</span> <span class="toc-text">栈的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈中可能出现的异常"><span class="toc-number">5.4.4.</span> <span class="toc-text">栈中可能出现的异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置栈内存大小"><span class="toc-number">5.4.5.</span> <span class="toc-text">设置栈内存大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的存储单位"><span class="toc-number">5.4.6.</span> <span class="toc-text">栈的存储单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈运行原理"><span class="toc-number">5.4.7.</span> <span class="toc-text">栈运行原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧的内部结构"><span class="toc-number">5.5.</span> <span class="toc-text">栈帧的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#局部变量表"><span class="toc-number">5.5.1.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字节码中方法内部结构剖析"><span class="toc-number">5.5.2.</span> <span class="toc-text">字节码中方法内部结构剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Slot"><span class="toc-number">5.5.3.</span> <span class="toc-text">Slot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slot的重复利用"><span class="toc-number">5.5.4.</span> <span class="toc-text">slot的重复利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态变量与局部变量的对比"><span class="toc-number">5.5.5.</span> <span class="toc-text">静态变量与局部变量的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈"><span class="toc-number">5.5.6.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码追踪"><span class="toc-number">5.5.7.</span> <span class="toc-text">代码追踪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈顶缓存技术"><span class="toc-number">5.5.8.</span> <span class="toc-text">栈顶缓存技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态连接"><span class="toc-number">5.6.</span> <span class="toc-text">动态连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的调用"><span class="toc-number">5.7.</span> <span class="toc-text">方法的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚方法和非虚方法"><span class="toc-number">5.7.1.</span> <span class="toc-text">虚方法和非虚方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invokedynamic指令"><span class="toc-number">5.7.2.</span> <span class="toc-text">invokedynamic指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法的重写"><span class="toc-number">5.7.3.</span> <span class="toc-text">方法的重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法返回地址"><span class="toc-number">5.8.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#附加信息"><span class="toc-number">5.9.</span> <span class="toc-text">附加信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的相关面试题"><span class="toc-number">5.10.</span> <span class="toc-text">栈的相关面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地方法栈"><span class="toc-number">5.11.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆"><span class="toc-number">5.12.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#堆的核心概述"><span class="toc-number">5.12.1.</span> <span class="toc-text">堆的核心概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆内存细分"><span class="toc-number">5.12.2.</span> <span class="toc-text">堆内存细分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置堆内存大小与OOM"><span class="toc-number">5.12.3.</span> <span class="toc-text">设置堆内存大小与OOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutOfMemory"><span class="toc-number">5.12.4.</span> <span class="toc-text">OutOfMemory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#年轻代与老年代"><span class="toc-number">5.12.5.</span> <span class="toc-text">年轻代与老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象分配过程"><span class="toc-number">5.12.6.</span> <span class="toc-text">对象分配过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象分配的特殊情况"><span class="toc-number">5.12.7.</span> <span class="toc-text">对象分配的特殊情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC"><span class="toc-number">5.12.8.</span> <span class="toc-text">GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆空间分代思想"><span class="toc-number">5.12.9.</span> <span class="toc-text">堆空间分代思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存分配策略"><span class="toc-number">5.12.10.</span> <span class="toc-text">内存分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLAB"><span class="toc-number">5.12.11.</span> <span class="toc-text">TLAB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆空间的参数设置小结"><span class="toc-number">5.12.12.</span> <span class="toc-text">堆空间的参数设置小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过逃逸分析看堆空间的对象分配策略"><span class="toc-number">5.13.</span> <span class="toc-text">通过逃逸分析看堆空间的对象分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化"><span class="toc-number">5.13.1.</span> <span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化之栈上分配"><span class="toc-number">5.13.2.</span> <span class="toc-text">代码优化之栈上分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化之同步省略"><span class="toc-number">5.13.3.</span> <span class="toc-text">代码优化之同步省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化之标量替换"><span class="toc-number">5.13.4.</span> <span class="toc-text">代码优化之标量替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆的小结"><span class="toc-number">5.13.5.</span> <span class="toc-text">堆的小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区"><span class="toc-number">5.14.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈、堆、方法区的交互关系"><span class="toc-number">5.15.</span> <span class="toc-text">栈、堆、方法区的交互关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的基本理解"><span class="toc-number">5.16.</span> <span class="toc-text">方法区的基本理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hotspot中方法区的演进"><span class="toc-number">5.17.</span> <span class="toc-text">Hotspot中方法区的演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置方法区大小和OOM"><span class="toc-number">5.18.</span> <span class="toc-text">设置方法区大小和OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metaspace举例"><span class="toc-number">5.19.</span> <span class="toc-text">Metaspace举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的内部结构"><span class="toc-number">5.20.</span> <span class="toc-text">方法区的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型信息"><span class="toc-number">5.20.1.</span> <span class="toc-text">类型信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#域信息"><span class="toc-number">5.20.2.</span> <span class="toc-text">域信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法信息"><span class="toc-number">5.20.3.</span> <span class="toc-text">方法信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#non-final的类变量"><span class="toc-number">5.20.4.</span> <span class="toc-text">non-final的类变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局常量"><span class="toc-number">5.20.5.</span> <span class="toc-text">全局常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class文件中的常量池"><span class="toc-number">5.20.6.</span> <span class="toc-text">class文件中的常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时常量池"><span class="toc-number">5.20.7.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的演进"><span class="toc-number">5.21.</span> <span class="toc-text">方法区的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable的调整"><span class="toc-number">5.21.1.</span> <span class="toc-text">StringTable的调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态变量的存储位置"><span class="toc-number">5.21.2.</span> <span class="toc-text">静态变量的存储位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的垃圾回收"><span class="toc-number">5.22.</span> <span class="toc-text">方法区的垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法接口"><span class="toc-number">6.</span> <span class="toc-text">本地方法接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-number">7.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的创建"><span class="toc-number">7.1.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的实例化"><span class="toc-number">7.2.</span> <span class="toc-text">对象的实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的内存布局"><span class="toc-number">7.3.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象访问定位"><span class="toc-number">7.4.</span> <span class="toc-text">对象访问定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接内存"><span class="toc-number">8.</span> <span class="toc-text">直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接内存的OOM"><span class="toc-number">8.1.</span> <span class="toc-text">直接内存的OOM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行引擎"><span class="toc-number">9.</span> <span class="toc-text">执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行引擎的概述"><span class="toc-number">9.1.</span> <span class="toc-text">执行引擎的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行引擎的工作过程"><span class="toc-number">9.2.</span> <span class="toc-text">执行引擎的工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java代码编译和执行过程"><span class="toc-number">9.3.</span> <span class="toc-text">Java代码编译和执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释器"><span class="toc-number">9.4.</span> <span class="toc-text">解释器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT编译器"><span class="toc-number">9.5.</span> <span class="toc-text">JIT编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#热点代码探测"><span class="toc-number">9.6.</span> <span class="toc-text">热点代码探测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HotSpot设置模式"><span class="toc-number">9.7.</span> <span class="toc-text">HotSpot设置模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringTable"><span class="toc-number">10.</span> <span class="toc-text">StringTable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String的基本特性"><span class="toc-number">10.1.</span> <span class="toc-text">String的基本特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String的内存分配"><span class="toc-number">10.2.</span> <span class="toc-text">String的内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String的基本操作"><span class="toc-number">10.3.</span> <span class="toc-text">String的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串拼接操作"><span class="toc-number">10.4.</span> <span class="toc-text">字符串拼接操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串拼接操作的底层原理"><span class="toc-number">10.5.</span> <span class="toc-text">字符串拼接操作的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接操作与append对比"><span class="toc-number">10.6.</span> <span class="toc-text">拼接操作与append对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intern-的使用"><span class="toc-number">10.7.</span> <span class="toc-text">intern()的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-String"><span class="toc-number">10.8.</span> <span class="toc-text">new String()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的String去重"><span class="toc-number">10.9.</span> <span class="toc-text">垃圾回收器的String去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收算法"><span class="toc-number">11.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收概述"><span class="toc-number">11.1.</span> <span class="toc-text">垃圾回收概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java自动内存管理介绍"><span class="toc-number">11.2.</span> <span class="toc-text">Java自动内存管理介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收相关算法"><span class="toc-number">11.3.</span> <span class="toc-text">垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数算法"><span class="toc-number">11.3.1.</span> <span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可达性分析算法"><span class="toc-number">11.3.2.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨代引用假说"><span class="toc-number">11.4.</span> <span class="toc-text">跨代引用假说</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的finalization机制"><span class="toc-number">11.5.</span> <span class="toc-text">对象的finalization机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用JProfiler查看GC-Roots"><span class="toc-number">11.6.</span> <span class="toc-text">使用JProfiler查看GC Roots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾清除算法"><span class="toc-number">11.7.</span> <span class="toc-text">垃圾清除算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-清除算法（Mark-Sweep）"><span class="toc-number">11.7.1.</span> <span class="toc-text">标记-清除算法（Mark-Sweep）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复制算法"><span class="toc-number">11.7.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标记-压缩算法（Mark-Compact）"><span class="toc-number">11.7.3.</span> <span class="toc-text">标记-压缩算法（Mark-Compact）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对比三种算法"><span class="toc-number">11.7.4.</span> <span class="toc-text">对比三种算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分代收集算法"><span class="toc-number">11.7.5.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#增量收集算法"><span class="toc-number">11.7.6.</span> <span class="toc-text">增量收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分区算法"><span class="toc-number">11.7.7.</span> <span class="toc-text">分区算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针碰撞"><span class="toc-number">11.8.</span> <span class="toc-text">指针碰撞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收相关概念"><span class="toc-number">12.</span> <span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-gc"><span class="toc-number">12.1.</span> <span class="toc-text">System.gc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存溢出与内存泄漏"><span class="toc-number">12.2.</span> <span class="toc-text">内存溢出与内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stop-The-World"><span class="toc-number">12.3.</span> <span class="toc-text">Stop The World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收的并行与并发"><span class="toc-number">12.4.</span> <span class="toc-text">垃圾回收的并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全点与安全区域"><span class="toc-number">12.5.</span> <span class="toc-text">安全点与安全区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#记忆集与卡表"><span class="toc-number">12.6.</span> <span class="toc-text">记忆集与卡表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写屏障"><span class="toc-number">12.7.</span> <span class="toc-text">写屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中几种不同引用"><span class="toc-number">12.8.</span> <span class="toc-text">Java中几种不同引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#强引用"><span class="toc-number">12.8.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#软引用"><span class="toc-number">12.8.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#弱引用"><span class="toc-number">12.8.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚引用"><span class="toc-number">12.8.4.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#终结器引用"><span class="toc-number">12.8.5.</span> <span class="toc-text">终结器引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收器"><span class="toc-number">13.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的分类"><span class="toc-number">13.1.</span> <span class="toc-text">垃圾回收器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评估GC的性能指标"><span class="toc-number">13.2.</span> <span class="toc-text">评估GC的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#吞吐量"><span class="toc-number">13.2.1.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#暂停时间"><span class="toc-number">13.2.2.</span> <span class="toc-text">暂停时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#吞吐量VS暂停时间"><span class="toc-number">13.2.3.</span> <span class="toc-text">吞吐量VS暂停时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器发展史"><span class="toc-number">13.3.</span> <span class="toc-text">垃圾收集器发展史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的组合关系"><span class="toc-number">13.4.</span> <span class="toc-text">垃圾回收器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看默认垃圾收集器"><span class="toc-number">13.5.</span> <span class="toc-text">查看默认垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial回收器"><span class="toc-number">13.5.1.</span> <span class="toc-text">Serial回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew回收器"><span class="toc-number">13.5.2.</span> <span class="toc-text">ParNew回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel回收器"><span class="toc-number">13.5.3.</span> <span class="toc-text">Parallel回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS回收器"><span class="toc-number">13.6.</span> <span class="toc-text">CMS回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMOS的特点"><span class="toc-number">13.6.1.</span> <span class="toc-text">CMOS的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">13.6.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-区域化分代式"><span class="toc-number">13.7.</span> <span class="toc-text">G1:区域化分代式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的特点"><span class="toc-number">13.7.1.</span> <span class="toc-text">G1的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的参数设置"><span class="toc-number">13.7.2.</span> <span class="toc-text">G1的参数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的使用场景"><span class="toc-number">13.7.3.</span> <span class="toc-text">G1的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Region"><span class="toc-number">13.7.4.</span> <span class="toc-text">Region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的垃圾回收过程"><span class="toc-number">13.7.5.</span> <span class="toc-text">G1的垃圾回收过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#记忆集与写屏障"><span class="toc-number">13.7.6.</span> <span class="toc-text">记忆集与写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1回收过程"><span class="toc-number">13.7.7.</span> <span class="toc-text">G1回收过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器总结"><span class="toc-number">13.8.</span> <span class="toc-text">垃圾回收器总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC日志分析"><span class="toc-number">13.9.</span> <span class="toc-text">GC日志分析</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1602420731963&amp;di=032f7d4d661e3091e66c2accca9403d1&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn19%2Fw1600h924%2F20180314%2F4ac2-fyscsmv6453502.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">深入JVM</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/05/06/深入JVM/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解JVM虚拟机》第三版，在此感谢宋红康老师的JVM教程</p>
<h2 id="走进Java"><a href="#走进Java" class="headerlink" title="走进Java"></a>走进Java</h2><ol>
<li>c/c++编译生成的可执行文件跟操作系统和指令集架构都有关系。满足相同<br>的操作系统和指令集架构这两个条件才可以执行这个可执行文件。指令集不<br>同  很好理解，如果指令集相同操作系统不同也是不能执行的。原因如下，<br>参考<a href="https://www.zhihu.com/question/22672994" target="_blank" rel="noopener">https://www.zhihu.com/question/22672994</a>  </li>
</ol>
<ul>
<li>一个可执行文件除了机器指令还包括各种数据和运行时资源，并且文件的格<br>式也不同</li>
<li>可执行文件执行前操作系统要有一些准备工作，不同的操作系统准备工作<br>不同</li>
<li>一个可执行文件所执行的绝大多数操作（比如：文件操作、输入输出、内存<br>申请释放、任务调度等等）都需要与操作系统交互才能完成，而不同的操作<br>系统使用这些操作的方法完全不同。Java的一大特点就是摆脱了硬件平台的<br>束缚，一次编写到处运行，这跟c/c++有很大的区别 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number6.jpg" alt></li>
</ul>
<ol start="2">
<li>java虚拟机的功能比Java要强大，实际上是跨语言的平台，不同的编程<br>语言编写的程序也可以编译成字节码文件，如果符合虚拟机规范也可以在虚<br>拟机上运行，实际上能在jvm平台执行的字节码格式都是一样的，统称为<br>jvm字节码 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number7.jpg" alt> 查看自己的Java环境 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number194.jpg" alt></li>
<li>JDK是用于支持Java程序开发的最小环境,JRE是支持Java程序运行的标准环境</li>
</ol>
<ul>
<li>Java程序设计语言，Java虚拟机，JavaAPI类库组成JDK</li>
<li>Java虚拟机，Java SE API组成JRE</li>
</ul>
<ol start="4">
<li>编译过程 编译器（javac）将Java代码翻译成字节码，也叫做前端编译器，<br>因为操作系统并不能识别字节码，所以Java虚拟机中的执行引擎中的JIT编译<br>器要将字节码翻译成机器指令被CPU执行，所以JIT被称为后端编译器</li>
<li>运行过程 Java虚拟机能够将字节码解释成具体平台的机器码 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number8.jpg" alt></li>
<li>虚拟机 是一台虚拟的计算机，也就是一个软件，用来执行一系列虚拟计算机指令 </li>
</ol>
<ul>
<li>系统虚拟机 VisualBox VMware 完全对物理计算机的仿真，提供一个<br>可运行完整操作系统的软件平台，实际上模拟的是上图硬件</li>
<li>程序虚拟机 Java虚拟机 专门为执行单个计算机程序而设计，Java虚<br>拟机中执行的指令称为Java字节码指令，Java字节码是可以运行在任何<br>支持Java虚拟机的硬件平台和操作系统上的二进制文件，字节码的执行<br>实际上是被翻译成机器代码而执行的过程。实际上模拟的是上图JVM</li>
</ul>
<h3 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h3><ol>
<li>HotSpot虚拟机 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number12.jpg" alt></li>
<li>JVM的整体结构 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number2.jpg" alt></li>
</ol>
<ul>
<li>Java代码执行流程 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number9.jpg" alt></li>
<li>指令集架构分为两种，Java编译器输入的指令流基本上是一种基于栈的指令集架构<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number10.jpg" alt> 反编译 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number195.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number196.jpg" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;x86</span><br><span class="line">mov $2, %eax</span><br><span class="line">add $3, %eax</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number13.jpg" alt></p>
<ol>
<li>虚拟机的启动 通过引导类加载器创建一个初始类来完成，这个类是由虚拟机<br>的具体实现指定</li>
<li>虚拟机的执行 执行Java程序，程序开始执行时执行，程序结束时结束。实际<br>上执行的是一个进程 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number89.jpg" alt> 进程执行结束后 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number90.jpg" alt></li>
<li>jps JVM Process Status 可以列出正在运行的虚拟机进程，并显示虚拟机<br>执行主类名称以及这些进程的本地虚拟机唯一ID</li>
<li>虚拟机的退出</li>
</ol>
<ul>
<li>程序正常结束</li>
<li>程序遇到异常或错误</li>
<li>操作系统错误</li>
<li>Runtime类或System类的exit方法</li>
</ul>
<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>之前已经介绍过，Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只<br>与Class文件这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机<br>指令集、符号表以及若干其他辅助信息</p>
<h3 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h3><p>任何一个Class文件都对应着唯一的一个类或接口的定义信息。Class文件是一组<br>以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文<br>件之中，中间没有添加任何分隔符，如果遇到占用8个字节以上空间的数据项时<br>会按照高位在前的方式分割成若干个8个字节存储，与x86正好相反</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构<br>只有两种数据类型 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number335.jpg" alt></p>
<ul>
<li>无符号数 u1表示1个字节的无符号数，还有u2 u4 u8等类推。可以用来描述<br>数字、索引引用、数量值或者按照UTF-8构成字符串值</li>
<li>表 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表<br>都以_info结尾，用于描述有层次关系的复合结构的数据</li>
</ul>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><h4 id="魔数0xCAFEBABE"><a href="#魔数0xCAFEBABE" class="headerlink" title="魔数0xCAFEBABE"></a>魔数0xCAFEBABE</h4><p>每个Class文件的前4个字节被称为魔数，它的唯一作用是确定这个文件是否为<br>一个能被虚拟机接受的Class文件，使用魔数而不是扩展名来进行识别主要是<br>基于安全考虑，文件的扩展名可以被随意改动</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>紧接着魔数的4个字节存储的是Class文件的版本号，分别是次版本号和主版本<br>号。Java的版本号是从45开始，JDK1.1之后的每个JDK大版本发布主版本号向<br>上加1，高版本的JDK能够向下兼容以前版本的Class文件，但不能兼容以后版<br>本的Class文件 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number336.jpg" alt></p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>版本号之后就是常量池入口，常量池可以比喻为Class文件里的资源仓库。由于<br>常量池中常量的数量时不固定的，所以在常量池入口需要放置一项u2类型的数<br>据，代表常量池容量计数值。这个容量计数是从1开始而不是0开始，例如<br>0x0016表示十进制22，代表常量池有21项常量，索引值范围在1~21，如果<br>某些指向常量池的索引值的数据在特定情况下需要表达不引用任何一个常量<br>池项目的含义，可以把索引值设置为0来表示。常量池中主要存放两大类常量</p>
<ol>
<li>字面量 文本字符串、被声明为final的常量值等</li>
<li>符号引用 当虚拟机加载时，将会从常量池中获得对应的符号引用，在类<br>创建时或运行时解析、翻译到具体的内存地址之中</li>
</ol>
<ul>
<li>被模块导出或者开放的包</li>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法句柄和方法类型</li>
<li>动态调用点和动态常量</li>
</ul>
<h4 id="常量类型"><a href="#常量类型" class="headerlink" title="常量类型"></a>常量类型</h4><p>常量池中每一项常量都是一个表，表结构起始的第一位是个u1类型的标志位<br>（tag），代表当前常量属于哪种常量类型，截止JDK13常量表中分别有17<br>种不同类型的常量 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number337.jpg" alt></p>
<ol>
<li>CONSTANT_CLASS_info 代表类或接口的符号引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类型 名称 数量</span><br><span class="line">u1 tag 1</span><br><span class="line">u2 name_index 1</span><br><span class="line">&#x2F;&#x2F;tag是标志位，用于区分常量类型</span><br><span class="line">&#x2F;&#x2F;name_index是常量池的索引值，它指向常量池中一个CONSTANT_Utf-8_info类型常量</span><br><span class="line">&#x2F;&#x2F;此常量代表这个类的全限定名</span><br></pre></td></tr></table></figure></li>
<li>CONSTANT_Utf-8_info<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u1 tag 1</span><br><span class="line">u2 length 1</span><br><span class="line">u1 bytes length</span><br><span class="line">&#x2F;&#x2F;Class文件中方法、字段都需要引用CONSTANT_Utf-8_info型常量来描述名称</span><br><span class="line">&#x2F;&#x2F;length说明字符串长度是多少字节，最大是65535，如果方法、字段名超过64KB则无法编译</span><br><span class="line">&#x2F;&#x2F;length值后边紧跟的是使用UTF-8缩略编码的字符串</span><br></pre></td></tr></table></figure>
<img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number338.jpg" alt></li>
</ol>
<h4 id="常量池17中数据类型结构总表"><a href="#常量池17中数据类型结构总表" class="headerlink" title="常量池17中数据类型结构总表"></a>常量池17中数据类型结构总表</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number339.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number340.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number341.jpg" alt></p>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>常量池之后紧接着是2个字节代表访问标志，这个标志用于识别一些类或者接口的<br>访问信息，包括这个Class是类还是接口，是否定义为public类型，是否定义为<br>abstract类型，如果是类是否声明为final等等，符合多个标志位例如A和B的<br>话标志值为 A|B，比如一个普通的public类 0x001 | 0x0020 = 0x0021<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number342.jpg" alt></p>
<h4 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h4><p>类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据<br>的集合，Class文件由这三项数据来确定该类型的继承关系。类索引用于确定这个<br>类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合就是<br>这个类实现了哪些接口。类索引、父类索引和接口索引集合都按顺序排列在访问<br>标志之后，类索引和父类索引用两个u2类型表示，各自指向类型为CONSTANT_<br>Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索<br>引值找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number343.jpg" alt><br>对于接口索引，入口的第一项u2类型的数据是接口计数器，表示索引表的容量，<br>如果该类没有实现任何接口则计数器值为0，后面接口的索引表不再占用任何<br>字节 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number344.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number345.jpg" alt></p>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>首先是一个容量计数器表示字段的数量，然后是字段表<br>字段表用于描述接口或者类中声明的变量，Java语言中的字段包括类级变量和<br>实例级变量，但不包括在方法内部声明的局部变量。字段可以包括的修饰符有<br>字段的作用域（public/private/protected）、实例变量还是类变量<br>（static)、可变性（final）、并发可见性（volatile，是否强制从主内存<br>读写）、可否被序列化（transient）、字段数据类型（基本类型、对象、数组）<br>、字段名称等等。上述这些信息各个修饰符都是布尔值，要么有某个修饰符要<br>么没有，很适合用标志位表示，而字段的名字和数据类型只能引用常量池<br>中的常量来描述<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number346.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number347.jpg" alt><br>name_index和description_index都是对常量池项的引用，分别代表字段的<br>简单名称以及字段和方法的描述符</p>
<ul>
<li>全限定名 org/fenixsoft/clazz/TestClass就是一个全限定名，仅仅把<br>类全名中的.换成了/而已</li>
<li>简单名称 没有类型和参数修饰的方法或字段名称，比如inc()方法和m字段<br>的简单名称就是inc和m</li>
</ul>
<p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型<br>以及顺序）和返回值，对象类型是字符L加对象的全限定名来表示<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number348.jpg" alt><br>对于数组类型，每一维度将使用一个前置的[字符来描述，如定义一个为<br>java.lang.String[][]类型的二维数组将被记录成[[Ljava/lang/String<br>一个整型数组int[]将被记录成[I<br>用描述符描述方法时按照先参数列表后返回值的顺序描述，参数列表按照参数<br>的严格顺序放在一组小括号()之内，比如方法void inc()描述符为()V，方法<br>java.lang.String.toString()描述为()Ljava/lang/String，方法<br>int indexOf(char[] source,int sourceOffset,int sourceCount,<br>char[] target,int targetOffset,int targetCount,int fromIndex)<br>的描述符为([CII][III)I<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number349.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number350.jpg" alt><br>在descriptor_index之后跟随一个属性表集合，用于存储一些额外的信息，<br>这部分在属性表再介绍。字段表集合中不会列出从父类或者父接口中继承而<br>来的字段，另外在Java语言中字段是无法重载的，必须使用不一样的名称</p>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，<br>方法表的结构如同字段表一样，依次包括访问标志、名称索引、描述符索引、属性<br>表集合 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number351.jpg" alt><br>因为volatile和transient关键字不能修饰方法，而synchronized native<br>strictfp abstract可以修饰方法 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number352.jpg" alt><br>方法里面的代码经过Javac编译器编译成字节码指令后存放在方法属性表集合中<br>一个名为Code的属性里面 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number353.jpg" alt></p>
<ol>
<li>与字段表集合类似，如果父类方法在子类中没有被重写那么就不会出现父类<br>方法的信息，但同样会出现编译器自动添加的方法，比如clinit和init</li>
<li>在Java语言中要重载一个方法，除了要与原方法具有相同的简单名称之外，<br>还必须要求拥有一个与原方法不同的特征签名。特征签名是指一个方法中各<br>个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特<br>征签名中，所以不能仅依靠返回值的不同对一个方法进行重载，Java代码的<br>方法特征签名只包括方法名称、参数顺序和参数类型，而字节码的特征签名<br>还包括方法返回值以及受查异常表</li>
</ol>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>Class文件、字段表、方法表都可以携带自己的属性表(attribute_info)集合<br>属性表集合的限制更为宽松，不再要求各个属性表具有严格顺序<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number354.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number355.jpg" alt><br>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型<br>的常量来表示，而属性值的结构完全自定义的，一个符合规则的属性表应该满足<br>的结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型 名称 数量</span><br><span class="line">u2 attribute_name_index 1</span><br><span class="line">u4 attribute_length 1</span><br><span class="line">u1 info attribute_length</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Code属性<br>Java程序方法体里面的代码经过编译后变为字节码指令存放在Code属性内，<br>Code属性存在于方法表的属性集合之中，接口或抽象类中的方法不存在Code<br>属性<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number356.jpg" alt><br>attribute_name_index是指向CONSTANT_Utf8_info型常量的索引，此常量<br>固定为Code，它代表了该属性的属性名称，attribute_length指示了属性值<br>的长度，属性值的长度为整个属性表长度减去6个字节（属性名称索引和属性<br>长度），max_stack代表操作数栈深度的最大值，max_locals代表局部变量<br>所需的存储空间，单位是slot，方法参数（包括实例方法的this）、显示异<br>常处理程序的参数（try-catch中catch块中所定义的异常）、方法体中定义<br>的局部变量都需要依赖局部变量表来存放，code_length和code用来存储Java<br>源程序编译后生成的字节码指令，code_length代表字节码长度，code是用<br>于存储字节码指令的一系列字节流。每条指令就是一个u1类型的单字节，当<br>虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的<br>是什么指令，并且可以根据这条指令后面是否需要跟随参数以及参数如何<br>解析。虽然code_length是4个字节，但是限制一个方法不允许超过65535<br>条指令，实际只能使用2个字节<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number357.jpg" alt><br>异常表对于Code属性来说并不是必须存在的 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number358.jpg" alt></p>
</li>
<li><p>Exceptions属性<br>与刚刚讲解的异常表不是一回事，列举出方法中可能抛出的受查异常，也就<br>是方法描述在throws关键字后面列举的异常，Exceptions属性结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型 名称 数量</span><br><span class="line">u2 attribute_name_index 1</span><br><span class="line">u4 attribute_length 1</span><br><span class="line">u2 number_of_exceptions 1</span><br><span class="line">u2 exception_index_table number_of_exceptions</span><br></pre></td></tr></table></figure>
<p>此属性的number_of_exceptions项表示方法可能抛出number_of_exceptions<br>中受查异常，每一种受查异常使用一个exception_index_table项表示，<br>exception_index_table指向常量池中CONSTANT_Class_info型常量的索引，<br>代表该受查异常的类型</p>
</li>
<li><p>LineNumberTable属性<br>用来描述Java源码行号和字节码行号之间的对应关系，line_number_info包含<br>两个数据项，start_pc是字节码行号，line_number是Java源码行号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2 attribute_name_index 1</span><br><span class="line">u4 attribute_length 1</span><br><span class="line">u2 line_number_table_length 1</span><br><span class="line">line_number_info line_number_table line_number_table_length</span><br></pre></td></tr></table></figure></li>
<li><p>LocalVariableTable及LocalVariableTypeTable属性<br>LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义<br>的变量之间的关系 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number359.jpg" alt><br>Local_variable_info代表一个栈帧与源码中的局部变量的关联 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number360.jpg" alt><br>start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移<br>量及其作用域范围覆盖的长度，index是这个局部变量在栈帧的局部变量表中<br>变量槽的位置，LocalVariableTypeTable属性可以描述泛型。为什么局部变<br>量也在常量池中有名称和描述符？我查了一下资料，发现在一篇博客中有提<br>到这样一句话：而对于基本类型数据(甚至是方法中的局部变量)，常量池中<br>只保留了他的的字段描述符I和字段的名称value，他们的字面量不会存在于<br>常量池 <a href="https://www.cnblogs.com/qingfengyiran-top1/p/11300654.html" target="_blank" rel="noopener">https://www.cnblogs.com/qingfengyiran-top1/p/11300654.html</a></p>
</li>
<li><p>SourceFile及SourceDebugExtension<br>用于记录生成这个Class文件的源码文件名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u2 attribute_name_index 1</span><br><span class="line">u4 attribute_length 1</span><br><span class="line">u2 sourcefile_index 1</span><br></pre></td></tr></table></figure></li>
<li><p>ConstantValue属性<br>通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量才可以使<br>用这项属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u2 attribute_name_index 1</span><br><span class="line">u4 attribute_length 1</span><br><span class="line">u2 constantvalue_index 1</span><br></pre></td></tr></table></figure></li>
<li><p>InnerClasses属性<br>用于记录内部类与宿主类之间的关系</p>
</li>
</ol>
<h3 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h3><p>Java虚拟机的指令是由一个字节长度的、代表着某种特定操作含义的数字（称为<br>操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作<br>数，Operand）构成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果不考虑异常处理，那Java虚拟机的解释器可以用以下伪代码表示</span><br><span class="line">do&#123;</span><br><span class="line">	自动计算PC寄存器的值加1；</span><br><span class="line">	根据PC寄存器知识的位置，从字节码流中取出操作码；</span><br><span class="line">	if（字节码存在操作数）从字节码流中取出操作数；</span><br><span class="line">	执行操作码所定义的操作；</span><br><span class="line">&#125; while（字节码流长度&gt;0）</span><br></pre></td></tr></table></figure>
<h4 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h4><p>在Java虚拟机指令集中大多数指定都包含其操作所对应的数据类型信息，例如<br>iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令<br>加载float类型的数据<br>对于大部分与数据类型相关的字节码指令，它们的操作码助记符都有特殊的字符<br>表明专门为哪种数据类型服务，i代表对int类型的数据操作，以此类推l s b<br>c f d a，a代表reference，arraylength指令操作数是一个数组类型的对象<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number361.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number362.jpg" alt><br>编译器在编译期或运行期将byte和short类型的数据符号扩展为int类型，将<br>boolean和char类型数据零位扩展为int类型，所以相应也会用int类型的字<br>节码指令来处理</p>
<h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><p>用于将数据在栈帧中的局部变量表和操作数栈之间传输</p>
<ol>
<li>将一个局部变量加载到操作数栈 iload iload&lt;\n&gt;</li>
<li>将一个数值从操作数栈存储到局部变量表 istore istore&lt;\n&gt;</li>
<li>将一个常量加载到操作数栈 bipush ldc iconst_ml</li>
</ol>
<h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4><p>对操作数栈上的两个值进行某种特定运算，并把结果重新存入操作数栈顶</p>
<ol>
<li>加法指令 iadd ladd fadd dadd</li>
<li>减法指令 isub lsub fsub dsub</li>
<li>乘法指令 imul lmul fmul dmul</li>
<li>除法指令 idiv ldiv fdiv ddiv</li>
<li>求余指令 irem lrem frem drem</li>
<li>取反指令 ineg lneg fneg dneg</li>
<li>位移指令 ishl ishr iushr lshl lshr lushr</li>
<li>按位或指令 ior lor</li>
<li>按位与指令 iand land</li>
<li>按位异或指令 ixor lxor</li>
<li>局部变量自增指令 iinc</li>
<li>比较指令 dcmpg dcmpl fcmpg fcmpl lcmp</li>
</ol>
<h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>将两种不同的数值类型相互转换，小范围向大范围转换无需显示的转换指令，例<br>如int到long float double，long到float double，float到double，处理<br>窄化类型转换用到的指令有i2b i2c i2s l2i f2i f2l d2i d2l d2f</p>
<h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4><p>Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令</p>
<ol>
<li>创建类实例的指令 new</li>
<li>创建数组的指令 newarray anewarray multianewarray</li>
<li>访问类字段的指令 getfield putfield getstatic putstatic</li>
<li>把一个数组元素加载到操作数栈的指令 baload caload saload aaload</li>
<li>将一个操作数栈的值存储到数组元素中的指令 bastore castore aastore</li>
<li>取数组长度的指令 arraylength</li>
<li>检查类实例类型的指令 instanceof checkcast</li>
</ol>
<h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><p>直接操作操作数栈</p>
<ol>
<li>将操作数栈的栈顶一个或两个元素出栈 pop pop2</li>
<li>复制栈顶一个或两个数并将复制值或双份的复制值重新压入栈 dup dup2</li>
<li>将栈最顶端两个数值交换 swap</li>
</ol>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><p>有条件或无条件跳转指定位置</p>
<ol>
<li>条件分支 ifeq iflt ifle ifne ifgt</li>
<li>复合条件分支 tableswitch lookupswitch</li>
<li>无条件分支 goto goto_w</li>
</ol>
<h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4><p>方法调用指令与数据类型无关，方法返回指令与数据类型有关，例如ireturn<br>（boolean byte char short int）lreturn freturn dreturn areturn<br>如果返回为void则是return </p>
<ol>
<li>invokevirtual指令 用于调用对象的实例方法</li>
<li>invokeinterface指令 用于调用接口方法</li>
<li>invokespecial指令 用于调用一些需要特殊处理的实例方法</li>
<li>invokestatic指令 用于调用类静态方法</li>
<li>invokedynamic指令 用于运行时动态解析处调用点限定符所引用的方法</li>
</ol>
<h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p>Java程序中显示抛出异常（throw）都是由athrow指令实现，处理异常不是由<br>字节码指令实现而是由异常表完成</p>
<h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><p>Java虚拟机支持方法级的同步和方法内部一段指令序列的同步</p>
<h2 id="类加载器与类加载过程"><a href="#类加载器与类加载过程" class="headerlink" title="类加载器与类加载过程"></a>类加载器与类加载过程</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解<br>析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称为虚拟机的<br>类加载机制。类加载过程都是在程序运行期间完成的，为Java提供了极高的扩展性<br>和灵活性，比如编写一个面向接口的程序，等到运行时指定实际的实现类，本地程<br>序运行时从网络或其他地方加载二进制流作为程序代码的一部分，比如JSP等技术。<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number14.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number15.jpg" alt></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number16.jpg" alt></li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据区</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各<br>种数据的访问入口</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number17.jpg" alt></p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol>
<li>验证是确保Class文件的字节流中包含的信息符合Java虚拟机规范中的全部<br>约束要求，保证这些信息不回被当做代码运行后危害虚拟机自身的安全</li>
<li>Java是相对安全的编程语言，无法访问数组边界以外的数据、将一个对象转<br>型为并未实现的类型、跳转到不存在的代码行之类的情况，可以编译但在运行时会报错</li>
<li>文件格式验证 只有通过了这一阶段的验证才被允许进入Java虚拟机内存中<br>的方法区中进行存储，之后的三个验证阶段都是基于方法区中的内容</li>
</ol>
<ul>
<li>是否以魔数0xCAFEBABE开头 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number18.jpg" alt></li>
<li>主、次版本号是否在当前Java虚拟机接受范围</li>
</ul>
<ol start="4">
<li>元数据验证 该阶段是对字节码描述的信息进行语义分析，保证符合Java<br>语言规范的要求</li>
</ol>
<ul>
<li>这个类是否有父类（除了java.lang.Object，所有的类都要有父类）</li>
<li>这个类是否继承了不被允许的类（被final修饰的类）</li>
<li>如果这个字段不是抽象类是否实现了父类或接口中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类参数矛盾（比如覆盖了父类的final方法，或<br>者出现不符合规则的方法重载，例如方法参数一样类型不一样）</li>
</ul>
<ol start="5">
<li>字节码验证 通过数据流分析和控制流分析确定语义是合法的、符合逻辑的<br>在第二阶段对元数据信息中的数据类型校验完毕后这一阶段对类的方法体进<br>行校验分析</li>
</ol>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会<br>出现在操作数栈中放置了一个int类型的数据，使用时却按long类型来加载入<br>本地变量表中</li>
<li>保证任何跳转指令都不会调转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的，例如吧一个子类对象赋给父类数据类<br>型是安全的，但是父类对象赋值给子类数据类型甚至对象赋值给毫无继承关<br>系的数据类型是不符合要求的</li>
</ul>
<ol start="6">
<li>符号引用验证 这一过程发生在虚拟机将符号引用转化为直接引用的时候，<br>这个转化过程将在连接的第三个阶段-解析阶段发生，可以看做是对类自身<br>以外的各类信息进行匹配性校验，该类是否缺少或者被禁止访问它依赖的某<br>些外部类、方法、字段等资源</li>
</ol>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的可访问性是否可被当前类访问</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段a赋值为0，初始化过程赋值为1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<ul>
<li>符号引用 符号引用十一组符号来描述所引用的目标，可以是任何形式的字<br>面量，只要使用时能无歧义地定位到目标即可</li>
<li>直接引用 直接引用是直接指向目标的指针、相对偏移量或者一个能间接定<br>位到目标的句柄</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>什么情况开始加载过程并没有强制约束，这点可以由虚拟机自由把握。<br>初始化阶段有且只有六种情况必须对类进行初始化（而加载、验证、准备等自然<br>已经完成），这六种场景称为对一个类型进行主动引用，其余引用方式称为被动<br>引用，接口也有初始化过程，但是接口中不能用static{}语句块，但是编译器仍<br>然会为接口生成clinit类构造器，用于初始化接口中所定义的成员变量，接口与<br>类的区别在于第三种场景，接口初始化时并不要求其所有父接口都完成初始化，<br>只有真正使用到父接口的时候才会初始化，也就是只有父接口中定义的变量被使用<br>时，才会被初始化。接口的实现类在初始化时也一样不会执行接口的clinit方法</p>
<ol>
<li>遇到new getstatic putstatic invokestatic这4条指令代码时如果类<br>型没有进行初始化则会出发初始化阶段，能够生成这4条指令的场景如下</li>
</ol>
<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段的时候（被final修饰已经在编译期就确定的<br>字段除外）</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
<ol start="2">
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候如果类型没有<br>初始化就先触发初始化</li>
<li>初始化类时，如果父类没有初始化就先触发父类的初始化</li>
<li>虚拟机启动时，用户需要指定一个要执行的主类（包含main方法），虚拟机<br>会先初始化这个类</li>
<li>使用JDK7新加入的动态语言支持时，如果java.lang.invoke.MethodHandle<br>实例最后的解析结果为REF_getStatic REF_putStatic REF_invokeStatic<br>RED_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有<br>过初始化会触发其初始化</li>
<li>当一个接口中定义了JDK8中新加入的默认方法（被default关键字修饰的接口<br>方法）时，如果这个接口的实现了发生初始化那么接口要先初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"super init"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"sub init"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String hello=<span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Sting[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(SubClass.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行上述代码只会输出 super init而不会输出 sub init</span></span><br><span class="line"><span class="comment">//对于静态字段，只有直接定义这个字段的类才会被初始化</span></span><br><span class="line"><span class="comment">//sub类引用super类的静态字段所以super会被初始化，但是加载和验证阶段并不确定</span></span><br><span class="line"><span class="comment">//对于HotSpot虚拟机可以通过-XX:+TraceClassLoading参数观察是否被加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		SuperClass[] array=<span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有输出 super init，说明没有触发super类的初始化</span></span><br><span class="line"><span class="comment">//通过数组定义类引用类，不会触发类的初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(SubClass.hello);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有输出 sub init</span></span><br><span class="line"><span class="comment">//编译阶段通过常量传播优化已经将常量的值"Hello World"存储在Test3类的常量池中</span></span><br><span class="line"><span class="comment">//以后Test3对于常量SubClass.hello的引用实际上被转化为Test3类对自身常量池的引用</span></span><br><span class="line"><span class="comment">//Test3的Class文件中并不存在对SubClass类的符号引用入口，这两个类在编译后就没有关系了</span></span><br></pre></td></tr></table></figure>
<img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number19.jpg" alt></li>
<li>以下代码是允许的，链接时将num和number都赋值为0，初始化时将赋值动<br>作和静态代码块按顺序执行，最终number的值为1，但是不能有打印语句，<br>在number声明之前可以赋值但是不能前向引用</li>
<li>类变量必须要加static，否则就是实例变量</li>
<li>如果不存在类变量的赋值（不光定义类变量）和静态代码块那么就不会有clinit方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		num=<span class="number">2</span>;</span><br><span class="line">		number=<span class="number">10</span>;</span><br><span class="line">		<span class="comment">//System.out.println(number);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//最终number是1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>每一个类加载器都有一个独立的类名称空间，也就是说比较两个类是否相等<br>的两个条件是来自同一个Class文件并且由同一个类加载器加载 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number20.jpg" alt></p>
<ol>
<li>启动类加载器 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number24.jpg" alt></li>
<li>自定义类加载器，Java虚拟机规范定义所有继承抽象类java.lang.ClassLoader<br>的类加载器都划分为自定义类加载器<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number21.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number22.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number23.jpg" alt></li>
<li>类加载器的复制关系一般不是以继承的关系来实现的，而是通常使用组合<br>关系来复用父加载器的代码 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number25.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number26.jpg" alt></li>
<li>用户自定义类加载器 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number27.jpg" alt></li>
</ol>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
<ol start="5">
<li>ClassLoader 是一个抽象类，所有类加载器都继承自ClassLoader<br>（除了引导类加载器）<img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number28.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number29.jpg" alt></li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number30.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number31.jpg" alt><br>自己定义了一个java.lang.String类，系统类加载器加载时首先往上委托，<br>发现启动类加载器可以加载java.lang.String，所以自己定义的java.lang.String<br>不会被加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"自己定义的String类"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		java.lang.String a=<span class="keyword">new</span> java.lang.String();</span><br><span class="line">		System.out.println(<span class="string">"到底加载了哪个String"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number32.jpg" alt><br>优势是避免类的重复加载，保护程序安全，防止核心API被随意篡改</p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number33.jpg" alt></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>JVM必须知道一个类型是由哪个类加载器加载的（是启动还是用户）。如<br>果是用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型<br>信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用时，JVM<br>需要保证这两个类型的类加载器是相同的</li>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number34.jpg" alt></li>
</ol>
<h2 id="运行时数据区内部结构"><a href="#运行时数据区内部结构" class="headerlink" title="运行时数据区内部结构"></a>运行时数据区内部结构</h2><p>一个进程对应一个红色区域，一个线程对应一个灰色区域  <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number35.jpg" alt></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number36.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number37.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number38.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number39.jpg" alt></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number40.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number41.jpg" alt></p>
<h3 id="程序计数器介绍"><a href="#程序计数器介绍" class="headerlink" title="程序计数器介绍"></a>程序计数器介绍</h3><p>java虚拟机中存在PC寄存器，也可以叫做程序计数器 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number42.jpg" alt></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>是一块很小的内存空间，也是运行速度最快的存储区域</li>
<li>每个线程都有自己的程序计数器，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是当前方法，程序计数器<br>会存储当前线程正在执行的Java方法的虚拟机字节码指令地址，如果执行<br>native方法则未指定值。是唯一不存在OOM的区域<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number43.jpg" alt></li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>虚拟机执行字节码指令实际是通过生成机器指令执行的 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number44.jpg" alt></p>
<h4 id="两个常见问题"><a href="#两个常见问题" class="headerlink" title="两个常见问题"></a>两个常见问题</h4><ol>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number45.jpg" alt></li>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number46.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number47.jpg" alt></li>
</ol>
<h4 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h4><ul>
<li>串行 线程排成队依次被CPU执行</li>
<li>并行 多个线程同时被执行</li>
<li>并发 一个CPU快速切换线程，看起来像是并行<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number48.jpg" alt></li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="虚拟机栈的概述"><a href="#虚拟机栈的概述" class="headerlink" title="虚拟机栈的概述"></a>虚拟机栈的概述</h4><p>java虚拟机栈早期也叫Java栈，每个线程创建时都会创建一个虚拟机栈<br>，其内部保存一个个栈帧，对应一次次的Java方法调用，生命周期和线程<br>一致，主管Java程序的运行，保存方法的局部变量、部分结果，并参与方法<br>的调用和返回。局部变量包括8种基本数据类型和对象的引用地址<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number49.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number50.jpg" alt></p>
<h4 id="栈帧的粗略描述"><a href="#栈帧的粗略描述" class="headerlink" title="栈帧的粗略描述"></a>栈帧的粗略描述</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number51.jpg" alt></p>
<h4 id="栈的优点"><a href="#栈的优点" class="headerlink" title="栈的优点"></a>栈的优点</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number52.jpg" alt></p>
<h4 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h4><p>HotSpot虚拟机的栈容量是不可以动态扩展的，所以不会出现虚拟机栈<br>无法扩展而导致的OOM异常，只要申请栈空间成功了就不会OOM，如果申<br>请时就失败会出现OOM <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number53.jpg" alt></p>
<h4 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number54.jpg" alt> 使用参数-Xss 设置线程的最大栈空间 1m=1024k<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number55.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number56.jpg" alt></p>
<h4 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number57.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number58.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number59.jpg" alt></p>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number60.jpg" alt></p>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number61.jpg" alt></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number62.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number66.jpg" alt><br>解析字节码文件 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number63.jpg" alt> </p>
<ol>
<li>main方法所在的栈帧中 locals=3 表示局部变量表的长度<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number64.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number65.jpg" alt></li>
</ol>
<h4 id="字节码中方法内部结构剖析"><a href="#字节码中方法内部结构剖析" class="headerlink" title="字节码中方法内部结构剖析"></a>字节码中方法内部结构剖析</h4><p>在IDEA插件中下载jclasslib，在view中show bytecode<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number70.jpg" alt></p>
<ul>
<li>public static + void + main，参数是String型数组 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number71.jpg" alt></li>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number72.jpg" alt></li>
</ul>
<h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>方法运行期间不会改变局部变量表的大小，这里的大小指的是变量槽的数量，<br>虚拟机自行决定是用多大的空间表示一个变量槽（32bit or 64bit）<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number67.jpg" alt> 静态方法的局部变量表中没有this，所以不能在静态方法中引用this<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number68.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number69.jpg" alt></p>
<h4 id="slot的重复利用"><a href="#slot的重复利用" class="headerlink" title="slot的重复利用"></a>slot的重复利用</h4><p>局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么<br>在其作用域之后申明的新的局部变量就很有可能过期局部变量的槽位，达到节<br>省资源的目的 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number74.jpg" alt><br>变量c使用之前已经销毁的变量b占据的slot的位置 </p>
<h4 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h4><ol>
<li>按数据类型分类 基本数据类型和引用数据类型</li>
<li>按照在类中声明的位置 成员变量和局部变量，成员变量又可分为是否<br>用static修饰。如果static修饰就是类变量否则就是实例变量</li>
<li>成员变量在使用前都被默认初始化，在类加载过程的链接中的准备阶段给类<br>变量默认赋值，在initial阶段给类变量显式赋值以及静态代码块赋值。实例变<br>量随着对象的创建会在堆空间中分配实例变量空间并进行默认赋值</li>
<li>局部变量在使用前必须进行显式赋值</li>
<li>如果局部变量表中没有指向堆的一个引用那么就会进行垃圾回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number75.jpg" alt></li>
</ol>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number76.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number77.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number78.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number79.jpg" alt></p>
<h4 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number80.jpg" alt> </p>
<ol>
<li>一开始指令地址指向0，局部变量表中只有this，将15（int）放入<br>操作数栈，然后指令地址指向2，执行出栈操作，同时局部变量表中加<br>入15 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number81.jpg" alt></li>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number82.jpg" alt></li>
<li>从局部变量表中依次取出索引为1和2的数据放入操作数栈中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number83.jpg" alt></li>
<li>iadd指令被执行引擎翻译成机器指令被CPU执行，将操作数栈中的两<br>个数出栈然后进行加法运算将结果放入操作数栈中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number84.jpg" alt></li>
<li>对于有返回值的情况，获取上一个栈帧返回的结果并保存在操<br>作数栈中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number85.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number86.jpg" alt></li>
</ol>
<h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number87.jpg" alt></p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ol>
<li>帧数据区：动态链接，一些附加信息，方法返回地址</li>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属法规办法的引用，<br>持有这个引用是为了支持调用过程中的动态链接</li>
<li>所有的变量和方法引用都作为符号引用保存在常量池中</li>
<li>字节码中的方法调用指令就以常量池中里指向方法的符号引用作为参数</li>
<li>静态解析 一部分符号引用会在类加载阶段或者第一次使用的时候被转化<br>为直接引用</li>
<li>动态解析 一部分符号引用会在每一次运行期间都转化为直接引用，例如多态<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number88.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number91.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number92.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number93.jpg" alt></li>
</ol>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number94.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number95.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"eat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"dog eat meat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"dog hunt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    	</span>&#123;</span><br><span class="line">    		<span class="keyword">super</span>(); <span class="comment">//早期绑定</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    	</span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>(); <span class="comment">//早期绑定</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"cat eat meat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"cat hunt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shotAnimal</span><span class="params">(Animal animal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        animal.eat(); <span class="comment">//表现为晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shotHunt</span><span class="params">(Huntable hunt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hunt.hunt(); <span class="comment">//表现为晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number96.jpg" alt></p>
<h4 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number97.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number98.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number99.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"final"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"common"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是重写的父类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(str+<span class="string">"son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(str+<span class="string">"private"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        showStatic(<span class="string">"aa"</span>);</span><br><span class="line">        <span class="keyword">super</span>.showStatic(<span class="string">"bb"</span>);</span><br><span class="line">        <span class="comment">/*这个应该也是special但是显示的是virtual，查阅发现JDK8是special，</span></span><br><span class="line"><span class="comment">        最新的版本是virtual</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showPrivate(<span class="string">"cc"</span>);</span><br><span class="line">        <span class="comment">//显式调用父类方法</span></span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line">        <span class="comment">//虽然显示的是virtual但是不是一个虚方法</span></span><br><span class="line">        showFinal();</span><br><span class="line">        <span class="comment">//没有显式调用父类方法，子类有可能重写所以是虚方法</span></span><br><span class="line">        showCommon();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number100.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number101.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number102.jpg" alt></p>
<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number103.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number104.jpg" alt><br>例如Son没有重写toString方法，如果没有虚方法表那么就会往上进行查找Father<br>然后到Object，有了虚方法表后直接到Object <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number105.jpg" alt></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>存放调用该方法的pc寄存器的值<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number106.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number107.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number108.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number109.jpg" alt></p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>例如对程序调试、性能收集相关的信息，这部分信息由具体虚拟机实现</p>
<h3 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number110.jpg" alt></p>
<ol>
<li>可以通过-Xss设置栈空间大小溢出时StackOverFlowError，可以动态扩展时如<br>果内存空间不足无法动态扩充栈空间时会出现OOM</li>
<li>不能保证，如果发生无限递归的情况一定会栈溢出</li>
<li>并不是，会挤占其它内存空间</li>
<li>不会</li>
<li>有可能存在不安全问题</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>HotSpot虚拟机不区分虚拟机栈和本地方法栈，因此-Xoss参数（设置本地方法栈）<br>虽然存在但是没有任何效果，栈容量只能由-Xss设定<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number116.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number117.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number118.jpg" alt></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>一个进程就对应一个JVM实例，一个JVM实例就有一个运行时数据区，一个运行时<br>数据区就有一个堆，一个进程的多个线程要共享一个堆空间 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number120.jpg" alt><br>Java堆即可实现成固定大小也可使是可扩展的，目前主流的虚拟机都是可以扩展<br>的，HotSpot虚拟机的栈容量是不可扩展的，通过参数-Xms -Xmx 动态扩展堆空间<br>将最大值与最小值设置为一样就可避免自动扩展 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number121.jpg" alt><br>VisualVM是功能最强大的运行监视和故障处理程序之一<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number122.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number123.jpg" alt><br>Visual GC 插件可以在工具中下载，可能要多次重试下载<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number124.jpg" alt> 12m+8+1m+7m=20m <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number125.jpg" alt> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; <span class="comment">//Main2代码跟Main一样，不过一个堆空间是10M一个是20M</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number126.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number197.jpg" alt></p>
<h4 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h4><p>设置堆空间的大小时实际只包括新生代和老年代，并不包括元空间<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number127.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number198.jpg" alt> <a href="number128.jpg"></a><br>-XX:PrintGCDetails 打印垃圾回收的细节 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number199.jpg" alt></p>
<h4 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h4><p>开发中建议将初始堆内存和最大堆内存设置一样大，否则GC之后会重新调整堆大小<br>给系统造成额外压力<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number129.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number200.jpg" alt><br>默认情况下实际可用的空间不足8G <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number201.jpg" alt><br>jstat -gc 监视Java堆运行情况 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number202.jpg" alt></p>
<h4 id="OutOfMemory"><a href="#OutOfMemory" class="headerlink" title="OutOfMemory"></a>OutOfMemory</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number130.jpg" alt></p>
<h4 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number131.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number132.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number133.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number134.jpg" alt><br>-XX:NewRatio=1 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number203.jpg" alt><br>jinfo的作用是实时查看和调整虚拟机各项参数 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number204.jpg" alt></p>
<h4 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number135.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number136.jpg" alt><br>红色的部分已经是垃圾，绿色的部分还要使用放到幸存者区 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number137.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number138.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number139.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number140.jpg" alt></p>
<h4 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h4><p>每次垃圾回收必须保证Eden区清空如果幸存者区放不下就放到老年区，YGC时<br>幸存者区也会进行垃圾回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number141.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number205.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number206.jpg" alt></p>
<h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number142.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number143.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number144.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number145.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number146.jpg" alt></p>
<h4 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number147.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number148.jpg" alt></p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number149.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number150.jpg" alt></p>
<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number151.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number152.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number153.jpg" alt><br>默认开启 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number207.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number154.jpg" alt></p>
<h4 id="堆空间的参数设置小结"><a href="#堆空间的参数设置小结" class="headerlink" title="堆空间的参数设置小结"></a>堆空间的参数设置小结</h4><ul>
<li>-XX:SurvivorRatio 设置新生代中Eden和s0/s1的占比，如果Eden过大那么<br>对象会更可能存放到老年代，使Minor GC失去意义，如果Eden过小那么<br>Minor GC的频率就会变高，会影响用户进程<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number155.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number156.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number157.jpg" alt></li>
</ul>
<h3 id="通过逃逸分析看堆空间的对象分配策略"><a href="#通过逃逸分析看堆空间的对象分配策略" class="headerlink" title="通过逃逸分析看堆空间的对象分配策略"></a>通过逃逸分析看堆空间的对象分配策略</h3><p>快速判断是否发生逃逸分析就看new的对象实体是否有可能在方法外调用，如果对<br>象声明是static仍然会发生逃逸 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number158.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number159.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number160.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number161.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number162.jpg" alt><br>总结就是在开发中应该多使用局部变量少在方法外定义 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number163.jpg" alt></p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number164.jpg" alt></p>
<h4 id="代码优化之栈上分配"><a href="#代码优化之栈上分配" class="headerlink" title="代码优化之栈上分配"></a>代码优化之栈上分配</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number165.jpg" alt></p>
<h4 id="代码优化之同步省略"><a href="#代码优化之同步省略" class="headerlink" title="代码优化之同步省略"></a>代码优化之同步省略</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number166.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number167.jpg" alt></p>
<h4 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number168.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number169.jpg" alt></p>
<h4 id="堆的小结"><a href="#堆的小结" class="headerlink" title="堆的小结"></a>堆的小结</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number170.jpg" alt><br>所以之前讲解的栈上分配实际上用的是标量替换，对象依然是在堆中<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number171.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number172.jpg" alt></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h3 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number173.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number174.jpg" alt></p>
<h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number175.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number176.jpg" alt><br>实际加载的类数量远多于直接能识别的类 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number209.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number208.jpg" alt></p>
<h3 id="Hotspot中方法区的演进"><a href="#Hotspot中方法区的演进" class="headerlink" title="Hotspot中方法区的演进"></a>Hotspot中方法区的演进</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number177.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number178.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number179.jpg" alt></p>
<h3 id="设置方法区大小和OOM"><a href="#设置方法区大小和OOM" class="headerlink" title="设置方法区大小和OOM"></a>设置方法区大小和OOM</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number180.jpg" alt> -XX:MetaspaceSize=100m <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number181.jpg" alt></p>
<h3 id="Metaspace举例"><a href="#Metaspace举例" class="headerlink" title="Metaspace举例"></a>Metaspace举例</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number210.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number182.jpg" alt></p>
<h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number183.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number184.jpg" alt></p>
<h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number185.jpg" alt></p>
<h4 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number186.jpg" alt></p>
<h4 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number187.jpg" alt></p>
<h4 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number188.jpg" alt></p>
<h4 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h4><p>static+final 每个全局常量在编译的时候就被分配了</p>
<h4 id="class文件中的常量池"><a href="#class文件中的常量池" class="headerlink" title="class文件中的常量池"></a>class文件中的常量池</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number189.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number190.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number191.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number192.jpg" alt><br>常量池就可以看做是一张表，虚拟机指令根据这张表找到要执行的类名、方法<br>名、参数类型、字面量类型</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number193.jpg" alt></p>
<h3 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h3><ol>
<li>jdk1.6以前 有永久代，静态变量存放在永久代上</li>
<li>jdk1.7 有永久代但是逐步去永久代，字符串常量池、静态变量移除保留在堆中</li>
<li>jdk1.8及以后 无永久代，类型信息、字段、方法、常量保存在本地内存的元<br>空间中，当字符串常量池、静态变量仍在堆中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number211.jpg" alt></li>
<li>为永久代设置空间大小是很难确定的，在某些场景下如果动态加载类过多<br>容易产生Perm区的OOM，比如某个实际的web工程中因为功能比较多在运<br>行过程中要不断加载很多类，元空间使用本地内存受本地内存大小的影响动态改变</li>
</ol>
<h4 id="StringTable的调整"><a href="#StringTable的调整" class="headerlink" title="StringTable的调整"></a>StringTable的调整</h4><p>jdk7中将StringTable放到了堆空间中，因为永久代的回收效率很低，在full gc<br>的时候才会触发，而full gc是老年代的空间不足、永久代空间不足时才触发，开发<br>中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆中能够及<br>时回收</p>
<h4 id="静态变量的存储位置"><a href="#静态变量的存储位置" class="headerlink" title="静态变量的存储位置"></a>静态变量的存储位置</h4><p>静态引用对应的对象实体始终存放在堆空间，与jdk版本无关，jdk7以后静态变量<br>本身也是放在堆空间中的</p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>Java虚拟机规范中并没有强制要求对方法区进行垃圾回收，方法区的垃圾回收主要<br>是常量池中废弃的常量和不再使用的类型。方法区常量池中主要存放的两大常量是<br>字面量和符号引用，字面量比较接近Java语言层次的常量概念，如文本字符串，<br>被声明为final的常量值等。符号引用则属于编译原理方面的概念，包括以下三类</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符<br>只要常量池中的常量没有被任何地方引用就可以被回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number212.jpg" alt></li>
</ul>
<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number111.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number112.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native和abstract不可以共存，native方法是有方法体的</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass(); <span class="comment">//Object</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number113.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number114.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number115.jpg" alt></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当Java虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中<br>定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解<br>析和初始化过，如果没有先执行相应类加载过程。对象所需的内存大小在类加载<br>完成后便可确定，内存分配完成后将分配到的空间（不包括对象头）都初始化<br>为零值，这步操作保证对象的实例字段在Java代码中不赋初始值就可以使用。<br>对象头中的内容如下</p>
<ul>
<li>这个对象是哪个类的实例</li>
<li>如何找到类的元数据信息</li>
<li>对象的哈希码（实际等到真正调用时才计算）</li>
<li>对象的GC分代年龄</li>
</ul>
<h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p>调用完构造器对象才算创建完成，new之后是默认赋值，调用构造器是显式赋值<br>，例如捏面人，如果new是捏了一个形状那么调用构造器就是上色。是否执行构<br>找函数是由new指令后面是否跟随invokespecial指令决定，Java编译器会在<br>遇到new关键字的地方同时生成这两条字节码指令<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number213.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number214.jpg" alt></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number215.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number216.jpg" alt></p>
<h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><p>栈帧中的对象引用访问到内部对象实例有两种方式</p>
<ul>
<li>句柄访问 好处是reference中存储的是稳定句柄地址，在对象被移动时只<br>会句柄中的实例数据指针，而reference本身不需要修改 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number217.jpg" alt></li>
<li>直接指针 好处是速度快，节省一次指针定位的时间开销，HotSpot采用这种<br>方式 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number218.jpg" alt></li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java是虚拟机规范中定<br>义的内存区域，但是这部分内存也频繁使用甚至出现OOM，JDK1.4加入了NIO类，<br>引入了一种基于通道与缓冲区的IO方式，使用Native函数库直接分配堆外内存，<br>然后通过堆中的DirectByteBuffer对象作为这块内存的引用进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接分配本地内存空间</span></span><br><span class="line">ByteBuffer bf=ByteBuffer.allocateDirect(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>通常访问直接内存的速度优于访问Java堆，即读写性能更高<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number219.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number220.jpg" alt></p>
<ul>
<li>处于性能考虑，读写频繁的场合可能考虑使用本地内存</li>
<li>Java的NIO库允许Java程序使用直接内存用于数据缓冲区</li>
</ul>
<h3 id="直接内存的OOM"><a href="#直接内存的OOM" class="headerlink" title="直接内存的OOM"></a>直接内存的OOM</h3><p>直接内存在Java堆外，它的大小不会受限于-Xmx指定的最大堆大小，但是系统<br>内存有限，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存，<br>直接内存大小可以通过MaxDirectMemorySize设置，如果不指定默认与堆的<br>最大值-Xmx参数值一致，缺点如下</p>
<ul>
<li>回收成本高</li>
<li>不受JVM内存回收管理</li>
</ul>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><h3 id="执行引擎的概述"><a href="#执行引擎的概述" class="headerlink" title="执行引擎的概述"></a>执行引擎的概述</h3><ol>
<li>虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区<br>别是物理机的执行引擎是建立在处理器、缓存、指令集合操作系统层面上，<br>而虚拟机的执行引擎是由软件自行实现，因此不受物理条件制约地定制指<br>令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式</li>
<li>JVM的主要任务是负责装载字节码到其内部，但字节码并不能直接运行在<br>操作系统上，因为字节码指令并非等价于本地机器指令，其内部包含的仅仅<br>只是一些能够被JVM所识别的字节码指令、符号表以及其它辅助信息</li>
<li>执行引擎的任务就是将字节码指令编译为对应平台的本地机器指令，也就<br>是将高级语言翻译成机器语言</li>
</ol>
<h3 id="执行引擎的工作过程"><a href="#执行引擎的工作过程" class="headerlink" title="执行引擎的工作过程"></a>执行引擎的工作过程</h3><p>所有Java虚拟机的输入输出形式都是一致的，输入的是字节码二进制流，处理<br>过程是字节码解析执行的等效过程，输出的是执行结果 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number221.jpg" alt></p>
<h3 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h3><p>HotSpot虚拟机既有解释器也有JIT编译器，所以说Java是半编译半解释型<br>语言 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number222.jpg" alt></p>
<ul>
<li>解释器 当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的<br>方式执行，每条字节码文件中的内容翻译为对应平台的本地机器指令</li>
<li>JIT编译器 将字节码直接编译成与本地机器平台相关的机器语言，但不执行</li>
</ul>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>将字节码中的内容翻译成对应平台的机器指令，一开始的解释器一条条执行效率<br>低下，目前JVM平台支持一种即时编译的技术，目的是避免函数被解释执行，而是<br>将整个函数体编译成机器码，每次函数执行时只执行编译后的机器码即可 </p>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><p>HotSpot虚拟机采用解释器与即时编译器并存的架构，在虚拟机运行时能够相互<br>协作，各自取长补短。当程序启动时解释器可以马上逐条执行不必等即时编译器<br>全部编译完成后再执行，随着程序的运行，根据热点探测功能编译器将有价值<br>的字节码编译为本地机器指令，以换取更高的执行效率。JRockit VM内部不包<br>含解释器，字节码全部依靠即时编译器编译后执行，所以执行性能高但是编译<br>需要一定时间所以启动时需要花费更长的时间编译 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number223.jpg" alt></p>
<h3 id="热点代码探测"><a href="#热点代码探测" class="headerlink" title="热点代码探测"></a>热点代码探测</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number224.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number225.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number226.jpg" alt><br>是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令需要根据<br>代码被调用执行的频率而定，那些需要被编译为本地代码的字节码也称为热点<br>代码，JIT编译器在运行时会针对那些频繁被调用的热点代码做出深度优化，将<br>其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number227.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number228.jpg" alt><br>回边计数器的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到<br>控制流后跳转的指令称为回边，显然建立回边计数器统计的目的就是为了触发<br>OSR编译 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number229.jpg" alt></p>
<h3 id="HotSpot设置模式"><a href="#HotSpot设置模式" class="headerlink" title="HotSpot设置模式"></a>HotSpot设置模式</h3><ul>
<li>-xint 完全采用解释器模式执行程序</li>
<li>-Xcomp 完全采用即时编译器执行程序，如果即时编译器出问题解释器会执行</li>
<li>-Xmixed 采用解释器+即时编译器混合执行 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number230.jpg" alt><br>在HotSpot中内嵌两个JIT编译器，分别是Client Compiler和Server Compiler<br>大多数情况下称为C1和C2编译器，可以通过如下命令指定</li>
<li>-client C1编译器会对字节码进行简单和可靠的优化，耗时短，可以更快编译</li>
<li>-server C2耗时较长的时间优化以及激进优化，但优化的代码执行效率更高<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number232.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number231.jpg" alt></li>
</ul>
<h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><p>JDK7以前，字符串常量池放在永久代，JDK7以后字符串常量池放在堆中</p>
<h3 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h3><ul>
<li>String:字符串，使用”fsd”这种字面量的定义方式，或者new String(“fsd”)</li>
<li>String声明为final，不可被继承</li>
<li>String实现了Serializable接口，表示字符串支持序列化，实现了Comparable<br>接口表示String可以比较大小 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number233.jpg" alt></li>
<li>String在jdk8及以前内部定义final char[] value用于存储字符串数据，jdk9<br>改为byte[]</li>
<li>String的不可变性</li>
</ul>
<ol>
<li>当对字符串重新赋值时需要重写指定内存区域赋值，不能使用原有的value</li>
<li>当对先有的字符串连接操作也需要重写指定内存区域赋值</li>
<li>replace()方法修改字符串也需要从写指定区域赋值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"fsd"</span>;</span><br><span class="line">String s2=<span class="string">"fsd"</span>;</span><br><span class="line"><span class="comment">//字符串常量池中不能有重复的字符串，指向同一个位置</span></span><br><span class="line"><span class="comment">//s1==s2</span></span><br><span class="line">String s2=<span class="string">"vxfs"</span>;</span><br><span class="line"><span class="comment">//字符串常量池中新创建一个字符串，s2指向另一个位置</span></span><br><span class="line">String s2+=<span class="string">"vsdfa"</span>;</span><br><span class="line"><span class="comment">//同上，总之就是字符串不可在原有基础修改</span></span><br><span class="line">String s2=s1.replace(<span class="string">"f"</span>,<span class="string">"m"</span>);</span><br><span class="line"><span class="comment">//s1并未变化只是创建了一个新的字符串赋给s2</span></span><br></pre></td></tr></table></figure>
jdk8开始可设置的最小值是1009 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number234.jpg" alt></li>
</ol>
<h3 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h3><p>8中基本数据类型和String类型都提供了一种常量池的概念，目的是使它们运行<br>过程中速度更快更节省内存。String常量池的使用方式有两种</p>
<ul>
<li>直接使用双引号什么出来的String对象会直接存储在常量池中</li>
<li>如果不使用双引号也可以使用String提供的intern()方法</li>
</ul>
<h3 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h3><p>Java语言规范要求完全相同的字符串字面量应该包含相同的字符序列，必须指向<br>同一个String实例 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number235.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number236.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number237.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">		Memory mem=<span class="keyword">new</span> Memory();</span><br><span class="line">		mem.foo(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		String str=param.toString();</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number238.jpg" alt></p>
<h3 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h3><ol>
<li>常量与常量的拼接结果放在常量池中，原理是编译期优化</li>
<li>常量池中不会存在相同内容的常量</li>
<li>只要有一个是变量，结果就在堆中（非常量池），原理是StringBuilder</li>
<li>如果拼接的结果是调用intern()方法，则主动将常量池中还没有的字符串<br>对象放入池中，并返回对象地址<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>; <span class="comment">//编译期就直接优化为"abc"</span></span><br><span class="line">String s2=<span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//s1==s2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"javaEE"</span>;</span><br><span class="line">String s2=<span class="string">"hadhoop"</span>;</span><br><span class="line">String s3=<span class="string">"javaEEhadhoop"</span>;</span><br><span class="line">String s4=<span class="string">"javaEE"</span>+<span class="string">"hadhoop"</span>;</span><br><span class="line"><span class="comment">//以下拼接过程出现变量，则相当于在堆空间中new String("javaEEhadhoop")</span></span><br><span class="line">String s5=s1+<span class="string">"hadhoop"</span>;</span><br><span class="line">String s6=<span class="string">"javaEE"</span>+s2;</span><br><span class="line">String s7=s1+s2;</span><br><span class="line"><span class="comment">//判断字符串常量池中是否有javaEEhadhoop，如果存在返回地址否则在常量池加载并返回</span></span><br><span class="line">String s8=s6.intern();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="字符串拼接操作的底层原理"><a href="#字符串拼接操作的底层原理" class="headerlink" title="字符串拼接操作的底层原理"></a>字符串拼接操作的底层原理</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number239.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"a"</span>;</span><br><span class="line">String s2=<span class="string">"b"</span>;</span><br><span class="line">String s3=<span class="string">"ab"</span>;</span><br><span class="line">String s4=s1+s2;</span><br><span class="line"><span class="comment">//首先new StringBuilder()</span></span><br><span class="line"><span class="comment">//append("a") append("b")</span></span><br><span class="line"><span class="comment">//toString() 约等于 new String("ab")</span></span><br><span class="line"><span class="keyword">final</span> String s5=<span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">final</span> String s6=<span class="string">"b"</span>;</span><br><span class="line">String s7=s5+s6;</span><br><span class="line"><span class="comment">//s3==s7</span></span><br><span class="line"><span class="comment">//如果拼接符号作用两边都是字符串常量或常量引用则在编译器优化</span></span><br></pre></td></tr></table></figure>
<h3 id="拼接操作与append对比"><a href="#拼接操作与append对比" class="headerlink" title="拼接操作与append对比"></a>拼接操作与append对比</h3><p>通过StringBuilder的append()方式添加字符串的效率要远高于使用String<br>的字符串拼接方式，前一种方式自始至终只创建一个StringBuilder对象，<br>后一种方式创建多个StringBuilder对象和多个String对象，而且由于创建<br>较多对象内存占用大，进行GC时花费时间更多。前一种方式的一种改进方式<br>是在创建对象时就指定一个容量减少扩容次数</p>
<h3 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number240.jpg" alt></p>
<h3 id="new-String"><a href="#new-String" class="headerlink" title="new String()"></a>new String()</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number241.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line"><span class="comment">//会创建两个对象，一个new在堆中，一个ldc在字符串常量池中</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number242.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"a"</span>)+<span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line"><span class="comment">//首先new StringBuilder</span></span><br><span class="line"><span class="comment">//new String("a") 常量池中"a"</span></span><br><span class="line"><span class="comment">//new String("b") 常量池中"b"</span></span><br><span class="line"><span class="comment">//StringBuilder的toString创建一个String对象</span></span><br><span class="line"><span class="comment">//字符串常量池中没有生成"ab"</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number243.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意以下的堆以及之前所说的堆在谈到与常量池的关系时都是指除去常量池的堆</span></span><br><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"1"</span>)+<span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">//s1指向堆中的地址，字符串常量池中不存在"11"</span></span><br><span class="line">s1.intern();</span><br><span class="line"><span class="comment">//在字符串常量池中生成"11"</span></span><br><span class="line">String s2=<span class="string">"11"</span>;</span><br><span class="line"><span class="comment">//使用的是字符串常量池中已经有的"11"</span></span><br><span class="line"><span class="comment">//jdk7及以后 s1==s2</span></span><br><span class="line"><span class="comment">//为什么s1==s2，一个是指向堆，一个指向常量池怎么会一样呢</span></span><br><span class="line"><span class="comment">//在jdk6的时候，字符串常量池还未放在堆中，所以会在常量池创建"11"，所以不一样</span></span><br><span class="line"><span class="comment">//jdk7及以后的一个重要变化就是字符串常量池放入堆中，首先得到s1的时候只是堆中有</span></span><br><span class="line"><span class="comment">//考虑到空间节省，既然s1.intern()之前常量池中没有"11"，那么就不在常量池创建"11"</span></span><br><span class="line"><span class="comment">//所以常量池中的"11"实际没有创建而是引用了堆中的"11"</span></span><br><span class="line"><span class="comment">//s2中指向的实际上是堆中的"11"</span></span><br><span class="line"><span class="comment">//之后我又测试了一下，如果没有s1.intern()这步操作那么s2就会在常量池创建"11"</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number244.jpg" alt></p>
<h3 id="垃圾回收器的String去重"><a href="#垃圾回收器的String去重" class="headerlink" title="垃圾回收器的String去重"></a>垃圾回收器的String去重</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number245.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number246.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number247.jpg" alt></p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h3><ol>
<li>垃圾 垃圾就是指在运行程序中没有任何指针指向的对象，这个对象就是需<br>要被回收的垃圾，如果不及时对内存中的垃圾进行清理，那么这些垃圾对象<br>所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象<br>使用</li>
<li>早期的c/c++时代，垃圾回收基本是手工进行，可以使用new进行内存申请，<br>并使用delete进行内存释放，但是给开发人员带来频繁申请和释放内存的管理<br>负担，万一有一块内存忘记delete了那么这块内存就永远没有被清除</li>
<li>除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收</li>
</ol>
<h3 id="Java自动内存管理介绍"><a href="#Java自动内存管理介绍" class="headerlink" title="Java自动内存管理介绍"></a>Java自动内存管理介绍</h3><p>自动内存管理，开发人员无需手动参与内存的分配和回收，降低内存泄漏和内存<br>溢出的风险，更加专注于业务的开发。但是也弱化了Java开发人员在程序出现内<br>存溢出时定位问题和解决问题的能力，所以了解JVM的自动内存分配和内存回收<br>原理就尤为重要</p>
<h3 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h3><p>在堆中存放几乎所有的Java对象实例，在GC执行垃圾回收之前首先需要区分内存<br>中哪些是存活对象，哪些是已经死亡的对象，只有被标记为已经死亡的对象才会<br>被回收。判断对象是否存活有两种方式，引用计数算法和可达性分析算法</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况，如果<br>对象的引用计数器的值为0那么这个对象就不再使用可以被回收。</p>
<ul>
<li>优点是实现简单，垃圾对象容易辨识，判定效率高，回收没有延迟性</li>
<li>缺点是需要单独的字段存储计数器，这样增加存储空间的开销，每次赋值都<br>需要更新计数器，伴随加法和减法操作增加时间开销，尤其是无法处理循环<br>引用的情况，导致Java的垃圾回收期中没有使用这种算法 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number248.jpg" alt></li>
</ul>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法不仅同样具备实现简单和执行高效等特点，而且有效解决在引用<br>计数器中循环利用的问题防止内存泄漏的发生，这种类型的垃圾收集也叫追踪性<br>垃圾收集，基本思路如下</p>
<ol>
<li>以根对象集合为起始点，按照从上至下的方式搜索被跟对象集合所连接的目<br>标对象是否可达，GC Roots根集合就是一组必须活跃的引用 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number249.jpg" alt></li>
<li>使用可达性分析算法以后，内存中的存活对象都会被根对象集合直接或间接<br>连接着，搜索所走过的路径称为引用链</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着对象已经死<br>亡，可以标记为垃圾对象</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是<br>存活对象 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number250.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number252.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number251.jpg" alt></li>
<li>如果要使用可达性分析算法来判断内存是否可以回收，那么分析工作必须<br>在一个能保障一致性的快照中进行，这点不满足分析结果的正确性就无法保<br>证，这点也是导致GC时必须”stop the world”的一个重要原因，及时在CMS<br>收集器中枚举根节点也是必须要停顿的</li>
</ol>
<h3 id="跨代引用假说"><a href="#跨代引用假说" class="headerlink" title="跨代引用假说"></a>跨代引用假说</h3><p>将堆内存分为新生代和老年代分别回收存在一个问题，对象不是孤立的，对象<br>之间存在跨代引用，例如现在进行一次新生代的收集，但是新生代的对象可能<br>被老年代的对象引用，所以为了找到存活对象必须遍历老年代，反过来也是一<br>样，实际上跨代引用相对同代引用仅占少数，只需要在新生代中建立一个全局<br>的数据结构（成为记忆集，Remembered Set），这个结构把老年代划分为若<br>干个小块，标识老年代哪一块内存会存在跨代引用</p>
<h3 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h3><ol>
<li>Java语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义<br>处理逻辑</li>
<li>当垃圾回收器发现没有一个引用指向一个对象，即垃圾回收此对象之前总会<br>先调用这个对象的finalize()方法</li>
<li>finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释<br>放，通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套<br>接字和数据库连接等</li>
<li>永远不要主动调用finalize()方法</li>
</ol>
<ul>
<li>在finalize()时可能导致对象复活</li>
<li>finalize()方法的执行时间没有保障，完全由GC线程决定，极端情况如果<br>不发生GC，则finalize()方法没有执行机会</li>
<li>一个糟糕的finalize()会严重影响GC的性能</li>
</ul>
<ol start="5">
<li>由于finalize()方法的存在对象存在三种状态 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number253.jpg" alt></li>
<li>具体过程 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number254.jpg" alt></li>
<li>可复活的对象 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number255.jpg" alt><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Main obj;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用重写的finalize"</span>);</span><br><span class="line">        obj=<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            obj=<span class="keyword">new</span> Main();</span><br><span class="line">            obj=<span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            System.out.println(<span class="string">"第一次gc"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span>(obj==<span class="keyword">null</span>)</span><br><span class="line">                System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">            System.out.println(<span class="string">"第二次gc"</span>);</span><br><span class="line">            obj=<span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span>(obj==<span class="keyword">null</span>)</span><br><span class="line">                System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="使用JProfiler查看GC-Roots"><a href="#使用JProfiler查看GC-Roots" class="headerlink" title="使用JProfiler查看GC Roots"></a>使用JProfiler查看GC Roots</h3><p>JProfiler能够在IDEA的plugins中下载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        Date birth=<span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数据加载完毕"</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">        list=<span class="keyword">null</span>;</span><br><span class="line">        birth=<span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"数据置空"</span>);</span><br><span class="line">        <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="垃圾清除算法"><a href="#垃圾清除算法" class="headerlink" title="垃圾清除算法"></a>垃圾清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，<br>释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内<br>存。目前JVM中常见的三种垃圾收集算法是标记-清除算法、复制算法、标记-压缩<br>算法</p>
<h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>当堆中的有效空间被耗尽的时候，就会停止整个程序，然后进行两项操作，一项<br>是标记，第二项是清除 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number258.jpg" alt></p>
<ul>
<li>标记 Collector从引用跟节点开始遍历，标记所有被引用的对象，一般是在<br>对象的Header中记录可达对象</li>
<li>清除 Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其<br>Header中没有标记为可达对象，则将其回收</li>
<li>缺点 效率并不高，需要停止整个应用程序，导致用户体验差，这种方式清理<br>出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表</li>
<li>清除 这里所谓的清除并不是真的清除，而是需要清除的对象地址保存在空<br>闲的地址列表里面，下次有新对象需要加载时，判断垃圾的位置空间是否够<br>，如果够就存放</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将活着的内存空间分为两块，每次只使用其中的一块，在垃圾回收时将正使用<br>的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块<br>中的所有对象，交换两个内存的角色，最后完成垃圾回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number259.jpg" alt></p>
<ul>
<li>优点 没有标记和清除过程，实现简单，运行高效，复制过去以后保证空间<br>的连续性，不会出现碎片问题</li>
<li>缺点 需要两倍的内存空间，对于G1这种分拆成为大量region的GC，复制<br>而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用<br>或者时间开销也不小</li>
<li>如果系统中垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，<br>或者说非常低比较好</li>
</ul>
<h4 id="标记-压缩算法（Mark-Compact）"><a href="#标记-压缩算法（Mark-Compact）" class="headerlink" title="标记-压缩算法（Mark-Compact）"></a>标记-压缩算法（Mark-Compact）</h4><p>老年代大部分对象是存活的对象，此时复制算法效果并不好，标记-压缩算法<br>可以应用在老年代中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number260.jpg" alt><br>标记-压缩算法的最终效果等同于标记-清除算法执行完成后再进行一次内存<br>碎片整理，因此也可以称为标记-清除-压缩算法，二者的本质区别是前者<br>是一种移动式的回收算法，后者是非移动式算法，是否移动回收后的存活<br>对象是一项优缺点并存的风险决策，可以看到标记的存活对象会被整理，<br>按照内存地址一次排列，而未被标记的内存会被清理，如此一来当需要给<br>新对象分配内存时JVM只需要持有一个内存的起始地址即可，这比维护一个<br>空闲列表显然少许多开销</p>
<ul>
<li>优点 消除了标记-清除算法中内存区域分散的缺点，我们需要给新对象<br>分配内存时，JVM只需要持有一个内存的起始地址即可，消除了复制算法<br>中内存减半的高额代价</li>
<li>缺点 从效率来说标记-整理算法要低于复制算法，移动对象的过程中如果<br>对象被其他对象引用，则还需要调整引用的地址，移动过程中需要全程暂停<br>用户应用程序即STW</li>
</ul>
<h4 id="对比三种算法"><a href="#对比三种算法" class="headerlink" title="对比三种算法"></a>对比三种算法</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number261.jpg" alt></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>具体问题具体分析，基于分代的概念，GC所使用的内存回收算法必须结合年轻代<br>和老年代各自的特点 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number262.jpg" alt></p>
<ul>
<li>年轻代 区域相对较小，对象生命周期短，这种情况复制算法最快，复制<br>算法的效率只与存活对象有关，很适用于年轻代的回收，而复制算法内存利<br>用率不高的问题通过HotSpot中的两个Survivor可以缓解</li>
<li>老年代 区域相对较大，对象生命周期长，一般有标记-清除或者是标记-清除<br>与标记-整理的混合实现</li>
</ul>
<h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number263.jpg" alt><br>缺点是由于在垃圾回收过程中间断性执行应用程序代码，能够减少系统的停顿<br>时间，但是线程切换和上下文准换的消耗会使得垃圾回收的总成本上升，造成<br>系统吞吐量下降</p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number264.jpg" alt></p>
<h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，<br>彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配<br>内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位<br>置上，这种分配方式就叫指针碰撞</p>
<h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc"></a>System.gc</h3><p>在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，<br>会显示触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃的对<br>象占用的内存，然而调用附带一个免责声明，就是无法保证对垃圾收集器的调<br>用，JVM实现者可以通过System.gc()调用来决定JVM的GC行为，而一般情况下，<br>垃圾回收应该是自动进行的，无需手动触发，在一些特殊情况下，比如正在编<br>写一个性能基准，我们可以在运行之间调用System.gc()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buffer始终占据局部变量表索引为1的位置，所以从新生代放入老年代后没有被回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value取代了buffer的索引位置，在Full GC的时候被回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> value=<span class="number">10</span>;</span><br><span class="line">	System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><ul>
<li>内存溢出 没有空闲内存，并且垃圾收集器也无法提供更多内存。没有空闲<br>内存有两种情况，一是Java虚拟机的堆内存设置不够，二是代码中创建了大<br>量大对象，并且长时间不能被垃圾收集器收集</li>
<li>内存泄漏 只有对象不会再被程序用到，但是GC又不能回收的情况才叫内<br>存泄漏，尽管内存泄漏并不会理科引起程序崩溃，但是一旦发生内存泄漏，<br>程序中的可用内存就会逐步被蚕食直至耗尽所有内存，最终出现OOM</li>
</ul>
<ol>
<li>单例模式 单例的生命周期的应用程序一样长，所以单例程序中，如果持<br>有对外部对象的引用的话那么这个对象是不能被回收的，则会导致内存泄漏<br>的产生</li>
<li>一些提供close的资源未关闭导致内存泄漏，数据库连接、网络连接和io<br>连接必须手动close，否则是不能被回收的</li>
</ol>
<h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h3><p>简称为STW，指的是GC事件发生过程中，会产生应用程序的停顿，停顿产生<br>时整个应用程序线程都会被暂停，没有任何响应。可达性分析算法中枚举所<br>有根节点会导致所有Java线程停顿</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析器件整个执行系统看起来像被冻结在某个时间点上</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确<br>性无法保证STW事件和采用哪款GC无关，所有的GC都有这个事件，哪怕<br>是G1也不能完全避免STW，只能说垃圾回收器越来越优秀，回收效率越<br>来越高，尽可能缩短了暂停时间。STW是JVM在后台自动发起和自动完成<br>的，在用户不可见的情况下把用户的正常工作线程全部停掉</li>
</ul>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><ul>
<li>并发 在操作系统中，指一个时间段中有几个程序都处于已启动运行到<br>运行完毕之间，且这几个程序都是在同一个处理器上，并发并不是真正意<br>义上的同时进行，用户线程和垃圾收集线程同时执行</li>
<li>并行 当系统有一个以上的CPU时，一个CPU执行一个进程，多个进程同<br>时执行，多条垃圾收集线程可以并行工作，此时用户线程仍处于等待状态，<br>比如ParNew Parallel Scavenge Parallel Old</li>
<li>如果用户线程和收集器并发工作，收集器在对象图上标记颜色（三色<br>标记），同时用户线程在修改引用关系，会产生两种后。一种是把原本<br>消亡的对象错误标记为存活，这个影响不大，另一种就是把原本存活<br>的对象错误标记为消亡。产生对象小时的情况如下</li>
<li>赋值器插入一条或多条从黑色对象到白色对象的新引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ul>
<p>解决方案是增量更新和原始快照。增量更新是当黑色对象插入新的白色对象<br>时将这个新插入的引用记录下来，等并发扫描结束再将这些记录过的引用<br>关系中的黑色对象为根，重新扫描一次。原始快照实际上不会理会删除，<br>还是按照第一次扫描进行搜索</p>
<h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number265.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number266.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number267.jpg" alt><br>GC发生时，检查所有线程都跑到最近的安全点停顿有两种方式</p>
<ul>
<li>抢先式中断 首先中断所有线程，如果还有线程不在安全点就恢复线程，<br>让线程跑到安全点，目前没有虚拟机采用</li>
<li>主动式中断 设置一个中断标志，各个线程运行到中断点的时候主动轮<br>询这个标志，如果中断标志为真，则将自己进行中断挂起，轮询标志的<br>地方和安全点是重合的</li>
<li>安全点的选取基本上是以是否具有让程序长时间执行的特征，例如方法<br>调用、循环跳转、异常跳转等都属于指令序列复用，所以具有这些功能的<br>指令才会产生安全点</li>
</ul>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代建立了名为记忆<br>集的数据结构，用以避免老年代加进GC Roots扫描范围</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>写屏障可以看成在虚拟机层面对引用类型字段赋值这个动作的AOP切面</p>
<h3 id="Java中几种不同引用"><a href="#Java中几种不同引用" class="headerlink" title="Java中几种不同引用"></a>Java中几种不同引用</h3><p>jdk1.2之后Java对引用的概念进行扩充，将引用分为强引用、软引用、弱<br>引用和虚引用，这4种引用强度依次逐渐减弱 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number268.jpg" alt></p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用可以直接访问目标对象，强引用所指向的对象在任何时候都不会被<br>系统回收，虚拟机宁愿抛出OOM异常也不会回收强引用指向的对象<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number269.jpg" alt></p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number270.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number271.jpg" alt></p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number272.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number273.jpg" alt></p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number274.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number275.jpg" alt></p>
<h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><p>它用以实现对象的finalize()方法，也可以称为终结器引用，在GC时，<br>终结器引用入队，由Finalizer线程通过终结器引用找到被引用的对象<br>并调用它的finalize()方法，第二次GC时才能回收被引用对象</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="垃圾回收器的分类"><a href="#垃圾回收器的分类" class="headerlink" title="垃圾回收器的分类"></a>垃圾回收器的分类</h3><p>JDK的版本处于高速迭代过程，Java发展至今已经衍生了许多GC版本，<br>Java不同版本的新特性可以从三个方面分析</p>
<ul>
<li>语法层面 Lambda表达式、switch、自动装箱、自动拆箱、enum、&lt;&gt;</li>
<li>API层面 Stream API、新的时间日期、Optional、String、集合框架</li>
<li>底层优化 JVM优化、GC的变化、元空间、静态域、字符串常量池</li>
</ul>
<h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number276.jpg" alt></p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number277.jpg" alt></p>
<h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number278.jpg" alt> </p>
<h4 id="吞吐量VS暂停时间"><a href="#吞吐量VS暂停时间" class="headerlink" title="吞吐量VS暂停时间"></a>吞吐量VS暂停时间</h4><p>在最大吞吐量优先的情况下，降低停顿时间 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number279.jpg" alt></p>
<h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number280.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number281.jpg" alt></p>
<ul>
<li>串行回收器 Serial,Serial Old</li>
<li>并行回收器 ParNew,Scavenge,Parallel Old</li>
<li>并发回收器 CMS,G1</li>
</ul>
<h3 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number282.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number283.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number284.jpg" alt></p>
<h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><ul>
<li>-XX:+PrintCommandLineFlags 查看命令行相关参数</li>
<li>使用命令行 jinfo -flag 相关垃圾回收器参数 进程ID<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number285.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number286.jpg" alt></li>
</ul>
<h4 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number287.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number288.jpg" alt></p>
<ul>
<li>优点 简单高效，对于限定单个CPU的环境来说，Serial收集器由于没有<br>线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率，<br>运行在Client模式下的虚拟机是个不错的选择</li>
<li>-XX:+UseSerialGC 参数可以指定年轻代和老年代都是用串行收集器</li>
<li>对于交互性较强的应用而言，这种垃圾收集器是不能接受的</li>
</ul>
<h4 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h4><p>ParNew收集器除了采用并行回收的方式执行内存回收外，与Serial几乎<br>没有区别，只是针对年轻代的回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number289.jpg" alt></p>
<ul>
<li>-XX:+UseParNewGC</li>
<li>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的<br>线程数</li>
</ul>
<h4 id="Parallel回收器"><a href="#Parallel回收器" class="headerlink" title="Parallel回收器"></a>Parallel回收器</h4><p>吞吐量优先，是Java8默认的垃圾收集器 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number290.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number291.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number292.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number293.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number294.jpg" alt></p>
<h3 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number295.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number296.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number297.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number298.jpg" alt></p>
<h4 id="CMOS的特点"><a href="#CMOS的特点" class="headerlink" title="CMOS的特点"></a>CMOS的特点</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number299.jpg" alt><br>CMS收集器的垃圾收集算法是标记-清除算法，会产生垃圾碎片，如果使用<br>Compact整理内存的话，但是还要保证用户线程能够继续执行，用户的运<br>行资源不能受影响，所以标记-清除算法更合适 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number300.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number301.jpg" alt></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number302.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number303.jpg" alt></p>
<h3 id="G1-区域化分代式"><a href="#G1-区域化分代式" class="headerlink" title="G1:区域化分代式"></a>G1:区域化分代式</h3><p>官方给G1设定的目标是在延迟可控的条件下获得尽可能高的吞吐量，所以<br>才担起全功能收集器的重任与期望</p>
<ul>
<li>G1是一个并行回收器，它把堆内存分割为很多不相关的region（物理上<br>不连续），使用不同的region表示各个区</li>
<li>G1避免了在整个Java堆中进行全区域的垃圾收集，G1跟踪各个region里<br>面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要时间的经<br>验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价<br>值最大的region</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的region，所以我们给G1取<br>名垃圾优先<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number304.jpg" alt></li>
</ul>
<h4 id="G1的特点"><a href="#G1的特点" class="headerlink" title="G1的特点"></a>G1的特点</h4><ul>
<li>优点 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number305.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number306.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number307.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number308.jpg" alt></li>
<li>缺点 在用户程序运行时，G1无论是为了垃圾收集产生的内存占用还是程序<br>运行的额外执行负载都要比CMS高</li>
</ul>
<h4 id="G1的参数设置"><a href="#G1的参数设置" class="headerlink" title="G1的参数设置"></a>G1的参数设置</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number309.jpg" alt></p>
<h4 id="G1的使用场景"><a href="#G1的使用场景" class="headerlink" title="G1的使用场景"></a>G1的使用场景</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number310.jpg" alt></p>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number311.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number312.jpg" alt></p>
<h4 id="G1的垃圾回收过程"><a href="#G1的垃圾回收过程" class="headerlink" title="G1的垃圾回收过程"></a>G1的垃圾回收过程</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number313.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number314.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number315.jpg" alt></p>
<h4 id="记忆集与写屏障"><a href="#记忆集与写屏障" class="headerlink" title="记忆集与写屏障"></a>记忆集与写屏障</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number316.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number317.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number318.jpg" alt></p>
<h4 id="G1回收过程"><a href="#G1回收过程" class="headerlink" title="G1回收过程"></a>G1回收过程</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number319.jpg" alt> </p>
<ul>
<li>年轻代GC <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number320.jpg" alt></li>
<li>并发标记过程 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number321.jpg" alt></li>
<li>混合回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number322.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number323.jpg" alt></li>
<li>Full GC <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number324.jpg" alt></li>
</ul>
<h3 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number325.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number326.jpg" alt></p>
<h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number327.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number328.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number329.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number330.jpg" alt></p>
<ul>
<li>垃圾回收数据的分析 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number331.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number332.jpg" alt></li>
<li>Minor GC  <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number333.jpg" alt></li>
<li>Full GC  <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number334.jpg" alt></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/05/06/%E6%B7%B1%E5%85%A5JVM/">https://skysea-gaoming.github.io/2020/05/06/%E6%B7%B1%E5%85%A5JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/15/IDEA/"><i class="fa fa-chevron-left">  </i><span>IDEA</span></a></div><div class="next-post pull-right"><a href="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>Java基础知识</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/05/06/%E6%B7%B1%E5%85%A5JVM/';
  this.page.identifier = '2020/05/06/深入JVM/';
  this.page.title = '深入JVM';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1602420731963&amp;di=032f7d4d661e3091e66c2accca9403d1&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn19%2Fw1600h924%2F20180314%2F4ac2-fyscsmv6453502.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>