<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入JVM"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>深入JVM | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考《深入理解JVM虚拟机》第三版"><span class="toc-number">1.</span> <span class="toc-text">参考《深入理解JVM虚拟机》第三版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#走进Java"><span class="toc-number">2.</span> <span class="toc-text">走进Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM架构"><span class="toc-number">2.1.</span> <span class="toc-text">JVM架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM的生命周期"><span class="toc-number">2.2.</span> <span class="toc-text">JVM的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器与类加载过程"><span class="toc-number">3.</span> <span class="toc-text">类加载器与类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载"><span class="toc-number">3.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接"><span class="toc-number">3.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#验证"><span class="toc-number">3.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#准备"><span class="toc-number">3.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解析"><span class="toc-number">3.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">3.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器分类"><span class="toc-number">3.4.</span> <span class="toc-text">类加载器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">3.5.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#沙箱安全机制"><span class="toc-number">3.6.</span> <span class="toc-text">沙箱安全机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">3.7.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时数据区内部结构"><span class="toc-number">4.</span> <span class="toc-text">运行时数据区内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存"><span class="toc-number">4.1.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">4.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序计数器介绍"><span class="toc-number">4.3.</span> <span class="toc-text">程序计数器介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#作用"><span class="toc-number">4.3.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子"><span class="toc-number">4.3.2.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个常见问题"><span class="toc-number">4.3.3.</span> <span class="toc-text">两个常见问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU时间片"><span class="toc-number">4.3.4.</span> <span class="toc-text">CPU时间片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟机栈"><span class="toc-number">4.4.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟机栈的概述"><span class="toc-number">4.4.1.</span> <span class="toc-text">虚拟机栈的概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈帧的粗略描述"><span class="toc-number">4.4.2.</span> <span class="toc-text">栈帧的粗略描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的优点"><span class="toc-number">4.4.3.</span> <span class="toc-text">栈的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈中可能出现的异常"><span class="toc-number">4.4.4.</span> <span class="toc-text">栈中可能出现的异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置栈内存大小"><span class="toc-number">4.4.5.</span> <span class="toc-text">设置栈内存大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的存储单位"><span class="toc-number">4.4.6.</span> <span class="toc-text">栈的存储单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈运行原理"><span class="toc-number">4.4.7.</span> <span class="toc-text">栈运行原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧的内部结构"><span class="toc-number">4.5.</span> <span class="toc-text">栈帧的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#局部变量表"><span class="toc-number">4.5.1.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字节码中方法内部结构剖析"><span class="toc-number">4.5.2.</span> <span class="toc-text">字节码中方法内部结构剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Slot"><span class="toc-number">4.5.3.</span> <span class="toc-text">Slot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slot的重复利用"><span class="toc-number">4.5.4.</span> <span class="toc-text">slot的重复利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态变量与局部变量的对比"><span class="toc-number">4.5.5.</span> <span class="toc-text">静态变量与局部变量的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈"><span class="toc-number">4.5.6.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码追踪"><span class="toc-number">4.5.7.</span> <span class="toc-text">代码追踪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈顶缓存技术"><span class="toc-number">4.5.8.</span> <span class="toc-text">栈顶缓存技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态连接"><span class="toc-number">4.6.</span> <span class="toc-text">动态连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法的调用"><span class="toc-number">4.7.</span> <span class="toc-text">方法的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚方法和非虚方法"><span class="toc-number">4.7.1.</span> <span class="toc-text">虚方法和非虚方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invokedynamic指令"><span class="toc-number">4.7.2.</span> <span class="toc-text">invokedynamic指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法的重写"><span class="toc-number">4.7.3.</span> <span class="toc-text">方法的重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法返回地址"><span class="toc-number">4.8.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#附加信息"><span class="toc-number">4.9.</span> <span class="toc-text">附加信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的相关面试题"><span class="toc-number">4.10.</span> <span class="toc-text">栈的相关面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地方法栈"><span class="toc-number">4.11.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆"><span class="toc-number">4.12.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#堆的核心概述"><span class="toc-number">4.12.1.</span> <span class="toc-text">堆的核心概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆内存细分"><span class="toc-number">4.12.2.</span> <span class="toc-text">堆内存细分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置堆内存大小与OOM"><span class="toc-number">4.12.3.</span> <span class="toc-text">设置堆内存大小与OOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutOfMemory"><span class="toc-number">4.12.4.</span> <span class="toc-text">OutOfMemory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#年轻代与老年代"><span class="toc-number">4.12.5.</span> <span class="toc-text">年轻代与老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象分配过程"><span class="toc-number">4.12.6.</span> <span class="toc-text">对象分配过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象分配的特殊情况"><span class="toc-number">4.12.7.</span> <span class="toc-text">对象分配的特殊情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC"><span class="toc-number">4.12.8.</span> <span class="toc-text">GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆空间分代思想"><span class="toc-number">4.12.9.</span> <span class="toc-text">堆空间分代思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存分配策略"><span class="toc-number">4.12.10.</span> <span class="toc-text">内存分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLAB"><span class="toc-number">4.12.11.</span> <span class="toc-text">TLAB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆空间的参数设置小结"><span class="toc-number">4.12.12.</span> <span class="toc-text">堆空间的参数设置小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过逃逸分析看堆空间的对象分配策略"><span class="toc-number">4.13.</span> <span class="toc-text">通过逃逸分析看堆空间的对象分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化"><span class="toc-number">4.13.1.</span> <span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化之栈上分配"><span class="toc-number">4.13.2.</span> <span class="toc-text">代码优化之栈上分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化之同步省略"><span class="toc-number">4.13.3.</span> <span class="toc-text">代码优化之同步省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化之标量替换"><span class="toc-number">4.13.4.</span> <span class="toc-text">代码优化之标量替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆的小结"><span class="toc-number">4.13.5.</span> <span class="toc-text">堆的小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区"><span class="toc-number">4.14.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈、堆、方法区的交互关系"><span class="toc-number">4.15.</span> <span class="toc-text">栈、堆、方法区的交互关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的基本理解"><span class="toc-number">4.16.</span> <span class="toc-text">方法区的基本理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hotspot中方法区的演进"><span class="toc-number">4.17.</span> <span class="toc-text">Hotspot中方法区的演进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置方法区大小和OOM"><span class="toc-number">4.18.</span> <span class="toc-text">设置方法区大小和OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metaspace举例"><span class="toc-number">4.19.</span> <span class="toc-text">Metaspace举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的内部结构"><span class="toc-number">4.20.</span> <span class="toc-text">方法区的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型信息"><span class="toc-number">4.20.1.</span> <span class="toc-text">类型信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#域信息"><span class="toc-number">4.20.2.</span> <span class="toc-text">域信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法信息"><span class="toc-number">4.20.3.</span> <span class="toc-text">方法信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#non-final的类变量"><span class="toc-number">4.20.4.</span> <span class="toc-text">non-final的类变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局常量"><span class="toc-number">4.20.5.</span> <span class="toc-text">全局常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class文件中的常量池"><span class="toc-number">4.20.6.</span> <span class="toc-text">class文件中的常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时常量池"><span class="toc-number">4.20.7.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的演进"><span class="toc-number">4.21.</span> <span class="toc-text">方法区的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable的调整"><span class="toc-number">4.21.1.</span> <span class="toc-text">StringTable的调整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态变量的存储位置"><span class="toc-number">4.21.2.</span> <span class="toc-text">静态变量的存储位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的垃圾回收"><span class="toc-number">4.22.</span> <span class="toc-text">方法区的垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法接口"><span class="toc-number">5.</span> <span class="toc-text">本地方法接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接内存"><span class="toc-number">6.</span> <span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-number">7.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的实例化"><span class="toc-number">7.1.</span> <span class="toc-text">对象的实例化</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582898893694&amp;di=15958b0625c3bcbdd505353b8b5deaa4&amp;imgtype=0&amp;src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F068c0cbf1b1571976ada2e55a53b3a079e1614c5.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">29</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591954918112&amp;di=2bc6f4358ea0e880687f5ced03157daf&amp;imgtype=0&amp;src=http%3A%2F%2Fyouimg1.c-ctrip.com%2Ftarget%2Ftg%2F620%2F406%2F859%2Fe7db3299a728401eb7b42effae33dadb.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">深入JVM</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/05/06/深入JVM/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考《深入理解JVM虚拟机》第三版"><a href="#参考《深入理解JVM虚拟机》第三版" class="headerlink" title="参考《深入理解JVM虚拟机》第三版"></a>参考《深入理解JVM虚拟机》第三版</h2><p>世界上没有完美的程序，但是我们并不因此沮丧，因为写程序本来就是一个不<br>断追求完美的过程</p>
<h2 id="走进Java"><a href="#走进Java" class="headerlink" title="走进Java"></a>走进Java</h2><ol>
<li>c/c++编译生成的可执行文件跟操作系统和指令集架构都有关系。满足相同<br>的操作系统和指令集架构这两个条件才可以执行这个可执行文件。指令集不<br>同  很好理解，如果指令集相同操作系统不同也是不能执行的。原因如下，<br>参考<a href="https://www.zhihu.com/question/22672994" target="_blank" rel="noopener">https://www.zhihu.com/question/22672994</a>  </li>
</ol>
<ul>
<li>一个可执行文件除了机器指令还包括各种数据和运行时资源，并且文件的格<br>式也不同</li>
<li>可执行文件执行前操作系统要有一些准备工作，不同的操作系统准备工作<br>不同</li>
<li>一个可执行文件所执行的绝大多数操作（比如：文件操作、输入输出、内存<br>申请释放、任务调度等等）都需要与操作系统交互才能完成，而不同的操作<br>系统使用这些操作的方法完全不同Java的一大特点就是摆脱了硬件平台的束<br>缚，一次编写到处运行，这跟c/c++有很大的区别 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number6.jpg" alt></li>
</ul>
<ol start="2">
<li>java虚拟机的功能比Java要强大，实际上是跨语言的平台，不同的编程<br>语言编写的程序也可以编译成字节码文件，如果符合虚拟机规范也可以在虚<br>拟机上运行，实际上能在jvm平台执行的字节码格式都是一样的，统称为<br>jvm字节码 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number7.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number194.jpg" alt></li>
<li>JDK是用于支持Java程序开发的最小环境,JRE是支持Java程序运行的<br>标准环境</li>
</ol>
<ul>
<li>Java程序设计语言，Java虚拟机，JavaAPI类库组成JDK</li>
<li>Java虚拟机，Java SE API组成JRE</li>
</ul>
<ol start="4">
<li>编译过程 编译器（javac）将Java代码翻译成字节码，也叫做前端编<br>译器，因为操作系统并不能识别字节码，所以Java虚拟机中的执行引擎中<br>的JIT编译器要将字节码翻译成机器指令  被CPU执行，所以JIT被称为后<br>端编译器</li>
<li>运行过程 Java虚拟机能够将字节码解释成具体平台的机器码 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number8.jpg" alt></li>
<li>虚拟机 是一台虚拟的计算机，也就是一个软件，用来执行一系列虚<br>拟计算机指令 </li>
</ol>
<ul>
<li>系统虚拟机 VisualBox VMware 完全对物理计算机的仿真，提供一个<br>可运行完整操作系统的软件平台，实际上模拟的是上图硬件</li>
<li>程序虚拟机 Java虚拟机 专门为执行单个计算机程序而设计，Java虚<br>拟机中执行的指令称为Java字节码指令，Java字节码是可以运行在任何<br>支持Java虚拟机的硬件平台和操作系统上的二进制文件，字节码的执行<br>实际上是被翻译成机器代码而执行的过程。实际上模拟的是上图JVM</li>
</ul>
<h3 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h3><ol>
<li>HotSpot虚拟机 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number12.jpg" alt></li>
<li>JVM的整体结构 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number2.jpg" alt></li>
</ol>
<ul>
<li>Java代码执行流程 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number9.jpg" alt></li>
<li>指令集架构分为两种，Java编译器输入的指令流基本上是一种基于<br>栈的指令集架构 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number10.jpg" alt> 反编译 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number195.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number196.jpg" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;x86</span><br><span class="line">mov $2, %eax</span><br><span class="line">add $3, %eax</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number13.jpg" alt></p>
<ol>
<li>虚拟机的启动 通过引导类加载器创建一个初始类来完成，这个类<br>是由虚拟机的具体实现指定</li>
<li>虚拟机的执行 执行Java程序，程序开始执行时执行，程序结束时<br>结束。实际上执行的是一个进程 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number89.jpg" alt><br>进程执行结束后 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number90.jpg" alt></li>
<li>jps JVM Process Status 可以列出正在运行的虚拟机进程，并<br>显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID</li>
<li>虚拟机的退出</li>
</ol>
<ul>
<li>程序正常结束</li>
<li>程序遇到异常或错误</li>
<li>操作系统错误</li>
<li>Runtime类或System类的exit方法</li>
</ul>
<h2 id="类加载器与类加载过程"><a href="#类加载器与类加载过程" class="headerlink" title="类加载器与类加载过程"></a>类加载器与类加载过程</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解<br>析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称为虚拟机的<br>类加载机制。类加载过程都是在程序运行期间完成的，为Java提供了极高的扩展性<br>和灵活性，比如编写一个面向接口的程序，等到运行时指定实际的实现类，本地程<br>序运行时从网络或其他地方加载二进制流作为程序代码的一部分，比如JSP等技术。<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number14.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number15.jpg" alt></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number16.jpg" alt></li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据区</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各<br>种数据的访问入口</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number17.jpg" alt></p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol>
<li>验证是确保Class文件的字节流中包含的信息符合Java虚拟机规范中的全部<br>约束要求，保证这些信息不回被当做代码运行后危害虚拟机自身的安全</li>
<li>Java是相对安全的编程语言，无法访问数组边界以外的数据、将一个对象转<br>型为并未实现的类型、跳转到不存在的代码行之类的情况，可以编译但在运行时会报错</li>
<li>文件格式验证 只有通过了这一阶段的验证才被允许进入Java虚拟机内存中<br>的方法区中进行存储，之后的三个验证阶段都是基于方法区中的内容</li>
</ol>
<ul>
<li>是否以魔数0xCAFEBABE开头 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number18.jpg" alt></li>
<li>主、次版本号是否在当前Java虚拟机接受范围</li>
</ul>
<ol start="4">
<li>元数据验证 该阶段是对字节码描述的信息进行语义分析，保证符合Java<br>语言规范的要求</li>
</ol>
<ul>
<li>这个类是否有父类（除了java.lang.Object，所有的类都要有父类）</li>
<li>这个类是否继承了不被允许的类（被final修饰的类）</li>
<li>如果这个字段不是抽象类是否实现了父类或接口中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类参数矛盾（比如覆盖了父类的final方法，或<br>者出现不符合规则的方法重载，例如方法参数一样类型不一样）</li>
</ul>
<ol start="5">
<li>字节码验证 通过数据流分析和控制流分析确定语义是合法的、符合逻辑的<br>在第二阶段对元数据信息中的数据类型校验完毕后这一阶段对类的方法体进<br>行校验分析</li>
</ol>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会<br>出现在操作数栈中放置了一个int类型的数据，使用时却按long类型来加载入<br>本地变量表中</li>
<li>保证任何跳转指令都不会调转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的，例如吧一个子类对象赋给父类数据类<br>型是安全的，但是父类对象赋值给子类数据类型甚至对象赋值给毫无继承关<br>系的数据类型是不符合要求的</li>
</ul>
<ol start="6">
<li>符号引用验证 这一过程发生在虚拟机将符号引用转化为直接引用的时候，<br>这个转化过程将在连接的第三个阶段-解析阶段发生，可以看做是对类自身<br>以外的各类信息进行匹配性校验，该类是否缺少或者被禁止访问它依赖的某<br>些外部类、方法、字段等资源</li>
</ol>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的可访问性是否可被当前类访问</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段a赋值为0，初始化过程赋值为1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<ul>
<li>符号引用 符号引用十一组符号来描述所引用的目标，可以是任何形式的字<br>面量，只要使用时能无歧义地定位到目标即可</li>
<li>直接引用 直接引用是直接指向目标的指针、相对偏移量或者一个能间接定<br>位到目标的句柄</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>什么情况开始加载过程并没有强制约束，这点可以由虚拟机自由把握。<br>初始化阶段有且只有六种情况必须对类进行初始化（而加载、验证、准备等自然<br>已经完成），这六种场景称为对一个类型进行主动引用，其余引用方式称为被动<br>引用，接口也有初始化过程，但是接口中不能用static{}语句块，但是编译器仍<br>然会为接口生成clinit类构造器，用于初始化接口中所定义的成员变量，接口与<br>类的区别在于第三种场景，接口初始化时并不要求其所有父接口都完成初始化，<br>只有真正使用到父接口的时候才会初始化，也就是只有父接口中定义的变量被使用<br>时，才会被初始化。接口的实现类在初始化时也一样不会执行接口的clinit方法</p>
<ol>
<li>遇到new getstatic putstatic invokestatic这4条指令代码时如果类<br>型没有进行初始化则会出发初始化阶段，能够生成这4条指令的场景如下</li>
</ol>
<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段的时候（被final修饰已经在编译期就确定的<br>字段除外）</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
<ol start="2">
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候如果类型没有<br>初始化就先触发初始化</li>
<li>初始化类时，如果父类没有初始化就先触发父类的初始化</li>
<li>虚拟机启动时，用户需要指定一个要执行的主类（包含main方法），虚拟机<br>会先初始化这个类</li>
<li>使用JDK7新加入的动态语言支持时，如果java.lang.invoke.MethodHandle<br>实例最后的解析结果为REF_getStatic REF_putStatic REF_invokeStatic<br>RED_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有<br>过初始化会触发其初始化</li>
<li>当一个接口中定义了JDK8中新加入的默认方法（被default关键字修饰的接口<br>方法）时，如果这个接口的实现了发生初始化那么接口要先初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"super init"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"sub init"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String hello=<span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Sting[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(SubClass.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行上述代码只会输出 super init而不会输出 sub init</span></span><br><span class="line"><span class="comment">//对于静态字段，只有直接定义这个字段的类才会被初始化</span></span><br><span class="line"><span class="comment">//sub类引用super类的静态字段所以super会被初始化，但是加载和验证阶段并不确定</span></span><br><span class="line"><span class="comment">//对于HotSpot虚拟机可以通过-XX:+TraceClassLoading参数观察是否被加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		SuperClass[] array=<span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有输出 super init，说明没有触发super类的初始化</span></span><br><span class="line"><span class="comment">//通过数组定义类引用类，不会触发类的初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(SubClass.hello);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有输出 sub init</span></span><br><span class="line"><span class="comment">//编译阶段通过常量传播优化已经将常量的值"Hello World"存储在Test3类的常量池中</span></span><br><span class="line"><span class="comment">//以后Test3对于常量SubClass.hello的引用实际上被转化为Test3类对自身常量池的引用</span></span><br><span class="line"><span class="comment">//Test3的Class文件中并不存在对SubClass类的符号引用入口，这两个类在编译后就没有关系了</span></span><br></pre></td></tr></table></figure>
<img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number19.jpg" alt></li>
<li>以下代码是允许的，链接时将num和number都赋值为0，初始化时将赋值动<br>作和静态代码块按顺序执行，最终number的值为1，但是不能有打印语句，<br>在number声明之前可以赋值但是不能前向引用</li>
<li>类变量必须要加static，否则就是实例变量</li>
<li>如果不存在类变量的赋值（不光定义类变量）和静态代码块那么就不会有clinit方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		num=<span class="number">2</span>;</span><br><span class="line">		number=<span class="number">10</span>;</span><br><span class="line">		<span class="comment">//System.out.println(number);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//最终number是1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>每一个类加载器都有一个独立的类名称空间，也就是说比较两个类是否相等<br>的两个条件是来自同一个Class文件并且由同一个类加载器加载 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number20.jpg" alt></p>
<ol>
<li>启动类加载器 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number24.jpg" alt></li>
<li>自定义类加载器，Java虚拟机规范定义所有继承抽象类java.lang.ClassLoader<br>的类加载器都划分为自定义类加载器<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number21.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number22.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number23.jpg" alt></li>
<li>类加载器的复制关系一般不是以继承的关系来实现的，而是通常使用组合<br>关系来复用父加载器的代码 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number25.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number26.jpg" alt></li>
<li>用户自定义类加载器 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number27.jpg" alt></li>
</ol>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
<ol start="5">
<li>ClassLoader 是一个抽象类，所有类加载器都继承自ClassLoader<br>（除了引导类加载器）<img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number28.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number29.jpg" alt></li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number30.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number31.jpg" alt><br>自己定义了一个java.lang.String类，系统类加载器加载时首先往上委托，<br>发现启动类加载器可以加载java.lang.String，所以自己定义的java.lang.String<br>不会被加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"自己定义的String类"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		java.lang.String a=<span class="keyword">new</span> java.lang.String();</span><br><span class="line">		System.out.println(<span class="string">"到底加载了哪个String"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number32.jpg" alt><br>优势是避免类的重复加载，保护程序安全，防止核心API被随意篡改</p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number33.jpg" alt></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>JVM必须知道一个类型是由哪个类加载器加载的（是启动还是用户）。如<br>果是用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型<br>信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用时，JVM<br>需要保证这两个类型的类加载器是相同的</li>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number34.jpg" alt></li>
</ol>
<h2 id="运行时数据区内部结构"><a href="#运行时数据区内部结构" class="headerlink" title="运行时数据区内部结构"></a>运行时数据区内部结构</h2><p>一个进程对应一个红色区域，一个线程对应一个灰色区域  <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number35.jpg" alt></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number36.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number37.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number38.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number39.jpg" alt></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number40.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number41.jpg" alt></p>
<h3 id="程序计数器介绍"><a href="#程序计数器介绍" class="headerlink" title="程序计数器介绍"></a>程序计数器介绍</h3><p>java虚拟机中存在PC寄存器，也可以叫做程序计数器 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number42.jpg" alt></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>是一块很小的内存空间，也是运行速度最快的存储区域</li>
<li>每个线程都有自己的程序计数器，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是当前方法，程序计数器<br>会存储当前线程正在执行的Java方法的虚拟机字节码指令地址，如果执行<br>native方法则未指定值，不存在OOM<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number43.jpg" alt></li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>虚拟机执行字节码指令实际是通过生成机器指令执行的 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number44.jpg" alt></p>
<h4 id="两个常见问题"><a href="#两个常见问题" class="headerlink" title="两个常见问题"></a>两个常见问题</h4><ol>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number45.jpg" alt></li>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number46.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number47.jpg" alt></li>
</ol>
<h4 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h4><ul>
<li>串行 线程排成队依次被CPU执行</li>
<li>并行 多个线程同时被执行</li>
<li>并发 一个CPU快速切换线程，看起来像是并行<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number48.jpg" alt></li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="虚拟机栈的概述"><a href="#虚拟机栈的概述" class="headerlink" title="虚拟机栈的概述"></a>虚拟机栈的概述</h4><p>java虚拟机栈早期也叫Java栈，每个线程创建时都会创建一个虚拟机栈<br>，其内部保存一个个栈帧，对应一次次的Java方法调用，生命周期和线程<br>一致，主管Java程序的运行，保存方法的局部变量、部分结果，并参与方法<br>的调用和返回。局部变量包括8种基本数据类型和对象的引用地址<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number49.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number50.jpg" alt></p>
<h4 id="栈帧的粗略描述"><a href="#栈帧的粗略描述" class="headerlink" title="栈帧的粗略描述"></a>栈帧的粗略描述</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number51.jpg" alt></p>
<h4 id="栈的优点"><a href="#栈的优点" class="headerlink" title="栈的优点"></a>栈的优点</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number52.jpg" alt></p>
<h4 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h4><p>HotSpot虚拟机的栈容量是不可以动态扩展的，所以不会出现虚拟机栈<br>无法扩展而导致的OOM异常，只要申请栈空间成功了就不会OOM，如果申<br>请时就失败会出现OOM <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number53.jpg" alt></p>
<h4 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number54.jpg" alt> 使用参数-Xss 设置线程的最大栈空间 1m=1024k<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number55.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number56.jpg" alt></p>
<h4 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number57.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number58.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number59.jpg" alt></p>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number60.jpg" alt></p>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number61.jpg" alt></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number62.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number66.jpg" alt><br>解析字节码文件 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number63.jpg" alt> </p>
<ol>
<li>main方法所在的栈帧中 locals=3 表示局部变量表的长度<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number64.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number65.jpg" alt></li>
</ol>
<h4 id="字节码中方法内部结构剖析"><a href="#字节码中方法内部结构剖析" class="headerlink" title="字节码中方法内部结构剖析"></a>字节码中方法内部结构剖析</h4><p>在IDEA插件中下载jclasslib，在view中show bytecode<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number70.jpg" alt></p>
<ul>
<li>public static + void + main，参数是String型数组 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number71.jpg" alt></li>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number72.jpg" alt></li>
</ul>
<h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>方法运行期间不会改变局部变量表的大小，这里的大小指的是变量槽的数量，<br>虚拟机自行决定是用多大的空间表示一个变量槽（32bit or 64bit）<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number67.jpg" alt> 静态方法的局部变量表中没有this，所以不能在静态方法中引用this<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number68.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number69.jpg" alt></p>
<h4 id="slot的重复利用"><a href="#slot的重复利用" class="headerlink" title="slot的重复利用"></a>slot的重复利用</h4><p>局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么<br>在其作用域之后申明的新的局部变量就很有可能过期局部变量的槽位，达到节<br>省资源的目的 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number74.jpg" alt><br>变量c使用之前已经销毁的变量b占据的slot的位置 </p>
<h4 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h4><ol>
<li>按数据类型分类 基本数据类型和引用数据类型</li>
<li>按照在类中声明的位置 成员变量和局部变量，成员变量又可分为是否<br>用static修饰。如果static修饰就是类变量否则就是实例变量</li>
<li>成员变量在使用前都被默认初始化，在类加载过程的链接中的准备阶段给类<br>变量默认赋值，在initial阶段给类变量显式赋值以及静态代码块赋值。实例变<br>量随着对象的创建会在堆空间中分配实例变量空间并进行默认赋值</li>
<li>局部变量在使用前必须进行显式赋值</li>
<li>如果局部变量表中没有指向堆的一个引用那么就会进行垃圾回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number75.jpg" alt></li>
</ol>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number76.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number77.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number78.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number79.jpg" alt></p>
<h4 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number80.jpg" alt> </p>
<ol>
<li>一开始指令地址指向0，局部变量表中只有this，将15（int）放入<br>操作数栈，然后指令地址指向2，执行出栈操作，同时局部变量表中加<br>入15 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number81.jpg" alt></li>
<li><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number82.jpg" alt></li>
<li>从局部变量表中依次取出索引为1和2的数据放入操作数栈中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number83.jpg" alt></li>
<li>iadd指令被执行引擎翻译成机器指令被CPU执行，将操作数栈中的两<br>个数出栈然后进行加法运算将结果放入操作数栈中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number84.jpg" alt></li>
<li>对于有返回值的情况，获取上一个栈帧返回的结果并保存在操<br>作数栈中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number85.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number86.jpg" alt></li>
</ol>
<h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number87.jpg" alt></p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><ol>
<li>帧数据区：动态链接，一些附加信息，方法返回地址</li>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属法规办法的引用，<br>持有这个引用是为了支持调用过程中的动态链接</li>
<li>所有的变量和方法引用都作为符号引用保存在常量池中</li>
<li>字节码中的方法调用指令就以常量池中里指向方法的符号引用作为参数</li>
<li>静态解析 一部分符号引用会在类加载阶段或者第一次使用的时候被转化<br>为直接引用</li>
<li>动态解析 一部分符号引用会在每一次运行期间都转化为直接引用，例如多态<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number88.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number91.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number92.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number93.jpg" alt></li>
</ol>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number94.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number95.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"eat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Huntable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"dog eat meat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"dog hunt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Huntable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    	</span>&#123;</span><br><span class="line">    		<span class="keyword">super</span>(); <span class="comment">//早期绑定</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    	</span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>(); <span class="comment">//早期绑定</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"cat eat meat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hunt</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"cat hunt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shotAnimal</span><span class="params">(Animal animal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        animal.eat(); <span class="comment">//表现为晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shotHunt</span><span class="params">(Huntable hunt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        hunt.hunt(); <span class="comment">//表现为晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number96.jpg" alt></p>
<h4 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number97.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number98.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number99.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">showFinal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"final"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCommon</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"common"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是重写的父类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showStatic</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(str+<span class="string">"son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showPrivate</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(str+<span class="string">"private"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        showStatic(<span class="string">"aa"</span>);</span><br><span class="line">        <span class="keyword">super</span>.showStatic(<span class="string">"bb"</span>);</span><br><span class="line">        <span class="comment">/*这个应该也是special但是显示的是virtual，查阅发现JDK8是special，</span></span><br><span class="line"><span class="comment">        最新的版本是virtual</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showPrivate(<span class="string">"cc"</span>);</span><br><span class="line">        <span class="comment">//显式调用父类方法</span></span><br><span class="line">        <span class="keyword">super</span>.showCommon();</span><br><span class="line">        <span class="comment">//虽然显示的是virtual但是不是一个虚方法</span></span><br><span class="line">        showFinal();</span><br><span class="line">        <span class="comment">//没有显式调用父类方法，子类有可能重写所以是虚方法</span></span><br><span class="line">        showCommon();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number100.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number101.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number102.jpg" alt></p>
<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number103.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number104.jpg" alt><br>例如Son没有重写toString方法，如果没有虚方法表那么就会往上进行查找Father<br>然后到Object，有了虚方法表后直接到Object <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number105.jpg" alt></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>存放调用该方法的pc寄存器的值<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number106.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number107.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number108.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number109.jpg" alt></p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>例如对程序调试、性能收集相关的信息，这部分信息由具体虚拟机实现</p>
<h3 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number110.jpg" alt></p>
<ol>
<li>可以通过-Xss设置栈空间大小溢出时StackOverFlowError，可以动态扩展时如<br>果内存空间不足无法动态扩充栈空间时会出现OOM</li>
<li>不能保证，如果发生无限递归的情况一定会栈溢出</li>
<li>并不是，会挤占其它内存空间</li>
<li>不会</li>
<li>有可能存在不安全问题</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number116.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number117.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number118.jpg" alt></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>一个进程就对应一个JVM实例，一个JVM实例就有一个运行时数据区，一个运行时<br>数据区就有一个堆，一个进程的多个线程要共享一个堆空间 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number120.jpg" alt><br>Java堆即可实现成固定大小也可使是可扩展的，目前主流的虚拟机都是可以扩展<br>的，HotSpot虚拟机的栈容量是不可扩展的，通过参数-Xms -Xmx 动态扩展堆空间<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number121.jpg" alt><br>VisualVM是功能最强大的运行监视和故障处理程序之一<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number122.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number123.jpg" alt><br>Visual GC 插件可以在工具中下载，可能要多次重试下载<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number124.jpg" alt> 12m+8+1m+7m=20m <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number125.jpg" alt> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; <span class="comment">//Main2代码跟Main一样，不过一个堆空间是10M一个是20M</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number126.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number197.jpg" alt></p>
<h4 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h4><p>设置堆空间的大小时实际只包括新生代和老年代，并不包括元空间<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number127.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number198.jpg" alt> <a href="number128.jpg"></a><br>-XX:PrintGCDetails 打印垃圾回收的细节 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number199.jpg" alt></p>
<h4 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h4><p>开发中建议将初始堆内存和最大堆内存设置一样大，否则GC之后会重新调整堆大小<br>给系统造成额外压力<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number129.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number200.jpg" alt><br>默认情况下实际可用的空间不足8G <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number201.jpg" alt><br>jstat -gc 监视Java堆运行情况 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number202.jpg" alt></p>
<h4 id="OutOfMemory"><a href="#OutOfMemory" class="headerlink" title="OutOfMemory"></a>OutOfMemory</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number130.jpg" alt></p>
<h4 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number131.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number132.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number133.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number134.jpg" alt><br>-XX:NewRatio=1 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number203.jpg" alt><br>jinfo的作用是实时查看和调整虚拟机各项参数 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number204.jpg" alt></p>
<h4 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number135.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number136.jpg" alt><br>红色的部分已经是垃圾，绿色的部分还要使用放到幸存者区 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number137.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number138.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number139.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number140.jpg" alt></p>
<h4 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h4><p>每次垃圾回收必须保证Eden区清空如果幸存者区放不下就放到老年区，YGC时<br>幸存者区也会进行垃圾回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number141.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number205.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number206.jpg" alt></p>
<h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number142.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number143.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number144.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number145.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number146.jpg" alt></p>
<h4 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number147.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number148.jpg" alt></p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number149.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number150.jpg" alt></p>
<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number151.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number152.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number153.jpg" alt><br>默认开启 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number207.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number154.jpg" alt></p>
<h4 id="堆空间的参数设置小结"><a href="#堆空间的参数设置小结" class="headerlink" title="堆空间的参数设置小结"></a>堆空间的参数设置小结</h4><ul>
<li>-XX:SurvivorRatio 设置新生代中Eden和s0/s1的占比，如果Eden过大那么<br>对象会更可能存放到老年代，使Minor GC失去意义，如果Eden过小那么<br>Minor GC的频率就会变高，会影响用户进程<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number155.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number156.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number157.jpg" alt></li>
</ul>
<h3 id="通过逃逸分析看堆空间的对象分配策略"><a href="#通过逃逸分析看堆空间的对象分配策略" class="headerlink" title="通过逃逸分析看堆空间的对象分配策略"></a>通过逃逸分析看堆空间的对象分配策略</h3><p>快速判断是否发生逃逸分析就看new的对象实体是否有可能在方法外调用，如果对<br>象声明是static仍然会发生逃逸 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number158.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number159.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number160.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number161.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number162.jpg" alt><br>总结就是在开发中应该多使用局部变量少在方法外定义 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number163.jpg" alt></p>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number164.jpg" alt></p>
<h4 id="代码优化之栈上分配"><a href="#代码优化之栈上分配" class="headerlink" title="代码优化之栈上分配"></a>代码优化之栈上分配</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number165.jpg" alt></p>
<h4 id="代码优化之同步省略"><a href="#代码优化之同步省略" class="headerlink" title="代码优化之同步省略"></a>代码优化之同步省略</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number166.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number167.jpg" alt></p>
<h4 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number168.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number169.jpg" alt></p>
<h4 id="堆的小结"><a href="#堆的小结" class="headerlink" title="堆的小结"></a>堆的小结</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number170.jpg" alt><br>所以之前讲解的栈上分配实际上用的是标量替换，对象依然是在堆中<br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number171.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number172.jpg" alt></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h3 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number173.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number174.jpg" alt></p>
<h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number175.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number176.jpg" alt><br>实际加载的类数量远多于直接能识别的类 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number209.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number208.jpg" alt></p>
<h3 id="Hotspot中方法区的演进"><a href="#Hotspot中方法区的演进" class="headerlink" title="Hotspot中方法区的演进"></a>Hotspot中方法区的演进</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number177.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number178.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number179.jpg" alt></p>
<h3 id="设置方法区大小和OOM"><a href="#设置方法区大小和OOM" class="headerlink" title="设置方法区大小和OOM"></a>设置方法区大小和OOM</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number180.jpg" alt> -XX:MetaspaceSize=100m <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number181.jpg" alt></p>
<h3 id="Metaspace举例"><a href="#Metaspace举例" class="headerlink" title="Metaspace举例"></a>Metaspace举例</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number210.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number182.jpg" alt></p>
<h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number183.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number184.jpg" alt></p>
<h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number185.jpg" alt></p>
<h4 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number186.jpg" alt></p>
<h4 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number187.jpg" alt></p>
<h4 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number188.jpg" alt></p>
<h4 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h4><p>static+final 每个全局常量在编译的时候就被分配了</p>
<h4 id="class文件中的常量池"><a href="#class文件中的常量池" class="headerlink" title="class文件中的常量池"></a>class文件中的常量池</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number189.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number190.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number191.jpg" alt><br><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number192.jpg" alt><br>常量池就可以看做是一张表，虚拟机指令根据这张表找到要执行的类名、方法<br>名、参数类型、字面量类型</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number193.jpg" alt></p>
<h3 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h3><ol>
<li>jdk1.6以前 有永久代，静态变量存放在永久代上</li>
<li>jdk1.7 有永久代但是逐步去永久代，字符串常量池、静态变量移除保留在堆中</li>
<li>jdk1.8及以后 无永久代，类型信息、字段、方法、常量保存在本地内存的元<br>空间中，当字符串常量池、静态变量仍在堆中 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number211.jpg" alt></li>
<li>为永久代设置空间大小是很难确定的，在某些场景下如果动态加载类过多<br>容易产生Perm区的OOM，比如某个实际的web工程中因为功能比较多在运<br>行过程中要不断加载很多类，元空间使用本地内存受本地内存大小的影响动态改变</li>
</ol>
<h4 id="StringTable的调整"><a href="#StringTable的调整" class="headerlink" title="StringTable的调整"></a>StringTable的调整</h4><p>jdk7中将StringTable放到了堆空间中，因为永久代的回收效率很低，在full gc<br>的时候才会触发，而full gc是老年代的空间不足、永久代空间不足时才触发，开发<br>中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆中能够及<br>时回收</p>
<h4 id="静态变量的存储位置"><a href="#静态变量的存储位置" class="headerlink" title="静态变量的存储位置"></a>静态变量的存储位置</h4><p>静态引用对应的对象实体始终存放在堆空间，与jdk版本无关，jdk7以后静态变量<br>本身也是放在堆空间中的</p>
<h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>Java虚拟机规范中并没有强制要求对方法区进行垃圾回收，方法区的垃圾回收主要<br>是常量池中废弃的常量和不再使用的类型。方法区常量池中主要存放的两大常量是<br>字面量和符号引用，字面量比较接近Java语言层次的常量概念，如文本字符串，<br>被声明为final的常量值等。符号引用则属于编译原理方面的概念，包括以下三类</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符<br>只要常量池中的常量没有被任何地方引用就可以被回收 <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number212.jpg" alt></li>
</ul>
<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number111.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number112.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native和abstract不可以共存，native方法是有方法体的</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass(); <span class="comment">//Object</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number113.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number114.jpg" alt> <img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number115.jpg" alt></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java是虚拟机规范中定<br>义的内存区域，但是这部分内存也频繁使用甚至出现OOM，JDK1.4加入了NIO类，<br>引入了一种基于通道与缓冲区的IO方式，使用Native函数库直接分配堆外内存，<br>然后通过堆中的DirectByteBuffer对象作为这块内存的引用进行操作</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><p><img src="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/number213.jpg" alt></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/05/06/%E6%B7%B1%E5%85%A5JVM/">https://skysea-gaoming.github.io/2020/05/06/%E6%B7%B1%E5%85%A5JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/15/IDEA/"><i class="fa fa-chevron-left">  </i><span>IDEA</span></a></div><div class="next-post pull-right"><a href="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>Java基础知识</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/05/06/%E6%B7%B1%E5%85%A5JVM/';
  this.page.identifier = '2020/05/06/深入JVM/';
  this.page.title = '深入JVM';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591954918112&amp;di=2bc6f4358ea0e880687f5ced03157daf&amp;imgtype=0&amp;src=http%3A%2F%2Fyouimg1.c-ctrip.com%2Ftarget%2Ftg%2F620%2F406%2F859%2Fe7db3299a728401eb7b42effae33dadb.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>