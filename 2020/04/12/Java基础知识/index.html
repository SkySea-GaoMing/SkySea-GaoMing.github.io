<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java基础知识"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java基础知识 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考《疯狂Java讲义》"><span class="toc-number">1.</span> <span class="toc-text">参考《疯狂Java讲义》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java语言概述与开发环境"><span class="toc-number">2.</span> <span class="toc-text">Java语言概述与开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java程序运行机制"><span class="toc-number">2.1.</span> <span class="toc-text">Java程序运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java版本"><span class="toc-number">2.2.</span> <span class="toc-text">Java版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第一个Java程序"><span class="toc-number">2.3.</span> <span class="toc-text">第一个Java程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java源文件命名规则"><span class="toc-number">2.3.1.</span> <span class="toc-text">Java源文件命名规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-number">3.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java面向对象特征"><span class="toc-number">3.1.</span> <span class="toc-text">Java面向对象特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类和对象"><span class="toc-number">3.1.1.</span> <span class="toc-text">类和对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型和运算符"><span class="toc-number">3.2.</span> <span class="toc-text">数据类型和运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文档注释"><span class="toc-number">3.2.1.</span> <span class="toc-text">文档注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标识符与关键字"><span class="toc-number">3.2.2.</span> <span class="toc-text">标识符与关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据类型分类"><span class="toc-number">3.2.3.</span> <span class="toc-text">数据类型分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本数据类型"><span class="toc-number">3.2.4.</span> <span class="toc-text">基本数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型转换"><span class="toc-number">3.3.</span> <span class="toc-text">基本类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自动类型转换"><span class="toc-number">3.3.1.</span> <span class="toc-text">自动类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#强制类型转换"><span class="toc-number">3.3.2.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#验证字符串"><span class="toc-number">3.3.3.</span> <span class="toc-text">验证字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表达式类型的自动提升"><span class="toc-number">3.3.4.</span> <span class="toc-text">表达式类型的自动提升</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流程控制与数组"><span class="toc-number">4.</span> <span class="toc-text">流程控制与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">4.1.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义数组"><span class="toc-number">4.2.</span> <span class="toc-text">定义数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的初始化"><span class="toc-number">4.2.1.</span> <span class="toc-text">数组的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#foreach循环"><span class="toc-number">4.2.2.</span> <span class="toc-text">foreach循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java8增强工具类Arrays"><span class="toc-number">4.2.3.</span> <span class="toc-text">Java8增强工具类Arrays</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-number">5.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类和对象-1"><span class="toc-number">5.1.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造器"><span class="toc-number">5.1.1.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的this引用"><span class="toc-number">5.1.2.</span> <span class="toc-text">对象的this引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法详解"><span class="toc-number">5.2.</span> <span class="toc-text">方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法的参数传递机制"><span class="toc-number">5.2.1.</span> <span class="toc-text">方法的参数传递机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#形参个数可变的方法"><span class="toc-number">5.2.2.</span> <span class="toc-text">形参个数可变的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法重载"><span class="toc-number">5.2.3.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#成员变量和局部变量"><span class="toc-number">5.2.4.</span> <span class="toc-text">成员变量和局部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐藏和封装"><span class="toc-number">5.3.</span> <span class="toc-text">隐藏和封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用访问修饰符"><span class="toc-number">5.3.1.</span> <span class="toc-text">使用访问修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Package"><span class="toc-number">5.3.2.</span> <span class="toc-text">Package</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#import"><span class="toc-number">5.3.3.</span> <span class="toc-text">import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java常用包"><span class="toc-number">5.3.4.</span> <span class="toc-text">Java常用包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的继承"><span class="toc-number">5.4.</span> <span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重写父类的方法"><span class="toc-number">5.4.1.</span> <span class="toc-text">重写父类的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super限定"><span class="toc-number">5.4.2.</span> <span class="toc-text">super限定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">5.5.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用变量的强制类型转换"><span class="toc-number">5.5.1.</span> <span class="toc-text">引用变量的强制类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof运算符"><span class="toc-number">5.5.2.</span> <span class="toc-text">instanceof运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化块"><span class="toc-number">5.5.3.</span> <span class="toc-text">初始化块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态初始化块"><span class="toc-number">5.5.4.</span> <span class="toc-text">静态初始化块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继续面向对象"><span class="toc-number">6.</span> <span class="toc-text">继续面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8增强的包装类"><span class="toc-number">6.1.</span> <span class="toc-text">Java8增强的包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Integer剖析"><span class="toc-number">6.1.1.</span> <span class="toc-text">Integer剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理对象"><span class="toc-number">6.2.</span> <span class="toc-text">处理对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-NaN"><span class="toc-number">6.2.1.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#和equals"><span class="toc-number">6.2.2.</span> <span class="toc-text">&#x3D;&#x3D;和equals</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类成员"><span class="toc-number">6.3.</span> <span class="toc-text">类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单例类"><span class="toc-number">6.3.1.</span> <span class="toc-text">单例类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final修饰符"><span class="toc-number">6.3.2.</span> <span class="toc-text">final修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#宏变量"><span class="toc-number">6.3.3.</span> <span class="toc-text">宏变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final方法"><span class="toc-number">6.3.4.</span> <span class="toc-text">final方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final类"><span class="toc-number">6.3.5.</span> <span class="toc-text">final类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不可变类"><span class="toc-number">6.3.6.</span> <span class="toc-text">不可变类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">6.4.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象方法和抽象类"><span class="toc-number">6.4.1.</span> <span class="toc-text">抽象方法和抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板模式"><span class="toc-number">6.4.2.</span> <span class="toc-text">模板模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">6.5.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#接口的继承"><span class="toc-number">6.5.1.</span> <span class="toc-text">接口的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用接口"><span class="toc-number">6.5.2.</span> <span class="toc-text">使用接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-number">6.6.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单工厂模式"><span class="toc-number">6.6.1.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令模式"><span class="toc-number">6.6.2.</span> <span class="toc-text">命令模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">6.7.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名内部类"><span class="toc-number">6.7.1.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非静态内部类"><span class="toc-number">6.7.2.</span> <span class="toc-text">非静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态内部类"><span class="toc-number">6.7.3.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用内部类"><span class="toc-number">6.7.4.</span> <span class="toc-text">使用内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda表达式"><span class="toc-number">6.8.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数式接口"><span class="toc-number">6.8.1.</span> <span class="toc-text">函数式接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java基础类库"><span class="toc-number">7.</span> <span class="toc-text">Java基础类库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运行Java程序的参数"><span class="toc-number">7.1.</span> <span class="toc-text">运行Java程序的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Scanner获取键盘输入"><span class="toc-number">7.2.</span> <span class="toc-text">使用Scanner获取键盘输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统相关"><span class="toc-number">7.3.</span> <span class="toc-text">系统相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#System类"><span class="toc-number">7.3.1.</span> <span class="toc-text">System类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime类"><span class="toc-number">7.3.2.</span> <span class="toc-text">Runtime类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用类"><span class="toc-number">7.4.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object类"><span class="toc-number">7.4.1.</span> <span class="toc-text">Object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clone"><span class="toc-number">7.4.2.</span> <span class="toc-text">clone</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String、StringBuffer、StringBuilder"><span class="toc-number">7.5.</span> <span class="toc-text">String、StringBuffer、StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">7.5.1.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">7.6.</span> <span class="toc-text">Math</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#入门"><span class="toc-number">8.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用泛型"><span class="toc-number">8.2.</span> <span class="toc-text">使用泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java9增强的菱形语法"><span class="toc-number">8.3.</span> <span class="toc-text">Java9增强的菱形语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深入泛型"><span class="toc-number">8.4.</span> <span class="toc-text">深入泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从泛型类派生子类"><span class="toc-number">8.5.</span> <span class="toc-text">从泛型类派生子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并不存在泛型类"><span class="toc-number">8.6.</span> <span class="toc-text">并不存在泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型通配符"><span class="toc-number">8.7.</span> <span class="toc-text">类型通配符</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582898893694&amp;di=15958b0625c3bcbdd505353b8b5deaa4&amp;imgtype=0&amp;src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F068c0cbf1b1571976ada2e55a53b3a079e1614c5.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">30</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1599140437492&amp;di=195fa5a4bc93905108d4f72b9167b0c0&amp;imgtype=0&amp;src=http%3A%2F%2Fphoto.tuchong.com%2F443730%2Ff%2F14505255.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/04/12/Java基础知识/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考《疯狂Java讲义》"><a href="#参考《疯狂Java讲义》" class="headerlink" title="参考《疯狂Java讲义》"></a>参考《疯狂Java讲义》</h2><p>这本书作为刚入门其实很不错</p>
<h2 id="Java语言概述与开发环境"><a href="#Java语言概述与开发环境" class="headerlink" title="Java语言概述与开发环境"></a>Java语言概述与开发环境</h2><h3 id="Java程序运行机制"><a href="#Java程序运行机制" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h3><p>Java是半编译半解释型语言，因为Java虚拟机既有解释器也有JIT即时编译器，<br>JIT即时编译器能够捕获程序中的热点代码，编译成机器码缓存起来存入方法区<br>中，当遇到相同的代码时，不必再去使用解释器翻译，直接去找对应的机器码执<br>行。</p>
<ul>
<li>编译型语言 指使用专门的编译器，针对特定平台（操作系统）将某种高级<br>语言源代码一次性”翻译”成可被该平台硬件执行的机器码（包括机器指令和<br>操作数），并包装成该平台所能识别的可执行性程序的格式，这个转换过程<br>称为编译（Compile）编译生成的可执行性程序可以脱离开发环境，在特定<br>的平台上独运行 C C++ Objective-C Swift kotlin</li>
<li>解释型语言 先编译成一种与平台无关的字节码文件，然后由解释器翻译<br>成特定机器码执行</li>
</ul>
<h3 id="Java版本"><a href="#Java版本" class="headerlink" title="Java版本"></a>Java版本</h3><p>Java分为三个版本</p>
<ul>
<li>Java SE Standard Edition(标准版) 包含那些构成Java语言核心的类，数据<br>库连接、接口定义、输入/输出、网络编程</li>
<li>Java EE Enterprise Edition(企业版) 包含Java SE 中的类，并且还包含用<br>于开发企业级应用的类，例如EJB、servlet、JSP、XML、事务控制</li>
<li>Java ME Micro Edition(微缩版) 包含Java SE中一部分类，用于消费类电子<br>产品的软件开发，例如呼机、智能卡、手机、PDA、机顶盒</li>
</ul>
<h3 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h3><p>保存为HelloWorld.java文件，表明这是一个Java源程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java严格区分大小写</span></span><br><span class="line"><span class="comment">//Java是一种严格面向对象的语言，所有的程序代码都要放在类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java源文件命名规则"><a href="#Java源文件命名规则" class="headerlink" title="Java源文件命名规则"></a>Java源文件命名规则</h4><ol>
<li>扩展名必须是 .java</li>
<li>在通常情况Java程序源文件的主文件名可以任意，但是如果程序中定义了一<br>个public类，主文件名必须与poblic类名相同</li>
<li>一个Java源文件最多定义一个public类</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>Java 完全支持面向对象的三种基本特征:继承、封装和多态。Java语言完全以<br>对象为中心，Java程序的最小程序单位是类，整个Java程序是由一个个类组成</p>
<ul>
<li>封装 将对象的实现细节隐藏起来，通过一些公用方法暴露对象的功能</li>
<li>继承 子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和方法</li>
<li>多态 子类对象可以直接赋给父类对象，但运行时表现为子类的行为特征，也<br>是说同一个类型的对象执行同一个方法，表现不同行为特征</li>
</ul>
<h3 id="Java面向对象特征"><a href="#Java面向对象特征" class="headerlink" title="Java面向对象特征"></a>Java面向对象特征</h3><p>Java语言中除了8中基本类型其余一切都是对象，每个对象都用唯一的标识来<br>引用，如果某个对象失去了引用就会被垃圾回收，Java语言不允许直接访问<br>对象，而是通过对象的引用来操作对象</p>
<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p>具有相同或相似性质的一组对象的抽象就是类，类是对一类事物的描述，对象是<br>实际存在的该类事物的个体，也叫实例。用class定义类，用new创建类的对象</p>
<h3 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h3><p>Java是一门强类型语言，强类型包括两个方面</p>
<ul>
<li>所有的变量必须先声明、后使用</li>
<li>指定类型的变量只能接受类型与之匹配的值，强类型语言可以在编译过程中<br>发现源代码的错误 ，从而保证程序更加健壮</li>
</ul>
<h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><p>API，英文全称Application Programming Interface，翻译为“应用程序编<br>程接口”。是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件<br>或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的<br>细节。对于Java语言而言，API文档通常详细说明了每个类、每个方法的功能和<br>用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Description</span></span><br><span class="line"><span class="comment"> <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> <span class="doctag">@version</span></span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h4><ol>
<li>; Java语句必须以 ； 结尾，Java程序允许一行书写多个语句，一个语句<br>也可以跨多行，但是字符串、变量名不能跨越多行</li>
<li>标识符就是用于给程序中变量、类、方法命名的符号。Java语言的标识符必<br>须以字母、下画线(_)、美元符($)开头，后面可以跟任意数目字母、数字、下<br>画线_和美元符($) 此处的宇母并不局限于26个英文字母，甚至可以包含中<br>文字符、日文字符等</li>
<li>关键字 Java语言中有一些具有特殊用途的单词被称为关键字，当定义标识<br>符时，不要让标识符和关键字相同，否则将引起错误 <img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpg" alt></li>
</ol>
<h4 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h4><p>Java语言支持的类型分为两类:基本类型（Primitive Type）和引用类型<br>（Reference Type）,基本类型包括 boolean 类型和数值类型。数值类<br>型有整数类型和浮点类型。整数类型包括 byte short int long char ,<br>浮点类型包括 float double</p>
<ul>
<li>引用类型 包括类、接口和数组类型，还有一种特殊的 null 类型所谓引<br>用数据类型就是对一个对象的引用，对象包括实例和数组两种。实际上<br>引用类型变量就是一个指针，只是Java语言里不再使用指针这个说法</li>
<li>空引用（null）只能被转换成引用类型 不能转换成基本类型，因此不要把<br>一个null值赋给基本数据类型的变量</li>
</ul>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>int 是最常用的整数类型，因为在通常情况下，直接给出一个整数值默认就是<br>int类型。除此之外，有如下两种情形必须指出</p>
<ul>
<li>如果直接将一个较小的整数值(在 byte short 类型的表数范围内〉赋给byte<br>short变量系统会自动把这个整数值当成byte或者short类型来处理</li>
<li>如果使用一个巨大的整数值(超出了int类型的表数范围)时Java不会自动把<br>这个整数值当成long 类型来处理。如果希望系统把一个整数值当成long类型<br>来处理，应在这个整数值后增加或者l作为后缀。通常推荐使用L<br><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.jpg" alt> <img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.jpg" alt> <img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/15.jpg" alt></li>
</ul>
<p>Java语言的默认浮点类型是double类型，double占8个字节，float占4个字节<br>如果希望将一个浮点数当成float，在浮点数值后加f或F，浮点数必须要有小数<br>点</p>
<h3 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h3><p>有两种类型转换方式，自动类型转换和强制类型转换</p>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>表数范围小的可以向表数范围大的自动转换 <img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/16.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="comment">// int 类型可以自动转换为 float 类型</span></span><br><span class="line"><span class="keyword">float</span> f = a ; </span><br><span class="line"><span class="comment">// 下面将输出 6.0</span></span><br><span class="line">System.out.println(f); </span><br><span class="line"><span class="comment">// 定义 byte 类型的整数变量</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">9</span> ; </span><br><span class="line"><span class="comment">// 下面代码将出错，byte 类型不能自动类型转换为 char 类型</span></span><br><span class="line"><span class="comment">// char c = b; </span></span><br><span class="line"><span class="comment">// byte 类型变量可以自动类型转换为 double 类型</span></span><br><span class="line"><span class="keyword">double</span> d = b ; </span><br><span class="line"><span class="comment">// 下面将输出 9.0</span></span><br><span class="line"><span class="function">System out <span class="title">printl</span> <span class="params">(d)</span> </span>;</span><br></pre></td></tr></table></figure>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>浮点数强制转换为整数时会截断浮点数的小数部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iValue = <span class="number">233</span>; </span><br><span class="line"><span class="comment">// 强制把一个 int 类型的值转换为 byte 类型 的值</span></span><br><span class="line"><span class="keyword">byte</span> bValue = (<span class="keyword">byte</span>)iValue; </span><br><span class="line"><span class="comment">// 将输出 -23</span></span><br><span class="line">System.out.println(bValue) ; </span><br><span class="line"><span class="keyword">double</span> dValue = <span class="number">3.98</span> ; </span><br><span class="line"><span class="comment">// 强制把 double 类型的值转换为 int 类型的值</span></span><br><span class="line"><span class="keyword">int</span> tol = (<span class="keyword">int</span>)dValue</span><br><span class="line"><span class="comment">// 将输出3</span></span><br><span class="line">System.out.println(tol);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/17.jpg" alt></p>
<h4 id="验证字符串"><a href="#验证字符串" class="headerlink" title="验证字符串"></a>验证字符串</h4><p>登录页面经常会有验证字符串，那么这些字符串是如何生成的呢。<br>首先可以随机生成一个指定范围的int数字，例如生成一个小写字母就是在97~<br>122之间，然后强制转换为char类型，将这些字符拼接起来就是一个验证字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个空字符串</span></span><br><span class="line">String resu1t = <span class="string">""</span>; </span><br><span class="line"><span class="comment">//进行6次循</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i ++) </span><br><span class="line"><span class="comment">//生成一个 97-122 间的 int 类型整数</span></span><br><span class="line"><span class="keyword">int</span> intVa1 = (<span class="keyword">int</span>) (Math.random() * <span class="number">26</span> + <span class="number">97</span>); </span><br><span class="line"><span class="comment">//将 intVa  强制转换为 char 类型后连接到 resu1t 后面</span></span><br><span class="line">result = result + (<span class="keyword">char</span>)intVal; </span><br><span class="line"><span class="comment">//输出随机字符串</span></span><br><span class="line">System.out.print1n(resu1t);</span><br></pre></td></tr></table></figure>
<h4 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h4><ol>
<li>所有的 byte 类型、 short 类型和 char 类型将被提升到 int 类型</li>
<li>整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> val=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//2是int类型，右边是int不能直接转换为short</span></span><br><span class="line">val=val-<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="流程控制与数组"><a href="#流程控制与数组" class="headerlink" title="流程控制与数组"></a>流程控制与数组</h2><p>break可以跳出一个循环，结束循环体，continue只是结束本次循环剩下的语句，<br>接着下一次循环，return 用于结束一个方法，不管return 处于多少个循环中</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>控制表达式的数据类型只能是short byte char int 四种类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expresson)</span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">case</span> conditionl: </span><br><span class="line">		statement(s) </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> condition2 : </span><br><span class="line">		statement(s) </span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">	<span class="keyword">case</span> conditionN : </span><br><span class="line">		statement(s) </span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">	<span class="keyword">default</span> : </span><br><span class="line">		statement(s)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><p>type[] array 此时还不能指定长度，引用变量还未指向有效的内存空间</p>
<h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><ul>
<li>静态初始化 初始化时由程序员显式指定每个数组元素的初始值，由系统决定<br>数组长度，可以简写为 array=[el1,el2…] <img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.jpg" alt></li>
<li>动态初始化 初始化时程序员只指定数组长度，由系统为数组元素分配初始值<br>int[] array=new int[5]</li>
</ul>
<h4 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h4><p>Java5之后提供了一种比for更简洁的循环，这种循环遍历数组和集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type variablename:array|collection)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//自动迭代访问每个元素，实际访问的是临时变量而不是数组变量本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java8增强工具类Arrays"><a href="#Java8增强工具类Arrays" class="headerlink" title="Java8增强工具类Arrays"></a>Java8增强工具类Arrays</h4><p>Arrays类里包含的static方法可以直接操作数组</p>
<ol>
<li>int binarySearch(type[] a,type key)<br>使用二分法查询key元素值在a数组中出现的索引，如果a数组不包含key元素<br>值则返回负数，调用该方法时要求数组中元素己经按升序排列这样才能得到<br>正确结果 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		当数组的长度小于8192时不会执行并行排序算法，因为</span></span><br><span class="line"><span class="comment">		数组太小并行排序效果不好</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_ARRAY_SORT_GRAN = <span class="number">8192</span>;</span><br><span class="line">	<span class="comment">//如果数组长度小于7那么就进行插入排序</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSERTIONSORT_THRESHOLD = <span class="number">7</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Arrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch0((<span class="keyword">int</span>[])a, <span class="number">0</span>, a.length, (<span class="keyword">int</span>)key);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex</span></span></span><br><span class="line"><span class="function"><span class="params">	, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">        <span class="keyword">int</span> high = toIndex - <span class="number">1</span>; <span class="comment">//不包括toIndex</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + high &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//相当于 (low+high)/2</span></span><br><span class="line">            <span class="keyword">int</span> midVal = a[mid];</span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; key) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (midVal &lt;= key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意如果查找失败返回的负数并不是任意的</span></span><br><span class="line">        <span class="keyword">return</span> -(low + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>int binarySearch(type[] a,int fromIndex,int tolndex,type key)<br>这个方法与前一个方法类似，但它只搜索a数组中fromIndex到tolndex索引<br>的元素。调用该方法时要求数组中元素己经按升序排列，这样才能得到正确<br>结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="comment">//从源码可以知道不包括toIndex索引</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch0(a, fromIndex, toIndex, key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>type[] copyOf(type[] original, int length)<br>这个方法将会把original数组复制成一个新数组，length是新数组的长度<br>如果length小于original数组的长度，则新数组就是原数组的前面length<br>个元素，如果length大于original数组的长度，则新数组的前面元素就是原<br>数组的所有元素，后面补充 0 、false 、null<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是我们自定义类的数组的复制方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, </span><br><span class="line">	Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        T[] copy = newType == Object[]<span class="class">.<span class="keyword">class</span> ? </span></span><br><span class="line">        new Object[newLength] : (Object[])Array.newInstance(</span><br><span class="line">        	newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(</span><br><span class="line">        	original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可以先看这个方法比较好理解核心原理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">        <span class="comment">//对应了之前的解释，先将较小的长度进行复制，其余补默认值</span></span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(</span><br><span class="line">        	original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy; <span class="comment">//可知返回的一定是一个新数组</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这是一个本地方法，非Java代码实现，复制数组方法的底层都用到了这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object var0, <span class="keyword">int</span> var1, </span></span></span><br><span class="line"><span class="function"><span class="params">	Object var2, <span class="keyword">int</span> var3, <span class="keyword">int</span> var4)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>type[] copyOfRange(type[] original, int from, int to)<br>但这个方法只复制original数组的from索引到to索引的元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOfRange(<span class="keyword">int</span>[] original, <span class="keyword">int</span> from, <span class="keyword">int</span> to) &#123;</span><br><span class="line">        <span class="keyword">int</span> newLength = to - from;</span><br><span class="line">        <span class="keyword">if</span> (newLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(from + <span class="string">" &gt; "</span> + to);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">            System.arraycopy(original, from, copy, <span class="number">0</span>, </span><br><span class="line">            	Math.min(original.length - from, newLength));</span><br><span class="line">            <span class="keyword">return</span> copy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>boolean equals(type[] a,type[] a2)<br>如果a数组和a2数组的长度相等，而且a数组和a2数组的数组元素也一一相<br>同，该方法将返回true<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == a2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; a2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = a.length;</span><br><span class="line">            <span class="keyword">if</span> (a2.length != length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ArraysSupport.mismatch(a, a2, length) &lt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mismatch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这一步是什么操作目前没看懂</span></span><br><span class="line">            i = vectorizedMismatch(a, </span><br><span class="line">            	(<span class="keyword">long</span>)Unsafe.ARRAY_INT_BASE_OFFSET, </span><br><span class="line">            	b, (<span class="keyword">long</span>)Unsafe.ARRAY_INT_BASE_OFFSET, </span><br><span class="line">            	length, LOG2_ARRAY_INT_INDEX_SCALE);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            i = length - ~i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>void fill(type[] a,type val)<br>该方法将会把a数组的所有元素都赋值为val<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = a.length; i &lt; len; ++i) &#123;</span><br><span class="line">            a[i] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>void fill(type[] a, int fromIndex int tolndex, type val)<br>该方法与前一个方法的作用相同，区别只是该方法仅仅将a数组的从<br>fromlndex到tolndex索引的数组元素赋值为val<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//这一步是检验索引值的正确性</span></span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = fromIndex; i &lt; toIndex; ++i) &#123;</span><br><span class="line">            a[i] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> arrayLength, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"fromIndex("</span> + </span><br><span class="line">            	fromIndex + <span class="string">") &gt; toIndex("</span> + toIndex + <span class="string">")"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(fromIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toIndex &gt; arrayLength) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(toIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>void sort(type[] a)<br>该方法对a数组的数组元素进行排序，具体内部使用哪种排序算法具体分析<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, (<span class="keyword">int</span>[])<span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase</span></span></span><br><span class="line"><span class="function"><span class="params">	, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt; <span class="number">286</span>) &#123;</span><br><span class="line">            sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">68</span>];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            run[<span class="number">0</span>] = left;</span><br><span class="line">            <span class="keyword">int</span> lo;</span><br><span class="line">            <span class="keyword">int</span> ao;</span><br><span class="line">            <span class="keyword">int</span> bo;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; right &amp;&amp; a[k] == a[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (k == right) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                    &#125; <span class="keyword">while</span>(k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        ++k;</span><br><span class="line">                    &#125; <span class="keyword">while</span>(k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">                    lo = run[count] - <span class="number">1</span>;</span><br><span class="line">                    ao = k;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                        ++lo;</span><br><span class="line">                        --ao;</span><br><span class="line">                        <span class="keyword">if</span> (lo &gt;= ao) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bo = a[lo];</span><br><span class="line">                        a[lo] = a[ao];</span><br><span class="line">                        a[ao] = bo;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - <span class="number">1</span>]) &#123;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">67</span>) &#123;</span><br><span class="line">                    sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count != <span class="number">1</span> || run[count] &lt;= right) &#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                    <span class="keyword">if</span> (run[count] &lt; right) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                        run[count] = right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span> odd = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(lo = <span class="number">1</span>; (lo &lt;&lt;= <span class="number">1</span>) &lt; count; odd = (<span class="keyword">byte</span>)(odd ^ <span class="number">1</span>)) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> blen = right - left;</span><br><span class="line">                    <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; blen || workBase + blen &gt; </span><br><span class="line">                    	work.length) &#123;</span><br><span class="line">                        work = <span class="keyword">new</span> <span class="keyword">int</span>[blen];</span><br><span class="line">                        workBase = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span>[] b;</span><br><span class="line">                    <span class="keyword">if</span> (odd == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">                        b = a;</span><br><span class="line">                        bo = <span class="number">0</span>;</span><br><span class="line">                        a = work;</span><br><span class="line">                        ao = workBase - left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        b = work;</span><br><span class="line">                        ao = <span class="number">0</span>;</span><br><span class="line">                        bo = workBase - left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> i;</span><br><span class="line">                        <span class="keyword">int</span> lo;</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">0</span> + <span class="number">2</span>; i &lt;= count; i += <span class="number">2</span>) &#123;</span><br><span class="line">                            lo = run[i];</span><br><span class="line">                            <span class="keyword">int</span> mi = run[i - <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">int</span> i = run[i - <span class="number">2</span>];</span><br><span class="line">                            <span class="keyword">int</span> p = i;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> q = mi; i &lt; lo; ++i) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (q &lt; lo &amp;&amp; (p &gt;= mi || </span><br><span class="line">                                	a[p + ao] &gt; a[q + ao])) &#123;</span><br><span class="line">                                    b[i + bo] = a[q++ + ao];</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    b[i + bo] = a[p++ + ao];</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ++last;</span><br><span class="line">                            run[last] = lo;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                            i = right;</span><br><span class="line">                            lo = run[count - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                                --i;</span><br><span class="line">                                <span class="keyword">if</span> (i &lt; lo) &#123;</span><br><span class="line">                                    ++last;</span><br><span class="line">                                    run[last] = right;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                b[i + bo] = a[i + ao];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span>[] t = a;</span><br><span class="line">                        a = b;</span><br><span class="line">                        b = t;</span><br><span class="line">                        lo = ao;</span><br><span class="line">                        ao = bo;</span><br><span class="line">                        bo = lo;</span><br><span class="line">                        count = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>void sort(type[] a, int fromIndex,int toIndex)<br>该方法与前一个方法相似，区别是该方法仅仅对fromlndex到toIndex<br>索引的元素进行排序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, (<span class="keyword">int</span>[])<span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>String toString(type[] a)<br>该方法将一个数组转换成一个字符串。该方法按顺序把多个数组元素连缀在<br>一起，多个数组元素使用英文逗号和空格隔开。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> iMax = a.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (iMax == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                b.append(<span class="string">'['</span>);</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    b.append(a[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i == iMax) &#123;</span><br><span class="line">                        <span class="keyword">return</span> b.append(<span class="string">']'</span>).toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                    b.append(<span class="string">", "</span>);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.jpg" alt></li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类和对象-1"><a href="#类和对象-1" class="headerlink" title="类和对象"></a>类和对象</h3><p>类是一批对象的抽象，对象是一个类的实例。类中有三个最常见的成员：构造器<br>、成员变量和方法，static修饰的成员不能访问没有static修饰的成员</p>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造器是一种特殊的方法，如果一个类没有构造器就无法创建实例，如果不显示<br>创建构造器系统会默认提供一个构造器，否则不提供，通过new来创建构造器返<br>回返回该类的实例</p>
<ol>
<li>构造器的语法格式如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 构造器名(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//可执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>修饰符 可以省略或者是public protected private其中之一</li>
<li>构造器名 必须与类名相同</li>
<li>构造器没有返回值，实际是返回实例对象，无需显示return </li>
</ul>
<ol start="2">
<li>成员变量的语法格式如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类型 成员变量名 [=默认值];</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>修饰符 可以省略，也可以是 public protected private static final，其中<br>public protected private只能出现一个，可以与 static final组合</li>
<li>类型 任意类型，包括基本类型和引用类型</li>
</ul>
<ol start="3">
<li>方法的语法格式如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法返回值类型 方法名(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//可执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>修饰符 可以省略，也可以是public protected private static final abstract<br>public protected private只能出现一个，final和abstract只能出现一个，<br>可以与static组合</li>
<li>返回值类型 可以是任意类型，包括基本类型和引用类型，也可以是void</li>
</ul>
<ol start="4">
<li>static可以修饰成员变量和方法，表示这个成员属于类本身而不是类的实例，<br>也叫做类变量，不用static修饰的是实例变量和方法</li>
</ol>
<h4 id="对象的this引用"><a href="#对象的this引用" class="headerlink" title="对象的this引用"></a>对象的this引用</h4><p>实例变量和非静态方法必须通过对象来引用。Java提供了一个this关键字，this关<br>键字总是指向调用该方法的对象，在大部分时候，一个方法访问该类中定义的其他<br>方法、成员变量时加不加this前缀的效果是完全一样的。static定义的方法中不能<br>使用this引用，因此Java语法规定静态成员不能访问非静态成员</p>
<h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><p>一旦将一个方法定义在某个类的类体内，如果这个方法使用了static修饰，则这个<br>方法属于这个类，否则这个方法属于这个类的实例</p>
<h4 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h4><p>基本类型和引用类型的参数传递机制都是值传递，引用类型传递的是对象的地址值</p>
<h4 id="形参个数可变的方法"><a href="#形参个数可变的方法" class="headerlink" title="形参个数可变的方法"></a>形参个数可变的方法</h4><p>JDK1.5之后，Java允许定义形参个数可变的参数，从而为方法指定数量不确定的<br>形参。如果在定义方法时，在最后一个形参的类型后增加三点则表明该形参可以接<br>受多个参数值，多个参数值被当成数组传入，个数可变的形参只能位于形参列表<br>的最后，一个方法只能有一个个数可变的形参，本质就是一个数组类型的形参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tt</span><span class="params">(<span class="keyword">int</span> a,String ... books)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(String book:books)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(book);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		test(<span class="number">5</span>,<span class="string">"fsd"</span>,<span class="string">"vaf"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>Java允许一个类里定义多个同名方法，只要方法的形参列表不同就行，至与方法<br>的其它部分比如返回值、修饰符等与方法重载无关，实际上在Java虚拟机内部的<br>判定条件只有参数列表</p>
<h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>成员变量可以不赋初始值就使用，而局部变量必须先赋初始值才能使用 <img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.jpg" alt></p>
<h3 id="隐藏和封装"><a href="#隐藏和封装" class="headerlink" title="隐藏和封装"></a>隐藏和封装</h3><p>封装是面向对象的三大特征之一(另外两个是继承和多态)，它指的是将对象的状<br>态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类<br>所提供的方法来实现对内部信息的操作和访问</p>
<h4 id="使用访问修饰符"><a href="#使用访问修饰符" class="headerlink" title="使用访问修饰符"></a>使用访问修饰符</h4><p><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.jpg" alt></p>
<ol>
<li>private 当前类访问权限：如果类里的一个成员(包括成员变量、方法和<br>构造器等)使用private访问控制符来修饰，则这个成员只能在当前类的内部<br>被访问。很显然，这个访问控制符用于修饰成员变量最合适，使用它来修饰<br>成员变量就可以把成员变量隐藏在该类的内部</li>
<li>default 包访问权限：如果类里的一个成员(包括成员变量、方法和构造<br>器等)或者一个外部类不使用任何访问控制符修饰，就称它是包访问权限的，<br>default访问控制的成员或外部类可以被相同包下的其他类访问</li>
<li>protected 子类访问权限：如果一个成员(包括成员变量、方法和构造器<br>等)使用protected访问控制符修饰，那么这个成员既可以被同一个包中的其<br>他类访问，也可以被不同包中的子类访问。在通常情况下，如果使用<br>protected来修饰一个方法，通常是希望其子类来重写这个方法</li>
<li>public 公共访问权限：这是一个最宽松的访问控制级别，如果一个成员<br>(包括成员变量、方法和构造器等)或者一个外部类使用public访问控制符修<br>饰。那么这个成员或外部类就可以被所有类访问。不管访问类和被访问类是<br>否处于同一个包中，是否具有父子继承关系<br><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.jpg" alt><br>外部类只有两种访问控制级别：public和默认</li>
</ol>
<h4 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h4><p>包就是用来解决类的命名冲突和类文件管理问题，Java允许将一组功能相关的类放<br>在同一package下，从而组成逻辑上的类库单元，如果希望把一个类放在指定的包<br>结构下，应该在Java源程序的第一个非注释行放置如下格式的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> packageName;</span><br></pre></td></tr></table></figure>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>如果要使用同一个包下的另一个类，则该类无需添加包前缀，如果访问另一个包中<br>的类必须添加包前缀</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lee;</span><br><span class="line"><span class="comment">//如果加上这句</span></span><br><span class="line"><span class="keyword">import</span> lee.sub.Test2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Hello a=<span class="keyword">new</span> Hello();</span><br><span class="line">		<span class="comment">//如果没有import必须加包前缀</span></span><br><span class="line">		lee.sub.Test2 test=<span class="keyword">new</span> lee.sub.Test2();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Hello a=<span class="keyword">new</span> Hello();</span><br><span class="line">		<span class="comment">//如果加上import</span></span><br><span class="line">		Test2 test=<span class="keyword">new</span> Test2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了简化编程，Java引入了import关键字，import可以向某个Java文件导入指定<br>包层次下某个类或者全部类，import语句应该出现在package语句之后类定义之前<br>。一个Java源文件只能有一个package语句但是可以有多个import语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">package</span>.subpackage...ClassName;</span><br></pre></td></tr></table></figure>
<p>也可以导入包下的所有类，但是不会导入子包的类。Java默认为所有源文件导入<br>java.lang包下的所有类，因此使用String System时无需导入包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">package</span>.subpackage...*;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.jpg" alt></p>
<h4 id="Java常用包"><a href="#Java常用包" class="headerlink" title="Java常用包"></a>Java常用包</h4><p>Java的核心类都放在java包及其子包下，Java扩展的许多类都放在javax包及其子包下<br><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.jpg" alt></p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>每个子类只有一个直接父类，子类可以获得父类的全部成员变量和方法，但是不能<br>获得父类的构造器。如果定义一个类的时候没有指定这个类的直接父类，这个类默<br>认扩展java.lang.Object类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h4><p>方法的重写遵循“两同两小一大”规则。两同指方法名相同、形参列表相同。两小指子<br>类方法的返回值类型比父类返回值类型更小或相同、子类方法抛出的异常比父类抛<br>出的异常更小或相同。一大指子类方法的访问权限比父类更大或相同并且覆盖方法<br>和被覆盖方法必须都是类方法或者实例方法。子类的对象无法调用父类被重写的方<br>法，只能在子类方法中通过super或类来调用父类方法，如果父类中有一个方法是<br>private访问权限，那么子类就不算是重写没有限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"fly"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"jump"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Ostrich a=<span class="keyword">new</span> Ostrich();</span><br><span class="line">		<span class="comment">//执行的是哪个fly呢</span></span><br><span class="line">		a.fly();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="super限定"><a href="#super限定" class="headerlink" title="super限定"></a>super限定</h4><p>super用于限定该对象调用它从父类继承到的实例变量和方法，创建子类的时候也<br>会为父类的变量分配空间，可以通过super.调用。不管是否使用super调用来执行<br>父类构造器的初始化代码，子类总是会调用父类构造器一次</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Java引用变量有两个类型，一个是编译时类型，另一个是运行时类型，编译时类型<br>由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定，如果<br>编译类型和运行类型不一致就可能出现多态。Java允许把一个子类对象直接赋给一<br>个父类引用变量，当调用引用变量的方法时总是表现子类方法的特征，但是不能调<br>用子类独有的方法。与方法相反，对象的实例变量不具备多态性，只能访问编译时<br>定义的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> book=<span class="number">6</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">base</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类覆盖"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String book=<span class="string">"fsd"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类覆盖"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"sub"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		BaseClass base=<span class="keyword">new</span> BaseClass();</span><br><span class="line">		System.out.println(base.book); <span class="comment">//6</span></span><br><span class="line">		base.base();</span><br><span class="line">		base.test();</span><br><span class="line">		SubClass sub=<span class="keyword">new</span> SubClass();</span><br><span class="line">		System.out.println(sub.book); <span class="comment">//fsd</span></span><br><span class="line">		sub.base();</span><br><span class="line">		sub.test();</span><br><span class="line">		BaseClass bs=<span class="keyword">new</span> SubClass();</span><br><span class="line">		System.out.println(bs.book); <span class="comment">//6</span></span><br><span class="line">		bs.base();</span><br><span class="line">		bs.test(); <span class="comment">//子类覆盖</span></span><br><span class="line">		<span class="comment">// bs.sub(); 不能调用</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过引用变量来访问其包含的实例变量时，系统总是访问编译时类型所定义的成员<br>变量，而不是运行时类型所定义的成员变量</p>
<h4 id="引用变量的强制类型转换"><a href="#引用变量的强制类型转换" class="headerlink" title="引用变量的强制类型转换"></a>引用变量的强制类型转换</h4><p>引用变量只能使用编译是类型的方法，如果要使用运行时类型的方法，需要进行强<br>制类型转换，引用类型之间的转换只能在具有继承关系的两个类之间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type)variable</span><br></pre></td></tr></table></figure>
<h4 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h4><p>instance运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一<br>个类或者接口，用于判断前面的对象是否是后面的类或者其子类需要注意前一个操<br>作数的编译类型要么相同要么与后面的类具有父子继承关系否则编译错误</p>
<h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>初始化块和构造器一样都能够对Java对象进行初始化操作，唯一的修饰符是static。<br>创建对象时先执行初始化块后执行构造器</p>
<h4 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h4><p>使用static修饰并且与类相关。是在类加载过程中执行，而且先会执行父类的静态<br>初始化块，只有所有类都加载到内存中之后这些类才能使用，然后才会按照顺序执<br>行初始化块和构造器</p>
<h2 id="继续面向对象"><a href="#继续面向对象" class="headerlink" title="继续面向对象"></a>继续面向对象</h2><h3 id="Java8增强的包装类"><a href="#Java8增强的包装类" class="headerlink" title="Java8增强的包装类"></a>Java8增强的包装类</h3><p>Java为8中基本数据类型分别定义了相应的引用类型，并称之为基本数据类型的包装类<br><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.jpg" alt><br>JDK提供了自动装箱和自动拆箱功能</p>
<ul>
<li>自动装箱 把一个基本数据类型直接赋给相应的包装类变量</li>
<li>自动拆箱 把一个包装类变量直接赋给一个对于的基本数据类型</li>
</ul>
<p>包装类还可以实现基本类型变量和字符串之间的转换，把字符串类型转换为基本类型有<br>两种方式</p>
<ul>
<li>parseXxx(String s) 静态方法</li>
<li>valueOf(String s) 静态方法</li>
</ul>
<p>对于Integer类型，自动装箱会有一些细节要注意</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">2</span>;</span><br><span class="line">Integer b=<span class="number">2</span>;</span><br><span class="line">Integer c=<span class="number">128</span>;</span><br><span class="line">Integer d=<span class="number">128</span>;</span><br><span class="line">a==b <span class="comment">//true</span></span><br><span class="line">c==d <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="Integer剖析"><a href="#Integer剖析" class="headerlink" title="Integer剖析"></a>Integer剖析</h4><ol>
<li>Integer的声明<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能被继承 继承Number类 实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>Integer的属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//占4个字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_VALUE = -<span class="number">2147483648</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BYTES = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure></li>
<li>valueOf<br>对于自动装箱，本质是调用valueOf方法，当-128&lt;=i&lt;=127的时候返回的<br>是缓存中的对象而不是创建新对象，如果用new Integer这种方式就不会<br>存在缓存操作，所以一般使用valueOf<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">Integer a=Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= Integer.IntegerCache.high ? </span><br><span class="line">        Integer.IntegerCache.cache[i + <span class="number">128</span>] : <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Integer类中有一个内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer[] cache;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue = </span><br><span class="line">            VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    i = Integer.parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    h = Math.min(i, <span class="number">2147483518</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException var4) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[high - -<span class="number">128</span> + <span class="number">1</span>];</span><br><span class="line">            i = -<span class="number">128</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; ++k) &#123;</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(i++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>equals<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//先判断类型是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value == (Integer)obj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>hashCode<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashCode(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>CompareTo<br>Integer实现了Comparable接口所以要实现CompareTo方法，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T var1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部实际调用compare方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y ? -<span class="number">1</span> : (x == y ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="处理对象"><a href="#处理对象" class="headerlink" title="处理对象"></a>处理对象</h3><p>Java对象都是Object类的实例，可以调用该类中定义的方法</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>很多类都重写了这个方法，直接输出一个对象时实际输出toString方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass().getName() + <span class="string">"@"</span> + </span><br><span class="line">        Integer.toHexString(<span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//每个类实例的hashCode值都不一样</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h4><p>对于引用类型必须指向同一个对象地址，很多类根据实际需求重写这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>用static修饰的是类成员，例如类变量、类方法和类初始化块，还包括内部<br>类。类成员不能访问实例成员</p>
<h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>如果一个类始终只能创建一个实例，那么这个类就是单例类。首先应该想到使用<br>private修饰构造器，然后提供一个public方法作为类的访问点，而且该方法<br>必须使用static修饰，因为调用这个方法之前还不存在对象，只能通过类来调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//使用一个类变量来缓存曾经创建的类实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="comment">//使用private修饰构造器防止被调用</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//类的访问点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//先判断是否创建过对象，如果已经创建就返回已经创建的对象</span></span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">			instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h4><p>final可以修饰变量、方法和类，表示修饰的内容不可变，即获取初始值后就<br>不能改变。与普通成员变量不同的是，final修饰的成员变量必须显示初始化，否<br>则不能访问</p>
<ul>
<li>类变量 必须在静态初始化块中指定初始值或声明该类变量时指定初始值</li>
<li>实例变量 必须在非静态初始化块或声明该实例变量或构造器中指定</li>
<li>局部变量 可以在定义时指定也可以在定义之后指定</li>
<li>基本类型变量 不能对基本类型变量重新赋值，也就是不能改变</li>
<li>引用类型变量 final保证这个引用对象的地址不变，但是对象内容可以变化</li>
</ul>
<h4 id="宏变量"><a href="#宏变量" class="headerlink" title="宏变量"></a>宏变量</h4><p>对于一个final变量，不管是类变量、实例变量还是局部变量，只要变量满足三个<br>条件，这个final变量就会变成一个直接量，在编译时就可以确定直接值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//在编译时a已经替换成为5</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/18.jpg" alt></p>
<h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><p>final修饰的方法不能被重写，如果不希望子类重写父类的方法则可以使用final<br>，如果再加上一个private就说明不是方法重写而相当于重新定义一个方法，因<br>为private修饰的方法只能在当前类可见，所以不存在重写pirvate方法</p>
<h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><p>final修饰的类不可以有子类，例如java.lang.Math类就是final类</p>
<h4 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h4><p>创建该类的实例后，该实例的实例变量是不可变的。Java的8个包装类和<br>java.lang.String类都是不可变类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用实例变量来保存这两个值，并且程序无法再修改实例变量的值</span></span><br><span class="line">Integer a=Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">String s=<span class="keyword">new</span> String(<span class="string">"fsd"</span>);</span><br></pre></td></tr></table></figure>
<p>一个不可变类需满足以下条件</p>
<ul>
<li>用private final修饰成员变量</li>
<li>提供带参数的构造器，用于传入参数来初始化类里的成员变量</li>
<li>只提供getter而不提供setter方法</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在某些情况下，如果父类知道子类应该包含什么样的方法，但是不知道子类怎么实<br>现这些方法，比如一个Shape类，如果有一个计算周长的方法cal()但是无法准确<br>描述这个方法的具体情况，Shape类可以不实现这个方法，但是在多态情况下实例<br>就不能够使用这个cal方法，必须强制转换为子类类型，这样不够灵活，提供方法<br>但是不提供具体实现，这就是抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有方法体</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//有方法体但为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h4><p>让Shape包含cal方法但是不提供具体实现，这就是抽象。抽象方法和抽象类必须用<br>abstract修饰，有抽象方法的类只能被定义为抽象类，抽象类里可以没有抽象方法</p>
<ul>
<li>抽象类和抽象方法必须使用abstract修饰，抽象方法不能有方法体</li>
<li>抽象类不能实例化，无法使用new关键字来调用抽象类的构造器，但是可<br>以被子类继承</li>
<li>抽象类可以包含成员变量、方法（普通方法和抽象方法）、构造器、初始化<br>块，内部类等。构造器是由子类调用而不是创建实例</li>
<li>包含抽象方法的类（直接定义一个抽象方法、继承一个抽象类但没有完全<br>实现父类包含的抽象方法、实现一个接口但没有完全实现接口中的方法）只<br>能被定义为抽象类</li>
<li>static和abstract不能修饰一个方法，但是可以修饰一个内部类</li>
<li>final和abstract不能同时使用，private和abstract也不能同时使用</li>
</ul>
<h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>抽象类是从多个具体类中抽象出来的父类，具有更高的抽象层次，抽象类就相当于<br>子类的模板，体现一种模板模式的设计</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口实际上是一种更为特殊的抽象类，只提供实现类需要实现的方法。Java9对接口<br>进行了改进，允许接口定义默认方法和类方法，并且都可以提供具体实现，还增加<br>了私有方法，也可以提供具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口1 , 父接口2 </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	常量</span><br><span class="line">	抽象方法</span><br><span class="line">	内部类</span><br><span class="line">	私有方法、默认方法或类方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修饰符可以是public或者省略，如果省略就是默认包访问权限</li>
<li>一个接口可以有多个父接口，只能继承接口不能继承类</li>
<li>接口中不能有构造器和初始化块</li>
<li>接口里的成员变量只能是静态变量</li>
<li>接口定义的是多个类共同的行为规范，所以接口里的常量、方法、内部类<br>和内部枚举都是public访问权限，定义接口成员时可以省略访问修饰符，<br>如果显示指定只能是public</li>
<li>Java9新增了一种私有方法，这种方法可以拥有方法体，也可以使用static<br>修饰</li>
<li>对于接口中的静态常量，它们是与接口相关的，所以系统会自动加static final<br>修饰，也就是说定义成员变量时会用 public static final 修饰，由于没有<br>构造器和初始化块，所以只能在定义时指定初始值</li>
<li>Java8允许在接口中定义默认方法，但是必须用default修饰，该方法不能用<br>static修饰<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size=<span class="number">50</span>;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size=<span class="number">50</span>;</span><br><span class="line"><span class="comment">//默认方法</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类方法，只能使用public修饰符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//私有静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ttt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接口里的方法只能是抽象方法、默认方法、类方法或私有方法，如果不是默<br>认类或私有方法，系统会自动为普通方法增加abstract修饰符，所以普通方<br>法总是使用 public abstract 修饰，其他方法必须有方法体</li>
<li>接口里的内部类、内部接口和内部枚举默认使用 public static 修饰</li>
</ul>
<h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>一个接口可以有多个直接父接口，可以父接口的所有抽象方法和常量</p>
<h4 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h4><p>接口不能创建实例，但是接口可以声明为引用类型变量，这个引用类型变量必须<br>引用到其实现类的对象，一个类可以实现多个接口，必须实现接口中的所以抽象<br>方法，否则就会定义为抽象类，一个类可以继承父类并实现多个接口，extends<br>必须放在implements之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1 , 接口2</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式就是对经常出现的软件设计问题的成熟解决方案，Java语言本身就包含<br>许多设计模式的思想，之前已经介绍过单例模式</p>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式就是最大限度解耦合，当代码重构时能够最小限度修改代码，比如<br>有个类Computer需要组合一个输出设备，如果直接组合Printer，重构时需要<br>在所有组合Printer的地方修改，如果组合一个Output，让Computer与Printer<br>分离，当修改Printer的时候不影响Computer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Output output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Output <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//如果要重构的时候，只需要把Printer改为BetterPrinter</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Printer();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Output</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Output</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterPrinter</span> <span class="keyword">implements</span> <span class="title">Output</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>某个方法需要完成某个行为，但是具体实现无法确定，必须等到执行该方法时才<br>可以确定，例如某个方法要遍历数组，但是只有调用这个方法的时候才知道如何<br>处理这个数组，Java8新增的Lambda表达式可以传入代码块作为参数，稍后会讲</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Process</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] array,Command cmd)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//传入不同的实现类对数组的操作不同</span></span><br><span class="line">		cmd.process(array);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在某些情况下把一个类放在另一个类的内部定义，这个定义在其他类的内部的类就<br>是内部类，包含内部类的类也称为外部类</p>
<ul>
<li>内部类提供了更好的封装，将内部类隐藏在外部类之内，而其他类不能访问</li>
<li>内部类可以直接访问外部类的私有数据，因为内部类也是被当成外部类的成<br>员，同一个类的成员可以相互访问，当外部类不能访问内部类的成员变量</li>
<li>内部类比外部类可以多使用 private protected static这三个修饰符</li>
<li>非静态内部类不能拥有静态成员</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类适合创建那种只需要使用一次的类，创建匿名内部类时会立即创建一<br>个该类的实例，可以使用局部变量，局部变量默认使用final修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类必须继承一个父类或者实现一个接口</span></span><br><span class="line"><span class="comment">//不能定义构造器但是可以定义初始化块</span></span><br><span class="line"><span class="keyword">new</span> 实现接口() | 父类构造器(实参列表)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//实现抽象类或接口中的所以抽象方法，如果是普通类相当于重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h4><p>定义内部类只需要把一个类放在另一个类内部定义即可，内部包括类中的任何位<br>置，甚至可以在方法中定义内部类。在生成class文件时，会生成两个class文件<br>一个是OuterClass文件，另一个是OuterClass$InnerClass文件，内部类可以<br>直接访问外部类的所有成员变量，也有一个this引用，只不过这个this表示内部<br>类的成员变量引用，如果要显示引用到外部类成员变量应该 OuterClass.this<br>外部类的静态方法和静态代码块不能访问非静态内部类，包括不能使用非静态<br>内部类定义变量、创建实例。非静态内部类也不能定义静态成员</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类可以包括静态和非静态成员，不能访问外部类的实例，即使是实例方法<br>也不能访问外部类的实例成员，但是可以访问外部类的类成员，可以在外部类创建<br>实例变量</p>
<h4 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h4><p><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">In</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">In</span><span class="params">(String msg)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Out.In a=<span class="keyword">new</span> Out().<span class="keyword">new</span> In(<span class="string">"fds"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建非静态内部类的子类时必须保证子类构造器可以调用父类构造器，所以必须<br>存在一个外部类的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">Out</span>.<span class="title">In</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">(Out out)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		out.<span class="keyword">super</span>(<span class="string">"fds"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用静态内部类时，因为其是与外部类类相关的，所以无需创建外部类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">In</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">In</span><span class="params">(String msg)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Out.In a=<span class="keyword">new</span> Out.In(<span class="string">"fds"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda表达式支持将代码块作为方法参数，Lambda允许使用更简洁的代码来创建<br>只有一个抽象方法的接口（这种接口被称为函数式接口）实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">class</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] array,Command command)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		command.process(array);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Test test=<span class="keyword">new</span> Test();</span><br><span class="line">		<span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">		<span class="comment">//匿名内部类</span></span><br><span class="line">		test.test(array,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				Arrays.toString(array);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//Lambda表达式</span></span><br><span class="line">		test.test(array,(<span class="keyword">int</span>[] array)-&gt;&#123;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>形参列表允许省略形参类型，如果形参只有一个参数那么圆括号也可以省略</li>
<li>箭头 -&gt;</li>
<li>如果方法体中只有一条返回语句则可以省略花括号，return也可以省略，会<br>自动返回这条语句的值</li>
</ul>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>Lambda表达式的目标类型必须是函数式接口，一个函数式接口代表只含一个抽象<br>方法的接口，可以包含多个默认方法和类方法，但是只能有一个抽象方法。Java8<br>为函数式接口提供了@FunctionalInterface注解，标注这个接口是函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Runnable r=()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以下编译错误，Object不是一个明确的函数式接口</span></span><br><span class="line">Object r=()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用强制类型转换可以确定表达式的目标类型是Runnable函数式接口</span></span><br><span class="line">Object r=(Runnable)()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.jpg" alt></p>
<h2 id="Java基础类库"><a href="#Java基础类库" class="headerlink" title="Java基础类库"></a>Java基础类库</h2><h3 id="运行Java程序的参数"><a href="#运行Java程序的参数" class="headerlink" title="运行Java程序的参数"></a>运行Java程序的参数</h3><p>如果在运行Java程序时紧跟一个或多个字符串，JVM就会将这些字符串<br>赋给args数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Scanner获取键盘输入"><a href="#使用Scanner获取键盘输入" class="headerlink" title="使用Scanner获取键盘输入"></a>使用Scanner获取键盘输入</h3><p>Scanner可以很方便获取键盘输入</p>
<ul>
<li>hasNextXxx() 是否还有下一个输入项，例如Int Long</li>
<li>hasNext() 是否还有下一个字符串</li>
<li>nextXxx() 获取下一个输入项</li>
<li>默认情况使用空格 Tab 回车作为多个输入项之间的分隔符</li>
<li>hasNextLine() 是否还有下一行</li>
<li>nextLine() 返回下一行字符串，不会以空格 Tab作为分隔符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(sc.hasNextInt())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还可以读取文件</span></span><br><span class="line">Scanner ss=<span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"file.java"</span>));</span><br><span class="line"><span class="keyword">while</span>(ss.hasNextLine)</span><br><span class="line">&#123;</span><br><span class="line">	ss.nextLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h3><p>Java程序在不同的操作系统运行可能需要取得平台相关的属性，或者<br>调用平台命令完成特定功能</p>
<h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><p>System类代表当前程序的运行平台，程序不能创建System对象，System<br>类提供了一些类变量和类方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">	<span class="comment">//System提供了标准输入 标准输出 输出错误的类变量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InputStream in;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream err;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h4><p>Runtime类代表Java程序的运行时环境，每个Java程序都有一个与之<br>对应的Runtime实例，可以通过getRuntime()获取对应的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runtime rt&#x3D;Runtime.getRuntime();</span><br><span class="line">rt.availableProcessors() &#x2F;&#x2F;处理器数量</span><br><span class="line">rt.freeMemory() &#x2F;&#x2F;空闲内存数</span><br><span class="line">rt.totalMemory() &#x2F;&#x2F;总内存数</span><br><span class="line">rt.maxMemory() &#x2F;&#x2F;最大内存数</span><br></pre></td></tr></table></figure>

<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>Object是所有类、数组、枚举类的父类，Java允许把任意类型对象赋给<br>Object类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//这个构造器没有任何内容，事实上任何类都会最终调用Object的构造器</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	&#125;</span><br><span class="line">     <span class="comment">//这是一个C语言实现的方法，hashCode值是根据对象的地址计算的</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">//必须是同一个对象才返回true</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == obj;</span><br><span class="line">    	&#125;</span><br><span class="line">     <span class="comment">//getClass之后再介绍</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass().getName() + <span class="string">"@"</span> + </span><br><span class="line">        Integer.toHexString(<span class="keyword">this</span>.hashCode());</span><br><span class="line">    	&#125;</span><br><span class="line">     <span class="comment">//克隆就是得到当前对象的一个副本</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><p>比如有一个对象Object1并且已经包含了一些值，可以克隆出一个对象<br>Object2，这个对象的值与Object1相同，但是是两个完全独立的对象<br>只不过Object2的初始值是Object1确定的。这是一个protected方法，<br>所以该方法只能被子类重写或者调用。自定义类实现克隆的步骤如下</p>
<ul>
<li>实现Cloneable接口，表示实现该接口的类可以实现自我克隆，接口<br>里没有定义任何方法</li>
<li>自定义类自己实现clone方法</li>
<li>实现clone方法时通过super.clone调用Object实现的clone方法可以<br>得到该对象的副本，并返回该副本</li>
</ul>
<p>克隆的是原始对象的副本，如果是基本类型数据就复制值，对于引用类型<br>数据并没有创建一个新的引用类型对象，只是简单的复制这个地址。这种<br>克隆也就是浅克隆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adress</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	String detail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	Adress adress;</span><br><span class="line">	<span class="comment">//如果不实现Cloneable接口就调用clone会抛出异常</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (User)<span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深克隆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adress</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	String detail;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Adress <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Adress)<span class="keyword">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	Adress adress;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		User user=(User)<span class="keyword">super</span>.clone();</span><br><span class="line">		user.adress=adress.clone();</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h3><p>String是一个不可变类，一旦一个String对象被创建之后，包含在这个<br>对象的字符序列不可改变，直至这个对象被销毁。StringBuffer则代表<br>一个字符序列可变的字符串。StringBuilder与StringBuffer基本相同<br>但是StringBuffer是线程安全的</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>Java9以前字符串采用char[]保存，一个char占两个字节，Java9之后<br>用byte[]保存字符串，一个byte占一个字节，这样更节省空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, </span></span><br><span class="line"><span class="class">	<span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.coder = <span class="string">""</span>.coder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.coder = original.coder;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>((<span class="keyword">char</span>[])value, <span class="number">0</span>, value.length, (Void)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Java5之前，将一个对象加入一个集合中，集合会忘记对象的类型，将所有对象<br>都当成Object处理，从集合中取出对象时需要进行强制类型转换。增加泛型后<br>的集合，会在编译时检查集合中元素的类型，如果向集合中加入不满足类型要<br>求的对象，编译器就会报错</p>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>引入泛型之前，取出的对象编译类型是Object，运行类型没变，导致任意的对象<br>都可以放入集合，取出时还要进行强制类型转换，增加编程难度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List list=<span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"fsd"</span>);</span><br><span class="line">list.add(<span class="string">"vaf"</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//Integer不能强制转换为String</span></span><br><span class="line">list.forEach(str-&gt; System.println(((String)str).length()));</span><br></pre></td></tr></table></figure>
<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><p>Java5以后引入参数化类型的概念，允许创建集合时指定集合元素的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"fsd"</span>);</span><br><span class="line">list.add(<span class="string">"vaf"</span>);</span><br><span class="line"><span class="comment">//编译错误</span></span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//不需要强制类型转换，取出的类型就是String</span></span><br><span class="line">list.forEach(str-&gt;System.out.println(str.length()));</span><br></pre></td></tr></table></figure>
<h3 id="Java9增强的菱形语法"><a href="#Java9增强的菱形语法" class="headerlink" title="Java9增强的菱形语法"></a>Java9增强的菱形语法</h3><p>允许在构造器后不需要带完整的泛型信息，只需要&lt;&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>允许在匿名内部类中使用菱形语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Foo&lt;String&gt; f=<span class="keyword">new</span> Foo&lt;&gt;()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String t)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				System.out.println(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//使用泛型通配符，相当于通配符的上限是Object</span></span><br><span class="line">		Foo&lt;?&gt; ff=<span class="keyword">new</span> Foo&lt;&gt;()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object t)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				System.out.println(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//使用泛型通配符，通配符上限是Number</span></span><br><span class="line">		Foo&lt;? extends Number&gt; fff=<span class="keyword">new</span> Foo&lt;&gt;()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Number t)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				System.out.println(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深入泛型"><a href="#深入泛型" class="headerlink" title="深入泛型"></a>深入泛型</h3><p>所谓泛型，就是允许在定义类、接口方法时使用类型形参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口时指定一个泛型形参，形参名为E</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//E可以作为参数类型</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(E x)</span></span>;</span><br><span class="line">	<span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">V <span class="title">put</span><span class="params">(K key,V val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从泛型类派生子类"><a href="#从泛型类派生子类" class="headerlink" title="从泛型类派生子类"></a>从泛型类派生子类</h3><p>当创建了带泛型声明的接口、父类之后，可以为该接口创建实例类，或者从该<br>父类派生子类，注意当使用这些接口、父类时不能包含泛型形参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//使用T类型定义实例变量</span></span><br><span class="line">	<span class="keyword">private</span> T info;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">	<span class="comment">//下面方法中使用 类型来定义构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(T info)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.info = info ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setlnfo</span><span class="params">(T info)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.info = info ;</span><br><span class="line">	&#125;		 </span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getlnfo</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.info;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Apple不能带泛型形参</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为T形参传入实际类型，则所有T类型都会被换为String</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//重写父类方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getlnfo</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"fsd"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回值类型必须是String</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getlnfo</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"fsd"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以不传入实际类型参数，会将T类型当成Object</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">	<span class="comment">//重写父类方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getlnfo</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//super.getInfo()返回的是Object类型</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="keyword">super</span>.getlnfo().toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并不存在泛型类"><a href="#并不存在泛型类" class="headerlink" title="并不存在泛型类"></a>并不存在泛型类</h3><p>不管泛型的实际类型参数是什么，在运行时总有相同的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.getClass()==list2.getClass();</span><br></pre></td></tr></table></figure>
<p>在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用泛型形参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//不能再静态变量声明使用泛型形参</span></span><br><span class="line">	<span class="keyword">static</span> T info;</span><br><span class="line">	T age;</span><br><span class="line">	<span class="comment">//不能再静态方法声明泛型形参</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(T temp)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">https://skysea-gaoming.github.io/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/06/%E6%B7%B1%E5%85%A5JVM/"><i class="fa fa-chevron-left">  </i><span>深入JVM</span></a></div><div class="next-post pull-right"><a href="/2020/04/06/VBlog/"><span>VBlog</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/04/12/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/';
  this.page.identifier = '2020/04/12/Java基础知识/';
  this.page.title = 'Java基础知识';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1599140437492&amp;di=195fa5a4bc93905108d4f72b9167b0c0&amp;imgtype=0&amp;src=http%3A%2F%2Fphoto.tuchong.com%2F443730%2Ff%2F14505255.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>