<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="算法总结2"><meta name="keywords" content="DataStructure"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>算法总结2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#个人简介"><span class="toc-number">1.</span> <span class="toc-text">个人简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#背包问题"><span class="toc-number">2.</span> <span class="toc-text">背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">3.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分治法"><span class="toc-number">3.1.</span> <span class="toc-text">分治法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回溯法"><span class="toc-number">3.2.</span> <span class="toc-text">回溯法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心算法"><span class="toc-number">3.3.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-number">3.4.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图论算法"><span class="toc-number">3.5.</span> <span class="toc-text">图论算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图的基本构造"><span class="toc-number">3.6.</span> <span class="toc-text">图的基本构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#检测图是否有环"><span class="toc-number">3.6.1.</span> <span class="toc-text">检测图是否有环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检测是否是二分图"><span class="toc-number">3.6.2.</span> <span class="toc-text">检测是否是二分图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有向环"><span class="toc-number">3.6.3.</span> <span class="toc-text">有向环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有向图的强连通性"><span class="toc-number">3.6.4.</span> <span class="toc-text">有向图的强连通性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小生成树"><span class="toc-number">3.6.5.</span> <span class="toc-text">最小生成树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-number">3.7.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union-find算法"><span class="toc-number">3.8.</span> <span class="toc-text">union-find算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NP问题"><span class="toc-number">4.</span> <span class="toc-text">NP问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希算法"><span class="toc-number">5.</span> <span class="toc-text">哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode"><span class="toc-number">5.0.1.</span> <span class="toc-text">hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希表"><span class="toc-number">5.0.2.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希化"><span class="toc-number">5.0.3.</span> <span class="toc-text">哈希化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正整数"><span class="toc-number">5.0.4.</span> <span class="toc-text">正整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浮点数"><span class="toc-number">5.0.5.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">5.0.6.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#软缓存"><span class="toc-number">5.0.7.</span> <span class="toc-text">软缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冲突"><span class="toc-number">5.1.</span> <span class="toc-text">冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拉链法"><span class="toc-number">5.1.1.</span> <span class="toc-text">拉链法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线性探测法"><span class="toc-number">5.1.2.</span> <span class="toc-text">线性探测法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对于hashCode的要求"><span class="toc-number">5.1.3.</span> <span class="toc-text">对于hashCode的要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见问题"><span class="toc-number">5.1.4.</span> <span class="toc-text">常见问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#脑筋急转弯"><span class="toc-number">6.</span> <span class="toc-text">脑筋急转弯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">6.1.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">6.2.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#广义表"><span class="toc-number">6.3.</span> <span class="toc-text">广义表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树和B-树"><span class="toc-number">6.4.</span> <span class="toc-text">B树和B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B树"><span class="toc-number">6.4.1.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-树"><span class="toc-number">6.4.2.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU算法"><span class="toc-number">6.5.</span> <span class="toc-text">LRU算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU实现"><span class="toc-number">6.5.1.</span> <span class="toc-text">LRU实现</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">算法总结2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/09/22/Algorithm-1/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/09/22/Algorithm-1/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><p>力扣地址：<a href="https://leetcode-cn.com/u/gao-ming-3/" target="_blank" rel="noopener">https://leetcode-cn.com/u/gao-ming-3/</a><br>牛客地址：高-明 <a href="https://www.nowcoder.com/profile/883461684" target="_blank" rel="noopener">https://www.nowcoder.com/profile/883461684</a></p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>将一个大问题分解为若干小问题，每个小问题都是相互独立并且与原问题有<br>相同的性质，求解小问题的解合并得到原问题的解，以下算法的具体问题求解<br>代码都已经放在Algorithm666仓库中</p>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>回溯法的本质是蛮力法，回溯法常使用深度优先搜索遍历，与蛮力法的区别、<br>在于回溯法会进行剪枝处理，回溯法不一定能够得到最优解</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>使用较为简单的方法找到局部最优，此时并不能保证该解是全局最优但是也<br>是一个不差的解，只解决当前局部问题不关心之前和之后的解，不同的贪心<br>准则可以得到不同的结果</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol>
<li>解决优化问题，将多阶段问题求解转化为一系列单阶段问题求解，找全<br>局最优，只有某些条件满足的问题才能使用动态规划。</li>
<li>状态的无后效性 如果某个阶段状态给定后，则该阶段以后过程的发展<br>不受该阶段以前各阶段状态的影响，也就是受状态具有马尔科父性。适用于<br>动态求解的问题具有状态的无后效性</li>
<li>策略 各个阶段决策的确定后，就组成一个决策序列，该序列称之为一<br>个策略，由某个阶段开始到终止阶段的过程称之为子过程，其对应的某个<br>策略称之为子策略</li>
<li>Bellman最优性原理 求解问题的一个最优策略序列的子策略序列总是<br>最优的，则称该问题满足最优性原理。对具有最优性原理性质的问题而言，<br>如果有一决策序列包含具有非最优的决策子序列，则该决策序列一定不是最优的</li>
<li>动态规划的思想实质是分治思想和解决冗余。与分治法类似的是将原问<br>题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题<br>的解。与分治法不同的是分解的子问题往往不是相互独立的，若用分治法<br>来解有些共同部分被重复计算了很多次，动态规划利用这种子问题的折叠性<br>质，对每一个子问题只解一次</li>
</ol>
<h3 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h3><ul>
<li>图的基本概念</li>
</ul>
<ol>
<li>一个图是由一系列的节点和边组成</li>
<li>节点的度指的是节点连接的边的条数，有向图有出度和入度</li>
<li>简单图指没有多重边且没有自环的图</li>
<li>无向图所有节点度数和为边数的两倍</li>
<li>有向图所有节点入度数等于出度数等于边数</li>
<li>一条路径由一系列的节点组成，并且相邻两个节点之间有一条边相连，<br>简单路径没有重复</li>
<li>树是一个无环连通的无向图</li>
<li>生成树是包含图中所有节点的树</li>
<li>加权图是每条边都有权值的图</li>
<li>环不是简单路径，起点和终点一致</li>
<li>稀疏图 E≈V ，稠密图 E≈V^2</li>
<li>任意两个节点都有边连接（有向图两个方向都有边）称为完全图 </li>
<li>连通分支是图中最大的连通子图</li>
<li>树的任意两个节点都有唯一的连通路径</li>
</ol>
<ul>
<li><p>邻接表<br>使用一个链表数组，对于稀疏图有效，可以节省空间，查找边时比较耗时<br>，矩阵运算不太方便</p>
</li>
<li><p>邻接矩阵<br>使用一个二维数组，对于稠密图有效</p>
</li>
<li><p>图的遍历之BFS<br>使用先进先出的队列，遍历之后可以形成一个BFS树，节点的深度是距离起始<br>点的最短距离，它首先访问起始顶点的所有邻接点，然后再访问较远的区域</p>
</li>
<li><p>图的遍历之DFS<br>使用先进后出的栈，遍历之后可以形成一个DFS森林，也就是一系列的DFS树<br>，深度优先搜索在于能够找到与某一顶点邻接且没有访问过的顶点。</p>
</li>
</ul>
<h3 id="图的基本构造"><a href="#图的基本构造" class="headerlink" title="图的基本构造"></a>图的基本构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> V;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;Integer&gt;[] adj;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> s;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.V=V;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		adj=(LinkedList&lt;Integer&gt;[])<span class="keyword">new</span> LinkedList[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">			adj[i]=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		edgeTo=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFScount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dfs(i);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFSsearch</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s=s;</span><br><span class="line">		bfs(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSsearch</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s=s;</span><br><span class="line">		dfs(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		id[v]=count;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">			&#123;</span><br><span class="line">				edgeTo[w]=v;</span><br><span class="line">				dfs(w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		markd[v]=<span class="keyword">true</span>;</span><br><span class="line">		list.add(v);</span><br><span class="line">		<span class="keyword">while</span>(!list.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> w=list.pop();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k:adj(w))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!marked[k])</span><br><span class="line">				&#123;</span><br><span class="line">					edgeTo[k]=w;</span><br><span class="line">					marked[k]=<span class="keyword">true</span>;</span><br><span class="line">					list.add(k);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!marked[v])</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		Stack&lt;Integer&gt; path=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=v;x!=s;x=edgeTo[x])</span><br><span class="line">		&#123;</span><br><span class="line">			path.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		path.push(s);</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> marked[w];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> V;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getE</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> E;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		adj[v].add(w);</span><br><span class="line">		adj[w].add(v);</span><br><span class="line">		E++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测图是否有环"><a href="#检测图是否有环" class="headerlink" title="检测图是否有环"></a>检测图是否有环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cycle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cycle</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;V;s++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">				dfs(s,s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">				dfs(w,v);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(w!=u)</span><br><span class="line">			    hasCycle=<span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hasCycle;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测是否是二分图"><a href="#检测是否是二分图" class="headerlink" title="检测是否是二分图"></a>检测是否是二分图</h4><p>如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边(i，j)所<br>关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称<br>图G为一个二分图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoColor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] color;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isTwocolor=<span class="keyword">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TwoColor</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		color=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;V;s++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">			  dfs(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">			&#123;</span><br><span class="line">				color[w]=!color[v];</span><br><span class="line">				dfs(w);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(color[w]==color[v])</span><br><span class="line">				isTwocolor=<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTwocolor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isTwocolor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有向环"><a href="#有向环" class="headerlink" title="有向环"></a>有向环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; cycle;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] onstack;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; reversepost;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		edgeTo=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		onstack=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		reversepost=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;V;v++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[v])</span><br><span class="line">				dfs(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		onstack[v]=<span class="keyword">true</span>;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(hasCycle)</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!marked[w])</span><br><span class="line">				&#123;</span><br><span class="line">					edgeTo[w]=v;</span><br><span class="line">				   dfs(w);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(onstack[w])</span><br><span class="line">			&#123;</span><br><span class="line">				cycle=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=v;x!=w;x=edgeTo[x])</span><br><span class="line">					cycle.push(x);</span><br><span class="line">				cycle.push(w);</span><br><span class="line">				cycle.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		onstack[v]=<span class="keyword">false</span>;</span><br><span class="line">		reversepost.push(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有向图的强连通性"><a href="#有向图的强连通性" class="headerlink" title="有向图的强连通性"></a>有向图的强连通性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kosara</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Kosara</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		G2=G.reverse();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s:G2.reversepost())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">				&#123;</span><br><span class="line">					dfs(s);</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.v=v;</span><br><span class="line">		<span class="keyword">this</span>.w=w;</span><br><span class="line">		<span class="keyword">this</span>.weight=weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ol>
<li>对于一个有向无环图，拓扑排序就是将所有顶点进行排序<br>，如果ViVj，那么Vi必须排在Vj<br>之前  </li>
<li>对全图进行DFS，记录每个节点的结束时间，以节点结束时<br>间由大到小的顺序输出节点即可</li>
<li>每次都删除入度为0的节点</li>
</ol>
<h3 id="union-find算法"><a href="#union-find算法" class="headerlink" title="union-find算法"></a>union-find算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] sz;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		count=N;</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			id[i]=i;</span><br><span class="line">		sz=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			sz[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(p!=id[p])</span><br><span class="line">			p=id[p];</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=find(p);</span><br><span class="line">		<span class="keyword">int</span> j=find(q);</span><br><span class="line">		<span class="keyword">if</span>(i==j)</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">if</span>(sz[i]&lt;sz[j])</span><br><span class="line">		&#123;</span><br><span class="line">			id[i]=j;</span><br><span class="line">			sz[j]+=sz[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			id[j]=i;</span><br><span class="line">			sz[i]+=sz[j];</span><br><span class="line">		&#125;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><ol>
<li>有些问题能够在多项式级别的算法解出，例如n^2,n^3</li>
<li>NP问题是指能够在多项式时间内检验一个解是否正确的问题</li>
<li>所有NP问题都能在多项式时间内归约成NPC问题</li>
</ol>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><p>这是一个用C语言实现的方法，作用是返回对象的散列码。Java中有几种集合类，<br>比如Map List一般存放的元素是有序可重复的，Set存放的元素是不可重复的。<br>判断一个元素是否重复一般使用equals方法，如果一个集合中有数亿的元素，<br>那么每新加入一个元素都要与这数亿个元素一起比较效率低下。Java集合采用哈<br>希表来实现查重，当集合要添加一个新元素时，首先调用hashCode方法，然后<br>经过哈希化得到一个在哈希表中的位置，如果这个位置没有元素就直接加入，否<br>则与这个位置的链表上的每个元素通过equals方法进行比较</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表也称为散列表，Hash表是一种根据关键字(key-value)而直接进行访问的<br>数据结构，它是基本数组将关键字映射到数组的某个下标来加快查找速度，但是<br>并不完全是数组，可以看成是数组和链表的结合体最重要的问题就是如何把关键<br>字转换为数组的下标，这个转换的函数为哈希函数，转换的过程叫做哈希化，同<br>时也有多个键散列到相同索引的情况，散列查找的第二步就是解决冲突碰撞问题</p>
<h4 id="哈希化"><a href="#哈希化" class="headerlink" title="哈希化"></a>哈希化</h4><p>散列表是在时间和空间上做出权衡的经典例子。如果没有内存限制，可以直接将<br>键作为数组的索引，所有的查找工作只需要访问内存一次就可以完成。如果没有<br>时间限制，可以使用无序数组并进行顺序查找，这样只需要很小的内存空间。哈<br>希算法在两种极端之间找到了一种平衡，首先就是散列函数的计算，如果有一个<br>能够保存M个键值对的数组，那么就需要将任意键转化为0~M-1的索引范围。散列<br>函数和键的类型有关，每种类型的键都需要一个对应的散列函数</p>
<h4 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h4><p>一般采用整数取余法，选择一个大小为素数M的数组，对于任意整数k计算k%M的<br>余数，M用素数可以均匀地散列散列值</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>将键表示为二进制数然后再使用除留取余数法</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>一种叫Horner方法的经典算法用N次乘法、加法和取余来计算一个字符串的散列值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">&#123;</span><br><span class="line">	hash=(R*hash+s.charAt(i))%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="软缓存"><a href="#软缓存" class="headerlink" title="软缓存"></a>软缓存</h4><p>如果散列值的计算很耗时，那么或许可以将每个键的散列值缓存起来，Java中的<br>String对象的hashCode()方法就使用了软缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="keyword">this</span>.hash;</span><br><span class="line">        <span class="comment">//如果h等于0就计算否则直接返回已经计算的值</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = h = <span class="keyword">this</span>.isLatin1() ? StringLatin1.</span><br><span class="line">            hashCode(<span class="keyword">this</span>.value) : StringUTF16.hashCode(<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>一个散列函数能够将键转化为数组索引，散列算法的第二步就是碰撞处理</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>将大小为M的数组中的每个元素都指向一条链表，链表中的每个结点都存储了散列<br>值为该元素索引的键值对。查找分为两步，首先根据散列值找到对应的链表，然后<br>沿着链表顺序查找相应的键</p>
<h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>用大小为M的数组保存N个键值对，其中M&gt;N。需要依靠数组中的空位解决碰撞冲<br>突，基于这种策略的所有方法统称为开放地址散列表</p>
<ul>
<li>线性探测 一个位置一个位置按顺序查找，但是很容易发生在某个索引位置聚<br>集，就好像围观群众一样在某个地方越来越大</li>
<li>二次探测 二次探测是防止聚集的一种方式，每次不是相邻位置探测而是探测<br>间隔位置。二次探测就是x+1 x-1 x+4 x-4 x+9 x-9</li>
<li>再哈希法 把关键字用不同的哈希函数再一次哈希，用这个结果作为步长<br>stepSize=constant-key%constant，constant是质数并且小与数组容量</li>
<li>设置公共溢出区法 即为所有冲突的关键字建立一个公共的溢出区来存放，<br>在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位<br>置进行比对如果相等，则查找成功如果不相等，则到溢出表去进行顺序查找<br>，如果对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对<br>查找性能来说还是非常高的</li>
</ul>
<h4 id="对于hashCode的要求"><a href="#对于hashCode的要求" class="headerlink" title="对于hashCode的要求"></a>对于hashCode的要求</h4><p>在程序运行期间，如果对象的变化不会导致equals方法的变化，那么hashCode的<br>返回值就不能改变</p>
<ul>
<li>equals返回true那么hashCode值一定相等</li>
<li>hashCode值相等不一定equals返回true</li>
</ul>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol>
<li>负载因子 α=填入表中元素的个数/hash表长度。哈希法的平均查找长度随<br>负载因子的增大而增大</li>
<li>在内存中的数据查找性能较好的是HashMap，在磁盘中查找性能较好的是<br>B+ Tree</li>
<li>开哈希表–链地址法  闭哈希表–开放地址法</li>
</ol>
<h2 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h2><ol>
<li>牛客上有一个题：一个有序数列，序列中的每一个值都能够被2或者3或者5所<br>整除，这个序列的初始值从1开始，但是1并不在这个数列中。求第1500个值是多少？<br>两个牛哥的思路：设x个数，x/2+x/3+x/5-x/6-x/10-x/15+x/30=1500<br>翻译过来是:在x以内,能整除2的有x/2个数,整除3的有x/3个数…但这些数有<br>重复的,需要利用容斥原理去重: A∪B∪C = A+B+C - A∩B - B∩C - C∩A +<br>A∩B∩C</li>
</ol>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>牛客上有一个算术表达式的题，求中缀表达式的后缀形式</li>
</ul>
<ol>
<li>这里我给出一个中缀表达式：a+b*c-(d+e)</li>
<li>第一步：按照运算符的优先级对所有的运算单位加括号：式子变成了<br>((a+(b*c))-(d+e))</li>
<li>第二步：转换前缀与后缀表达式</li>
<li>前缀：把运算符号移动到对应的括号前面</li>
<li>则变成了：-( +(a *(bc)) +(de))</li>
<li>把括号去掉：-+a*bc+de 前缀式子出现</li>
<li>后缀：把运算符号移动到对应的括号后面</li>
<li>则变成了：((a(bc)* )+ (de)+ )-</li>
<li>把括号去掉：abc*+de+- 后缀式子出现</li>
</ol>
<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>广义表是一种非线性的数据结构，列表的表头可以是原子或者子表，但是表尾<br>必须是子表</p>
<h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><p>参考 <a href="https://blog.csdn.net/zhuanzhe117/article/details/78039692" target="_blank" rel="noopener">https://blog.csdn.net/zhuanzhe117/article/details/78039692</a></p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>每个节点都存储key和data，所有节点组成这棵树，叶子节点指针为null<br><img src="/2020/09/22/Algorithm-1/1.jpg" alt></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>只有叶子节点存储data，叶子节点包含这棵树所有的键值，叶子节点不存储指针<br><img src="/2020/09/22/Algorithm-1/2.jpg" alt><br>后来B+树上增加了顺序访问指针，也就是每个叶子节点都增加一个指向相邻叶子<br>节点的指针，这样一棵树成了数据库系统实现索引的首选数据结构</p>
<h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p>参考 <a href="https://www.cnblogs.com/wyq178/p/9976815.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyq178/p/9976815.html</a><br>原意是  Least Recently Used ，即最近最久未使用算法，是由一个著名的操<br>作系统基础理论得来：最近使用的页面数据会在未来一段时期内仍然被使用，已<br>经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。基于<br>这个思想,会存在一种缓存淘汰机制，每次从内存中找到最久未使用的数据然后<br>置换出来，从而存入新的数据！它的主要衡量指标是使用的时间，附加指标是<br>使用的次数</p>
<h4 id="LRU实现"><a href="#LRU实现" class="headerlink" title="LRU实现"></a>LRU实现</h4><p>可以利用双向链表实现，双向链表的特点就是链表是双路的，利用先进先出原则<br>将最近获得的元素最早被获取，添加新元素直接放在链表头上，访问时如果是头<br>节点不用管，如果访问的是中间位置或尾部就要将其移动到头节点，修改操作跟<br>访问一样，删除是直接删除该节点。</p>
<ol>
<li>缓存实现：查询、更新，一定是使用HashMap</li>
<li>通过链表来判断最近最少使用的是哪一个，即：最近有使用的放链表头、最近<br>最少使用的放链表尾</li>
<li>因为需要删除链表中某个过期的节点，所以选择使用双向链表</li>
<li>HashMap中key就存查询搜索的key；value存放双向链表的节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    Object key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    Object value;</span><br><span class="line">    <span class="comment">//上一个节点</span></span><br><span class="line">    Node pre;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
定义一个LRU类，然后定义它的大小、容量、头节点、尾节点等部分<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRU</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;<span class="comment">//当前的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;<span class="comment">//总容量</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Node&gt; caches;<span class="comment">//所有的node节点</span></span><br><span class="line">    <span class="keyword">private</span> Node first;<span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node last;<span class="comment">//尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        currentSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capcity = size;</span><br><span class="line">        caches = <span class="keyword">new</span> HashMap&lt;K, Node&gt;(size);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
添加元素的时候首先判断是不是新的元素，如果是新元素，判断当前的大小是<br>不是大于总容量了，防止超过总链表大小，如果大于的话直接抛弃最后一个节<br>点，然后再以传入的key\value值创建新的节点。对于已经存在的元素，直接<br>覆盖旧值，再将该元素移动到头部，然后保存在map中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node node = caches.get(key);</span><br><span class="line">    <span class="comment">//如果新元素</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果超过元素容纳量</span></span><br><span class="line">        <span class="keyword">if</span> (caches.size() &gt;= capcity) &#123;</span><br><span class="line">            <span class="comment">//移除最后一个节点</span></span><br><span class="line">            caches.remove(last.key);</span><br><span class="line">            removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建新节点</span></span><br><span class="line">        node = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">        caches.put(key, node);</span><br><span class="line">        currentSize++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//已经存在的元素覆盖旧值</span></span><br><span class="line">        node.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把元素移动到首部</span></span><br><span class="line">    moveToHead(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过key值来访问元素，主要的做法就是先判断如果是不存在的，直接返回<br>null。如果存在，把数据移动到首部头节点，然后再返回旧值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node node = caches.get(key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把访问的节点移动到首部</span></span><br><span class="line">    moveToHead(node);</span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在根据key 删除节点的操作中，我们需要做的是把节点的前一个节点的指针<br>指向当前节点下一个位置，再把当前节点的下一个的节点的上一个指向当前<br>节点的前一个<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node node = caches.get(key);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == first) &#123;</span><br><span class="line">            first = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == last) &#123;</span><br><span class="line">            last = node.pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> caches.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接下来实现移动元素到头节点，首先把当前节点移除，类似于删除的效果(但<br>是没有移除该元素)，然后再将首节点设为当前节点的下一个，再把当前节点<br>设为头节点的前一个节点。当前节点设为首节点。再把首节点的前一个节点设<br>为null，这样就是间接替换了头节点为当前节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node == last) &#123;</span><br><span class="line">        last = last.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span> || last == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = last = node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.next = first;</span><br><span class="line">    first.pre = node;</span><br><span class="line">    first = node;</span><br><span class="line">    first.pre = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/09/22/Algorithm-1/">https://skysea-gaoming.github.io/2020/09/22/Algorithm-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStructure/">DataStructure</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/05/VBlog2/"><i class="fa fa-chevron-left">  </i><span>VBlog2</span></a></div><div class="next-post pull-right"><a href="/2020/09/21/LeetCodeandnowcoder2/"><span>刷题2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/09/22/Algorithm-1/';
  this.page.identifier = '2020/09/22/Algorithm-1/';
  this.page.title = '算法总结2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>