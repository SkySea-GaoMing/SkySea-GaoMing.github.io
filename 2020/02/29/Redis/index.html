<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Redis"><meta name="keywords" content="数据库"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Redis | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NoSql概述"><span class="toc-number">2.</span> <span class="toc-text">NoSql概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#横向扩展和纵向扩展"><span class="toc-number">2.1.</span> <span class="toc-text">横向扩展和纵向扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSql特点"><span class="toc-number">2.2.</span> <span class="toc-text">NoSql特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL四大分类"><span class="toc-number">2.3.</span> <span class="toc-text">NoSQL四大分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis概述"><span class="toc-number">2.4.</span> <span class="toc-text">Redis概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux下载Redis"><span class="toc-number">2.5.</span> <span class="toc-text">Linux下载Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis配置"><span class="toc-number">2.5.1.</span> <span class="toc-text">Redis配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试性能"><span class="toc-number">2.6.</span> <span class="toc-text">测试性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">3.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识"><span class="toc-number">3.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五大基本数据类型"><span class="toc-number">3.2.</span> <span class="toc-text">五大基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-Key"><span class="toc-number">3.2.1.</span> <span class="toc-text">Redis-Key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">3.2.2.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三大特殊类型"><span class="toc-number">3.3.</span> <span class="toc-text">三大特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#geospatial"><span class="toc-number">3.3.1.</span> <span class="toc-text">geospatial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hyperloglog"><span class="toc-number">3.3.2.</span> <span class="toc-text">Hyperloglog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap"><span class="toc-number">3.3.3.</span> <span class="toc-text">Bitmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务"><span class="toc-number">3.3.4.</span> <span class="toc-text">事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis实现乐观锁"><span class="toc-number">3.4.</span> <span class="toc-text">Redis实现乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis配置文件详解"><span class="toc-number">3.5.</span> <span class="toc-text">Redis配置文件详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">3.6.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">3.7.</span> <span class="toc-text">AOF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis是什么？"><span class="toc-number">3.8.</span> <span class="toc-text">Redis是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的优缺点？"><span class="toc-number">3.9.</span> <span class="toc-text">Redis的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系型数据库和非关系型数据库的区别？"><span class="toc-number">3.10.</span> <span class="toc-text">关系型数据库和非关系型数据库的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#横向扩展和纵向扩展的区别？"><span class="toc-number">3.11.</span> <span class="toc-text">横向扩展和纵向扩展的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis为什么这么快？"><span class="toc-number">3.12.</span> <span class="toc-text">Redis为什么这么快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis相比memcached有哪些优势？"><span class="toc-number">3.13.</span> <span class="toc-text">Redis相比memcached有哪些优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-的数据类型？"><span class="toc-number">3.14.</span> <span class="toc-text">Redis 的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis三大特殊类型？"><span class="toc-number">3.15.</span> <span class="toc-text">Redis三大特殊类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的常用场景？"><span class="toc-number">3.16.</span> <span class="toc-text">Redis的常用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-持久化机制是什么？"><span class="toc-number">3.17.</span> <span class="toc-text">redis 持久化机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-底层的数据结构？"><span class="toc-number">3.18.</span> <span class="toc-text">redis 底层的数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-常见命令？"><span class="toc-number">3.19.</span> <span class="toc-text">Redis 常见命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跳跃表是什么？"><span class="toc-number">3.20.</span> <span class="toc-text">跳跃表是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串类型是怎么实现的？"><span class="toc-number">3.21.</span> <span class="toc-text">字符串类型是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式锁是什么？"><span class="toc-number">3.22.</span> <span class="toc-text">分布式锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式锁应该具备哪些条件？"><span class="toc-number">3.23.</span> <span class="toc-text">分布式锁应该具备哪些条件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式锁的实现有哪些"><span class="toc-number">3.24.</span> <span class="toc-text">分布式锁的实现有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-实现分布式锁？"><span class="toc-number">3.25.</span> <span class="toc-text">Redis 实现分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka-是什么？"><span class="toc-number">3.26.</span> <span class="toc-text">Kafka 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis"><span class="toc-number">3.27.</span> <span class="toc-text">Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事务-1"><span class="toc-number">3.27.1.</span> <span class="toc-text">事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot整合Redis"><span class="toc-number">3.28.</span> <span class="toc-text">SpringBoot整合Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义RedisTemplate"><span class="toc-number">3.28.1.</span> <span class="toc-text">自定义RedisTemplate</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Redis</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/02/29/Redis/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/02/29/Redis/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Redis设计与实现》 遇见狂神说</p>
<h2 id="NoSql概述"><a href="#NoSql概述" class="headerlink" title="NoSql概述"></a>NoSql概述</h2><p>单机MySQL的年代 <img src="/2020/02/29/Redis/1.jpg" alt><br>Memcached(缓存)+Mysql+垂直拆分(读写分离) <img src="/2020/02/29/Redis/2.jpg" alt><br>分库分表+水平拆分+MySQL集群 <img src="/2020/02/29/Redis/3.jpg" alt><br>NoSQL not only sql不仅仅是数据库，泛指非关系型数据库。传统的关系型数据<br>库无法应对大数据，NoSQL在当今大数据时代发展瞬速。很多的数据类型比如用户<br>的个人信息、社交网络、地理位置等并不需要一个固定的格式，不需要多余的操作<br>就可以横向扩展</p>
<h3 id="横向扩展和纵向扩展"><a href="#横向扩展和纵向扩展" class="headerlink" title="横向扩展和纵向扩展"></a>横向扩展和纵向扩展</h3><p>横向扩展：多增加几台API服务器，一起服务。也叫水平扩展，用更多的节点支撑更<br>大量的请求。 如成千上万的蚂蚁完成一项搬运工作<br>纵向扩展：把API服务器换成性能更好的机器。又叫垂直扩展，扩展一个点的能力支<br>撑更大的请求。如利用1个人的能力，如蜘蛛侠逼停火车</p>
<h3 id="NoSql特点"><a href="#NoSql特点" class="headerlink" title="NoSql特点"></a>NoSql特点</h3><ol>
<li>方便扩展，数据之间没有关系</li>
<li>大数据高性能（Redis一秒写8万，读取11万）缓存记录级、细粒度</li>
<li>数据类型是多样型的，不需要事先设计数据库，随取随用</li>
<li>不仅仅保存数据</li>
<li>没有固定的查询语言</li>
<li>键值对存储、列存储、文档存储、图形数据库</li>
<li>最终一致性</li>
<li>CAP定理(一致性（Consistency）、可用性（Availability）、分区容错性，<br>这三个要素最多只能同时实现两点)和BASE(基本可用（Basically Available）<br>软状态（Soft state）最终一致（Eventually consistent）)</li>
<li>高性能、高可用、高可扩</li>
<li>关系型数据库特点</li>
</ol>
<ul>
<li>结构化组织</li>
<li>SQL</li>
<li>数据和关系都存储在单独的表中</li>
<li>有专门的数据操作以及数据定义语言</li>
<li>严格的一致性原则</li>
</ul>
<h3 id="NoSQL四大分类"><a href="#NoSQL四大分类" class="headerlink" title="NoSQL四大分类"></a>NoSQL四大分类</h3><p><img src="/2020/02/29/Redis/4.jpg" alt></p>
<ol>
<li>KV键值对</li>
</ol>
<ul>
<li>Redis</li>
</ul>
<ol start="2">
<li>文档型数据库 boson格式，和json一样</li>
</ol>
<ul>
<li>MongoDB 基于分布式文件存储的数据库，主要用来处理大量文档，是介于<br>关系型数据库和菲关系型数据库之间的产品</li>
<li>ConthDB</li>
</ul>
<ol start="3">
<li>列存储数据库</li>
</ol>
<ul>
<li>HBase</li>
<li>分布式文件系统</li>
</ul>
<ol start="4">
<li>图关系数据库</li>
</ol>
<ul>
<li>Neo4j</li>
<li>InfoGrid</li>
</ul>
<h3 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h3><p>Remote Dictionary Server，即远程字典服务</p>
<ol>
<li>内存存储，持久化(rdb aof)</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器</li>
</ol>
<h3 id="Linux下载Redis"><a href="#Linux下载Redis" class="headerlink" title="Linux下载Redis"></a>Linux下载Redis</h3><p>我在VMware虚拟机中创建centos，用xhell远程连接<br>如果有网络问题请参考 <a href="https://www.bbsmax.com/A/rV57Qk3jzP/" target="_blank" rel="noopener">https://www.bbsmax.com/A/rV57Qk3jzP/</a><br>下载Redis压缩文件，通过pscp从windows系统传送到Linux系统<br>注意最新的版本也就是6开头的话gcc的版本也要是最新的，这里我用了旧版本<br>pscp -r D:\shared\redis-5.0.10.tar.gz root@IP:/opt <img src="/2020/02/29/Redis/5.jpg" alt></p>
<h4 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h4><p>进入Redis-5.0.10可以查看所有文件，redis.conf是配置文件 <img src="/2020/02/29/Redis/6.jpg" alt><br>安装 yum install gcc-c++ ，Redis是用C++写的<br>安装完成后执行 make &amp; make install <img src="/2020/02/29/Redis/7.jpg" alt><br>Redis的默认安装路径在/usr/local/bin <img src="/2020/02/29/Redis/8.jpg" alt><br>cp /home/ming/redis-5.0.10/redis.conf kconfig 将配置文件复制一份<br>编辑redis.conf文件，将daemonize改为yes，默认后台启动<br>启动redis <img src="/2020/02/29/Redis/9.jpg" alt><br>关闭redis <img src="/2020/02/29/Redis/10.jpg" alt></p>
<h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><p>redis-benchmark是一个压力测试工具 <img src="/2020/02/29/Redis/11.jpg" alt><br>比如现在来测试100个并发连接和100000个请求<br>redis-benchmark -h localhost -p 6379 -c 100 -n 100000 <img src="/2020/02/29/Redis/12.jpg" alt><br>对100000个请求进行写入测试，一共有100个并发客户端，每次写入3个字节，<br>只有一台服务器处理这些请求，每秒能够处理51255.77个请求</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>以上的所有操作都能完成后就可以正式学习Redis了</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>Redis默认有16个数据库，可以查看redis.conf文件，默认使用的是第0个<br>数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select index #index就是指定使用哪个数据库</span><br><span class="line">dbsize #查看当前数据库的大小</span><br><span class="line">keys * #查看所有的key</span><br><span class="line">flushdb #清空数据库</span><br><span class="line">flushall #清空所有数据库</span><br></pre></td></tr></table></figure>
<p>Redis是单线程的，Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis<br>的瓶颈是根据机器内存和网络带宽，既然可以使用单线程就使用了呗。Redis是<br>用C语言写的，官方提供的数据为100000+的QPS，Redis有以下误区</p>
<ol>
<li>高性能服务器一定是多线程？</li>
<li>多线程一定比单线程效率高？</li>
</ol>
<p>Redis是将所有的数据全部放入内存中，所以使用单线程是最快的，因为多线程<br>会存在CPU上下文切换耗时</p>
<h3 id="五大基本数据类型"><a href="#五大基本数据类型" class="headerlink" title="五大基本数据类型"></a>五大基本数据类型</h3><p>通过官方介绍可以知道Redis可以用作数据库、缓存和消息中间件MQ。支持多种<br>类型的数据结构 string,hashes,lists,sets,sorted sets和范围查询，<br>bitmaps,hyperloglogs和地理空间索引半径查询 <img src="/2020/02/29/Redis/13.jpg" alt></p>
<h4 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">move key 1 #将key移动到指定数据库</span><br><span class="line">del key #删除键</span><br><span class="line">expire key 10 #key在10s后过期</span><br><span class="line">ttl key #可以查看key还有几秒过期</span><br><span class="line">type key #查看类型</span><br></pre></td></tr></table></figure>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end #查看从start到end的字符串，从0开始如果end为-1则为全部</span><br><span class="line">setrange key start xx #从start开始将字符串替换为xx，替换的长度就是xx的长度</span><br><span class="line">setex key time value #设置值的同时设置过期时间</span><br><span class="line">setnx key xx #如果当前key不存在的时候进行创建，如果存在则创建失败，在分布式锁中使用</span><br><span class="line">mset k1 v1 k2 v2 #批量设置</span><br><span class="line">mget k1 k2 k3 #批量获取</span><br><span class="line">msetnx k1 v1 k2 v2 #k1 k2必须都不存在才设置成功，原子性操作</span><br><span class="line">getset key xx #如果不存在key则返回null否则获取之前值设置新的值</span><br></pre></td></tr></table></figure>

<h3 id="三大特殊类型"><a href="#三大特殊类型" class="headerlink" title="三大特殊类型"></a>三大特殊类型</h3><h4 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h4><p>这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人。底层原理是Zset</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">geoadd china:city 114.109 22.544 shenzhen</span><br><span class="line">geoadd china:city 121.445 31.213 shanghai</span><br><span class="line">geoadd china:city 106.50 29.53 chongqing</span><br><span class="line">geoadd china:city 116.40 39.90 beijing</span><br><span class="line">geopos china:city beijin chongqing #获取经纬度</span><br><span class="line">geodist china:city shenzhen shanghai #获取两地之间的距离</span><br><span class="line">#以某个地点为圆心半径为1000的所有地点</span><br><span class="line">georadius china:city 110 30 1000 km withdist withcoord count</span><br><span class="line">georadiusbymember china:city shenzhen 1000 km</span><br><span class="line">geohash china:city shenzhen #将经纬度转换为一个字符串</span><br></pre></td></tr></table></figure>

<h4 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h4><p>占用的内存是固定的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd key xx #添加元素，重复的元素实际上不会成功添加</span><br><span class="line">pfcount key #统计不重复的元素数量</span><br><span class="line">pfmerge key key2 key3 #将key2和key3的元素合并放入key</span><br></pre></td></tr></table></figure>
<h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p>位存储，比如每天打卡就可以使用0或1来表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br><span class="line">setbit sign 0 1 #这就可以表示星期一打卡</span><br><span class="line">getbit key offset</span><br><span class="line">bitcount key</span><br></pre></td></tr></table></figure>

<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>Redis单条命令是具有原子性的，但是Redis的事务是不具有原子性的</p>
<ol>
<li>开启事务使用 multi</li>
<li>命令入队 所有操作先不执行，只有发起执行命令才会执行</li>
<li>执行命令 exec 一次性、顺序性、排他性</li>
<li>取消事务 discard 之前入队的操作都不会被执行</li>
</ol>
<p>对于一个事务，如果这个事务中存在错误命令等情况，所有命令都不会被执行，<br>如果命令没错但是运行时出现错误，其余正确的操作依然可以正常运行</p>
<h3 id="Redis实现乐观锁"><a href="#Redis实现乐观锁" class="headerlink" title="Redis实现乐观锁"></a>Redis实现乐观锁</h3><ul>
<li>悲观锁：认为什么时候都会出问题，无论做什么都会加锁</li>
<li>乐观锁：认为什么时候都不会出问题，无论做什么都不加锁。更新数据的时候<br>会判断一下数据是否被修改，如果数据被修改则更新失败</li>
</ul>
<p>现在开启两个线程，一开始money为80，在新建会话8中监视money并开启事务，<br>此时先不执行事务，在新建会话7中修改money为1000，然后在会话8中执行事<br>务，可以看到事务执行失败，watch可以当做redis的乐观锁操作，unwatch<br>可以解锁放弃监视 <img src="/2020/02/29/Redis/14.jpg" alt> <img src="/2020/02/29/Redis/15.jpg" alt></p>
<h3 id="Redis配置文件详解"><a href="#Redis配置文件详解" class="headerlink" title="Redis配置文件详解"></a>Redis配置文件详解</h3><p>Redis启动的时候就通过配置文件来启动</p>
<ol>
<li>默认单位 配置文件unit单位对大小写不敏感<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1k &#x3D;&gt; 1000 bytes</span><br><span class="line"># 1kb &#x3D;&gt; 1024 bytes</span><br><span class="line"># 1m &#x3D;&gt; 1000000 bytes</span><br><span class="line"># 1mb &#x3D;&gt; 1024*1024 bytes</span><br><span class="line"># 1g &#x3D;&gt; 1000000000 bytes</span><br><span class="line"># 1gb &#x3D;&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br></pre></td></tr></table></figure></li>
<li>可以包含多个配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &#x2F;path&#x2F;to&#x2F;local.conf</span><br><span class="line"># include &#x2F;path&#x2F;to&#x2F;other.conf</span><br></pre></td></tr></table></figure></li>
<li>网络<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 #默认在本地访问</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure></li>
<li>通用配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes #以守护进程的方式运行</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid #如果以后台方式运行就需要指定一个pid文件</span><br><span class="line">databases 16 #默认有16个数据库</span><br><span class="line">#redis是内存数据库，如果没有持久化那么数据断点即失</span><br><span class="line">save 900 1 #如果900s内至少有一个key被修改就进行持久化操作</span><br><span class="line">save 300 10 #300s内至少10个key被修改则进行持久化操作</span><br><span class="line">save 60 10000 #60s内有至少10000个key被修改则进行持久化操作</span><br><span class="line">stop-writes-on-bgsave-error yes #持久化出错是否还要继续工作</span><br><span class="line">rdbcompression yes #是否压缩rdb文件，需要消耗一些CPU资源</span><br></pre></td></tr></table></figure></li>
<li>安全<br>Redis默认是没有密码的，可以通过set requirepass xxx 来设置，登录的<br>时候 auth xxx 输入密码即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># requirepass foobared</span><br></pre></td></tr></table></figure></li>
<li>限制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最多10000个客户端连接过来</span><br><span class="line">maxclients 10000</span><br><span class="line">maxmemory &lt;bytes&gt; #可以配置的最大内存</span><br><span class="line">maxmemory-policy noeviction #内存到达上限之后的处理策略</span><br></pre></td></tr></table></figure></li>
<li>aof配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no #默认不开启，默认使用rdb持久化</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>之前就已经提过，Redis是内存数据库，如果不将内存中的数据库状态保存<br>到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所<br>Redis提供了持久化功能 <img src="/2020/02/29/Redis/17.jpg" alt><br>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快<br>照，它恢复时是将快照文件直接读到内存里。Redis会单独创建一个子进程<br>来进行持久化，先会将数据写到一个临时文件中，等持久化过程都结束了，<br>再用这个临时文件替换上次持久化好的文件，整个过程主进程不进行任何<br>IO操作，这就确保极高的性能。如果需要对大规模数据进行恢复，且对于<br>数据恢复的完整性不是非常敏感，那么RDB就比AOF更加高效，RDB的缺<br>点是最后一次持久化的数据可能丢失</p>
<ul>
<li>优点 适合大规模的数据恢复，对数据的完整性要求不高</li>
<li>缺点 需要一定时间间隔进程操作</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>将所有命令都记录下来，恢复的时候就把这个文件全部都执行一遍 <img src="/2020/02/29/Redis/18.jpg" alt><br>以日志的形式记录每个写操作，将Redis执行过的所有命令记录下来（读<br>操作不记录），只许追加文件但不可以改写文件，Redis启动之初会读取<br>该文件重新构建数据，也就是说Redis重启的话就根据日志文件的内容将<br>写指令从前到后执行一次以完成数据的恢复工作</p>
<h3 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h3><p>﻿Redis本质上是一个Key-Value 类型的内存数据库，很像memcached，整个数<br>据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到<br>硬盘上进行保存</p>
<h3 id="Redis的优缺点？"><a href="#Redis的优缺点？" class="headerlink" title="Redis的优缺点？"></a>Redis的优缺点？</h3><ol>
<li>优点</li>
</ol>
<ul>
<li>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读<br>写操作，是已知性能最快的Key-Value DB</li>
<li>支持保存多种数据结构，此外单个value的最大限制是1GB，不像memcached<br>只能保存1MB的数据，因此Redis可以用来实现很多有用的功能</li>
</ul>
<ol start="2">
<li>缺点</li>
</ol>
<ul>
<li>是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此<br>Redis适合的场景主要局限在较小数据量的高性能操作和运算上</li>
</ul>
<h3 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h3><ol>
<li>数据存储结构 关系型数据库一般都有固定的表结构，比如基于文档的，K-V<br>键值对的，还有基于图的等，对于数据的格式十分灵活没有固定的表结构，方<br>便扩展</li>
<li>可扩展性 关系型数据库横向扩展难，不好对数据进行分片等，而一些非关<br>系型数据库则原生就支持数据的水平扩展(比如mongodb的sharding机制)</li>
<li>数据一致性 非关系型数据库一般强调的是数据最终一致性，而不没有像<br>ACID 一样强调数据的强一致性，从非关系型数据库中读到的有可能还是处<br>于一个中间态的数据，因此如果你的业务对于数据的一致性要求很高，那么<br>非关系型数据库并不一个很好的选择，非关系型数据库可能更多的偏向于<br>OLAP(联机分析处理)场景，而关系型数据库更多偏向于OLTP场景</li>
</ol>
<h3 id="横向扩展和纵向扩展的区别？"><a href="#横向扩展和纵向扩展的区别？" class="headerlink" title="横向扩展和纵向扩展的区别？"></a>横向扩展和纵向扩展的区别？</h3><ol>
<li>横向扩展：多增加几台API服务器，一起服务。也叫水平扩展，用更多的节<br>点支撑更大量的请求。 如成千上万的蚂蚁完成一项搬运工作</li>
<li>纵向扩展：把API服务器换成性能更好的机器。又叫垂直扩展，扩展一个点<br>的能力支撑更大的请求。如利用1个人的能力，如蜘蛛侠逼停火车</li>
</ol>
<h3 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h3><ol>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存<br>中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li>
<li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者<br>多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操<br>作，没有因为可能出现死锁而导致的性能消耗</li>
<li>使用多路I/O复用模型，非阻塞IO</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协<br>议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的<br>话，会浪费一定的时间去移动和请求</li>
</ol>
<h3 id="Redis相比memcached有哪些优势？"><a href="#Redis相比memcached有哪些优势？" class="headerlink" title="Redis相比memcached有哪些优势？"></a>Redis相比memcached有哪些优势？</h3><ol>
<li>redis支持更丰富的数据类型（支持更复杂的应用场景）：Redis不仅仅支持<br>简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储<br>。memcache支持简单的数据类型，String</li>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候<br>可以再次加载进行使用，而Memecache把数据全部存在内存之中。</li>
<li>集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集<br>群中分片写入数据，但是 redis 目前是原生支持 cluster 模式的</li>
<li>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路<br>IO 复用模型</li>
</ol>
<h3 id="Redis-的数据类型？"><a href="#Redis-的数据类型？" class="headerlink" title="Redis 的数据类型？"></a>Redis 的数据类型？</h3><p>Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表）<br>，set（集合）及 zset sorted set：有序集合</p>
<ol>
<li>string：redis 中字符串 value 最大可为512M。可以用来做一些计数功<br>能的缓存（也是实际工作中最常见的）。 常规计数：微博数，粉丝数等</li>
<li>list：简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表<br>的头部（左边）或者尾部（右边），Redis list的实现为一个双向链表，即<br>可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。可<br>以实现一个简单消息队列功能，做基于redis的分页功能等。可以通过lrange<br>命令，就是从某个元素开始读取多少个元素，可以基于list 实现分页查询，<br>类似微博那种下拉不断分页，微博的时间轴</li>
<li>set：是一个字符串类型的无序集合。可以用来进行全局去重等。(比如：在<br>微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存<br>在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功<br>能。这个过程也就是求交集的过程)</li>
<li>sorted set：是一个字符串类型的有序集合，给每一个元素一个固定的分<br>数score来保持顺序。可以用来做排行榜应用或者进行范围查找等</li>
<li>hash：键值对集合，是一个字符串类型的Key和 Value 的映射表，也就是<br>说其存储的Value是一个键值对（Key- Value）hash 特别适合用于存储对象<br>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如<br>我们可以 hash 数据结构来存储用户信息，商品信息等等</li>
</ol>
<h3 id="Redis三大特殊类型？"><a href="#Redis三大特殊类型？" class="headerlink" title="Redis三大特殊类型？"></a>Redis三大特殊类型？</h3><p>geospatial Hyperloglog Bitmap</p>
<ol>
<li>geospatial 这个功能可以推算地理位置的信息，两地之间的距离，方圆几<br>里的人</li>
<li>Hyperloglog 用来做基数统计的算法，占用的内存是固定的，因为其只会<br>根据输入元素来计算基数，而不会储存输入元素本身，基数=不重复元素的个<br>数。一个人访问了一个网站多次，但是还是算作一个人</li>
<li>通过一个bit位来表示某个元素对应的值或者状态，可以用来统计用户信息<br>，登陆，未登录，打卡</li>
</ol>
<h3 id="Redis的常用场景？"><a href="#Redis的常用场景？" class="headerlink" title="Redis的常用场景？"></a>Redis的常用场景？</h3><ol>
<li>计数器 可以对String 进行自增自减运算，从而实现计数器功能。Redis<br>这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量</li>
<li>排行榜 集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操<br>作的时候变的非常简单，Redis 只是正好提供了这两种数据结构</li>
<li>会话缓存 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用<br>服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意<br>一个应用服务器，从而更容易实现高可用性以及可伸缩性</li>
</ol>
<h3 id="redis-持久化机制是什么？"><a href="#redis-持久化机制是什么？" class="headerlink" title="redis 持久化机制是什么？"></a>redis 持久化机制是什么？</h3><p>Redis提供了两种不同的持久化方法可以将数据存储在磁盘中，一种叫快照RDB，<br>另一种叫只追加文件AOF</p>
<ol>
<li>RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘(Snapshot)，它<br>恢复时是将快照文件直接读到内存里。Redis 会单独创建(fork)一个子进程来<br>进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再<br>用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何<br>IO 操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于<br>数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB<br>的缺点是最后一次持久化后的数据可能丢失</li>
</ol>
<ul>
<li>优点 适合大规模的数据恢复 对数据完整性和一致性要求不高</li>
<li>缺点 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢<br>失最后一次快照后的所有修改</li>
</ul>
<ol start="2">
<li>AOF 以日志的形式来记录每个写操作，将Redis 执行过的所有写指令记录<br>下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读<br>取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写<br>指令从前到后执行一次以完成数据的恢复工作。<br>AOF保存的是appendonly.aof文件，采用文件追加方式，文件会越来越大为避<br>免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，<br>Redis 就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集</li>
</ol>
<ul>
<li>优点 每次发生数据变更会被立即记录到磁盘,性能较差但数据完整性比较好</li>
</ul>
<h3 id="redis-底层的数据结构？"><a href="#redis-底层的数据结构？" class="headerlink" title="redis 底层的数据结构？"></a>redis 底层的数据结构？</h3><p>有8种底层数据结构</p>
<ol>
<li>string 字符串对象的编码可以是int、raw或者embstr，如果一个字符串的<br>内容可以转换为long，那么该字符串就会被转换成为long类型，对象的ptr就<br>会指向该 long，并且对象类型也用 int 类型表示。普通的字符串有两种，<br>embstr和raw。。如果字符串对象的长度小于39字节，就用embstr对象。否<br>则用传统的raw对象</li>
<li>哈希对象 ziplist或者hashtable</li>
<li>列表对象 ziplist或者linkedlist</li>
<li>集合对象 intset或者hashtable，intset是一个整数集合，里面存的为<br>某种同一类型的整数</li>
<li>有序集合对象 一种是ziplist，另一种是skiplist与dict的结合</li>
</ol>
<h3 id="Redis-常见命令？"><a href="#Redis-常见命令？" class="headerlink" title="Redis 常见命令？"></a>Redis 常见命令？</h3><ol>
<li>string get 、 set 、 del 、 incr、 decr</li>
<li>Hash hget 、hset 、 hdel</li>
<li>List</li>
</ol>
<ul>
<li>lpush+lpop=Stack(栈)</li>
<li>lpush+rpop=Queue（队列）</li>
<li>lpush+ltrim=Capped Collection（有限集合）</li>
<li>lpush+brpop=Message Queue（消息队列）</li>
</ul>
<ol start="4">
<li>Set  sset 、srem、scard、smembers、sismember</li>
<li>zset zadd 、 zrange、 zscore</li>
</ol>
<h3 id="跳跃表是什么？"><a href="#跳跃表是什么？" class="headerlink" title="跳跃表是什么？"></a>跳跃表是什么？</h3><ol>
<li>跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的<br>数据链表。跳跃列表的平均查找和插入时间复杂度都是O(logn)</li>
<li>快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层<br>链表元素的子集，本质是对链表加多级索引</li>
<li>一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两<br>个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到<br>找到需要查找的元素为止</li>
</ol>
<h3 id="字符串类型是怎么实现的？"><a href="#字符串类型是怎么实现的？" class="headerlink" title="字符串类型是怎么实现的？"></a>字符串类型是怎么实现的？</h3><ol>
<li>在redis的字符串类型对象中，底层都是采用的是简单动态字符串SDS<br>数据结构来实现</li>
<li>SDS 也叫简单动态字符串</li>
<li>C 字符串中他本身不记录自身的长度信息，所有为了获取一个C字符串的<br>长度，程序必须遍历整个字符串，对每个字符进行计数，直到遇到空字符为<br>止，时间复杂度O(N)。和C字符串相比SDS在len属性中记录了字符串本身的<br>长度信息，因此获取SDS长度的时间复杂度O(1)，这极大程度上提高了性能</li>
<li>C字符串还会容易产生缓冲区溢出，SDS的空间分配完全杜绝了发生缓冲<br>区溢出的可能性</li>
</ol>
<h3 id="分布式锁是什么？"><a href="#分布式锁是什么？" class="headerlink" title="分布式锁是什么？"></a>分布式锁是什么？</h3><p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调<br>技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个<br>分布式锁</p>
<h3 id="分布式锁应该具备哪些条件？"><a href="#分布式锁应该具备哪些条件？" class="headerlink" title="分布式锁应该具备哪些条件？"></a>分布式锁应该具备哪些条件？</h3><ol>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行</li>
<li>高可用的获取锁与释放锁</li>
<li>高性能的获取锁与释放锁</li>
<li>具备可重入特性</li>
<li>具备锁失效机制，防止死锁</li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li>
</ol>
<h3 id="分布式锁的实现有哪些"><a href="#分布式锁的实现有哪些" class="headerlink" title="分布式锁的实现有哪些"></a>分布式锁的实现有哪些</h3><ol>
<li>Memcached：利用 Memcached 的 add 命令。此命令是原子性操作，只有<br>在key 不存在的情况下，才能add 成功，也就意味着线程得到了锁</li>
<li>Redis：和 Memcached 的方式类似，利用 Redis 的setnx 命令。此命令<br>同样是原子性操作，只有在key 不存在的情况下，才能set 成功</li>
<li>Zookeeper：利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待<br>队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的</li>
<li>Chubby：Google 公司实现的粗粒度分布式锁服务，底层利用了Paxos<br>一致性算法</li>
</ol>
<h3 id="Redis-实现分布式锁？"><a href="#Redis-实现分布式锁？" class="headerlink" title="Redis 实现分布式锁？"></a>Redis 实现分布式锁？</h3><ol>
<li>加锁 使用SETNX指令插入一个键值对，如果Key 已经存在，那么会返回<br>False，否则插入成功并返回 True，说明key 原本不存在，该线程成功得<br>到了锁</li>
<li>当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放<br>锁的最简单方式是执行del 指令</li>
<li>锁超时 如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地<br>释放锁，这块资源将会永远被锁住（死锁），别的线程再也别想进来。所以<br>，setnx 的key 必须设置一个超时时间，以保证即使没有被显式释放，这<br>把锁也要在一定时间后自动释放。setnx 不支持超时参数，所以需要额外<br>的指令 expire</li>
</ol>
<h3 id="Kafka-是什么？"><a href="#Kafka-是什么？" class="headerlink" title="Kafka 是什么？"></a>Kafka 是什么？</h3><ol>
<li>Kafka 是一款基于发布与订阅的消息系统。它一般被称为“分布式提交日<br>志”或者“分布式流平台”。</li>
<li>kafka的目标是实现一个为处理实时数据提供一个统一、高吞吐、低延迟<br>的平台</li>
</ol>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>Jedis是官方推荐的Java连接开发工具</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>连接redis，如果连接不成功尝试关闭防火墙，反正情况很多<br>systemctl stop firewalld.service <img src="/2020/02/29/Redis/16.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis=<span class="keyword">new</span> Jedis(<span class="string">"192.168.8.11"</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//所有的api命令就是对应redis命令</span></span><br><span class="line">        System.out.println(<span class="string">"判断某个键是否存在"</span>+jedis.exists(<span class="string">"money"</span>));</span><br><span class="line">        System.out.println(jedis.set(<span class="string">"username"</span>,<span class="string">"kuangshen"</span>));</span><br><span class="line">        Set&lt;String&gt; keys=jedis.keys(<span class="string">"*"</span>);</span><br><span class="line">        System.out.println(keys);</span><br><span class="line">        System.out.println(jedis.del(<span class="string">"username"</span>));</span><br><span class="line">        System.out.println(jedis.flushDB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis=<span class="keyword">new</span> Jedis(<span class="string">"192.168.8.11"</span>,<span class="number">6379</span>);</span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">        map.put(<span class="string">"name"</span>,<span class="string">"kuangshen"</span>);</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">"user1"</span>, map.toString());</span><br><span class="line">            multi.set(<span class="string">"user2"</span>,map.toString());</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//事实上以下这句根本就没有执行</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            multi.discard();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">"user1"</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><p>底层由jedis替换成了lettuce</p>
<ul>
<li>jedis 采用的直连，多个线程操作是不安全的</li>
<li>lettuce 采用netty，实例可以在多个线程中共享，不存在线程不安全的情况<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
配置连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.host&#x3D;localhost</span><br><span class="line">spring.redis.port&#x3D;6379</span><br></pre></td></tr></table></figure>
RedisTemplate可以操作不同的数据类型，api和Redis指令是对应的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">"user"</span>,<span class="string">"fsd"</span>);</span><br><span class="line">redisTemplate.opsForvalue().get(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h4><p>redis不能直接保存没有序列化的对象，所有对象都需要序列化或者通过jackson<br>转换成字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User(<span class="string">"你好"</span>,<span class="number">2</span>);</span><br><span class="line">        String jsonUser=<span class="keyword">new</span> ObjectMapper().writeValueAsString(user);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"user"</span>,jsonUser);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">"user"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的序列化是JDK的序列化，可以自定义序列化方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    	RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        <span class="comment">//一般直接使用&lt;String,Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; template=<span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=</span><br><span class="line">        <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ObjectMapper om=<span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">//String的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer=<span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">//key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//value的序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/02/29/Redis/">https://skysea-gaoming.github.io/2020/02/29/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/Git/"><i class="fa fa-chevron-left">  </i><span>Git</span></a></div><div class="next-post pull-right"><a href="/2020/02/29/ComputerNetwork/"><span>应用层总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/02/29/Redis/';
  this.page.identifier = '2020/02/29/Redis/';
  this.page.title = 'Redis';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>