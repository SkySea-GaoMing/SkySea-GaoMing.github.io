<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JVM"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>JVM | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#《深入理解计算机系统》-《计算机系统概论》"><span class="toc-number">1.</span> <span class="toc-text">《深入理解计算机系统》 《计算机系统概论》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机系统漫游"><span class="toc-number">2.</span> <span class="toc-text">计算机系统漫游</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#计算机系统"><span class="toc-number">2.1.</span> <span class="toc-text">计算机系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HelloWorld"><span class="toc-number">2.2.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序的编译"><span class="toc-number">2.3.</span> <span class="toc-text">程序的编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在Linux上测试Hello-c"><span class="toc-number">2.4.</span> <span class="toc-text">在Linux上测试Hello.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统硬件的组成"><span class="toc-number">2.5.</span> <span class="toc-text">系统硬件的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序的运行"><span class="toc-number">2.6.</span> <span class="toc-text">程序的运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储设备"><span class="toc-number">2.7.</span> <span class="toc-text">存储设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作系统的抽象概念"><span class="toc-number">2.8.</span> <span class="toc-text">操作系统的抽象概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统之间的网络通信"><span class="toc-number">2.9.</span> <span class="toc-text">系统之间的网络通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">2.10.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信息的存储和表示"><span class="toc-number">3.</span> <span class="toc-text">信息的存储和表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进制间的转换原理"><span class="toc-number">3.1.</span> <span class="toc-text">进制间的转换原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#布尔代数以及C语言运算符"><span class="toc-number">3.2.</span> <span class="toc-text">布尔代数以及C语言运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整数的表示"><span class="toc-number">3.3.</span> <span class="toc-text">整数的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有符号数和无符号数"><span class="toc-number">3.4.</span> <span class="toc-text">有符号数和无符号数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制小数和IEEE浮点数"><span class="toc-number">3.5.</span> <span class="toc-text">二进制小数和IEEE浮点数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#冯诺依曼模型"><span class="toc-number">4.</span> <span class="toc-text">冯诺依曼模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器"><span class="toc-number">4.1.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存"><span class="toc-number">4.2.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理单元"><span class="toc-number">4.3.</span> <span class="toc-text">处理单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制单元"><span class="toc-number">4.4.</span> <span class="toc-text">控制单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一台冯诺依曼机器"><span class="toc-number">4.5.</span> <span class="toc-text">一台冯诺依曼机器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改变执行顺序"><span class="toc-number">4.6.</span> <span class="toc-text">改变执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令周期的控制"><span class="toc-number">4.7.</span> <span class="toc-text">指令周期的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#停机操作"><span class="toc-number">4.8.</span> <span class="toc-text">停机操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LC-3结构"><span class="toc-number">5.</span> <span class="toc-text">LC-3结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ISA"><span class="toc-number">5.1.</span> <span class="toc-text">ISA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存组织"><span class="toc-number">5.2.</span> <span class="toc-text">内存组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器-1"><span class="toc-number">5.3.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令集"><span class="toc-number">5.4.</span> <span class="toc-text">指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作码"><span class="toc-number">5.5.</span> <span class="toc-text">操作码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">5.6.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寻址模式"><span class="toc-number">5.7.</span> <span class="toc-text">寻址模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件码"><span class="toc-number">5.8.</span> <span class="toc-text">条件码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作指令"><span class="toc-number">5.9.</span> <span class="toc-text">操作指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据搬移指令"><span class="toc-number">5.10.</span> <span class="toc-text">数据搬移指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PC相对寻址"><span class="toc-number">5.11.</span> <span class="toc-text">PC相对寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#间接寻址"><span class="toc-number">5.12.</span> <span class="toc-text">间接寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基址偏移寻址"><span class="toc-number">5.13.</span> <span class="toc-text">基址偏移寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#立即数寻址"><span class="toc-number">5.14.</span> <span class="toc-text">立即数寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个例子"><span class="toc-number">5.15.</span> <span class="toc-text">一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制指令"><span class="toc-number">5.16.</span> <span class="toc-text">控制指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个例子-1"><span class="toc-number">5.17.</span> <span class="toc-text">一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMP指令"><span class="toc-number">5.18.</span> <span class="toc-text">JMP指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TRAP指令"><span class="toc-number">5.19.</span> <span class="toc-text">TRAP指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符数统计例子"><span class="toc-number">5.20.</span> <span class="toc-text">字符数统计例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结：数据通路"><span class="toc-number">5.21.</span> <span class="toc-text">总结：数据通路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令周期"><span class="toc-number">5.22.</span> <span class="toc-text">指令周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的机器级表示"><span class="toc-number">6.</span> <span class="toc-text">程序的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#机器级代码"><span class="toc-number">6.1.</span> <span class="toc-text">机器级代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序存储器"><span class="toc-number">6.2.</span> <span class="toc-text">程序存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举个栗子"><span class="toc-number">6.3.</span> <span class="toc-text">举个栗子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据格式"><span class="toc-number">6.4.</span> <span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问信息"><span class="toc-number">6.5.</span> <span class="toc-text">访问信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作数指示符"><span class="toc-number">6.6.</span> <span class="toc-text">操作数指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据存送指令"><span class="toc-number">6.7.</span> <span class="toc-text">数据存送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据传送示例"><span class="toc-number">6.8.</span> <span class="toc-text">数据传送示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算术和逻辑操作"><span class="toc-number">6.9.</span> <span class="toc-text">算术和逻辑操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制"><span class="toc-number">6.10.</span> <span class="toc-text">控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件码-1"><span class="toc-number">6.11.</span> <span class="toc-text">条件码</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582898893694&amp;di=15958b0625c3bcbdd505353b8b5deaa4&amp;imgtype=0&amp;src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F068c0cbf1b1571976ada2e55a53b3a079e1614c5.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">Java forever</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">29</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://tiebapic.baidu.com/forum/w%3D580/sign=65511a41a9096b6381195e583c338733/aeb75982b2b7d0a263e3d9f3dcef76094b369a3d.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JVM</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/02/29/JVM/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/02/29/JVM/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="《深入理解计算机系统》-《计算机系统概论》"><a href="#《深入理解计算机系统》-《计算机系统概论》" class="headerlink" title="《深入理解计算机系统》 《计算机系统概论》"></a>《深入理解计算机系统》 《计算机系统概论》</h2><h2 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h2><h3 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h3><p>计算机系统是由硬件和系统软件组成，它们共同工作来运行应用程序。从一个高级C语言程序的生命<br>周期开始学习计算机系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>首先计算机将这些代码保存到一个Hello.c文件中，文件内容是由文本字符组成。首先计算机并不<br>认识这些字符，计算机只知道0和1，0和1是按照电压的高低决定的。一个文本字符就是由一个字节<br>来表示，而字节又是由0和1组成，所以计算机可以识别。</p>
<ol>
<li>字节是由8个位组成，每位是0或者1。所以Hello.c源程序实际是以0或者1组成的位序列，国际<br>规范Ascall码用唯一一个字节来表示每一个字符，像Hello.c这样的文件称为文本文件，其它文件<br>是二进制文件，字节是存储空间的基本计量单位，一个字节可以表示一个英文字母或半个汉字</li>
<li>系统中的所有信息都是由0和1组成（磁盘中的文件，网络传送的数据，存储器中的数据等），<br>区分不同数据对象的唯一方法就是读取到这些对象的上下文，在不同的上下文中同一个字节序列<br>可能表示整数、浮点数、字符串或者机器指令</li>
<li>源程序指未编译的按照一定的程序设计语言编写的文本文件</li>
<li>位是电子计算机中最小的数据单位，每一位的状态只能是0或1</li>
<li>字由若干字节组成，字的位数称为字长，不同档次的机器有不同的字长，字是计算机进行数据<br>处理和运算的单位</li>
<li>每个字节都有一个整数值，而该整数值对应一个字符 <img src="/2020/02/29/JVM/number28.jpg" alt></li>
<li>UNIX操作系统是由c语言编写的</li>
</ol>
<h3 id="程序的编译"><a href="#程序的编译" class="headerlink" title="程序的编译"></a>程序的编译</h3><p>计算机系统无法读懂高级语言只能够判断0和1，所有高级语言所写的程序必须最终转变为0和1的序<br>列才可以被计算机读懂，这其中需要经过一系列的过程 <img src="/2020/02/29/JVM/number1.jpg" alt><br>UNIX系统上从源文件到目标文件的转化是通过编译器驱动程序完成的，这个翻译的过程可以分为<br>四个阶段，四个阶段一起构成编译系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o Hello Hello.c</span><br></pre></td></tr></table></figure>
<ol>
<li>预处理器 源程序文件经过预处理器处理变为被修改的源程序文件，预处理器读取第一行#开头<br>的命令修改Hello.c文件，第一行#include&lt;stdio.h&gt;命令告诉与处理器读取系统头文件stdio.h<br>的内容，并把它直接插入到程序文本中得到另一个C程序，一般是以.i为文件扩展名</li>
<li>编译器 编译器将文本文件Hello.i编译为文本文件Hello.s，该文件包含汇编语言程序，汇编<br>语言是一种低级语言，汇编语言程序中每条语句都以一种标准的文本格式确切描述一条低级语言指<br>令，汇编语言能为不同的高级语言的不同编译器提供通用的汇编语言指令（在这里遗憾大一下没<br>学好汇编），汇编语言跟硬件有关，不同的硬件可能有不同的指令</li>
<li>汇编器 汇编器将Hello.s翻译成机器语言指令，机器语言是二进制代码表示的计算机能够直接<br>识别和执行的一种机器指令的集合，将这些指令打包成一种叫做可重定位目标程序的格式，并将结<br>果保存在文件Hello.o中，Hello.o是一个二进制文件，它的字节编码是机器预言指令而不是字符<br>，如果打开该文件会发现是一堆乱码</li>
<li>链接器 在Hello.c文件中调用了一个printf函数打印语句，它是每个C编译器都会提供的标准<br>C库中的一个函数，可以直接使用，printf函数存在于一个名为prinf.o的单独预编译好了的目标<br>文件中，这个文件会以某种方式合并到Hello.o文件中，链接器就是负责处理这种合并，结果就会<br>得到一个Hello文件，它是一个可执行目标程序，可以被加载到内存中，由系统运行  </li>
</ol>
<h3 id="在Linux上测试Hello-c"><a href="#在Linux上测试Hello-c" class="headerlink" title="在Linux上测试Hello.c"></a>在Linux上测试Hello.c</h3><ul>
<li>在Linux下创建Hello.c文件 <img src="/2020/02/29/JVM/number2.jpg" alt></li>
<li>预处理 gcc -E Hello.c  上面部分都是stdio.h的内容下面的是主代码内容，主代码内<br>容不改变 <img src="/2020/02/29/JVM/number3.jpg" alt></li>
<li>编译阶段 gcc -S Hello.i <img src="/2020/02/29/JVM/number4.jpg" alt></li>
<li>汇编阶段 gcc -c Hello.s</li>
<li>链接阶段 gcc -o Hello.o</li>
</ul>
<h3 id="系统硬件的组成"><a href="#系统硬件的组成" class="headerlink" title="系统硬件的组成"></a>系统硬件的组成</h3><p>经过以上过程生成的可执行Hello文件已经放在磁盘中，那么该文件是如何运行的呢？<br>简单了解各个组件 <img src="/2020/02/29/JVM/number5.jpg" alt></p>
<ol>
<li>总线 贯穿整个系统的一组电子管道，通常用来传送定长的字节块，也就是字。字的大小与系统<br>有关，在64位系统中一个字是8个字节。总线每次只传送一个字</li>
<li>I/O设备 输入输出设备是系统与外部世界相连的通道，上图有4个IO设备。用户输入的键盘和<br>鼠标，用户输出的显示器，以及用于长期存储数据和程序的磁盘。每个IO设备都通过一个控制器或<br>适配器与IO总线相连。控制器是IO设备本身或系统的主印刷电路板（主板）的芯片组，而适配器<br>则是一块插在主板插槽上的卡。无论如何它们的功能都是在IO总线和IO设备之间传递信息</li>
<li>主存 计算机的一个临时存储设备（内存），在处理器执行程序的时候用来存放程序和程序处理<br>的数据，物理上讲主存是一组动态随机存取存储器（DRAM）芯片组成，逻辑上讲是一个线性的字<br>节数组每个字节都有唯一的地址（数组索引）</li>
<li>处理器 全称中央处理器（CPU），是解释（执行）存储在主存中指令的引擎，处理器的核心是<br>一个字长的存储设备（寄存器），简称程序计数器，任何时候都会指向主存中的某条机器指令，<br>即含有该指令的地址。从系统通电到断电，处理器一直不断执行程序计数器所指向的指令，再更新<br>程序计数器，使其指向下一条指令。处理器看上去是按照非常简单的指令执行模型来操作的，这个<br>模型是由指令集结构决定的。在这个模型中指令按照严格的顺序执行，执行一条执行包含一系列的<br>步骤，处理器从程序计数器指向的存储器读取指令，解释指令中的位，执行该指令指示的简单操作<br>然后更新程序计数器执行下一条指令，这条指令并不一定与存储器刚刚执行的指令相邻。处理器所<br>做的操作是围绕主存、寄存器文件以及算术/逻辑单元（ALU）进行的，寄存器文件是一个小的存<br>储设备，由一些1字长的寄存器组成，每个寄存器都有  唯一的名字，ALU则计算新的数据和地址</li>
<li>CPU在指令的要求下会做如下的操作</li>
</ol>
<ul>
<li>加载 将一个字节或者字从主存中复制到寄存器中，以覆盖寄存器原来的内容</li>
<li>存储 将一个字节或者字从寄存器复制到主存中，以覆盖原来的内容</li>
<li>操作 将两个寄存器的内容复制到ALU中，ALU对这两个字做算术操作，将结果放到一个寄存器<br>中覆盖原来的内容</li>
<li>跳转 从指令本身抽取一个字并将这个字复制到程序计数器（PC）中覆盖原来的内容</li>
</ul>
<h3 id="程序的运行"><a href="#程序的运行" class="headerlink" title="程序的运行"></a>程序的运行</h3><p>如果要在Linux系统中运行该可执行文件，需要将文件名输入到称为shell的应用程序中，shell<br>是一个命令行解释器，它输出一个提示符等待你输入一个命令然后执行该命令，如果该命令行的<br>第一个单词不是一个内置的外壳命令，那么外壳就会认为这是一个可执行文件的名字，就会加载<br>并运行该文件，外壳程序会字符串读入寄存器，然后放到存储器 <img src="/2020/02/29/JVM/number6.jpg" alt><br>命令输入完成后外壳会执行一系列指令加载Hello文件，将Hello目标文件的代码和数据复制到主存<br>，处理器开始执行Hello程序中的main程序中的机器语言指令。这些指令将”Hello World\n”<br>字符串中的字节从主存复制到寄存器文件，再从寄存器复制到显示设备,最终显示在屏幕<br><img src="/2020/02/29/JVM/number7.jpg" alt></p>
<h3 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h3><p>hello程序的指令最初存放在磁盘上，程序加载时被放到主存，当处理器运行程序时又从主存复制<br>到处理器，字符串”Hello World/n”最初存放在磁盘上，后来又复制到主存，后来又复制到显示设备</p>
<ol>
<li>从磁盘加载可执行文件到主存 <img src="/2020/02/29/JVM/number8.jpg" alt></li>
<li>将输出字符串从内存写到显示器 <img src="/2020/02/29/JVM/number9.jpg" alt></li>
<li>高速缓存处理器 根据机械原理，较大的存储设备比较小的存储设备运行地慢，而快速设备的造<br>价远高于同类低速设备，一个典型系统上的磁盘驱动器可能比内存大1000倍，但是对于处理器而言<br>从磁盘驱动器读取一个字的时间开销比从内存读取慢1000倍。<br>一个典型的寄存器文件只能存储几百字节的数据，而内存可以存储几十亿字节的数据，处理器从<br>寄存器文件读取的速度远高于从内存中读取的速度。如何减小由于数据复制产生的开销呢？可以采<br>用更小更快的存储设备，也就是高速缓存存储器，作为暂时的集结区域，用来存放处理器暂时可能<br>需要的信息 <img src="/2020/02/29/JVM/number10.jpg" alt></li>
<li>存储设备的金字塔结构 在处理器和主存之间插入更快更小的存储设备，存储器层次结构的主要<br>思想就是上一层的存储器作为下一层存储器的高速缓存 <img src="/2020/02/29/JVM/number11.jpg" alt></li>
</ol>
<h3 id="操作系统的抽象概念"><a href="#操作系统的抽象概念" class="headerlink" title="操作系统的抽象概念"></a>操作系统的抽象概念</h3><p>操作系统可以看成应用程序和硬件之间的一层软件，应用程序对硬件的操作必须经过操作系统，常<br>见的操作系统有Linux、Windows和Unix <img src="/2020/02/29/JVM/number12.jpg" alt></p>
<ol>
<li>操作系统防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂而又大相径庭的低级硬件设备 <img src="/2020/02/29/JVM/number13.jpg" alt></li>
<li>进程 运行Hello程序的时候操作系统会提供一种假象好像系统只有这个程序在运行，处理器好<br>像不间断地一条条执行程序中的命令，好像程序中的代码和数据是系统中的唯一对象，这其实是<br>一种假象。进程是操作系统对一种正在运行的程序的一种抽象，在一个系统上可以运行多个进程，<br>每个进程都好像在独占地使用硬件，实际上它们是并发执行的，即一个进程的指令和另一个进程的<br>指令是交替运行，在多数操作系统中需要运行的进程数是多于CPU数的</li>
<li>在单CPU中系统在一个时刻只能运行一个进程，多核CPU中系统可以一个时刻处理多个进程，但<br>是不管单核还是多核一个核只能并发执行多个进程，这是通过处理器在进程之间切换实现的，而<br>操作系统实现这种交错机制称为上下文切换</li>
<li>上下文 操作系统保持跟踪进程运行所需的所有状态信息，比如PC和寄存器文件的当前值，主<br>存的内容。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，<br>保存当前进程上下文，恢复新进程上下文 <img src="/2020/02/29/JVM/number14.jpg" alt></li>
<li>通常认为一个进程只有一个单一的控制流，但是现在的操作系统中一个进程可以由多个称为<br>线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。<br>由于网络服务器对并行处理的需求，线程称为越来越重要的编程模型，多线程比多进程更容易<br>共享数据，而且线程一般比进程更高效</li>
<li>虚拟存储器 虚拟存储器是一个抽象的概念，为每一个进程提供了假象，每个进程都在独占地<br>使用内存，每个进程看到的是一致的存储器，称为虚拟地址空间。也就是当内存不够用时将一部分<br>硬盘空间充当内存缓解内存的紧张。以下是Linux系统的虚拟内存，地址是由下往上增大的<br><img src="/2020/02/29/JVM/number15.jpg" alt></li>
<li>在Linux系统中地址空间最上面的区域是为操作系统中的代码和数据保留的，这对所有进程是<br>一致的，地址空间的底部区域存放用户进程定义的代码和数据，上图的地址从下往上是增大的</li>
<li>程序代码和数据 对于所有进程来说代码是从同一固定位置开始，紧接着是全局变量相对应<br>的数据位置</li>
<li>堆 代码和数据区后紧随的是运行时堆，代码和数据区在进程一开始就规定了大小，而当调用<br>了malloc或free这样的C标准库函数时，堆可以在运行时动态扩展和收缩</li>
<li>共享库 存放像C标准库和数据库这样的代码和数据的区域</li>
<li>栈 位于用户虚拟地址空间的顶部，编译器用它实现函数调用，用户栈在程序执行期间可以动<br>态扩展和收缩，调用一个函数时栈会增长，一个函数返回时栈会收缩</li>
<li>内存虚拟存储器 内核总是驻留在内存中，是操作系统的一部分，不允许应用程序读写这个区<br>域的内容或者直接定义内核代码的函数</li>
</ol>
<h3 id="系统之间的网络通信"><a href="#系统之间的网络通信" class="headerlink" title="系统之间的网络通信"></a>系统之间的网络通信</h3><p>从一个单独的系统看网络可以视为一个IO设备，当系统从内存将一串字节复制到网络适配器时，<br>数据流经过网络到达另一台机器，而不是本地磁盘驱动器之类的地方。相似地系统可以读取从<br>其他机器发送来的数据，并把数据复制到自己的内存 <img src="/2020/02/29/JVM/number29.jpg" alt> <img src="/2020/02/29/JVM/number30.jpg" alt></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>多核处理器 <img src="/2020/02/29/JVM/number31.jpg" alt> <img src="/2020/02/29/JVM/number32.jpg" alt></li>
</ol>
<h2 id="信息的存储和表示"><a href="#信息的存储和表示" class="headerlink" title="信息的存储和表示"></a>信息的存储和表示</h2><ol>
<li>计算机中所有的信息都以二进制的形式表示，也就是0和1组成的序列，大多数计算机使用字节<br>来作为最小的可寻址的存储器单位，而不是在存储器中访问单独的位，也就是我们访问的计算机最<br>小的单位是8个位构成的字节而不是单个位</li>
<li>程序会将存储器作为一个非常大的字节数组，称为虚拟存储器，存储器的每一个字节都由唯一<br>的数字来标识，也就是地址，所有可能的地址集合称为虚拟地址空间，比如C语言的一个指针的值<br>无论该指针指向一个整数、一个结构或是其他程序对象，都是某个存储块的第一个字节的虚拟地址</li>
<li>16进制表示法 一个字节是8位，二进制表示就是从00000000到11111111，十进制就是0到255<br>16进制使用数字0到9字母A到F,一般使用0x或0X开头 <img src="/2020/02/29/JVM/number33.jpg" alt> <img src="/2020/02/29/JVM/number34.jpg" alt></li>
<li>字 每个计算机都有一个字长，指明整数和指针数据的标称大小。64位字长程序最多访问2^64个<br>字节计算机进行加工处理一次存取加工和传送的数据长度称为字，一个字通常有多个字节组成，<br>虚拟空间中的地址就是用一个字来编码，字长决定了虚拟空间地址的最大大小</li>
<li>数据大小 在64位系统指针大小是8个字节 <img src="/2020/02/29/JVM/number16.jpg" alt></li>
<li>寻址和字节顺序 在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址<br>为所使用字节中最小的地址，比如一个类型为int的变量x地址为0x100,那么地址表达式&amp;x的值<br>就是0x100,x的4个字节被存储在存储器的0x100,0x101,0x102,0x123</li>
<li>小端法 按照从最低有效字节到最高有效字节的顺序存储对象，也就是最低有效字节在最前面</li>
<li>大端法 按照从最高有效字节到最低有效字节的顺序存储对象，也就是最高有效直接在最前面</li>
<li>字节排列的方式有两种，必须遵循已建立的关于字节顺序的规则 <img src="/2020/02/29/JVM/number17.jpg" alt></li>
<li>数据类型 计算机在解释一个数据类型的值时主要有4个因素</li>
</ol>
<ul>
<li>位排列顺序</li>
<li>起始位置</li>
<li>数据类型的字节数</li>
<li>数据类型的解释方式</li>
</ul>
<ol start="11">
<li>ISO C90标准下有符号和无符号整数字面量按照无符号数比较，整数变量按照有符号比较，<br>ISO C99将无符号常量看成long long类型，无符号数的运算按照无符号数处理</li>
</ol>
<h3 id="进制间的转换原理"><a href="#进制间的转换原理" class="headerlink" title="进制间的转换原理"></a>进制间的转换原理</h3><p>用一组固定的数字和一套统一的规则来表示数目的方法称为数制，进位计数制的数码所表示的<br>数值大小则与它在数中所取得位置有关，常见的有二进制，十进制，十六进制</p>
<ol>
<li>数码 用来表示进制数的元素，比如二进制位0和1，十进制为0,1,2,3,4,5,6,7,8,9</li>
<li>基数 数码的个数 比如二进制基数为2，十六进制基数为16</li>
<li>位权 数制中固定位置对应的单位值称为位权，对于N进制，整数部分第i位为N^(i-1)，小<br>数部分第j位为N^(-j) <img src="/2020/02/29/JVM/number18.jpg" alt></li>
<li>二进制转换为十进制 （10.10101）2=（1x2^1+0x2^0+1x2^-1+0x2^-2+1x2^-3+<br>0x2^-4+1x2^-5）=（2+0+0.5+0+0.125+0+0.03125）10=（2.65625）10</li>
<li>二进制转换为十六进制 每4位2进制数对应1个十六进制数，以小数点为界整数位从右向左<br>每4位隔开，不足4位用0填补，小数位从左向右每4位隔开，不足4位用0填补（10.10101）2=<br>（0010.1010 1000）2=（2.A8）16</li>
<li>十进制转换为2进制 以小数点为界，整数部分除以2，每次得到商和余数，用商继续除以2，<br>第一次得到的余数作为2进制的个位，第二次得到的余数作为2进制的十位，依次类推，最后一次<br>得到的小于2的商为最高位。小数部分先乘2，然后获得运算结果的整数部分，将结果中的小数部<br>分继续乘2，直到小数部分为0，第一次得到的整数部分作为二进制小数的最高位，依次类推<br>（93）10=（1011101）2<br>（0.3125）10=（0.0101）2</li>
</ol>
<h3 id="布尔代数以及C语言运算符"><a href="#布尔代数以及C语言运算符" class="headerlink" title="布尔代数以及C语言运算符"></a>布尔代数以及C语言运算符</h3><ul>
<li>~ 位级运算非</li>
<li>&amp; 位级运算与 逻辑运算&amp;&amp;有短路功能</li>
<li>| 位级运算或 逻辑运算||有短路功能</li>
<li>^ 位级运算异或</li>
<li>! 逻辑运算非<br><img src="/2020/02/29/JVM/number19.jpg" alt> <img src="/2020/02/29/JVM/number20.jpg" alt></li>
</ul>
<ol>
<li>移位运算 &lt;&lt; k 丢弃最高位的k位低位补k个0 ，移位从左至右是可结合的</li>
<li><blockquote>
<blockquote>
<p>支持两种形式的右移，逻辑右移和算术右移。逻辑右移左端补k个0，算术右移在左端补k个<br>最高有效位的值。Java中 &gt;&gt;k为算术右移 &gt;&gt;&gt;k为逻辑右移。无符号数必须逻辑右移，有符号数可以<br>逻辑右移也可以算术右移，然而几乎所有机器都对有符号数使用算术右移。加减法的优先级比移位<br>运算要高  <img src="/2020/02/29/JVM/number21.jpg" alt></p>
</blockquote>
</blockquote>
</li>
</ol>
<h3 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h3><p>整数分为两种，一种是非负数，另一种是有符号数。Java只支持后者 <img src="/2020/02/29/JVM/number22.jpg" alt></p>
<ol>
<li>C语言数据类型可以用来指定大小，同时可以指定表示的是负数还是非负数</li>
<li>C语言标准所定义的每种数据类型所能表示的最小取值范围 <img src="/2020/02/29/JVM/number23.jpg" alt></li>
<li>由图可知正数和负数的取值范围是对称的</li>
<li>无符号数的编码 即用unsigned声明，无符号的二进制，对于任意一个w位的无符号序列，都存<br>在唯一一个整数介于0到2^w-1 <img src="/2020/02/29/JVM/number24.jpg" alt></li>
<li>反码和原码 原码：一个整数按照绝对值大小转换为二进制数，最高位为符号位<br>反码： 将原码的最高位外其余位取反，正数的反码为原码<br>补码： 反码最低位加1<br>对于正数反码补码和原码都一样，符号位为0，数值位相同。目前几乎所有的机器都使用补码</li>
</ol>
<h3 id="有符号数和无符号数"><a href="#有符号数和无符号数" class="headerlink" title="有符号数和无符号数"></a>有符号数和无符号数</h3><p>有符号数和无符号数之间的转换的一般规则是，数值可能改变但是位模式不变,无符号数一般带u<br>在C语言中当执行一个运算，如果有一个运算数是无符号数另一个是有符号数会隐式地将有符号<br>参数转换为无符号数 <img src="/2020/02/29/JVM/number35.jpg" alt> <img src="/2020/02/29/JVM/number36.jpg" alt> <img src="/2020/02/29/JVM/number37.jpg" alt></p>
<ol>
<li>扩展一个数字的位 将一个无符号数转换为一个更大的数据类型，只需要在前面添加0。将一个<br>补码数字转换成一个更大的数据类型，只需要在开头添加符号位。一个数据大小到另一个数据大小<br>的转换一般默认是先改变大小，然后改变符号</li>
<li>截断数字 将一个w位的数截断为一个k位的数，只需要高位截断w-k位 <img src="/2020/02/29/JVM/number38.jpg" alt></li>
<li>无符号数加法 <img src="/2020/02/29/JVM/number39.jpg" alt></li>
<li>有符号数加法 <img src="/2020/02/29/JVM/number40.jpg" alt></li>
<li>无符号乘法 <img src="/2020/02/29/JVM/number41.jpg" alt></li>
<li>有符号乘法 <img src="/2020/02/29/JVM/number42.jpg" alt></li>
</ol>
<h3 id="二进制小数和IEEE浮点数"><a href="#二进制小数和IEEE浮点数" class="headerlink" title="二进制小数和IEEE浮点数"></a>二进制小数和IEEE浮点数</h3><p>二进制小数不像整数一样只要位数足够就可以表示所有整数，仅考虑有限长度的编码，二进制小数<br>无法精确表示任意小数，比如0.2，只能增加二进制长度提高表示的精度 <img src="/2020/02/29/JVM/number25.jpg" alt></p>
<ol>
<li>IEEE浮点数标准 <img src="/2020/02/29/JVM/number43.jpg" alt></li>
<li>单精度浮点数s exp frac分别为1位 k=8位 n=23位，得到一个32位表示</li>
<li>双精度浮点数s exp frac分别为1位 k=11位 n=52位，得到一个64位表示 <img src="/2020/02/29/JVM/number44.jpg" alt></li>
<li>对于单精度值分为三种情况 <img src="/2020/02/29/JVM/number45.jpg" alt></li>
<li><img src="/2020/02/29/JVM/number47.jpg" alt> <img src="/2020/02/29/JVM/number48.jpg" alt> <img src="/2020/02/29/JVM/number49.jpg" alt> <img src="/2020/02/29/JVM/number50.jpg" alt></li>
</ol>
<h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><ol>
<li>逻辑电路分为两种，一类可以存储信息，一类不能存储信息</li>
<li>基本部件 程序是计算机指令的集合，每条指令对应计算机的一个基本动作，指令是程序的<br>最小单位，一条指令那么完全指令，要么完全不执行，无法只执行部分指令</li>
<li>冯诺依曼模型分为5个部分</li>
</ol>
<ul>
<li>内存 存放程序</li>
<li>处理单元 </li>
<li>输入</li>
<li>输出</li>
<li>控制单元 负责指令的有序执行<br><img src="/2020/02/29/JVM/number51.jpg" alt></li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>计算机处理的数据都是由多个bit构成，LC-3在大多数情况下都是用16-bit来表示数据，有必要<br>将这些bit存储为各个独立的单元。寄存器就是这样一种结构，能够将多个bit组合成一个独立的<br>单元。寄存器的bit宽度可大可小，在LC-3中PC、IR和MAR等寄存器的宽度都是16bit，而N Z P<br>都是1bit宽度的寄存器</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ol>
<li>内存一定数目的“位置”组成，每个位置可以被单独识别并独立存放一个数据，通常称位置识别<br>符为地址，又称存储在各个位置中的bit数目为寻址能力。比如一个厂商说这个PC机有16MB的内存<br>就是说计算机有16MB个内存位置，每个位置能够容纳一个字节的信息</li>
</ol>
<ul>
<li>内存中可以独立识别的位置总数称为寻址空间</li>
<li>每个内存位置包含的bit数称为寻址能力，原先的计算机在数据处理或接收键盘输入时都会转<br>为8-bit的ASCLL，一个ASCLL刚好占用一个存储位置，方便读写和修改。用于科学计算的大型计<br>算机一般采用64-bit寻址，因为可以表示一个浮点数</li>
</ul>
<ol start="2">
<li>今天的计算机都是2^28-8-bit模式，内存的寻址空间是2^28，每个单元可存储8bit信息，也<br>就是寻址能力为8位，每个单元都具备唯一的28位地址。对于LC-3的ISA定义中，LC-3的寻址空间<br>是2^16，寻址能力是16位</li>
<li>访问内存的第一步是向内存提供被访问内存单元的地址</li>
</ol>
<ul>
<li>读操作 首先将被访问内存单元的地址放入CPU的内存地址寄存器，然后发送信号通知内存，内存<br>将该单元存放的数据传送到内存数据寄存器</li>
<li>写操作 首先将内存单元的地址放入MAR寄存器，然后将写入的数据放入MDR寄存器，最后向内存<br>发送写信号，MDR的内容被写入MDR指向的内存单元</li>
<li>左边的内容代表地址（0到7），每个单元包含一个8位信息 <img src="/2020/02/29/JVM/number52.jpg" alt></li>
</ul>
<h3 id="处理单元"><a href="#处理单元" class="headerlink" title="处理单元"></a>处理单元</h3><ol>
<li>处理单元是信息真正被处理的地方，它由很多功能单元组成，每个功能单元负责一个功能，<br>比如除法操作、求平方根等功能单元。</li>
<li>ALU是最简单的功能单元，ALU是算术逻辑运算单元的缩写，ALU所能完成的功能包括基本运算<br>（ADD SUBTRACT）和基本逻辑操作（AND NOT OR）</li>
<li>ALU所能处理的量化大小通常被称为计算机的字长，而量化的基本单位被称为一个字，比如<br>LC-3的ALU所能处理的量化大小是16bit，所以称LC-3是一个16bit位的机器，大部分计算机是<br>64位的</li>
<li>通常会为ALU在其附近配备少量存储器，以便存放最近生成的中间计算结果，比如在(A+B)*C<br>的计算过程中，可能将A+B的结果存放在内存中，然后与C相乘时再从内存中读出，相比ADD和<br>MULTIPLY两次运算操作，两次内存访问占据太多时间，几乎所有计算机都为ALU配备临时存储空间<br>用来存放A+B的结果。临时存储器最常见的设计方式就是一组寄存器，每个寄存器的宽度应该与<br>ALU处理数据的宽度一致，每个寄存器存放一个字，LC-3中有8个临时寄存器，每个宽度是16bit</li>
</ol>
<h3 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h3><ol>
<li>用来控制所有其他单元之间的协同工作，在计算机的逐步执行过程中，既负责控制程序执行<br>过程的每一步，又负责控制其中每条指令执行的每一步</li>
<li>控制单元有几个特殊的寄存器，一是指令寄存器，保存正在被执行的那条指令，二是PC寄存器<br>用来指示下一条待处理的指令，该寄存器被命名为程序计数器，也可以叫做指令指针，因为该寄存<br>器的内容实际上是指向下一个待处理指令的地址</li>
</ol>
<h3 id="一台冯诺依曼机器"><a href="#一台冯诺依曼机器" class="headerlink" title="一台冯诺依曼机器"></a>一台冯诺依曼机器</h3><p><img src="/2020/02/29/JVM/number55.jpg" alt></p>
<ul>
<li>内存 包括存储单元以及MAR和MDR，MAR是16-bit宽度，意味着LC-3最大可寻址空间是2^16,<br>MDR也是16-bit，意味着每个存储单元存储16-bit信息</li>
<li>处理单元 包括一个算术逻辑单元（ALU）和8个寄存器（R0~R7)，这8个寄存器作为临时寄存器<br>用以存放近期被后面指令使用的操作数，ALU只实现一种运算操作（ADD）和两种逻辑操作AND NOT</li>
<li>控制单元 包含所有与信息处理控制相关的结构，其中最重要的一个结构就是有限状态机，它控<br>制着系统的所有活动，运算或处理操作时一步一步完成的，具体地说是一个接一个时钟周期有序操<br>作的</li>
<li>指令是计算机执行的最小单位，指令本身又由操作码和操作数组成，操作码表示指令是做什么<br>的，操作数表示该次操作的对象是哪些，LC-3的指令长度是16位，bit[15:12]是操作码，剩余的<br>是操作数 <img src="/2020/02/29/JVM/number53.jpg" alt> <img src="/2020/02/29/JVM/number54.jpg" alt></li>
</ul>
<ol>
<li>指令周期 指令的处理过程是在控制单元的控制下精确地一步步完成的，称这个执行的顺序是<br>指令周期。每一步称为节拍，一个指令周期称为6个节拍</li>
</ol>
<ul>
<li>FETCH 该节拍负责从内存中读取下一条待执行的指令，并将其装入控制单元的指令寄存器IR，<br>一个计算机程序是一组指令的集合，每条指令又表示为一个bit序列集合，在冯诺依曼模型中指出<br>程序执行时整个程序的所有指令都必须保存在内存中，要获取下一条指令前提是知道它在内存中的<br>准确位置，程序计数器PC就是负责记录下一条指令在内存中的位置 <img src="/2020/02/29/JVM/number56.jpg" alt><br>之后指令解进入译码节拍，由于当前指令完成之后还要读取下一条指令，这是PC内容应该修改为<br>指向下一条指令的地址，所以在当前FETCH节拍还应该补充一个动作，即修改PC寄存器的内容，<br>称之为PC增量，在下一条指令的FETCH节拍，下一个内存单元的指令会自动装入IR</li>
<li>DECODE <img src="/2020/02/29/JVM/number57.jpg" alt></li>
<li>EVALUATE ADDRESS <img src="/2020/02/29/JVM/number58.jpg" alt></li>
<li>FETCH OPERAND <img src="/2020/02/29/JVM/number59.jpg" alt></li>
<li>EXECUTE <img src="/2020/02/29/JVM/number60.jpg" alt></li>
<li>STORE RESULT <img src="/2020/02/29/JVM/number61.jpg" alt> <img src="/2020/02/29/JVM/number62.jpg" alt> <img src="/2020/02/29/JVM/number63.jpg" alt></li>
</ul>
<h3 id="改变执行顺序"><a href="#改变执行顺序" class="headerlink" title="改变执行顺序"></a>改变执行顺序</h3><ol>
<li>指令分为运算指令（ADD）、数据搬移指令（LDR）、控制指令</li>
<li>控制指令可以改变程序的执行顺序，任意的指令周期都是从PC的内容装载到MAR开始的，如果要<br>改变程序执行的顺序，那么必须在一条指令的取指令节拍，即在PC+1之后与下一条指令的取指令<br>之前的这段期间内，修改程序计数器PC的值，控制指令在指令的执行节拍来修改PC的内容，覆盖<br>之前取指令节拍PC+1后的值，该控制指令执行完成后，在下一个指令周期开始时，计算机访问PC<br>获得的地址值，是由控制执行在执行节拍换入的新地址值，而不是之前PC+1后的地址值<br><img src="/2020/02/29/JVM/number64.jpg" alt></li>
</ol>
<h3 id="指令周期的控制"><a href="#指令周期的控制" class="headerlink" title="指令周期的控制"></a>指令周期的控制</h3><ol>
<li>一个指令周期包含6个节拍，每个节拍可分解为若干子步骤，比如取指令节拍需要三个步骤执<br>行才能完成，一是将PC内容装入MAR寄存器，二是读取内存，三是将MDR寄存器内容装入IR寄存器</li>
<li>所有指令节拍的步骤都被控制单元的有限状态机控制 <img src="/2020/02/29/JVM/number65.jpg" alt></li>
</ol>
<h3 id="停机操作"><a href="#停机操作" class="headerlink" title="停机操作"></a>停机操作</h3><p>如果要终止指令周期，只需要清零RUN状态即可，HALT指令可以完成这个功能</p>
<h2 id="LC-3结构"><a href="#LC-3结构" class="headerlink" title="LC-3结构"></a>LC-3结构</h2><h3 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h3><p>ISA是软件命令和硬件执行体之间的接口，ISA向以机器语言编程的程序员提供有关控制机器<br>所需要的所有必要信息，ISA给出了内存组织方式、寄存器组、指令集等信息。也称为指令集体系<br>结构  <img src="/2020/02/29/JVM/number125.jpg" alt></p>
<h3 id="内存组织"><a href="#内存组织" class="headerlink" title="内存组织"></a>内存组织</h3><p><img src="/2020/02/29/JVM/number66.jpg" alt></p>
<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><p>内存读取的速度很慢，LC-3提供临时存储空间，临时存储空间最常见的实现方式是寄存器，<br>LC-3提供了一组寄存器，每个寄存器称为通用寄存器</p>
<ul>
<li>记忆特性 每个寄存器可以存储信息并且能被再次读出，每个寄存器存储的大小是一个字</li>
<li>独立寻址 每个寄存器必须有唯一标识<br>如下是一条指令 <img src="/2020/02/29/JVM/number67.jpg" alt> <img src="/2020/02/29/JVM/number68.jpg" alt></li>
</ul>
<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p><img src="/2020/02/29/JVM/number69.jpg" alt></p>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>有的ISA有一个庞大的指令操作码集合，其中每一个操作码对应计算机的各种功能之一，LC-3的<br>ISA结构定义了15条指令，每条指令对应一个操作码，指令可以分为运算、数据搬移和控制<br><img src="/2020/02/29/JVM/number70.jpg" alt>  <img src="/2020/02/29/JVM/number71.jpg" alt></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="/2020/02/29/JVM/number72.jpg" alt></p>
<h3 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h3><p><img src="/2020/02/29/JVM/number73.jpg" alt></p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p><img src="/2020/02/29/JVM/number74.jpg" alt></p>
<h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><p><img src="/2020/02/29/JVM/number75.jpg" alt> R3的内容是 1010111100001111<br>下图的内容是数据通路中执行NOT有关的关键部分，由于NOT是单操作指令，所以ALU的输入只有<br>A，ALU的信号表名是NOT操作（按位取反操作），源操作数是R5，运算结果写入R3寄存器<br><img src="/2020/02/29/JVM/number76.jpg" alt> <img src="/2020/02/29/JVM/number77.jpg" alt> <img src="/2020/02/29/JVM/number78.jpg" alt><br><img src="/2020/02/29/JVM/number79.jpg" alt> <img src="/2020/02/29/JVM/number80.jpg" alt></p>
<h3 id="数据搬移指令"><a href="#数据搬移指令" class="headerlink" title="数据搬移指令"></a>数据搬移指令</h3><p><img src="/2020/02/29/JVM/number81.jpg" alt></p>
<h3 id="PC相对寻址"><a href="#PC相对寻址" class="headerlink" title="PC相对寻址"></a>PC相对寻址</h3><p><img src="/2020/02/29/JVM/number82.jpg" alt> <img src="/2020/02/29/JVM/number83.jpg" alt></p>
<h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p><img src="/2020/02/29/JVM/number84.jpg" alt> <img src="/2020/02/29/JVM/number85.jpg" alt></p>
<h3 id="基址偏移寻址"><a href="#基址偏移寻址" class="headerlink" title="基址偏移寻址"></a>基址偏移寻址</h3><p><img src="/2020/02/29/JVM/number86.jpg" alt> <img src="/2020/02/29/JVM/number87.jpg" alt></p>
<h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p><img src="/2020/02/29/JVM/number88.jpg" alt> <img src="/2020/02/29/JVM/number89.jpg" alt></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p><img src="/2020/02/29/JVM/number90.jpg" alt> <img src="/2020/02/29/JVM/number91.jpg" alt> <img src="/2020/02/29/JVM/number92.jpg" alt></p>
<h3 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h3><p><img src="/2020/02/29/JVM/number93.jpg" alt> <img src="/2020/02/29/JVM/number94.jpg" alt> <img src="/2020/02/29/JVM/number95.jpg" alt><br><img src="/2020/02/29/JVM/number96.jpg" alt> <img src="/2020/02/29/JVM/number97.jpg" alt></p>
<h3 id="一个例子-1"><a href="#一个例子-1" class="headerlink" title="一个例子"></a>一个例子</h3><p><img src="/2020/02/29/JVM/number98.jpg" alt> <img src="/2020/02/29/JVM/number99.jpg" alt> <img src="/2020/02/29/JVM/number100.jpg" alt><br><img src="/2020/02/29/JVM/number101.jpg" alt> <img src="/2020/02/29/JVM/number102.jpg" alt> <img src="/2020/02/29/JVM/number103.jpg" alt><br><img src="/2020/02/29/JVM/number104.jpg" alt> <img src="/2020/02/29/JVM/number105.jpg" alt></p>
<h3 id="JMP指令"><a href="#JMP指令" class="headerlink" title="JMP指令"></a>JMP指令</h3><p><img src="/2020/02/29/JVM/number106.jpg" alt> <img src="/2020/02/29/JVM/number107.jpg" alt></p>
<h3 id="TRAP指令"><a href="#TRAP指令" class="headerlink" title="TRAP指令"></a>TRAP指令</h3><p><img src="/2020/02/29/JVM/number108.jpg" alt></p>
<h3 id="字符数统计例子"><a href="#字符数统计例子" class="headerlink" title="字符数统计例子"></a>字符数统计例子</h3><p><img src="/2020/02/29/JVM/number109.jpg" alt><br>循环体每执行一遍处理一个，这里采用哨兵方法，即EOT作为哨兵字符<br><img src="/2020/02/29/JVM/number110.jpg" alt> <img src="/2020/02/29/JVM/number111.jpg" alt> <img src="/2020/02/29/JVM/number112.jpg" alt><br><img src="/2020/02/29/JVM/number113.jpg" alt> <img src="/2020/02/29/JVM/number114.jpg" alt></p>
<h3 id="总结：数据通路"><a href="#总结：数据通路" class="headerlink" title="总结：数据通路"></a>总结：数据通路</h3><p><img src="/2020/02/29/JVM/number115.jpg" alt> <img src="/2020/02/29/JVM/number116.jpg" alt> <img src="/2020/02/29/JVM/number117.jpg" alt><br><img src="/2020/02/29/JVM/number118.jpg" alt> 扩展（即在不满16位的数值前填充0，补够16位宽度）</p>
<h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p><img src="/2020/02/29/JVM/number119.jpg" alt> <img src="/2020/02/29/JVM/number120.jpg" alt></p>
<h2 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h2><ol>
<li>老师说LC-3其实没什么用，但我还是复习了一下LC-3并总结了一下。</li>
<li>计算机执行机器代码，用字节序列编码低级的操作，包括数据处理、管理存储器、读写存储设<br>备上的数据，以及网络通信。GCC c编译器以汇编代码的形式产生输出，汇编代码是机器<br>代码的文本表示给出程序的每一条指令，然后GCC调用汇编器和链接器，根据汇编代码生成可执<br>行的机器代码</li>
<li>机器语言 计算机不能够直接识别C程序或者Java程序，只能识别机器语言，机器语言用二进制<br>代码表示的计算机能够直接识别和执行的一种机器指令系统的集合。本章会讲解两种机器语言。<br>是处理器执行的字节级程序</li>
</ol>
<ul>
<li>Intel IA32 大多数计算机的主导语言</li>
<li>x86-64  IA32在64位上的扩展</li>
</ul>
<ol start="4">
<li>汇编语言 汇编语言的主体是汇编指令，汇编指令和机器指令的差别在于指令的表示方法上，汇<br>编指令是机器指令便于记忆的书写格式 <img src="/2020/02/29/JVM/number27.jpg" alt> <img src="/2020/02/29/JVM/number121.jpg" alt></li>
<li>汇编语言指令是机器指令的一种符号表示，而不同的CPU有不同的机器指令系统，也就有不同的<br>汇编语言，所以汇编语言程序与机器有密切关系，所以除了同系列不同型号的CPU有之间的汇编语<br>言程序有一定程度的可移植性，其他类型的CPU无法移植。是机器代码的文本表示</li>
<li>高级语言 高级语言与计算机的硬件结构和指令系统无关，抽象级别较高。用高级语言编写的程<br>序可以在不同的机器上编译和执行，而汇编代码与特定的机器密切相关</li>
<li>汇编语言操作的对象不是具体的数据，而是寄存器或者存储器，也就是说汇编语言直接与<br>寄存器和存储器打交道，因此汇编语言的执行速度比高级语言快。</li>
</ol>
<ul>
<li>机器相关性</li>
<li>高速度和高效率</li>
<li>编写和调试复杂</li>
</ul>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p><img src="/2020/02/29/JVM/number124.jpg" alt> <img src="/2020/02/29/JVM/number127.jpg" alt></p>
<ol>
<li>机器级体系结构 它定义的处理器的状态、指令的格式以及每条指令对状态的影响</li>
<li>机器级程序使用的地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组，存储<br>器系统的实际实现是将多个硬件存储器和操作系统软件结合起来</li>
<li>c语言提供的模型可以在存储器中声明和分配各种数据类型的对象，但是机器代码知识简单地<br>将存储器看成一个很大的按字节寻址的数组</li>
<li>c语言中的聚合数据类型，例如数组和结构，在机器代码中用连续的一组字节来表示。即使是<br>标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分<br>指针和整数</li>
</ol>
<ul>
<li>程序计数器（在IA32中称为PC，用%eip表示） 指示将要执行的下一条指令在存储器中的地址</li>
<li>整数寄存器文件 包含8个命令的位置，分别存储32位的值可以存储一些地址或者整数的数据。<br>有的用来记录某些重要的程序状态，有的用来保存临时数据，比如局部变量和函数的返回值</li>
<li>条件码寄存器 保存最近执行的算术或者逻辑指令的状态信息，它们用来实现控制或者数据流<br>中的条件变化，比如用来实现if和while语句</li>
<li>浮点寄存器 存储浮点数据</li>
<li>高速度和高效率</li>
<li>编写和调试复杂</li>
</ul>
<h3 id="程序存储器"><a href="#程序存储器" class="headerlink" title="程序存储器"></a>程序存储器</h3><ol>
<li>包括程序的可执行代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，<br>以及用户分配的存储器块</li>
<li>程序存储器用虚拟地址来寻址，在任意给定的时刻，只认为有限的虚拟地址是合法的，操作<br>系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器存储器中的物理地址</li>
<li>一条机器指令只执行一个非常基本的操作，例如将存放在寄存器中的两个数字相加，在存储器<br>和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从<br>而实现程序结构</li>
<li>寻址空间 内存中可独立识别的位置总数</li>
<li>寻址能力 每个内存位置中包含的bit数目</li>
<li>Intel术语 字/word/16-bit 双字/double words/32-bit 四字/quad/words/64-bit</li>
</ol>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> accum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t= x+y;</span><br><span class="line">    accum += t;</span><br><span class="line">    <span class="keyword">return</span> t;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum: </span><br><span class="line">   pushl %ebp</span><br><span class="line">   movl  %esp,%ebp</span><br><span class="line">   movl  %12(%ebp),%eax</span><br><span class="line">   addl  8(%ebp),%eax</span><br><span class="line">   addl  %eax,accum</span><br><span class="line">   popl  %ebp</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>

<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ol>
<li>IA32不支持64位整数运算，大多数GCC生成的汇编代码指令都有一个字符后缀，表名操作数的<br>大小，例如数据传送指令有三个变种 <img src="/2020/02/29/JVM/number122.jpg" alt></li>
</ol>
<ul>
<li>movb 传送字节</li>
<li>movw 存送字</li>
<li>movl 存送双字</li>
</ul>
<ol start="2">
<li>x86-64 <img src="/2020/02/29/JVM/number126.jpg" alt></li>
</ol>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>一个IA32中央处理单元(CPU)包含一组8个存储32位值的寄存器，这些寄存器用来存储整数数据<br>和指针，它们的名字都以%e来开头，不过它们都另有特殊的名字。在大多数情况下前六个寄存器<br>可以看成通用寄存器，对它们的使用没有限制，有些指令以固定的寄存器作为源寄存器或者目的<br>寄存器，另外在处理过程中前三个寄存器的保存和恢复惯例不同于接下来的三个寄存器，最后两<br>个寄存器保存程序栈中重要位置的指针，只有根据栈管理的标准惯例才能修改这两个寄存器的值<br>寄存器指令可以独立地读和写前4个寄存器的两个低位字节<br><img src="/2020/02/29/JVM/number123.jpg" alt></p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><ol>
<li>大多数指令有一个或多个操作数，指示出执行一个操作中要引用的源数据值，以及放置结果的<br>目标位置。IA32支持多操作数格式，源数据值可以以常数形式给出，或是从寄存器或存储器读出，<br>结果可以放在寄存器或存储器中</li>
<li>操作数可以分为三种类型</li>
</ol>
<ul>
<li>立即数 也就是常数，书写方式是$后面跟标准C表示法表示的整数，比如$-577 $0x1F，任何一<br>个能放进32位的字里的数值都可以作为立即数，不过汇编器在可能时会使用一个或两个字节的编码</li>
<li>寄存器 对于双字操作，它是8个32位寄存器中的一个(例如%eax)，对于字操作来说，可以是8个<br>16位寄存器中的一个(例如%ax)，对于字节操作来说可以是8个单字节寄存器中的一个(例如%al),<br>用Ea表示任意寄存器a，用引用R[Ea]表示它的值，这是将寄存器集合看成一个数组R，用寄存器<br>标识符作为索引</li>
<li>存储器引用 它会根据计算的地址访问某个存储器位置，因为将存储器看成一个很大的字节数组<br>用符号Mb[Addr]表示对存储在存储器中从地址Addr开始的b个字节的引用</li>
</ul>
<ol start="3">
<li>有多种不同的寻址模式，允许不同的存储器引用</li>
</ol>
<ul>
<li>Imm(Eb,Ei,s)是最常用的形式，这样的引用有4个组成部分，一个立即数偏移Imm，一个基址<br>寄存器Eb，一个变址寄存器Ei和一个比例因子s，引用数组元素时会用到这种通用形式，其他形式<br>都是这种通用形式的特殊情况 <img src="/2020/02/29/JVM/number128.jpg" alt></li>
</ul>
<h3 id="数据存送指令"><a href="#数据存送指令" class="headerlink" title="数据存送指令"></a>数据存送指令</h3><p>数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单<br>的数据传送指令能够完成在好多机器中要好几条指令才能完成的功能。可以把指令分为指令类，一<br>类指令执行相同的操作，只不过操作数的大小不一样 <img src="/2020/02/29/JVM/number129.jpg" alt> <img src="/2020/02/29/JVM/number130.jpg" alt><br><img src="/2020/02/29/JVM/number131.jpg" alt> <img src="/2020/02/29/JVM/number132.jpg" alt> <img src="/2020/02/29/JVM/number133.jpg" alt></p>
<ol>
<li>以上的例子都是将寄存器%eax的低位字节设置为%edx的第二个字节，movb不改变其他三个字节<br>根据源字节的最高位movsbl将其他三个字节全部设置为0或者1，movzbl将其他三个字节全部设置<br>为0</li>
<li>栈 <img src="/2020/02/29/JVM/number135.jpg" alt> <img src="/2020/02/29/JVM/number136.jpg" alt> <img src="/2020/02/29/JVM/number137.jpg" alt> <img src="/2020/02/29/JVM/number138.jpg" alt></li>
</ol>
<h3 id="数据传送示例"><a href="#数据传送示例" class="headerlink" title="数据传送示例"></a>数据传送示例</h3><ol>
<li>过程体 <img src="/2020/02/29/JVM/number139.jpg" alt> <img src="/2020/02/29/JVM/number140.jpg" alt> <img src="/2020/02/29/JVM/number141.jpg" alt></li>
</ol>
<h3 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h3><ol>
<li>有效地址 <img src="/2020/02/29/JVM/number142.jpg" alt> <img src="/2020/02/29/JVM/number143.jpg" alt> <img src="/2020/02/29/JVM/number144.jpg" alt><br><img src="/2020/02/29/JVM/number145.jpg" alt></li>
<li>一元操作和二元操作 <img src="/2020/02/29/JVM/number146.jpg" alt></li>
<li>移位操作  <img src="/2020/02/29/JVM/number147.jpg" alt> <img src="/2020/02/29/JVM/number148.jpg" alt></li>
<li>特殊的算术操作 <img src="/2020/02/29/JVM/number149.jpg" alt> <img src="/2020/02/29/JVM/number150.jpg" alt> <img src="/2020/02/29/JVM/number151.jpg" alt><br><img src="/2020/02/29/JVM/number152.jpg" alt></li>
</ol>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p><img src="/2020/02/29/JVM/number153.jpg" alt> <img src="/2020/02/29/JVM/number154.jpg" alt></p>
<h3 id="条件码-1"><a href="#条件码-1" class="headerlink" title="条件码"></a>条件码</h3><ol>
<li><img src="/2020/02/29/JVM/number155.jpg" alt> <img src="/2020/02/29/JVM/number156.jpg" alt></li>
<li>访问条件码 <img src="/2020/02/29/JVM/number157.jpg" alt> <img src="/2020/02/29/JVM/number158.jpg" alt> <img src="/2020/02/29/JVM/number159.jpg" alt></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/02/29/JVM/">https://skysea-gaoming.github.io/2020/02/29/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/JavaWeb/"><i class="fa fa-chevron-left">  </i><span>JavaWeb</span></a></div><div class="next-post pull-right"><a href="/2020/02/29/Git/"><span>Git</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/02/29/JVM/';
  this.page.identifier = '2020/02/29/JVM/';
  this.page.title = 'JVM';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(http://tiebapic.baidu.com/forum/w%3D580/sign=65511a41a9096b6381195e583c338733/aeb75982b2b7d0a263e3d9f3dcef76094b369a3d.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>