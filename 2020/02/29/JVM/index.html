<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JVM"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>JVM | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#《深入理解计算机系统》"><span class="toc-number">1.</span> <span class="toc-text">《深入理解计算机系统》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HelloWorld"><span class="toc-number">2.1.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本文件"><span class="toc-number">2.2.</span> <span class="toc-text">文本文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序的编译"><span class="toc-number">2.3.</span> <span class="toc-text">程序的编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统硬件的组成"><span class="toc-number">2.4.</span> <span class="toc-text">系统硬件的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储设备"><span class="toc-number">2.5.</span> <span class="toc-text">存储设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">2.6.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信息"><span class="toc-number">3.</span> <span class="toc-text">信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进制间的转换原理"><span class="toc-number">3.1.</span> <span class="toc-text">进制间的转换原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种运算"><span class="toc-number">3.2.</span> <span class="toc-text">三种运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整数的表示"><span class="toc-number">3.3.</span> <span class="toc-text">整数的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制类型转换"><span class="toc-number">3.4.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制小数和IEEE浮点数"><span class="toc-number">3.5.</span> <span class="toc-text">二进制小数和IEEE浮点数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的机器级表示"><span class="toc-number">4.</span> <span class="toc-text">程序的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序编码"><span class="toc-number">4.1.</span> <span class="toc-text">程序编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#机器级代码"><span class="toc-number">4.2.</span> <span class="toc-text">机器级代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序存储器"><span class="toc-number">4.3.</span> <span class="toc-text">程序存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举个栗子"><span class="toc-number">4.4.</span> <span class="toc-text">举个栗子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式的注解"><span class="toc-number">4.5.</span> <span class="toc-text">格式的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据格式"><span class="toc-number">4.6.</span> <span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问信息"><span class="toc-number">4.7.</span> <span class="toc-text">访问信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作数指示符"><span class="toc-number">4.8.</span> <span class="toc-text">操作数指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据存送指令"><span class="toc-number">4.9.</span> <span class="toc-text">数据存送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算术和逻辑操作"><span class="toc-number">4.10.</span> <span class="toc-text">算术和逻辑操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件码"><span class="toc-number">4.11.</span> <span class="toc-text">条件码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跳转"><span class="toc-number">4.12.</span> <span class="toc-text">跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件传送指令"><span class="toc-number">4.13.</span> <span class="toc-text">条件传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch语句"><span class="toc-number">4.14.</span> <span class="toc-text">switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过程"><span class="toc-number">4.15.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转移控制"><span class="toc-number">4.16.</span> <span class="toc-text">转移控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组分配和访问"><span class="toc-number">4.17.</span> <span class="toc-text">数组分配和访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异质的数据结构"><span class="toc-number">4.18.</span> <span class="toc-text">异质的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储器的越界引用和缓冲区溢出"><span class="toc-number">4.19.</span> <span class="toc-text">存储器的越界引用和缓冲区溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x86-64"><span class="toc-number">4.20.</span> <span class="toc-text">x86-64</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理器体系结构"><span class="toc-number">5.</span> <span class="toc-text">处理器体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化程序性能"><span class="toc-number">6.</span> <span class="toc-text">优化程序性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储器层次结构"><span class="toc-number">7.</span> <span class="toc-text">存储器层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链接"><span class="toc-number">8.</span> <span class="toc-text">链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582898893694&amp;di=15958b0625c3bcbdd505353b8b5deaa4&amp;imgtype=0&amp;src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F068c0cbf1b1571976ada2e55a53b3a079e1614c5.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">29</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591954918112&amp;di=2bc6f4358ea0e880687f5ced03157daf&amp;imgtype=0&amp;src=http%3A%2F%2Fyouimg1.c-ctrip.com%2Ftarget%2Ftg%2F620%2F406%2F859%2Fe7db3299a728401eb7b42effae33dadb.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JVM</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/02/29/JVM/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/02/29/JVM/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="《深入理解计算机系统》"><a href="#《深入理解计算机系统》" class="headerlink" title="《深入理解计算机系统》"></a>《深入理解计算机系统》</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>只有了解计算机底层原理才能走的更远。<br>计算机系统是由硬件和系统软件组成，它们共同工作来运行应用程序。<br>如下是一个简单的c语言代码，记为Hello.c文件，接下来简单分析一下它的生命周期。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><p>运行一个程序首先要写程序，写程序肯定就是用英文字符来写，就好像写英文作文一样。<br>但是计算机并不认识这些字符，计算机是一个电子产品内部都是各种电子器件。初中学过物理<br>可以知道电压有高低之分，可以用1和0表示电压的高低。可以将0,1与英文字符联系起来。<br>英文字符一共有26个，加上一些标点符号等等都可以用0和1表示，用8个位就可以表示所有的<br>英文字符加上各种符号。把8个位叫做一个字节。</p>
<ol>
<li>所以Hello.c源程序实际是以0或者1组成的位序列。ASCALL码用唯一一个字节来表示<br>每一个字符，只能表示英文字符和一些标点符号，没有中文字符。</li>
<li>计算机中的所有信息都是由0和1组成  </li>
<li>源程序指未编译的按照一定的程序设计语言（Java，c，c++）编写的文本文件，二进制<br>文件是用0和1表示的</li>
<li>位是电子计算机中最小的数据单位，每一位的状态只能是0或1</li>
<li>每个字节都有一个整数值，而该整数值对应一个字符，每个文本行都是用换行符结束，<br>但是换行符不可见 <img src="/2020/02/29/JVM/number28.jpg" alt></li>
<li>GBK中一个汉字两个字节，UTF-8中一个汉字三个字节</li>
</ol>
<h3 id="程序的编译"><a href="#程序的编译" class="headerlink" title="程序的编译"></a>程序的编译</h3><p>计算机系统无法读懂高级语言只能够判断0和1，所有高级语言所写的程序必须最终转变为0和1<br>的序列才可以被计算机读懂，这其中需要经过一系列的过程 <img src="/2020/02/29/JVM/number1.jpg" alt> </p>
<ol>
<li>预处理器 源程序文件经过预处理器处理变为被修改的源程序文件，预处理器读取第一行#开头<br>的命令修改Hello.c文件，第一行#include&lt;stdio.h&gt;命令告诉与处理器读取系统头文件stdio.h<br>的内容，并把它直接插入到程序文本中得到另一个C程序，一般是以.i为文件扩展名</li>
<li>编译器 编译器将文本文件Hello.i编译为文本文件Hello.s，该文件包含汇编语言程序，汇编<br>语言是一种低级语言，汇编语言程序中每条语句都以一种标准的文本格式确切描述一条低级语言指<br>令</li>
<li>汇编器 汇编器将Hello.s翻译成机器语言指令，机器语言是二进制代码表示的计算机能够直接<br>识别和执行的一种机器指令的集合，Hello.o是一个二进制文件，它的字节编码是机器语言指令而<br>不是字符  </li>
<li>链接器 在Hello.c文件中调用了一个printf函数打印语句，它是每个C编译器都会提供的标准<br>C库中的一个函数，可以直接使用，printf函数存在于一个名为prinf.o的单独预编译好了的目标<br>文件中，这个文件会以某种方式合并到Hello.o文件中，链接器就是负责处理这种合并，结果就会<br>得到一个Hello文件，它是一个可执行目标程序，可以被加载到内存中，由系统运行</li>
</ol>
<h3 id="系统硬件的组成"><a href="#系统硬件的组成" class="headerlink" title="系统硬件的组成"></a>系统硬件的组成</h3><p>经过以上过程生成的可执行Hello文件已经放在磁盘中，那么该文件是如何运行的呢？<br>简单了解各个组件 <img src="/2020/02/29/JVM/number5.jpg" alt></p>
<ol>
<li>总线 贯穿整个系统的一组电子管道，通常用来传送定长的字节块，也就是字。字的大小与系统<br>有关，在64位系统中一个字是8个字节。总线每次只传送一个字</li>
<li>I/O设备 输入输出设备是系统与外部世界相连的通道，它们的功能都是在IO总线和IO设备之间<br>传递信息，上图最下面4个设备就是IO设备</li>
<li>主存 计算机的一个临时存储设备（内存），在处理器执行程序的时候用来存放程序和程序处理<br>的数据，逻辑上讲是一个线性的字节数组每个字节都有唯一的地址（数组索引）</li>
<li>处理器 全称中央处理器（CPU），是解释（执行）存储在主存中指令的引擎，处理器的核心是<br>一个字长的存储设备（或寄存器），简称程序计数器，任何时候都指向主存中的某条机器指令<br>即含有该指令的地址。执行完一条指令之后更新程序计数器执行下一条指令，处理器所做的操作是<br>围绕主存、寄存器文件以及算术/逻辑单元（ALU）进行的，寄存器文件是一个小的存储设备，由一<br>些1字长的寄存器组成，每个寄存器都有唯一的名字，ALU则计算新的数据和地址</li>
<li>CPU在指令的要求下会做如下的操作</li>
</ol>
<ul>
<li>加载 将一个字节或者字从主存中复制到寄存器中，以覆盖寄存器原来的内容</li>
<li>存储 将一个字节或者字从寄存器复制到主存中，以覆盖原来的内容</li>
<li>操作 将两个寄存器的内容复制到ALU中，ALU对这两个字做算术操作，将结果放到一个寄存器<br>中覆盖原来的内容</li>
<li>跳转 从指令本身抽取一个字并将这个字复制到程序计数器（PC）中覆盖原来的内容  </li>
</ul>
<h3 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h3><p>hello程序的指令最初存放在磁盘上，程序加载时被放到主存，当处理器运行程序时又从主存复制<br>到处理器，字符串”Hello World/n”最初存放在磁盘上，后来又复制到主存，后来又复制到显示设备</p>
<ol>
<li>从磁盘加载可执行文件到主存 <img src="/2020/02/29/JVM/number8.jpg" alt></li>
<li>将输出字符串从内存写到显示器 <img src="/2020/02/29/JVM/number9.jpg" alt></li>
<li>高速缓存处理器 根据机械原理，较大的存储设备比较小的存储设备运行地慢，而快速设备的造<br>价远高于同类低速设备，一个典型系统上的磁盘驱动器可能比内存大1000倍，但是对于处理器而言<br>从磁盘驱动器读取一个字的时间开销比从内存读取慢1000倍。<br>一个典型的寄存器文件只能存储几百字节的数据，而内存可以存储几十亿字节的数据，处理器从<br>寄存器文件读取的速度远高于从内存中读取的速度。如何减小由于数据复制产生的开销呢？可以采<br>用更小更快的存储设备，也就是高速缓存存储器，作为暂时的集结区域，用来存放处理器暂时可能<br>需要的信息 <img src="/2020/02/29/JVM/number10.jpg" alt></li>
<li>存储设备的金字塔结构 在处理器和主存之间插入更快更小的存储设备，存储器层次结构的主要<br>思想就是上一层的存储器作为下一层存储器的高速缓存 <img src="/2020/02/29/JVM/number11.jpg" alt></li>
</ol>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>多核处理器 <img src="/2020/02/29/JVM/number31.jpg" alt> <img src="/2020/02/29/JVM/number32.jpg" alt></li>
</ol>
<h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><ul>
<li>无符号数 基于传统的二进制表示法，表示大于或等于0的数</li>
<li>补码 表示有符号整数</li>
<li>浮点数</li>
</ul>
<ol>
<li>16进制表示法 一个字节是8位，二进制表示就是从00000000到11111111，十进制就是0到255<br>16进制使用数字0到9字母A到F（a到f）,一般使用0x或0X开头，如果一个二进制数字位总数不是4<br>的倍数，就在最左边补0。8进制以0开头 <img src="/2020/02/29/JVM/number33.jpg" alt> </li>
<li>如果一个数表示为2^n，而n可以表示为i+4j，那么二进制表示就是1后面加上n个0,16进制表示<br>就是开头根据1(i=0),2(i=1),4(i=2),8(i=3)后面跟j个0</li>
<li>寻址和字节顺序 在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址<br>为所使用字节中最小的地址，比如一个类型为int的变量x地址为0x100,那么地址表达式&amp;x的值<br>就是0x100,x的4个字节被存储在存储器的0x100,0x101,0x102,0x123</li>
<li>小端法 按照从最低有效字节到最高有效字节的顺序存储对象，也就是最低有效字节在最前面</li>
<li>大端法 按照从最高有效字节到最低有效字节的顺序存储对象，也就是最高有效直接在最前面</li>
<li>0x01234567 <img src="/2020/02/29/JVM/number17.jpg" alt></li>
</ol>
<h3 id="进制间的转换原理"><a href="#进制间的转换原理" class="headerlink" title="进制间的转换原理"></a>进制间的转换原理</h3><p>用一组固定的数字和一套统一的规则来表示数目的方法称为数制，进位计数制的数码所表示的<br>数值大小则与它在数中所取得位置有关，常见的有二进制，十进制，十六进制</p>
<ol>
<li>数码 用来表示进制数的元素，比如二进制位0和1，十进制为0,1,2,3,4,5,6,7,8,9</li>
<li>基数 数码的个数 比如二进制基数为2，十六进制基数为16</li>
<li>位权 数制中固定位置对应的单位值称为位权，对于N进制，整数部分第i位为N^(i-1)，小<br>数部分第j位为N^(-j) <img src="/2020/02/29/JVM/number18.jpg" alt></li>
<li>二进制转换为十进制 （10.10101）2=（1x2^1+0x2^0+1x2^-1+0x2^-2+1x2^-3+<br>0x2^-4+1x2^-5）=（2+0+0.5+0+0.125+0+0.03125）10=（2.65625）10</li>
<li>二进制转换为十六进制 每4位2进制数对应1个十六进制数，以小数点为界整数位从右向左<br>每4位隔开，不足4位用0填补，小数位从左向右每4位隔开，不足4位用0填补（10.10101）2=<br>（0010.1010 1000）2=（2.A8）16</li>
<li>十进制转换为2进制 以小数点为界，整数部分除以2，每次得到商和余数，用商继续除以2，<br>第一次得到的余数作为2进制的个位，第二次得到的余数作为2进制的十位，依次类推，最后一次<br>得到的小于2的商为最高位。小数部分先乘2，然后获得运算结果的整数部分，将结果中的小数部<br>分继续乘2，直到小数部分为0，第一次得到的整数部分作为二进制小数的最高位，依次类推<br>（93）10=（1011101）2<br>（0.3125）10=（0.0101）2</li>
</ol>
<h3 id="三种运算"><a href="#三种运算" class="headerlink" title="三种运算"></a>三种运算</h3><ul>
<li>位级运算</li>
<li>逻辑运算</li>
<li>移位运算</li>
</ul>
<ol>
<li>位级运算 </li>
</ol>
<ul>
<li>~01=10</li>
<li>11&amp;00=00</li>
<li>11|01=11</li>
<li>11^01=10</li>
</ul>
<ol start="2">
<li>逻辑运算<br>对第一个参数求值确定表达式结果就不会对第二个参数求值，这点与位级运算不同</li>
</ol>
<ul>
<li>01001||01000=1</li>
<li>10000&amp;&amp;00000=0</li>
<li>!10101=0</li>
</ul>
<ol start="3">
<li>移位运算<br>如果k很大时实际上移动k mod w位，w是数据的组成位数</li>
</ol>
<ul>
<li>&lt;&lt; k 左移k位，右端补k个0</li>
<li>&gt;&gt; k 右移k位，可以分为逻辑右移和算术右移，逻辑右移左端补k个0，算术右移左端<br>补k个最高有效位，对于Java x&gt;&gt;k表示算术右移，x&gt;&gt;&gt;k表示逻辑右移</li>
</ul>
<h3 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h3><ul>
<li>整数分为两种，一种是无符号数，另一种是有符号数。Java只支持后者 <img src="/2020/02/29/JVM/number22.jpg" alt></li>
<li>C语言数据类型可以用来指定大小，同时可以指定表示的是负数还是非负数</li>
</ul>
<ol>
<li>无符号数的编码 即用unsigned声明，无符号的二进制，对于任意一个w位的无符号序列，都存<br>在唯一一个整数介于0到2^w-1，用B2Uw表示 <img src="/2020/02/29/JVM/number24.jpg" alt></li>
<li>有符号数的编码–补码<br>原码：一个整数按照绝对值大小转换为二进制数，最高位为符号位<br>反码： 将原码的最高位外其余位取反，正数的反码为原码<br>补码： 反码最低位加1<br>对于正数反码补码和原码都一样，符号位为0，数值位相同。目前几乎所有的机器都使用补码<br>有符号数表示为B2Tw，B2Tw(X)=-Xw-1*2^(w-1)+∑Xi*2^i(0到w-2)</li>
</ol>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>有符号数和无符号数之间的转换的一般规则是，数值可能改变但是位模式不变,无符号数一般带u<br>在C语言中当执行一个运算，如果有一个运算数是无符号数另一个是有符号数会隐式地将有符号<br>参数转换为无符号数 <img src="/2020/02/29/JVM/number35.jpg" alt> <img src="/2020/02/29/JVM/number36.jpg" alt> <img src="/2020/02/29/JVM/number37.jpg" alt></p>
<ol>
<li>扩展一个数字的位 将一个无符号数转换为一个更大的数据类型，只需要在前面添加0。将一个<br>补码数字转换成一个更大的数据类型，只需要在开头添加符号位。一个数据大小到另一个数据大小<br>的转换一般默认是先改变大小，然后改变符号</li>
<li>截断数字 将一个w位的数截断为一个k位的数，只需要高位截断w-k位 <img src="/2020/02/29/JVM/number38.jpg" alt></li>
<li>无符号数加法 <img src="/2020/02/29/JVM/number39.jpg" alt></li>
<li>有符号数加法 <img src="/2020/02/29/JVM/number40.jpg" alt></li>
<li>补码的非 -X=X=-2^(w-1)?-2^(w-1):-X</li>
<li>无符号乘法 <img src="/2020/02/29/JVM/number41.jpg" alt></li>
<li>有符号乘法 <img src="/2020/02/29/JVM/number42.jpg" alt></li>
</ol>
<h3 id="二进制小数和IEEE浮点数"><a href="#二进制小数和IEEE浮点数" class="headerlink" title="二进制小数和IEEE浮点数"></a>二进制小数和IEEE浮点数</h3><p>二进制表示法可以对形如V=x*2^y的有理数进行编码<br>二进制小数不像整数一样只要位数足够就可以表示所有整数，仅考虑有限长度的编码，二进制小数<br>无法精确表示任意小数，比如0.2，只能增加二进制长度提高表示的精度 <img src="/2020/02/29/JVM/number25.jpg" alt></p>
<ol>
<li>IEEE浮点数标准 <img src="/2020/02/29/JVM/number43.jpg" alt></li>
<li>单精度浮点数s exp frac分别为1位 k=8位 n=23位，得到一个32位表示</li>
<li>双精度浮点数s exp frac分别为1位 k=11位 n=52位，得到一个64位表示 <img src="/2020/02/29/JVM/number44.jpg" alt></li>
<li>根据阶码数值可以分为三种情况 <img src="/2020/02/29/JVM/number45.jpg" alt></li>
<li>NaN Not a Number</li>
<li>规格化的值 阶码的值=E-Bias，其中e是无符号数，Bias=2^(k-1)-1，尾数为M=1+f，这种<br>方式也叫隐含的以1开头</li>
<li>非规格化的值 阶码的值=1-Bias，尾数的值=f，不包含隐含的开头1</li>
<li>特殊值 阶码全为1，小数域全为0时表示无穷，s=0是正无穷，s=1是负无穷</li>
<li><img src="/2020/02/29/JVM/number47.jpg" alt> <img src="/2020/02/29/JVM/number48.jpg" alt> <img src="/2020/02/29/JVM/number49.jpg" alt> <img src="/2020/02/29/JVM/number50.jpg" alt></li>
</ol>
<h2 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h2><ul>
<li>Intel IA32 大多数计算机的主导语言</li>
<li>x86-64  IA32在64位上的扩展</li>
</ul>
<ol>
<li>汇编语言 汇编语言的主体是汇编指令，汇编指令和机器指令的差别在于指令的表示方法上，汇<br>编指令是机器指令便于记忆的书写格式 <img src="/2020/02/29/JVM/number27.jpg" alt> <img src="/2020/02/29/JVM/number121.jpg" alt></li>
<li>汇编语言指令是机器指令的一种符号表示，而不同的CPU有不同的机器指令系统，也就有不同的<br>汇编语言，所以汇编语言程序与机器有密切关系，所以除了同系列不同型号的CPU有之间的汇编语<br>言程序有一定程度的可移植性，其他类型的CPU无法移植。是机器代码的文本表示</li>
<li>高级语言 高级语言与计算机的硬件结构和指令系统无关，抽象级别较高。用高级语言编写的程<br>序可以在不同的机器上编译和执行，而汇编代码与特定的机器密切相关</li>
<li>汇编语言操作的对象不是具体的数据，而是寄存器或者存储器，也就是说汇编语言直接与<br>寄存器和存储器打交道，因此汇编语言的执行速度比高级语言快。</li>
</ol>
<h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -01 -o p p1.c p2.c</span><br></pre></td></tr></table></figure>
<ul>
<li>-01表示一级优化，提高优化级别会使程序运行更快，但是编译时间会变长。</li>
<li>编译器产生两个汇编文件p1.s p2.s，汇编器将两个汇编文件转化为目标代码文件p1.o p2.o，<br>目标代码文件是机器代码的一种形式，包含指令的二进值表示但是没有填入地址的全局值，最后<br>链接器将两个文件与实现库函数的代码合并成可执行文件p，p是处理器执行的代码格式</li>
</ul>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p><img src="/2020/02/29/JVM/number124.jpg" alt> <img src="/2020/02/29/JVM/number127.jpg" alt></p>
<ol>
<li>机器级体系结构 它定义的处理器的状态、指令的格式以及每条指令对状态的影响</li>
<li>机器级程序使用的地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组，存储<br>器系统的实际实现是将多个硬件存储器和操作系统软件结合起来</li>
<li>c语言提供的模型可以在存储器中声明和分配各种数据类型的对象，但是机器代码只是简单地<br>将存储器看成一个很大的按字节寻址的数组</li>
<li>c语言中的聚合数据类型，例如数组和结构，在机器代码中用连续的一组字节来表示。即使是<br>标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分<br>指针和整数</li>
</ol>
<ul>
<li>程序计数器（在IA32中称为PC，用%eip表示） 指示将要执行的下一条指令在存储器中的地址</li>
<li>整数寄存器文件 包含8个命令的位置，分别存储32位的值可以存储一些地址或者整数的数据。<br>有的用来记录某些重要的程序状态，有的用来保存临时数据，比如局部变量和函数的返回值</li>
<li>条件码寄存器 保存最近执行的算术或者逻辑指令的状态信息，它们用来实现控制或者数据流<br>中的条件变化，比如用来实现if和while语句</li>
<li>浮点寄存器 存储浮点数据</li>
<li>高速度和高效率</li>
<li>编写和调试复杂</li>
</ul>
<h3 id="程序存储器"><a href="#程序存储器" class="headerlink" title="程序存储器"></a>程序存储器</h3><ol>
<li>包括程序的可执行代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，<br>以及用户分配的存储器块（malloc）</li>
<li>程序存储器用虚拟地址来寻址，在任意给定的时刻，只认为有限的虚拟地址是合法的，操作<br>系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器存储器中的物理地址</li>
<li>一条机器指令只执行一个非常基本的操作，例如将存放在寄存器中的两个数字相加，在存储器<br>和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从<br>而实现程序结构</li>
<li>寻址空间 内存中可独立识别的位置总数</li>
<li>寻址能力 每个内存位置中包含的bit数目</li>
<li>Intel术语 字/word/16-bit 双字/double words/32-bit 四字/quad/words/64-bit</li>
</ol>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> accum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t= x+y;</span><br><span class="line">    accum += t;</span><br><span class="line">    <span class="keyword">return</span> t;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum: </span><br><span class="line">   pushl %ebp</span><br><span class="line">   movl  %esp,%ebp</span><br><span class="line">   movl  %12(%ebp),%eax</span><br><span class="line">   addl  8(%ebp),%eax</span><br><span class="line">   addl  %eax,accum</span><br><span class="line">   popl  %ebp</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
<ul>
<li>反汇编器 根据目标代码产生类似汇编代码的格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d code.o</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00000000&lt;sum&gt;:</span><br><span class="line">   0 pushl %ebp</span><br><span class="line">   1 movl  %esp,%ebp</span><br><span class="line">   3 movl  0xc(%ebp),%eax</span><br><span class="line">   6 addl  0x8(%ebp),%eax</span><br><span class="line">   9 addl  %eax,0x0</span><br><span class="line">   f popl  %ebp</span><br><span class="line">   10 ret</span><br></pre></td></tr></table></figure></li>
<li>每条指令的长度在1到15个字节不等，常用的指令字节数较少</li>
<li>设计指令的格式是从某个指定位置开始讲字节唯一解码成机器指令</li>
<li>反汇编器只是基于机器代码文件来确定汇编代码</li>
<li>生成实际可执行代码需要目标文件中含有一个main函数，假设main.c中有main函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -01 -o prog code.o main.c</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">08048394&lt;sum&gt;:</span><br><span class="line">   pushl %ebp</span><br><span class="line">   movl  %esp,%ebp</span><br><span class="line">   movl  0xc(%ebp),%eax</span><br><span class="line">   addl  0x8(%ebp),%eax</span><br><span class="line">   addl  01 05 18 a0 04 08   %eax,0x804a018</span><br><span class="line">   popl  %ebp</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure></li>
<li>反汇编后发现汇编代码与之前的汇编代码基本一样，一个主要的区别就是左边列出的地址<br>不同。另一个区别是链接器确定了存储全局变量accum的地址，也可以从指令的最后4个字节<br>得出，因为数据使用小端法表示，所以地址是804a018</li>
</ul>
<h3 id="格式的注解"><a href="#格式的注解" class="headerlink" title="格式的注解"></a>格式的注解</h3><ul>
<li>汇编文件中所有以点开头的行都是指导汇编器和链接器的命令，通常可以忽略</li>
<li>我们使用的都是ATT格式的汇编代码</li>
</ul>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ol>
<li>IA32不支持64位整数运算，大多数GCC生成的汇编代码指令都有一个字符后缀，表明操作数的<br>大小，例如数据传送指令有三个变种 <img src="/2020/02/29/JVM/number122.jpg" alt></li>
</ol>
<ul>
<li>movb 传送字节</li>
<li>movw 存送字</li>
<li>movl 存送双字</li>
</ul>
<ol start="2">
<li>x86-64 <img src="/2020/02/29/JVM/number126.jpg" alt></li>
</ol>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><ul>
<li>一个IA32中央处理单元包含一组8个存储32位值的寄存器</li>
<li>一个x86-64中央处理单元包含16个存储64位值的寄存器<br><img src="/2020/02/29/JVM/number123.jpg" alt> <img src="/2020/02/29/JVM/number161.jpg" alt></li>
</ul>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><ol>
<li>大多数指令有一个或多个操作数，指示出执行一个操作中要引用的源数据值，以及放置结果的<br>目标位置。</li>
<li>三种类型的操作数</li>
</ol>
<ul>
<li>立即数 也就是常数，书写方式是$后面跟标准C表示法表示的整数，比如$-577 $0x1F</li>
<li>寄存器 对于双字操作，它是8个32位寄存器中的一个(例如%eax)，对于字操作来说，可以是8个<br>16位寄存器中的一个(例如%ax)，对于字节操作来说可以是8个单字节寄存器中的一个(例如%al),<br>用Ea表示任意寄存器a，用引用R[Ea]表示它的值，这是将寄存器集合看成一个数组R，用寄存器<br>标识符作为索引</li>
<li>存储器引用 它会根据计算的地址访问某个存储器位置，因为将存储器看成一个很大的字节数组<br>用符号Mb[Addr]表示对存储在存储器中从地址Addr开始的b个字节的引用</li>
</ul>
<ol start="3">
<li>寻址模式</li>
</ol>
<ul>
<li>Imm(Eb,Ei,s)是最常用的形式，这样的引用有4个组成部分，一个立即数偏移Imm，一个基址<br>寄存器Eb，一个变址寄存器Ei和一个比例因子s，引用数组元素时会用到这种通用形式，其他形式<br>都是这种通用形式的特殊情况 <img src="/2020/02/29/JVM/number128.jpg" alt></li>
</ul>
<h3 id="数据存送指令"><a href="#数据存送指令" class="headerlink" title="数据存送指令"></a>数据存送指令</h3><p>数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示的通用性使得一条简单<br>的数据传送指令能够完成在好多机器中要好几条指令才能完成的功能。可以把指令分为指令类，一<br>类指令执行相同的操作，只不过操作数的大小不一样 <img src="/2020/02/29/JVM/number129.jpg" alt> <img src="/2020/02/29/JVM/number130.jpg" alt><br><img src="/2020/02/29/JVM/number131.jpg" alt> <img src="/2020/02/29/JVM/number132.jpg" alt> <img src="/2020/02/29/JVM/number133.jpg" alt></p>
<ol>
<li>以上的例子都是将寄存器%eax的低位字节设置为%edx的第二个字节，movb不改变其他三个字节<br>根据源字节的最高位movsbl将其他三个字节全部设置为0或者1，movzbl将其他三个字节全部设置<br>为0</li>
<li>栈 <img src="/2020/02/29/JVM/number135.jpg" alt> <img src="/2020/02/29/JVM/number136.jpg" alt> <img src="/2020/02/29/JVM/number137.jpg" alt> <img src="/2020/02/29/JVM/number138.jpg" alt></li>
</ol>
<h3 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h3><ol>
<li>有效地址 <img src="/2020/02/29/JVM/number142.jpg" alt> <img src="/2020/02/29/JVM/number143.jpg" alt> </li>
<li>一元操作和二元操作 <img src="/2020/02/29/JVM/number146.jpg" alt></li>
<li>移位操作  <img src="/2020/02/29/JVM/number147.jpg" alt> </li>
<li>特殊的算术操作 <img src="/2020/02/29/JVM/number149.jpg" alt> <img src="/2020/02/29/JVM/number150.jpg" alt> <img src="/2020/02/29/JVM/number151.jpg" alt><br><img src="/2020/02/29/JVM/number152.jpg" alt></li>
</ol>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><ol>
<li><img src="/2020/02/29/JVM/number155.jpg" alt> <img src="/2020/02/29/JVM/number156.jpg" alt></li>
<li>访问条件码 <img src="/2020/02/29/JVM/number157.jpg" alt> <img src="/2020/02/29/JVM/number158.jpg" alt> <img src="/2020/02/29/JVM/number159.jpg" alt></li>
</ol>
<h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><ul>
<li>正常情况指令一条条顺序执行</li>
<li>跳转会切换到一个全新的位置</li>
</ul>
<ol>
<li>无条件跳转，跳转的目的地通常用一个标号指明，也是指令的一部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmp .L1</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">.L1:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>间接跳转，跳转目标是从寄存器或存储器位置中读取出来，写法是 * + 一个操作数指示符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp *%eax #用寄存器的值作为跳转目标</span><br><span class="line">jmp *(%eax) #用寄存器的值作为读地址，从存储器中读取跳转目标</span><br></pre></td></tr></table></figure>
<img src="/2020/02/29/JVM/number162.jpg" alt></li>
<li>PC相关寻址时程序计数器的值是跳转指令后面的那条指令，而不是跳转指令本身，得到反汇编<br>代码后计算跳转地址时要用跳转指令的下一条指令地址加上目标编码</li>
</ol>
<h3 id="条件传送指令"><a href="#条件传送指令" class="headerlink" title="条件传送指令"></a>条件传送指令</h3><p>实现条件操作的传统方式是利用控制的条件转移，但是效率非常低。数据的条件转移是一种替代<br>策略，先计算一个条件操作的两种结果然后根据条件是否满足选择其中一个。<br>v=test-wxpr? then-expr : else-expr  <img src="/2020/02/29/JVM/number163.jpg" alt>  </p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch语句可以根据一个整数索引值进行多重分支，提高可读性以及能通过跳转表实现分支跳转。<br>跳转表就是一个数组，情况标号跨过一个不连续的区域，有些情况有多个标号，有些情况可能落<br>入其余情况中数组的索引就是一个代码段的地址。可以将数组的元素分为几部分，先找defalut，<br>再找重复位置标号，再找没有break的部分并且承接下面的部分。这样做题的时候结构更清晰。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">case</span> <span class="number">104</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">106</span>:</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"> 	<span class="keyword">default</span>:</span><br><span class="line"> 	    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>一个过程就是调用一个函数的过程，包括将数据（形参和返回值）和控制从代码的一部分传递到<br>另一部分，在进入一个过程时还要为局部变量分配空间，退出时释放空间。一个过程就是一个栈帧，<br>有两个指针在两个顶端，%ebp为帧指针，%esp为栈指针。<br>P是调用者，Q是被调用者，Q的参数是放在P的帧栈中，P调用Q时将P的返回地址压入栈中，形成P<br>帧栈的末尾，返回地址就是调用完Q后应该继续执行的地方，因为这个时候P还没执行完。Q的帧栈<br>是从帧指针开始，后面是保存的寄存器的值。%ebp的内容就是P的帧栈的底部内容<br>Q的许多局部变量也保存在栈中</p>
<ul>
<li>寄存器数量有限，只能保存一部分局部变量</li>
<li>有些局部变量是数组或者结构</li>
<li>如果要得到一个局部变量的地址，那么必须用栈来保存<br><img src="/2020/02/29/JVM/number164.jpg" alt></li>
</ul>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><ul>
<li>call Label 过程调用</li>
<li>call *Operand 过程调用</li>
<li>leave 为返回准备栈</li>
<li>ret 从过程调用中返回，也就是从栈中弹出地址并跳转到这个位置<br><img src="/2020/02/29/JVM/number165.jpg" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># leave</span><br><span class="line">movl %ebp,%esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h3><ul>
<li>T A[N]<br>首先在内存中分配一个L*N字节的连续区域，然后引入标识符A，用A作为指向数组开头的指针，<br>从0到N-1的整数索引来访问数组元素，数组元素i会存放在地址为xA+L*i的地方，xA是起始位置</li>
</ul>
<h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><ul>
<li>结构 起始地址+该字段的偏移量=该字段的指针</li>
<li>联合</li>
<li>数据对齐 数据类型的地址必须是数据类型字节大小的倍数，如果是short就是2，类似int以及<br>更大的类型就是4</li>
</ul>
<h3 id="存储器的越界引用和缓冲区溢出"><a href="#存储器的越界引用和缓冲区溢出" class="headerlink" title="存储器的越界引用和缓冲区溢出"></a>存储器的越界引用和缓冲区溢出</h3><p>一种情况就是输入的字符串长度大于分配的空间，那么剩余的字符串就会覆盖其余的空间，可能<br>破坏%ebp的值，还有可能返回地址被攻击的指针覆盖，最后跳转到攻击位置 <img src="/2020/02/29/JVM/number166.jpg" alt></p>
<h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3><ol>
<li>许多函数不需要栈帧，只有那些不能将所有的局部变量都放在寄存器中的函数才需要在栈<br>上分配空间</li>
<li>没有帧指针，对栈位置的引用相对于栈指针，大多数函数在调用时开始分配所需要的整个<br>栈存储，并保持栈指针指向固定位置</li>
<li>最多有6个整型参数可以通过寄存器传递</li>
</ol>
<h2 id="处理器体系结构"><a href="#处理器体系结构" class="headerlink" title="处理器体系结构"></a>处理器体系结构</h2><p>这一部分主要与硬件相关</p>
<ul>
<li>指令集体系结构ISA 一个处理器支持的指令和指令的字节级编码</li>
</ul>
<h2 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h2><h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接就是将各种代码和数据部分合并为一个单一文件。这个文件可以被加载到存储器中并执行。</p>
<ul>
<li>执行于编译时 在源代码翻译成机器代码时执行</li>
<li>执行于加载时 程序被加载到存储器时执行</li>
<li>执行于运行时 在运行时执行</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/02/29/JVM/">https://skysea-gaoming.github.io/2020/02/29/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/JavaWeb/"><i class="fa fa-chevron-left">  </i><span>JavaWeb</span></a></div><div class="next-post pull-right"><a href="/2020/02/29/Git/"><span>Git</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/02/29/JVM/';
  this.page.identifier = '2020/02/29/JVM/';
  this.page.title = 'JVM';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591954918112&amp;di=2bc6f4358ea0e880687f5ced03157daf&amp;imgtype=0&amp;src=http%3A%2F%2Fyouimg1.c-ctrip.com%2Ftarget%2Ftg%2F620%2F406%2F859%2Fe7db3299a728401eb7b42effae33dadb.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>