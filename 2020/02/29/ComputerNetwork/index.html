<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="应用层总结"><meta name="keywords" content="NetWork"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>应用层总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用层概述"><span class="toc-number">2.</span> <span class="toc-text">应用层概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用层术语"><span class="toc-number">2.1.</span> <span class="toc-text">应用层术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算机之间的通信方式"><span class="toc-number">2.2.</span> <span class="toc-text">计算机之间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2P的优缺点"><span class="toc-number">2.3.</span> <span class="toc-text">P2P的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态IP和静态IP"><span class="toc-number">2.4.</span> <span class="toc-text">动态IP和静态IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-S和C-S"><span class="toc-number">2.5.</span> <span class="toc-text">B&#x2F;S和C&#x2F;S</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-S和C-S的区别"><span class="toc-number">2.6.</span> <span class="toc-text">B&#x2F;S和C&#x2F;S的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#域名结构"><span class="toc-number">2.7.</span> <span class="toc-text">域名结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#域名解析过程"><span class="toc-number">2.8.</span> <span class="toc-text">域名解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归查询和迭代查询"><span class="toc-number">2.9.</span> <span class="toc-text">递归查询和迭代查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入一个URL到打开网页的过程"><span class="toc-number">2.10.</span> <span class="toc-text">输入一个URL到打开网页的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP协议"><span class="toc-number">2.11.</span> <span class="toc-text">HTTP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长连接和短连接的区别与使用场景"><span class="toc-number">2.12.</span> <span class="toc-text">长连接和短连接的区别与使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1的流水线和非流水线"><span class="toc-number">2.13.</span> <span class="toc-text">HTTP&#x2F;1.1的流水线和非流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求报文和响应报文"><span class="toc-number">2.14.</span> <span class="toc-text">请求报文和响应报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求方法"><span class="toc-number">2.15.</span> <span class="toc-text">请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见状态码"><span class="toc-number">2.16.</span> <span class="toc-text">常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#301和302状态码的区别"><span class="toc-number">2.17.</span> <span class="toc-text">301和302状态码的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-常见字段"><span class="toc-number">2.18.</span> <span class="toc-text">http 常见字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-0和HTTP1-1的区别"><span class="toc-number">2.19.</span> <span class="toc-text">HTTP1.0和HTTP1.1的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET和POST的区别？"><span class="toc-number">2.20.</span> <span class="toc-text">GET和POST的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">2.21.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DHCP"><span class="toc-number">2.22.</span> <span class="toc-text">DHCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用"><span class="toc-number">2.23.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-1"><span class="toc-number">2.23.1.</span> <span class="toc-text">Cookie</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么理解WebSocket协议？"><span class="toc-number">2.24.</span> <span class="toc-text">怎么理解WebSocket协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用WebSocket？"><span class="toc-number">2.25.</span> <span class="toc-text">为什么使用WebSocket？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket和Socket的区别是什么？"><span class="toc-number">2.26.</span> <span class="toc-text">WebSocket和Socket的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http与WebSocket的区别？"><span class="toc-number">2.27.</span> <span class="toc-text">Http与WebSocket的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS什么情况使用UDP和TCP？"><span class="toc-number">2.28.</span> <span class="toc-text">DNS什么情况使用UDP和TCP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全方法和不安全方法有哪些？"><span class="toc-number">2.29.</span> <span class="toc-text">安全方法和不安全方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#幂等性了解吗？"><span class="toc-number">2.30.</span> <span class="toc-text">幂等性了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP的特性有哪些？"><span class="toc-number">2.31.</span> <span class="toc-text">HTTP的特性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-0了解吗？"><span class="toc-number">2.32.</span> <span class="toc-text">HTTP&#x2F;2.0了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-0优点有哪些？"><span class="toc-number">2.33.</span> <span class="toc-text">HTTP&#x2F;2.0优点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-3是什么？"><span class="toc-number">2.34.</span> <span class="toc-text">HTTP&#x2F;3是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session的作用是什么？"><span class="toc-number">2.35.</span> <span class="toc-text">Session的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session与Cookie的区别有哪些？"><span class="toc-number">2.36.</span> <span class="toc-text">Session与Cookie的区别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie被禁用怎么办？"><span class="toc-number">2.37.</span> <span class="toc-text">Cookie被禁用怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-的属性有哪些？"><span class="toc-number">2.38.</span> <span class="toc-text">Cookie 的属性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向代理是什么？"><span class="toc-number">2.39.</span> <span class="toc-text">反向代理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨域产生的原因？"><span class="toc-number">2.40.</span> <span class="toc-text">跨域产生的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie如何跨域？"><span class="toc-number">2.41.</span> <span class="toc-text">Cookie如何跨域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决跨域？"><span class="toc-number">2.42.</span> <span class="toc-text">如何解决跨域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理和网关是什么？"><span class="toc-number">2.43.</span> <span class="toc-text">代理和网关是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie的类型？"><span class="toc-number">2.44.</span> <span class="toc-text">Cookie的类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS的优缺点有哪些？"><span class="toc-number">2.45.</span> <span class="toc-text">HTTPS的优缺点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http通信存在的问题"><span class="toc-number">2.46.</span> <span class="toc-text">http通信存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-怎么建立连接？"><span class="toc-number">2.47.</span> <span class="toc-text">HTTPS 怎么建立连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https（问为什么要对称加密数据，而不用非对称加密数据呢）？"><span class="toc-number">2.48.</span> <span class="toc-text">https（问为什么要对称加密数据，而不用非对称加密数据呢）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么http一定要用TCP呢？"><span class="toc-number">2.49.</span> <span class="toc-text">为什么http一定要用TCP呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长连接的好处？"><span class="toc-number">2.50.</span> <span class="toc-text">长连接的好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写一个简单的webserver？"><span class="toc-number">2.51.</span> <span class="toc-text">写一个简单的webserver？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-server实现了什么？"><span class="toc-number">2.52.</span> <span class="toc-text">web server实现了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URI和URL的区别是什么？"><span class="toc-number">2.53.</span> <span class="toc-text">URI和URL的区别是什么？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">应用层总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/02/29/ComputerNetwork/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/02/29/ComputerNetwork/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《网络是怎样连接的》 《计算机网络》 <a href="http://www.cyc2018.xyz" target="_blank" rel="noopener">http://www.cyc2018.xyz</a><br><a href="https://bithachi.blog.csdn.net/article/details/104722679" target="_blank" rel="noopener">https://bithachi.blog.csdn.net/article/details/104722679</a></p>
<h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><h3 id="应用层术语"><a href="#应用层术语" class="headerlink" title="应用层术语"></a>应用层术语</h3><ol>
<li>域名系统（DNS）：域名系统将人类可读的域名转换为机器可读的IP地址</li>
<li>文件传输协议（FTP）：用于Internet 上的控制文件的双向传输。用户<br>经常遇到两个概念：”下载”和”上传”。 “下载”文件就是从远程主机拷贝文<br>件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远<br>程主机上</li>
<li>简单文件传输协议（TFTP）：是TCP/IP 协议族中的一个用来在客<br>户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的<br>文件传输服务。端口号为69，使用UDP数据报</li>
<li>远程终端协议（TELNET）：Telnet 协议是 TCP/IP 协议族中的<br>一员，是Internet 远程登陆服务的标准协议和主要方式。它为用户提<br>供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上<br>使用telnet 程序，用它连接到服务器。终端使用者可以在telnet 程<br>序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控<br>制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会<br>话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控<br>制Web 服务器的方法，使用TCP连接</li>
<li>万维网（WWW）是环球信息网的缩写，英文全称为“World Wide Web<br>”，中文名字为“万维网”，常简称为 Web。分为Web 客户端和Web 服务<br>器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览Web 服务器<br>上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访<br>问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全<br>局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议传送<br>给用户，而后者通过点击链接来获得资源</li>
<li>统一资源定位符（URL）：统一资源定位符是对可以从互联网上得<br>到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源<br>的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指<br>出文件的位置以及浏览器应该怎么处理它。由四部分组成：<br>协议://主机:端口/路径</li>
<li>超文本传输协议（HTTP）：是互联网上应用最为广泛的一种网络<br>协议。所有的WWW 文件都必须遵守这个标准。设计HTTP 最初的目的是<br>为了提供一种发布和接收HTML页面的方法</li>
<li>代理服务器：代理服务器是一种网络实体，它又称为万维网高速缓<br>存。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到<br>达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂<br>存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服<br>务器可在客户端或服务器工作，也可以在中间系统工作</li>
<li>简单邮件传输协议(SMTP) : 即简单邮件传输协议,它是一组用于由<br>源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP<br>协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下<br>一个目的地。 通过SMTP 协议所指定的服务器,就可以把E-mail 寄到收<br>信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件</li>
<li>脚本：指一个程序，它被另一个程序而不是计算机的处理机来解释<br>或执行</li>
<li>搜索引擎:是指根据一定的策略、运用特定的计算机程序从互联网上<br>搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户<br>检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引</li>
</ol>
<h3 id="计算机之间的通信方式"><a href="#计算机之间的通信方式" class="headerlink" title="计算机之间的通信方式"></a>计算机之间的通信方式</h3><p>计算机之间的通信方式可以分为两类：客户-服务器方式和对等方式</p>
<ol>
<li>客户-服务器方式 C/S<br>客户是请求方，服务器是服务提供方，B/S是浏览器-服务器方式，是C/S<br>的一种特例。客户和服务器的通信建立连接后通信是双向的</li>
<li>对等连接方式 P2P<br>不区分请求方和服务方，两台主机都运行了对等连接软件</li>
</ol>
<h3 id="P2P的优缺点"><a href="#P2P的优缺点" class="headerlink" title="P2P的优缺点"></a>P2P的优缺点</h3><ol>
<li>P2P的优点 减轻了服务器的计算压力，消除了对某个服务器的完全依<br>赖，可扩展性好，网络健壮性强单个结点的失效不会影响其他部分的结点</li>
<li>P2P的缺点 在获取服务的同时，还要给其他结点提供服务，因此会占<br>用较多的内存，影响整机速度</li>
</ol>
<h3 id="动态IP和静态IP"><a href="#动态IP和静态IP" class="headerlink" title="动态IP和静态IP"></a>动态IP和静态IP</h3><p>动态IP需要在连接网络时自动获取IP地址以供用户正常上网，而静态IP是<br>ISP在装机时分配给用户的IP地址，可以直接连接上网不需要获取IP地址</p>
<h3 id="B-S和C-S"><a href="#B-S和C-S" class="headerlink" title="B/S和C/S"></a>B/S和C/S</h3><ol>
<li>B/S 即浏览器/服务器结构 只是要求安装一个浏览器</li>
<li>C/S 即客户机/服务器结构 客户端需要安装专用的客户软件</li>
</ol>
<h3 id="B-S和C-S的区别"><a href="#B-S和C-S的区别" class="headerlink" title="B/S和C/S的区别"></a>B/S和C/S的区别</h3><ol>
<li>硬件要求不同 c/s一般建立在专用的网络上，是小范围的网络环境，<br>而B/S一般构建于广域网上，不需要专门的网络硬件环境，只要能接入网<br>络即可</li>
<li>维护成本 c/s维护成本高，发生一次升级，则所有客户端的程序都需<br>要改变</li>
<li>响应速度 c/s安全性能高，由于只有一层交互，因此响应速度较快</li>
<li>逻辑处理 c/s会处理一些运算，业务逻辑的处理。b/s极少数事务逻辑<br>在前端实现</li>
</ol>
<h3 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h3><ol>
<li>因特网采用层次树状结构的命名方法。采用这种命名方法，任何一个连接<br>到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名</li>
<li>不区分大小写，级别低在左边级别高在右边</li>
<li>顶级域名分为如下三大类:</li>
</ol>
<ul>
<li>国家顶级域名 如“.cn”表示中国，“.us”表示美国，.uk”表示英国。</li>
<li>通用顶级域名 常见的有“.com” (公司)、“.net” (网络服务机构)、“.org”<br>(非营利性组织)和“.gov” (国家或政府部门)等</li>
<li>基础结构域名 这种顶级域名只有一个，即arpa,用于反向域名解析，因此<br>又称反向域名。反向域名解析与通常的正向域名解析相反，提供IP地址到域<br>名的对应</li>
</ul>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>共使用8个UDP报文如下:假定某客户机想获知域名为y.abc.com主机的IP地址</p>
<ol>
<li>客户机向其本地域名服务器发出DNS请求报文</li>
<li>本地域名服务器收到请求后，查询本地缓存，若没有该记录，则以DNS客<br>户的身份向根域名服务器发出解析请求</li>
<li>根域名服务器收到请求后，判断该域名属于.com域，将对应的顶级域名<br>服务器dns.com的IP地址返回给本地域名服务器</li>
<li>本地域名服务器向顶级域名服务器dns.com发出解析请求报文</li>
<li>顶级域名服务器dns.com收到请求后，判断该域名属于abc.com域，因此<br>将对应的授权域名服务器dns.abc.com的IP地址返回给本地域名服务器</li>
<li>本地域名服务器向授权域名服务器dns.abc.com发起解析请求报文</li>
<li>授权域名服务器dns.abc.com收到请求后，将查询结果返回给本地域名服<br>务器</li>
<li>本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</li>
</ol>
<h3 id="递归查询和迭代查询"><a href="#递归查询和迭代查询" class="headerlink" title="递归查询和迭代查询"></a>递归查询和迭代查询</h3><ol>
<li>主机向本地域名服务器的查询采用的是递归查询</li>
<li>本地域名服务器向根域名服务器的查询采用迭代查询</li>
</ol>
<h3 id="输入一个URL到打开网页的过程"><a href="#输入一个URL到打开网页的过程" class="headerlink" title="输入一个URL到打开网页的过程"></a>输入一个URL到打开网页的过程</h3><ol>
<li>DHCP 配置主机信息 如果最初没有IP地址等信息的话，那么就需要先<br>使用DHCP来获取。主机生成一个DHCP请求报文，并将这个报文放入具有目<br>的端口67和源端口68的UDP 报文段中，放入具有广播IP目的地址(255.</li>
<li>255.255)和源IP地址(0.0.0.0)的IP数据报中。DHCP服务器最后<br>就会把相关信息发送给主机</li>
<li>ARP解析MAC地址 DHCP过程只知道网关路由器的IP地址，为了获取网关<br>路由器的MAC地址，需要使用ARP协议</li>
<li>DNS解析 首先查找域名服务器获取相应域名的IP地址，首先以UDP数据<br>报的形式发送给本地域名服务器。主机向本地域名服务器的查询一般采用递<br>归查询，递归查询就是如果主机询问的本地域名服务器不知道被查询的IP<br>地址，那么本地域名服务器就会以DNS客户的身份器其他根域名服务器查询<br>，主机不会进行下一步查询。本地域名服务器向根域名服务器查询分为两种<br>方式，通常采用迭代查询：当根域名服务器收到本地域名服务器的请求时<br>会告诉本地域名服务器应该去哪一个域名服务器查询而不是帮助本地域名<br>服务器查询。本地服务器也可以采用递归查询，取决于最初查询请求报文<br>的设置是哪一种方式。为了提高DNS 查询效率在域名服务器和主机中都是<br>用了高速缓存</li>
<li>HTTP协议建立在TCP协议之上，HTTP请求前，必须先与HTTP服务器<br>进行三次握手来建立连接</li>
<li>HTTP协议生成请求报文 生成针对目标Web服务器的HTTP请求报文</li>
<li>HTTP协议对请求进行处理，比如返回相应的资源，HTTP响应报文</li>
<li>HTML页面的解析与渲染 抽取出Web页面内容，浏览器之后进行渲染，显<br>示Web页面</li>
</ol>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ol>
<li>HTTP定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎<br>样把文档传送给浏览器</li>
<li>HTTP是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页<br>面时，服务器的响应与第一次被访问时的相同。因为服务器并不记得曾经访问<br>过的这个客户，也不记得为该客户曾经服务过多少次。HTTP的无状态特性简<br>化了服务器的设计，使服务器更容易支持大量并发的HTTP请求</li>
<li>每请求一个文档都需要两倍RTT开销，每一次新建TCP连接都要分配缓存<br>和变量</li>
</ol>
<h3 id="长连接和短连接的区别与使用场景"><a href="#长连接和短连接的区别与使用场景" class="headerlink" title="长连接和短连接的区别与使用场景"></a>长连接和短连接的区别与使用场景</h3><ol>
<li>短连接：例如普通的web请求，在三次握手之后建立连接，发送数据包并<br>得到服务器返回的结果之后，通过客户端和服务端的四次握手进行关闭断开</li>
<li>长连接：区别于短连接，由于三次握手链接及四次握手断开，在请求频繁<br>的情况下，链接请求和断开请求的开销较大，影响效率。采用长连接方式，执<br>行三次握手链接后，不断开链接，保持客户端和服务端通信，直到服务器超<br>时自动断开链接，或者客户端主动断开链接。持久连接的特点是，只要任意<br>一端没有明确提出断开连接，则保持TCP 连接状态<br>短连接：适用于网页浏览等数据刷新频度较低的场景<br>长连接：适用于客户端和服务端通信频繁的场景，例如聊天室，实时游戏等</li>
</ol>
<h3 id="HTTP-1-1的流水线和非流水线"><a href="#HTTP-1-1的流水线和非流水线" class="headerlink" title="HTTP/1.1的流水线和非流水线"></a>HTTP/1.1的流水线和非流水线</h3><ol>
<li>对于非流水线方式，客户在收到前一个响应后才能发出下一个请求</li>
<li>HTTP/1.1 的默认方式是使用流水线的持久连接。这种情况下，客户每<br>遇到一个对象引用就立即发出一个请求，因而客户可以逐个地连续发出对<br>各个引用对象的请求。如果所有的请求和响应都是连续发送的，那么所有<br>引用的对象共计经历1个RTT延迟，而不是像非流水线方式那样，每个引<br>用都必须有1个RTT延迟</li>
</ol>
<h3 id="请求报文和响应报文"><a href="#请求报文和响应报文" class="headerlink" title="请求报文和响应报文"></a>请求报文和响应报文</h3><ol>
<li>请求报文</li>
</ol>
<ul>
<li>请求行 请求方法、URL、协议版本</li>
<li>首部行 为请求报文添加了一些附加信息，头部字段名和值</li>
<li>实体主体 可选部分，比如GET 请求就没有请求正文</li>
</ul>
<ol start="2">
<li>响应报文</li>
</ol>
<ul>
<li>状态行 协议版本、状态码以及描述</li>
<li>首部行 响应报文添加了一些附加信息，头部字段名和值</li>
<li>实体主体 响应的内容主体</li>
</ul>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ol>
<li>OPTION 请求选项信息</li>
<li>GET 读取URL标志的信息</li>
<li>POST 添加信息</li>
<li>DELETE 删除URL资源</li>
</ol>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ol>
<li>1xx：表示请求已接收，正在处理</li>
</ol>
<ul>
<li>100 表明到目前为止都很正常，客户端可以继续发送请求或者忽略<br>这个响应</li>
</ul>
<ol start="2">
<li>2xx：成功 表示请求已被成功接收、理解、接受</li>
</ol>
<ul>
<li>200 OK 正在被正确处理</li>
<li>204 No Content 请求已经成功处理，但是返回的响应报文不包含实体的主<br>体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</li>
<li>206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返<br>回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功<br>的状态</li>
</ul>
<ol start="3">
<li>3xx：重定向–要完成请求必须进行更进一步的操作，虽然 HTTP 协议规定<br>301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数<br>浏览器都会在 301、302 和303 状态下的重定向把 POST方法改成GET方法</li>
</ol>
<ul>
<li>301 Moved Permanently 永久性重定向，资源分配性的URL</li>
<li>302 Found 临时性重定向，说明请求的资源还在，但暂时需要用另一个<br>URL 来访问</li>
<li>303 See Other 和 302 有着相同的功能，但是 303 明确要求客户端应<br>该采用 GET 方法获取资源</li>
<li>304 Not Modified 如果请求报文首部包含一些条件，例如： If-Match，<br>If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since<br>，允许访问但是不满足条件，则服务器会返回 304 状态码</li>
<li>307 Temporary Redirect 临时重定向，与 302 的含义类似，但是307<br>要求浏览器不会把重定向请求的改变</li>
</ul>
<ol start="4">
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
</ol>
<ul>
<li>400 Bad Request 请求报文中存在语法错误</li>
<li>401 Unauthorized 该状态码表示发送的请求需要有认证信息（BASIC<br>认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败</li>
<li>403 Forbidden 请求资源被服务器拒绝，实体部分返回原因描述</li>
<li>404 Not Found</li>
</ul>
<ol start="5">
<li>5xx：服务器端错误–服务器未能处理合法的请求</li>
</ol>
<ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误</li>
<li>501 Not Implemented ：表示客户端请求的功能还不支持</li>
<li>502 Bad Gateway ：通常是服务器作为网关或代理时返回的错误码，表<br>示服务器自身工作正常，访问后端服务器发生了错误</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维<br>护，现在无法处理请求</li>
</ul>
<h3 id="301和302状态码的区别"><a href="#301和302状态码的区别" class="headerlink" title="301和302状态码的区别"></a>301和302状态码的区别</h3><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的URL，<br>浏览器会自动重定向新的URL</p>
<ul>
<li>301是永久性重定向(Permanently Moved)，表示一个旧的网址所代表的<br>资源已经被永久地移除了，不能再访问了，并且搜索引擎在获取新的资源的<br>同时也将旧的网址转换为重定向之后的地址</li>
<li>302是临时重定向(Temporarily Moved)，这个重定向只是临时地从一个<br>旧的地址跳转到一个新的地址，旧的地址的资源还在，还可以继续访问，搜<br>索引擎会获取资源并保存旧的地址</li>
</ul>
<h3 id="http-常见字段"><a href="#http-常见字段" class="headerlink" title="http 常见字段"></a>http 常见字段</h3><ol>
<li>Host 客户端发送请求时，用来指定服务器的域名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br></pre></td></tr></table></figure></li>
<li>Content-Length 服务器在返回数据时，会有Content-Length 字段，表<br>明本次回应的数据长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本次服务器回应的数据长度是 1000 个字节</span><br><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure></li>
<li>Connection 最常用于客户端要求服务器使用TCP 持久连接，以便其他请<br>求复用，HTTP/1.1版本的默认连接都是持久连接，但为了兼容老版本的HTTP<br>，需要指定Connection 首部字段的值为 Keep-Alive<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></li>
<li>Content-Type 用于服务器回应时，告诉客户端，本次数据是什么格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送的是网页，而且编码是UTF-8</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure></li>
<li>Accept 客户端请求的时候，可以使用 Accept 字段声明自己可以接受<br>哪些数据格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端声明自己可以接受任何格式的数据</span><br><span class="line">Accept: *&#x2F;*</span><br></pre></td></tr></table></figure></li>
<li>Content-Encoding 说明数据的压缩方法。表示服务器返回的数据使用了<br>什么压缩格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">告知客户端需要用此方式解压</span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></li>
<li>Accept-Encoding 客户端在请求时，用Accept-Encoding 字段说明自<br>己可以接受哪些压缩方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h3><ol>
<li>缓存处理 在HTTP/1.0中主要使用header里的If-Modified=Since,<br>Expires来作为缓存判断的标准，HTTP/1.1则引入更多的缓存控制策略<br>例如Entity tag等</li>
<li>带宽优化及网络连接的使用 HTTP/1.0中客户端只是需要某个对象的<br>一部分，当服务器将整个对象传送过来，并且不支持断点续传功能，<br>HTTP/1.1在请求头中引入range头域，允许只请求资源的某个部分，<br>返回码是206</li>
<li>错误通知的管理 在HTTP/1.1中新增了24个错误状态响应码，如409<br>表示请求的资源与资源当前状态冲突，410表示服务器上的某个资源被<br>永久性删除</li>
<li>Host头处理 HTTP/1.0中认为每台服务器都绑定唯一的IP地址，所以<br>在URL中没有传递主机名，但是一个物理服务器上可以有多个虚拟主机，<br>共享一个IP地址，HTTP/1.1支持Host头域</li>
<li>长连接 HTTP/1.1支持长连接和请求的流水线处理，在一个TCP连接<br>上可以传送多个HTTP请求和响应。在HTTP/1.0中，默认使用的是短连接</li>
<li>管道网络传输 即可在同一个 TCP 连接里面，客户端可以发起多个<br>请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求<br>出去，可以减少整体的响应时间</li>
</ol>
<h3 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h3><ol>
<li>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、<br>页面、图片视频等。而POST 方法则是相反操作，它向 URI 指定的资源提交<br>数据，数据就放在报文的body 里</li>
<li>参数位置 GET和POST的请求都能使用额外的参数，但是GET 的参数是<br>以查询字符串出现在URL 中，而POST 的参数存储在实体主体中。不能因<br>为POST参数存储在实体主体中就认为它的安全性更高，因为照样可以通<br>过一些抓包工具（Fiddler）查看</li>
<li>参数长度 GET方法的URL 长度有限度，POST 长度没有显示</li>
<li>参数编码 GET方法参数编码是ASCLL 码，POST 没有限制</li>
<li>TCP数据包 GET方法产生一个TCP数据包，把首部和数据一起发送，POST<br>方法产生两个TCP数据包，先发首部，服务器响应后再发数据</li>
<li>安全 安全的HTTP 方法不会改变服务器状态，也就是说它只是可读的，<br>GET 方法是安全的，而POST 却不是，因为POST 的目的是传送实体主体内<br>容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把<br>这个数据存储到数据库中，因此状态也就发生了改变</li>
<li>可缓存 如果要对响应进行缓存，需要满足以下条件</li>
</ol>
<ul>
<li>请求报文的HTTP 方法本身是可缓存的，包括GET 和HEAD，但是 PUT<br>和 DELETE 不可缓存，POST 在多数情况下不可缓存的</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301<br>, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存</li>
</ul>
<ol start="8">
<li>XMLHttpRequest XMLHttpRequest 是一个 API，它为客户端提供了在<br>客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的<br>简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会<br>打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用</li>
</ol>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再<br>发送 Data。但并不是所有浏览器会这么做，例如火狐就不会</li>
<li>而 GET 方法 Header 和 Data 会一起发送</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>表示为在用户和服务器之间传递的状态信息</p>
<ol>
<li>当用户A浏览一个使用Cookie的网站时，该网站的服务器就会为A产生唯一<br>一个识别码，并以此作为索引在服务器的后端产生</li>
<li>给A的HTTP响应报文中添加一个叫做Set-cookie的首部行，这里首部字段<br>名就是Set-cookie，值就是赋予用户的识别码</li>
<li>A接收到响应之后浏览器就在它管理的特定Cookie文件中添加一行，其中<br>就包括这个服务器的主机名和Set-cookie后面给出的识别码，当A继续浏览<br>网站时每发送一个HTTP请求报文其浏览器就会从Cookie文件中取出这个网<br>站的识别码并放到HTTP请求报文的Cookie首部行中，于是网站就能够持续<br>跟踪这个用户的活动，所以可以用于告知服务端两个请求是否来自同一浏<br>览器</li>
</ol>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话<br>期内有效</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就<br>成为了持久性的 Cookie</li>
</ul>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态主机配置协议常用于给主机动态地分配IP地址，它提供了即插即用联网<br>的机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参<br>与。DHCP是应用层协议，它是基于UDP的</p>
<ol>
<li>使用客户/服务器方式</li>
<li>需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主<br>机就成为DHCP客户。本地网络上所有主机都能收到此广播报文，但只有DHCP服<br>务器才回答此广播报文，这个报文放入具有目的端口67和源端口68的UDP报文<br>段中，放入具有广播IP 目的地址(255.255.255.255)和源IP地址(0.0.0.0)<br>的IP数据报中</li>
<li>DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找<br>到的信息</li>
<li>若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。DHCP服<br>务器的回答报文称为提供报文</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的<br>一个接口，应用进程使用网络进行通信时发送socket系统调用，创建一个<br>套接字，实际就是把网络通信需要的一些资源（存储空间、CPU、带宽）分<br>配给应用进程</p>
<ol>
<li>bind 绑定套接字的本地地址</li>
<li>listen 服务器把套接字设置为被动模式，随时接受客户请求，只有TCP<br>需要使用bind</li>
<li>accept 服务器调用以便将客户发来的连接请求提取出来，指明是哪个<br>套接字发起的连接。服务器支持并发处理多个连接，一调用accept就为每<br>一个新连接创建一个新的套接字，并把套接字标识符返回给客户，同时服<br>务器创建一个从属进程处理新连接</li>
<li>connect 客户进程调用以便和服务器建立连接</li>
<li>send 传送数据，需要三个变量：套接字描述符，要发送的数据的地址<br>和数据的长度</li>
<li>recv 接收数据，需要三个变量：套接字的描述符，缓存的地址和缓存<br>空间的长度</li>
<li>close 释放连接和撤销套接字</li>
</ol>
<h4 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP是无状态的，但是网上购物时服务器必须记住用户的身份，可以在HTTP中<br>使用，万维网站点可以使用Cookie来跟踪用户，可以表示为在用户和服务器之<br>间传递的状态信息。当用户A浏览一个使用Cookie的网站时，该网站的服务器<br>就会为A产生唯一一个识别码，并以此作为索引在服务器的后端数据库中产生<br>一个项目，接着在给A的HTTP响应报文中添加一个叫做Set-cookie的首部行<br>，这里首部字段名就是Set-cookie，值就是赋予用户的识别码，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: 31d3h432h4u23</span><br></pre></td></tr></table></figure>
<p>A接收到响应之后浏览器就在它管理的特定Cookie文件中添加一行，其中就包括<br>这个服务器的主机名和Set-cookie后面给出的识别码，当A继续浏览网站时每<br>发送一个HTTP请求报文其浏览器就会从Cookie文件中取出这个网站的识别码<br>并放到HTTP请求报文的Cookie首部行中，于是网站就能够持续跟踪这个用户<br>的活动</p>
<h3 id="怎么理解WebSocket协议？"><a href="#怎么理解WebSocket协议？" class="headerlink" title="怎么理解WebSocket协议？"></a>怎么理解WebSocket协议？</h3><p>websocket是HTML5的一个新协议，它允许服务端向客户端传递信息，实现<br>浏览器和客户端全双工通信。服务器可以主动向客户端推送信息，客户端也<br>可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技<br>术的一种</p>
<h3 id="为什么使用WebSocket？"><a href="#为什么使用WebSocket？" class="headerlink" title="为什么使用WebSocket？"></a>为什么使用WebSocket？</h3><p>当我们在处理页面数据自动更新的时候，在使用js不断的请求服务器，查看<br>是否有新数据，如果有就获取到新数据，进行对页面信息的跟新，但是当页<br>面长时间没有更新数据时，这样就会存在资源浪费的情况，所以才会使用<br>WebSocket来解决</p>
<h3 id="WebSocket和Socket的区别是什么？"><a href="#WebSocket和Socket的区别是什么？" class="headerlink" title="WebSocket和Socket的区别是什么？"></a>WebSocket和Socket的区别是什么？</h3><p>Socket是应用层与TCP/IP协议通信的中间软件抽象层，它是一组接口。而<br>WebSocket则不同，它是一个完整的应用层协议，包含一套标准的API</p>
<h3 id="Http与WebSocket的区别？"><a href="#Http与WebSocket的区别？" class="headerlink" title="Http与WebSocket的区别？"></a>Http与WebSocket的区别？</h3><ol>
<li>http协议是短链接，因为请求之后，都会关闭连接，下次重新请求数据<br>，需要再次打开连接。WebSocket协议是一种长连接，只需要通过一次请求<br>来初始化链接，然后所有的请求和响应都是通过这个TCP 链接进行通信，<br>那么这就不用一次次加入cookie，也就是一个持久化的协议</li>
<li>WebSocket也借助了HTTP的握手，是HTTP的一个解决特定问题的补丁，<br>多了如下内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="DNS什么情况使用UDP和TCP？"><a href="#DNS什么情况使用UDP和TCP？" class="headerlink" title="DNS什么情况使用UDP和TCP？"></a>DNS什么情况使用UDP和TCP？</h3><ol>
<li>UDP UDP速度更快，不需要三次握手。DNS 请求和响应通常都很小，一般<br>数据内容不会超过512字节。可以在应用层弥补UDP不可靠的缺点，自己完成<br>超时和重传处理。还有一个点是关于DNS负载均衡，事实上每次返回的IP 地<br>址并不一定都是一样的，资源是分布在许多的服务器，DNS会根据每台机器<br>的负载量该机器距离用户地理位置的距离来返回一个合适的IP</li>
<li>如果DNS响应超过512个字节那么使用UDP 就会将数据截断为512个字<br>节，多余的部分会抛弃，因为UDP没有字段来表示报文ID。所以当响应报<br>文的长度大于512个字节的时候就会使用TCP</li>
</ol>
<h3 id="安全方法和不安全方法有哪些？"><a href="#安全方法和不安全方法有哪些？" class="headerlink" title="安全方法和不安全方法有哪些？"></a>安全方法和不安全方法有哪些？</h3><p>在HTTP 协议里，所谓的安全是指请求方法不会破坏服务器上的资源</p>
<ol>
<li>安全的方法除了 GET 之外还有：HEAD、OPTIONS</li>
<li>不安全的方法除了 POST 之外还有 PUT、DELETE</li>
</ol>
<h3 id="幂等性了解吗？"><a href="#幂等性了解吗？" class="headerlink" title="幂等性了解吗？"></a>幂等性了解吗？</h3><p>幂等的HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，<br>服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计<br>用途除外）。所有的安全方法也都是幂等的。在正确实现的条件下，GET，<br>HEAD，PUT 和 DELETE 等方法都是幂等的，而POST 方法不是</p>
<h3 id="HTTP的特性有哪些？"><a href="#HTTP的特性有哪些？" class="headerlink" title="HTTP的特性有哪些？"></a>HTTP的特性有哪些？</h3><ol>
<li>简单 HTTP 基本的报文格式就是 header + body，头部信息也是<br>key-value 简单文本的形式，易于理解，降低了学习和使用的门槛</li>
<li>灵活和易于扩展 HTTP协议里的各类请求方法、URI/URL、状态码、头<br>字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充</li>
<li>应用广泛和跨平台</li>
<li>无状态</li>
</ol>
<ul>
<li>好处 因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记<br>录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外<br>提供服务</li>
<li>坏处 既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦</li>
</ul>
<ol start="5">
<li>明文传输 在传输过程中的信息，是可方便阅读的，很容易就能被窃取</li>
</ol>
<h3 id="HTTP-2-0了解吗？"><a href="#HTTP-2-0了解吗？" class="headerlink" title="HTTP/2.0了解吗？"></a>HTTP/2.0了解吗？</h3><p>参考 <a href="https://segmentfault.com/a/1190000016656529" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016656529</a><br>HTTP/2是HTTP协议的第二个主要版本。HTTP/2主要基于SPDY协议。HTTP2.0<br>的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大<br>幅度提高了web性能。<br>SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层<br>协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩<br>短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数<br>。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。<br>HTTP1.x有以下几个主要缺点：</p>
<ol>
<li>HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用<br>的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因<br>此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟</li>
<li>单向请求，只能由客户端发起</li>
<li>请求报文与响应报文首部信息冗余量大</li>
<li>数据未压缩，导致数据的传输量大</li>
</ol>
<h3 id="HTTP-2-0优点有哪些？"><a href="#HTTP-2-0优点有哪些？" class="headerlink" title="HTTP/2.0优点有哪些？"></a>HTTP/2.0优点有哪些？</h3><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的</p>
<ol>
<li>新的二进制格式 HTTP/1.x 的解析是基于文本，基于文本协议的解析<br>存在天然缺陷，文本的表现形式由多样性，要做到健壮性考虑的场景必须<br>很多。二进制则不同，只认0和1的组合。基于这种考虑HTTP/2.0的协议解<br>析决定采用二进制格式，实现方便且健壮，头信息和数据体都是二进制<br>，并且统称为帧（frame）：头信息帧和数据帧。</li>
<li>多路复用 即连接共享，每一个request都是用做连接共享机制的，一个<br>request对应一个id，这样一个连接上可以有多个request，每个连接的<br>request可以随机混杂在一起，接受方可以根据request的id将request<br>再归属到各自不同的服务端请求中。不需要排队等待，也就不会再出现<br>队头阻塞问题，降低了延迟，大幅度提高了连接的利用率</li>
<li>header压缩 HTTP/1.x的header带有大量信息，如果你同时发出多个<br>请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分<br>。HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会<br>存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号<br>，这样就提高速度了</li>
<li>服务端推送 同SPDY一样，HTTP/2.0也具有server push功能，服务端<br>可以在客户端某个请求后，主动推送其他资源</li>
<li>数据流 HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数<br>据包，可能属于不同的回应。因此必须要对数据包做标记，指出它属于哪个<br>回应。每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数<br>据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为<br>奇数， 服务器发出的数据流编号为偶数</li>
</ol>
<h3 id="HTTP-3是什么？"><a href="#HTTP-3是什么？" class="headerlink" title="HTTP/3是什么？"></a>HTTP/3是什么？</h3><ol>
<li>HTTP/2 主要的问题在于，多个HTTP 请求在复用一个TCP 连接，下层的<br>TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会<br>触发TCP 的重传机制，这样在一个TCP 连接中的所有的HTTP 请求都必须等<br>待这个丢了的包被重传回来</li>
<li>HTTP/3 把HTTP 下层的TCP 协议改成了 UDP，UDP 发生是不管顺序，也<br>不管丢包的，所以不会出现HTTP/1.1 的队头阻塞和HTTP/2 的一个丢包全部<br>重传问题。</li>
<li>基于UDP 的QUIC 协议可以实现类似TCP 的可靠性传输</li>
<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是<br>TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互<br>合并成了 3 次，减少了交互次数</li>
</ol>
<h3 id="Session的作用是什么？"><a href="#Session的作用是什么？" class="headerlink" title="Session的作用是什么？"></a>Session的作用是什么？</h3><ol>
<li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session</li>
<li>同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为<br>session对象的ID）</li>
<li>然后将该Cookie 发送至浏览器端。浏览器端发送第N（N&gt;1）次请求到服<br>务器端，浏览器端访问服务器端时携带该name为JSESSIONID的Cookie对象</li>
<li>服务器端根据name为JSESSIONID 的Cookie的value(sessionId)，去<br>查询Session 对象，从而区分不同用户</li>
</ol>
<h3 id="Session与Cookie的区别有哪些？"><a href="#Session与Cookie的区别有哪些？" class="headerlink" title="Session与Cookie的区别有哪些？"></a>Session与Cookie的区别有哪些？</h3><p>cookie和session都是用来跟踪浏览器用户身份的会话方式。不同之处如下</p>
<ol>
<li>存储位置 Cookie是客户端技术，数据保存在客户端，Session是服务端<br>会话技术，数据保存在服务器端</li>
<li>存储容量 Cookie一般小于等于4KB，Session无限制</li>
<li>跨域支持 Cookie支持跨域，Session不支持</li>
<li>作用 Cookie一般存储少量不太敏感的数据，Token授权机制，时间戳超时<br>机制，签名机制，拒绝重复调用</li>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的<br>数据，因此在考虑数据复杂性时首选 Session</li>
<li>相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写<br>入Cookie中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密</li>
<li>Cookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录<br>用户的状态</li>
</ol>
<h3 id="Cookie被禁用怎么办？"><a href="#Cookie被禁用怎么办？" class="headerlink" title="Cookie被禁用怎么办？"></a>Cookie被禁用怎么办？</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能<br>再将 Session ID存放到Cookie中，而是使用URL重写技术，将 Session ID<br>作为 URL 的参数进行传递</p>
<h3 id="Cookie-的属性有哪些？"><a href="#Cookie-的属性有哪些？" class="headerlink" title="Cookie 的属性有哪些？"></a>Cookie 的属性有哪些？</h3><ol>
<li>domain属性 指定可访问此cookie的域名 非顶级域名，如二级域名或者三<br>级域名，设置的cookie的domain 只能为顶级域名或者二级域名或者三级域名<br>本身，不能设置其他二级域名的cookie。要想cookie 在多个二级域名中共享<br>，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个<br>cookie的值了</li>
<li>path属性 指定该cookie的页面路径 比如domain是abc.com。path是<br>/test，那么只有/test路径下的页面可以读取此cookie，Cookie的路径<br>是在服务器创建Cookie时设置的，它的作用是决定浏览器访问服务器的<br>某个资源时，需要将浏览器端保存的那些Cookie归还给服务器</li>
</ol>
<h3 id="反向代理是什么？"><a href="#反向代理是什么？" class="headerlink" title="反向代理是什么？"></a>反向代理是什么？</h3><ol>
<li>反向代理方式是指以代理服务器来接收Internet 上的连接请求，然后将请<br>求转发给内部网络上的服务器 ，并将从服务器上得到的结果返回给Internet<br>上请求连接的客户端，此时代理服务器对外就表现为一个服务器</li>
<li>反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要<br>进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容<br>发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获<br>得的内容返回给客户端，就像这些内容原本就是它自己的一样</li>
</ol>
<h3 id="跨域产生的原因？"><a href="#跨域产生的原因？" class="headerlink" title="跨域产生的原因？"></a>跨域产生的原因？</h3><p>参考 <a href="https://www.jianshu.com/p/827b041be446" target="_blank" rel="noopener">https://www.jianshu.com/p/827b041be446</a><br>跨域是指从一个域名去请求另一个域名的资源，严格来说，只要域名，协议<br>，端口任何一个不同，就视为跨域。为了网络安全起见，浏览器设置了一个<br>同源策略，规定只有域名，端口，协议全部相同，就叫做同源。当页面在执<br>行一个脚本时，会检查访问的资源是否同源，如果不是，就会报错。可是在<br>实际开发中，经常会有跨域加载资源的需求，避免不了跨域请求，所以就<br>出现了跨域。<br>同源策略（Same Orgin Policy）是一种约定，它是浏览器核心也最基本<br>的安全功能，它会阻止一个域的js脚本和另外一个域的内容进行交互，如<br>果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源（即在<br>同一个域）就是两个页面具有相同的协议（protocol）、主机（host）<br>和端口号（port）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.baidu.com:8080&#x2F;index.html （http协议，www.baidu.com </span><br><span class="line">域名、8080 端口 ，只要这三个有一项不一样的都是跨域，这里不一一举例子）</span><br><span class="line">http:&#x2F;&#x2F;www.baidu.com:8080&#x2F;matsh.html（不跨域）</span><br><span class="line">http:&#x2F;&#x2F;www.baidu.com:8081&#x2F;matsh.html（端口不一样，跨域）</span><br><span class="line">注意：localhost 和127.0.0.1 虽然都指向本机，但也属于跨域</span><br></pre></td></tr></table></figure>
<p>同源策略限制的具体表现</p>
<ol>
<li>cookie、LocalStorage和Index DB 无法读取</li>
<li>Dom 无法获得</li>
<li>AJAX请求不能发送</li>
</ol>
<h3 id="Cookie如何跨域？"><a href="#Cookie如何跨域？" class="headerlink" title="Cookie如何跨域？"></a>Cookie如何跨域？</h3><p>正常的cookie只能在一个应用中共享，即一个cookie只能由创建它的应用获得</p>
<ol>
<li>可在同一应用服务器内共享方法 设置cookie.setPath(“/“)</li>
<li>跨域共享cookie的方法 设置cookie.setDomain(“.jszx.com”)</li>
<li>Nginx 反向代理来解决cookie 跨域问题，其实是通过“欺骗”浏览器来实现<br>的，通过nginx，我们可以将不同工程的cookie放到nginx域下，通过nginx反<br>向代理就可以取到不同工程写入的cookie</li>
</ol>
<h3 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h3><ol>
<li>JSONP – 原理就是利用了script标签，在标签外套了一层壳，利用标<br>签特性达到跨域加载资源的效果，JSONP由两部分组成，回调函数和数据，<br>缺点如下。会创建一个查询字符串参数 callback=? ，这个参数会加在请<br>求的URL后面。服务器端应当在JSON 数据前加上回调函数名，以便完成一<br>个有效的JSONP请求，意思就是远程服务端需要对返回的数据做下处理，<br>根据客户端提交的callback的参数，返回一个callback(json)的数据<br>，而客户端将会用script的方式处理返回数据，来对json数据做处理</li>
</ol>
<ul>
<li>只支持GET请求，不支持POST请求</li>
<li>不够安全。因为JSONP是从其他域中加载代码执行，如果其他域不安全，可<br>能会在响应中带有恶意代码</li>
<li>不容易确认请求是否失败</li>
</ul>
<ol start="2">
<li>CORS– 跨站资源共享，它是跨域的官方解决方案，升级版的JSONP。原<br>理是使用自定义的HTTP 头部让浏览器与服务器进行沟通，从而决定请求或<br>响应是应该成功还是失败。请求和响应都不包含cookie信息。<br>CORS需要浏览器和后端同时支持，浏览器会自动进行CORS通信，实现CORS<br>通信的关键是后端，只要后端实现了CORS，就实现了跨域，服务端设置<br>Access-Control-Allow-Origin 就可以开启CORS，该属性表示哪<br>些域名可以访问资源，如果设置通配符则表示所有网站都可以访问<br>资源</li>
<li>webSockets – 不受同源策略影响。原理是因为它不使用HTTP协议，而使<br>用一种自定义的协议，专门为快速传输小数据设计</li>
<li>Nginx代理服务器 – 代理跨域。反向代理跨域</li>
</ol>
<h3 id="代理和网关是什么？"><a href="#代理和网关是什么？" class="headerlink" title="代理和网关是什么？"></a>代理和网关是什么？</h3><ol>
<li>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端’中间人’<br>的角色，接收客户端发送的请求不改变请求的URI并转发给服务器，同时也接<br>收服务器返回的相应并转发客户端</li>
<li>缓存代理：代理转发响应时会预先将资源缓存在代理服务器上当代理再次<br>接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之<br>前缓存的资源作为响应返回</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工的代理类型</li>
<li>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时<br>，它就像自己拥有资源的源服务器一样对请求进行处理，其工作机制和代理<br>类似，而网关能使通信线路上的服务器提供非HTTP协议的服务</li>
</ol>
<h3 id="Cookie的类型？"><a href="#Cookie的类型？" class="headerlink" title="Cookie的类型？"></a>Cookie的类型？</h3><ol>
<li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie<br>，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话<br>期内有效，浏览器关闭之后它会被自动删除</li>
<li>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持<br>久性 Cookie可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</li>
</ol>
<h3 id="HTTPS的优缺点有哪些？"><a href="#HTTPS的优缺点有哪些？" class="headerlink" title="HTTPS的优缺点有哪些？"></a>HTTPS的优缺点有哪些？</h3><p>https不是一种新的协议，它是http+SSL(TLS)的结合体，SSL是一种独<br>立协议</p>
<ol>
<li>优点：相比于http，https可以提供更加优质保密的信息，保证了用户<br>数据的安全性，此外https 同时也一定程度上保护了服务端，使用恶意攻<br>击和伪装数据的成本大大提高</li>
<li>缺点：</li>
</ol>
<ul>
<li>第一https的技术门槛较高，多数个人或者私人网站难以支撑，CA机构颁<br>发的证书都是需要年费的，此外对接Https协议也需要额外的技术支持</li>
<li>目前来说大多数网站并不关心数据的安全性和保密性，其https最大的优<br>点对它来说并不适用</li>
<li>https加重了服务端的负担，相比于http其需要更多的资源来支撑，同时<br>也降低了用户的访问速度</li>
<li>目前来说Http网站仍然大规模使用，在浏览器侧也没有特别大的差别，很<br>多用户不关心的话根本不感知</li>
</ul>
<h3 id="http通信存在的问题"><a href="#http通信存在的问题" class="headerlink" title="http通信存在的问题"></a>http通信存在的问题</h3><ol>
<li>容易被监听 http通信都是明文</li>
<li>被伪装 无法保证通信双方是合法的，通信方可能是伪装的</li>
<li>被篡改 hacker中间篡改数据后，接收方并不知道数据已经被更改</li>
</ol>
<h3 id="HTTPS-怎么建立连接？"><a href="#HTTPS-怎么建立连接？" class="headerlink" title="HTTPS 怎么建立连接？"></a>HTTPS 怎么建立连接？</h3><ol>
<li>客户端发送请求到服务器端</li>
<li>服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在</li>
<li>客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用<br>公开密钥加密发送到服务器端</li>
<li>服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送<br>到客户端</li>
<li>客户端使用共享密钥解密数据</li>
<li>SSL加密建立</li>
</ol>
<h3 id="https（问为什么要对称加密数据，而不用非对称加密数据呢）？"><a href="#https（问为什么要对称加密数据，而不用非对称加密数据呢）？" class="headerlink" title="https（问为什么要对称加密数据，而不用非对称加密数据呢）？"></a>https（问为什么要对称加密数据，而不用非对称加密数据呢）？</h3><ol>
<li>因为非对称加密加密解密算法效率较低，不适合客户端和服务器端这样高<br>频率的通信过程，在某些极端情况下，甚至能比非对称加密慢上1000倍</li>
<li>非对称加密的优势在于它可以很好帮助完成秘钥的交换，所以前期交换秘<br>钥必须使用非对称加密算法</li>
</ol>
<h3 id="为什么http一定要用TCP呢？"><a href="#为什么http一定要用TCP呢？" class="headerlink" title="为什么http一定要用TCP呢？"></a>为什么http一定要用TCP呢？</h3><ol>
<li>如果用UDP，网页源文件传输后可能出现错误，浏览器解析出错</li>
</ol>
<h3 id="长连接的好处？"><a href="#长连接的好处？" class="headerlink" title="长连接的好处？"></a>长连接的好处？</h3><ol>
<li>减少CPU及内存的使用，因为不需要经常的建立及关闭连接</li>
<li>减少网络的堵塞，因为减少了TCP请求，单个客户端不允许开启2个以上<br>的长连接，这个标准的目的是减少HTTP响应的时候，减少网络堵塞</li>
<li>减少后续请求的响应时间，因为此时不需要建立TCP，也不需要TCP握手<br>等过程</li>
<li>当发生错误时，可以在不关闭连接的情况下进行提示</li>
<li>缺点：可能会损害服务器的整体性能，如apache的长连接时间的长短，直<br>接影响到服务器的并发数</li>
</ol>
<h3 id="写一个简单的webserver？"><a href="#写一个简单的webserver？" class="headerlink" title="写一个简单的webserver？"></a>写一个简单的webserver？</h3><ol>
<li>服务器是属于被动的一方，当浏览器发起请求的时候，服务器才能和浏览<br>器通信，在此之前，服务器都处于一个等待监听的状态</li>
<li>实现服务器的第一步是建立一个 socket 连接，socket 套接字是对<br>TCP/UDP协议 的一个封装，socket()用于创建一个套接字，该套接字用<br>于监听某个端口</li>
<li>解析http请求 在bind()中套接字与端口绑定，随后通过listen()进行监<br>听，这时候就进入服务器程序的主循环，当有连接建立后，accpet()被调用<br>并返回一个新的套接字用于处理连接，这时派生一个子进程进行处理，子进<br>程中recv()从缓冲区读取数据交由相关函数处理</li>
<li>构造响应报文 拿到了请求报文并将其解析后，我们可以开始构造响应报文<br>的内容了，处理完毕后的结果通过send()发送出去，随后关闭用于处理的套<br>接字，子进程退出</li>
</ol>
<h3 id="web-server实现了什么？"><a href="#web-server实现了什么？" class="headerlink" title="web server实现了什么？"></a>web server实现了什么？</h3><p>Web服务器可以解析(handles)HTTP协议。当Web服务器接收到一个HTTP请<br>求(request)，会返回一个HTTP响应(response)</p>
<h3 id="URI和URL的区别是什么？"><a href="#URI和URL的区别是什么？" class="headerlink" title="URI和URL的区别是什么？"></a>URI和URL的区别是什么？</h3><ol>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标<br>识一个资源</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资<br>源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指<br>明了如何locate 这个资源</li>
<li>URI一般由三部组成</li>
</ol>
<ul>
<li>访问资源的命名机制</li>
<li>存放资源的主机名</li>
<li>资源自身的名称，由路径表示，着重强调于资源</li>
</ul>
<ol start="4">
<li>URL</li>
</ol>
<ul>
<li>协议(或称为服务方式)</li>
<li>存有该资源的主机IP地址(有时也包括端口号)</li>
<li>主机资源的具体地址。如目录和文件名等</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的<br>URI，它不仅唯一标识资源，而且还提供了定位该资源的信息</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/02/29/ComputerNetwork/">https://skysea-gaoming.github.io/2020/02/29/ComputerNetwork/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NetWork/">NetWork</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/Redis/"><i class="fa fa-chevron-left">  </i><span>Redis</span></a></div><div class="next-post pull-right"><a href="/2020/02/29/Linux/"><span>Linux</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/02/29/ComputerNetwork/';
  this.page.identifier = '2020/02/29/ComputerNetwork/';
  this.page.title = '应用层总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>