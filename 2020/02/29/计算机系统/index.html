<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机系统"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>计算机系统 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#《深入理解计算机系统》"><span class="toc-number">1.</span> <span class="toc-text">《深入理解计算机系统》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HelloWorld"><span class="toc-number">2.1.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本文件"><span class="toc-number">2.2.</span> <span class="toc-text">文本文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序的编译"><span class="toc-number">2.3.</span> <span class="toc-text">程序的编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统硬件的组成"><span class="toc-number">2.4.</span> <span class="toc-text">系统硬件的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储设备"><span class="toc-number">2.5.</span> <span class="toc-text">存储设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作系统管理硬件"><span class="toc-number">2.6.</span> <span class="toc-text">操作系统管理硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程"><span class="toc-number">2.6.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程"><span class="toc-number">2.6.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟存储器"><span class="toc-number">2.6.3.</span> <span class="toc-text">虚拟存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件"><span class="toc-number">2.6.4.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统之间利用网络通信"><span class="toc-number">2.6.5.</span> <span class="toc-text">系统之间利用网络通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">2.7.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信息"><span class="toc-number">3.</span> <span class="toc-text">信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进制间的转换原理"><span class="toc-number">3.1.</span> <span class="toc-text">进制间的转换原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种运算"><span class="toc-number">3.2.</span> <span class="toc-text">三种运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整数的表示"><span class="toc-number">3.3.</span> <span class="toc-text">整数的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制类型转换"><span class="toc-number">3.4.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制小数和IEEE浮点数"><span class="toc-number">3.5.</span> <span class="toc-text">二进制小数和IEEE浮点数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的机器级表示"><span class="toc-number">4.</span> <span class="toc-text">程序的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#程序编码"><span class="toc-number">4.1.</span> <span class="toc-text">程序编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#机器级代码"><span class="toc-number">4.2.</span> <span class="toc-text">机器级代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序存储器"><span class="toc-number">4.3.</span> <span class="toc-text">程序存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举个栗子"><span class="toc-number">4.4.</span> <span class="toc-text">举个栗子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式的注解"><span class="toc-number">4.5.</span> <span class="toc-text">格式的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据格式"><span class="toc-number">4.6.</span> <span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问信息"><span class="toc-number">4.7.</span> <span class="toc-text">访问信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作数指示符"><span class="toc-number">4.8.</span> <span class="toc-text">操作数指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据存送指令"><span class="toc-number">4.9.</span> <span class="toc-text">数据存送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算术和逻辑操作"><span class="toc-number">4.10.</span> <span class="toc-text">算术和逻辑操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件码"><span class="toc-number">4.11.</span> <span class="toc-text">条件码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跳转"><span class="toc-number">4.12.</span> <span class="toc-text">跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件传送指令"><span class="toc-number">4.13.</span> <span class="toc-text">条件传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch语句"><span class="toc-number">4.14.</span> <span class="toc-text">switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过程"><span class="toc-number">4.15.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转移控制"><span class="toc-number">4.16.</span> <span class="toc-text">转移控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器使用惯例"><span class="toc-number">4.17.</span> <span class="toc-text">寄存器使用惯例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组分配和访问"><span class="toc-number">4.18.</span> <span class="toc-text">数组分配和访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本原则"><span class="toc-number">4.18.1.</span> <span class="toc-text">基本原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异质的数据结构"><span class="toc-number">4.19.</span> <span class="toc-text">异质的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#结构"><span class="toc-number">4.19.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#联合"><span class="toc-number">4.19.2.</span> <span class="toc-text">联合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据对齐"><span class="toc-number">4.20.</span> <span class="toc-text">数据对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#越界访问和缓冲区溢出"><span class="toc-number">4.21.</span> <span class="toc-text">越界访问和缓冲区溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对抗缓冲区溢出攻击"><span class="toc-number">4.22.</span> <span class="toc-text">对抗缓冲区溢出攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理器体系结构"><span class="toc-number">5.</span> <span class="toc-text">处理器体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HCL"><span class="toc-number">5.1.</span> <span class="toc-text">HCL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化程序性能"><span class="toc-number">6.</span> <span class="toc-text">优化程序性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化编译器的能力和局限性"><span class="toc-number">6.1.</span> <span class="toc-text">优化编译器的能力和局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内联函数替换优化函数调用"><span class="toc-number">6.1.1.</span> <span class="toc-text">内联函数替换优化函数调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表示程序性能"><span class="toc-number">6.2.</span> <span class="toc-text">表示程序性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储器层次结构"><span class="toc-number">7.</span> <span class="toc-text">存储器层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#随机访问存储器RAM"><span class="toc-number">7.1.</span> <span class="toc-text">随机访问存储器RAM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#增强版DRAM"><span class="toc-number">7.1.1.</span> <span class="toc-text">增强版DRAM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非易失性存储器"><span class="toc-number">7.2.</span> <span class="toc-text">非易失性存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘"><span class="toc-number">7.3.</span> <span class="toc-text">磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘容量"><span class="toc-number">7.3.1.</span> <span class="toc-text">磁盘容量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链接"><span class="toc-number">8.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链接"><span class="toc-number">8.1.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目标文件"><span class="toc-number">8.2.</span> <span class="toc-text">目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重定位目标文件"><span class="toc-number">8.3.</span> <span class="toc-text">可重定位目标文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号和符号表"><span class="toc-number">8.4.</span> <span class="toc-text">符号和符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号解析"><span class="toc-number">8.5.</span> <span class="toc-text">符号解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#程序符号的强弱"><span class="toc-number">8.5.1.</span> <span class="toc-text">程序符号的强弱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态库"><span class="toc-number">8.6.</span> <span class="toc-text">静态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定位"><span class="toc-number">8.7.</span> <span class="toc-text">重定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可执行目标文件"><span class="toc-number">8.8.</span> <span class="toc-text">可执行目标文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常控制流"><span class="toc-number">9.</span> <span class="toc-text">异常控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常"><span class="toc-number">9.1.</span> <span class="toc-text">异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程"><span class="toc-number">10.</span> <span class="toc-text">并发编程</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603820855526&amp;di=814b302a9516d264731a29c3c1fce803&amp;imgtype=0&amp;src=http%3A%2F%2Fwenhui.whb.cn%2Fu%2Fcms%2Fwww%2F201804%2F16135756wr02.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">计算机系统</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/02/29/计算机系统/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="《深入理解计算机系统》"><a href="#《深入理解计算机系统》" class="headerlink" title="《深入理解计算机系统》"></a>《深入理解计算机系统》</h2><p>只有了解计算机底层原理才能走的更远</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>计算机系统是由硬件和系统软件组成，它们共同工作来运行应用程序。<br>如下是一个简单的c语言代码，记为Hello.c文件，接下来简单分析一下它的生命周期。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><p>运行一个程序首先要写程序，写程序肯定就是用英文字符来写，就好像写英文作<br>文一样。但是计算机并不认识这些字符，计算机是一个电子产品内部都是各种电<br>子器件。初中学过物理可以知道电压有高低之分，可以用1和0表示电压的高低。<br>可以将0,1与英文字符联系起来。英文字符一共有26个，加上一些标点符号等等<br>都可以用0和1表示，用8个位就可以表示所有的英文字符加上各种符号。把8个<br>位叫做一个字节。</p>
<ol>
<li>所以Hello.c源程序实际是以0或者1组成的位序列。ASCALL码用唯一一个字<br>节来表示每一个字符，只能表示英文字符和一些标点符号，没有中文字符</li>
<li>计算机中的所有信息都是由0和1组成  </li>
<li>源程序指未编译的按照一定的程序设计语言（Java，c，c++）编写的文本<br>文件，二进制文件是用0和1表示的</li>
<li>位是电子计算机中最小的数据单位，每一位的状态只能是0或1</li>
<li>每个字节都有一个整数值，而该整数值对应一个字符，每个文本行都是用换<br>行符结束，但是换行符不可见 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number28.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number182.jpg" alt></li>
<li>GBK中一个汉字两个字节，UTF-8中一个汉字三个字节</li>
</ol>
<h3 id="程序的编译"><a href="#程序的编译" class="headerlink" title="程序的编译"></a>程序的编译</h3><p>计算机系统无法读懂高级语言只能够判断0和1，所有高级语言所写的程序必须<br>最终转变为0和1的序列才可以被计算机读懂，这其中需要经过一系列的过程<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number1.jpg" alt> </p>
<ol>
<li>预处理器 源程序文件经过预处理器处理变为被修改的源程序文件，预处理<br>器读取第一行#开头的命令修改Hello.c文件，第一行#include&lt;stdio.h&gt;<br>命令告诉与处理器读取系统头文件stdio.h的内容，并把它直接插入到程序<br>文本中得到另一个C程序，一般是以.i为文件扩展名 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number183.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number184.jpg" alt></li>
<li>编译器 编译器将文本文件Hello.i编译为文本文件Hello.s，该文件包<br>含汇编语言程序，汇编语言是一种低级语言，汇编语言程序中每条语句都以<br>一种标准的文本格式确切描述一条低级语言指令 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number185.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number186.jpg" alt></li>
<li>汇编器 汇编器将Hello.s翻译成机器语言指令，机器语言是二进制代码<br>表示的计算机能够直接识别和执行的一种机器指令的集合，Hello.o是一个<br>二进制文件，它的字节编码是机器语言指令而不是字符 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number187.jpg" alt></li>
<li>链接器 在Hello.c文件中调用了一个printf函数打印语句，它是每个C<br>编译器都会提供的标准C库中的一个函数，可以直接使用，printf函数存在<br>于一个名为prinf.o的单独预编译好了的目标文件中，这个文件会以某种方<br>式合并到Hello.o文件中，链接器就是负责处理这种合并，结果就会得到一<br>个Hello文件，它是一个可执行目标程序，可以被加载到内存中，由系统运<br>行 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number188.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number189.jpg" alt></li>
</ol>
<h3 id="系统硬件的组成"><a href="#系统硬件的组成" class="headerlink" title="系统硬件的组成"></a>系统硬件的组成</h3><p>经过以上过程生成的可执行Hello文件已经放在磁盘中，那么该文件是如何<br>运行的呢？简单了解各个组件 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number5.jpg" alt></p>
<ol>
<li>总线 贯穿整个系统的一组电子管道，通常用来传送定长的字节块，也就<br>是字。字的大小与系统有关，在64位系统中一个字是8个字节。总线每次只传<br>送一个字</li>
<li>I/O设备 输入输出设备是系统与外部世界相连的通道，它们的功能都是<br>在IO总线和IO设备之间传递信息，上图最下面4个设备就是IO设备</li>
<li>主存 计算机的一个临时存储设备（内存），在处理器执行程序的时候用<br>来存放程序和程序处理的数据，由一组动态随机存储器(DRAM)芯片组成，逻<br>辑上讲是一个线性的字节数组每个字节都有唯一的地址（数组索引），地址<br>是从零开始</li>
<li>处理器 全称中央处理器（CPU），是解释（执行）存储在主存中指令的<br>引擎，处理器的核心是一个字长的存储设备（或寄存器），简称程序计数器<br>，任何时候都指向主存中的某条机器指令，即含有该指令的地址。执行完一<br>条指令之后更新程序计数器执行下一条指令，处理器所做的操作是围绕主存<br>、寄存器文件以及算术/逻辑单元（ALU）进行的，寄存器文件是一个小的存<br>储设备，由一些1字长的寄存器组成，每个寄存器都有唯一的名字，ALU则计<br>算新的数据和地址</li>
<li>CPU在指令的要求下会做如下的操作</li>
</ol>
<ul>
<li>加载 将一个字节或者字从主存中复制到寄存器中，以覆盖寄存器原来的内容</li>
<li>存储 将一个字节或者字从寄存器复制到主存中，以覆盖原来的内容</li>
<li>操作 将两个寄存器的内容复制到ALU中，ALU对这两个字做算术操作，将结<br>果放到一个寄存器中覆盖原来的内容</li>
<li>跳转 从指令本身抽取一个字并将这个字复制到程序计数器（PC）中覆盖原<br>来的内容  </li>
</ul>
<h3 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h3><p>hello程序的指令最初存放在磁盘上，程序加载时被放到主存，当处理器运行<br>程序时又从主存复制到处理器，字符串”Hello World/n”最初存放在磁盘上，<br>后来又复制到主存，后来又复制到显示设备</p>
<ol>
<li>从磁盘加载可执行文件到主存 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number8.jpg" alt></li>
<li>将输出字符串从内存写到显示器 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number9.jpg" alt></li>
<li>高速缓存处理器 根据机械原理，较大的存储设备比较小的存储设备运行<br>地慢，而快速设备的造价远高于同类低速设备，一个典型系统上的磁盘驱动<br>器可能比内存大1000倍，但是对于处理器而言从磁盘驱动器读取一个字的时<br>间开销比从内存读取慢1000倍。一个典型的寄存器文件只能存储几百字节的<br>数据，而内存可以存储几十亿字节的数据，处理器从寄存器文件读取的速度<br>远高于从内存中读取的速度。如何减小由于数据复制产生的开销呢？可以采<br>用更小更快的存储设备，也就是高速缓存存储器，作为暂时的集结区域，用<br>来存放处理器暂时可能需要的信息 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number10.jpg" alt></li>
<li>存储设备的金字塔结构 在处理器和主存之间插入更快更小的存储设备，存<br>储器层次结构的主要思想就是上一层的存储器作为下一层存储器的高速缓存 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number11.jpg" alt></li>
</ol>
<h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><p>加载和运行Hello程序时并没有直接访问键盘、显示器、磁盘和内存这些硬件，<br>都是依靠操作系统提供的服务。操作系统可以看成是应用程序和硬件之间的<br>一层软件 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number190.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number191.jpg" alt><br>操作系统有两个基本功能</p>
<ul>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的硬件设<br>备，操作系统通过几个抽象的概念实现这两个功能。文件是对IO设备的抽<br>象表示，虚拟存储器是对主存和磁盘IO设备的抽象表示，进程是对处理器<br>、主存和IO设备的抽象表示</li>
</ul>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是对操作系统正在运行的程序的一种抽象，一个系统可以同时运行多<br>个进程。一个单核处理器在一个时刻只能执行一个进行，进程是在不断切<br>换的，操作系统实现这种交错执行的机制称为上下文切换。上下文保持跟<br>踪进程运行所需的所以状态信息，比如PC寄存器的值和主存的内容<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number192.jpg" alt></p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个进程实际可以由多个线程组成，每个线程都运行在进程的上下文中，<br>共享同样的代码和全局数据</p>
<h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><p>每个进程实际都有一个内存空间，虚拟存储器是一个抽象的概念，好像每<br>个进程都在使用同一个存储器 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number193.jpg" alt><br>虚拟存储器的运作需要硬件和操作系统之间紧密复杂的交互，包括对处理<br>器生成的每个地址的硬件翻译，其基本思想就是把一个进程虚拟存储器的<br>内容存储在磁盘上，然后用主存作为此磁盘的高速缓存</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件就是字节序列。每个IO设备包括磁盘、键盘、显示器甚至网络都可以视<br>为文件。系统中的所有输入输出都是通过使用一组称为Unix I/O的系统函<br>数调用读写文件实现的</p>
<h4 id="系统之间利用网络通信"><a href="#系统之间利用网络通信" class="headerlink" title="系统之间利用网络通信"></a>系统之间利用网络通信</h4><p>从一个单独的系统来看，网络可以视为一个IO设备，当系统从主存将一串<br>字节复制到网络适配器，数据流经过网络到达另一台机器<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number194.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number195.jpg" alt></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>多核处理器 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number31.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number32.jpg" alt></li>
<li>抽象的使用是计算机科学中最为重要的概念之一，例如为一组函数规定<br>一个简单的应用程序接口(API)，程序员无需了解内部原理就能使用函数<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number196.jpg" alt></li>
</ol>
<h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><ul>
<li>无符号数 基于传统的二进制表示法，表示大于或等于0的数</li>
<li>补码 表示有符号整数</li>
<li>浮点数</li>
</ul>
<ol>
<li>16进制表示法 一个字节是8位，二进制表示就是从00000000到11111111，<br>十进制就是0到255，16进制使用数字0到9字母A到F（a到f）,一般使用0x或<br>0X开头，如果一个二进制数字位总数不是4的倍数，就在最左边补0。8进制以<br>0开头 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number33.jpg" alt></li>
<li>寻址和字节顺序 在几乎所有的机器上，多字节对象都被存储为连续的字节<br>序列，对象的地址为所使用字节中最小的地址，比如一个类型为int的变量x地<br>址为0x100,那么地址表达式&amp;x的值就是0x100,x的4个字节被存储在存储器的<br>0x100，0x101，0x102，0x123</li>
<li>小端法 按照从最低有效字节到最高有效字节的顺序存储对象，也就是最低有<br>效字节在最前面</li>
<li>大端法 按照从最高有效字节到最低有效字节的顺序存储对象，也就是最高有<br>效直接在最前面</li>
<li>0x01234567 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number17.jpg" alt></li>
</ol>
<h3 id="进制间的转换原理"><a href="#进制间的转换原理" class="headerlink" title="进制间的转换原理"></a>进制间的转换原理</h3><p>用一组固定的数字和一套统一的规则来表示数目的方法称为数制，进位计数制的<br>数码所表示的数值大小则与它在数中所取得位置有关，常见的有二进制，十进制<br>，十六进制</p>
<ol>
<li>数码 用来表示进制数的元素，比如二进制位0和1，十进制为0,1,2,3,4,5,<br>6,7,8,9</li>
<li>基数 数码的个数 比如二进制基数为2，十六进制基数为16</li>
<li>位权 数制中固定位置对应的单位值称为位权，对于N进制，整数部分第i位为<br>N^(i-1)，小数部分第j位为N^(-j) <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number18.jpg" alt></li>
<li>二进制转换为十进制<br>（10.10101）2=（1x2^1+0x2^0+1x2^-1+0x2^-2+1x2^-3+0x2^-4+1x2^-5）<br>=（2+0+0.5+0+0.125+0+0.03125）10=（2.65625）10</li>
<li>二进制转换为十六进制 每4位2进制数对应1个十六进制数，以小数点为界<br>整数位从右向左每4位隔开，不足4位用0填补，小数位从左向右每4位隔开，<br>不足4位用0填补（10.10101）2=（0010.1010 1000）2=（2.A8）16</li>
<li>十进制转换为2进制 以小数点为界，整数部分除以2，每次得到商和余数，<br>用商继续除以2，第一次得到的余数作为2进制的个位，第二次得到的余数作<br>为2进制的十位，依次类推，最后一次得到的小于2的商为最高位。小数部分<br>先乘2，然后获得运算结果的整数部分，将结果中的小数部分继续乘2，直到<br>小数部分为0，第一次得到的整数部分作为二进制小数的最高位，依次类推<br>（93）10=（1011101）2   （0.3125）10=（0.0101）2</li>
</ol>
<h3 id="三种运算"><a href="#三种运算" class="headerlink" title="三种运算"></a>三种运算</h3><ul>
<li>位级运算</li>
<li>逻辑运算</li>
<li>移位运算</li>
</ul>
<ol>
<li>位级运算 </li>
</ol>
<ul>
<li>~01=10</li>
<li>11&amp;00=00</li>
<li>11|01=11</li>
<li>11^01=10</li>
</ul>
<ol start="2">
<li>逻辑运算 对第一个参数求值确定表达式结果就不会对第二个参数求值，这<br>点与位级运算不同，返回结果是1或者0</li>
</ol>
<ul>
<li>01001||01000=1</li>
<li>10000&amp;&amp;00000=0</li>
<li>!10101=0</li>
</ul>
<ol start="3">
<li>移位运算<br>如果k很大时实际上移动k mod w位，w是数据的组成位数</li>
</ol>
<ul>
<li>&lt;&lt; k 左移k位，右端补k个0</li>
<li>&gt;&gt; k 右移k位，可以分为逻辑右移和算术右移，逻辑右移左端补k个0，<br>算术右移左端补k个最高有效位，对于Java x&gt;&gt;k表示算术右移，x&gt;&gt;&gt;k表示<br>逻辑右移</li>
</ul>
<h3 id="整数的表示"><a href="#整数的表示" class="headerlink" title="整数的表示"></a>整数的表示</h3><ul>
<li>整数分为两种，一种是无符号数，另一种是有符号数。Java只支持后者 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number22.jpg" alt></li>
<li>C语言数据类型可以用来指定大小，同时可以指定表示的是负数还是非负数</li>
</ul>
<ol>
<li>无符号数的编码 即用unsigned声明，无符号的二进制，对于任意一<br>个w位的无符号序列，都存在唯一一个整数介于0到2^w-1，用B2Uw表示 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number24.jpg" alt></li>
<li>有符号数的编码–补码 </li>
</ol>
<ul>
<li>原码：一个整数按照绝对值大小转换为二进制数，最高位为符号位  </li>
<li>反码： 将原码的最高位外其余位取反，正数的反码为原码  </li>
<li>补码： 反码最低位加1  </li>
<li>对于正数反码补码和原码都一样，符号位为0，数值位相同。目前几乎所有<br>的机器都使用补码有符号数表示为B2Tw，B2Tw(X)=-Xw-1*2^(w-1)+<br>∑Xi*2^i(0到w-2)</li>
</ul>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>有符号数和无符号数之间的转换的一般规则是，数值可能改变但是位模式不<br>变，无符号数一般带u在C语言中当执行一个运算，如果有一个运算数是无符<br>号数另一个是有符号数会隐式地将有符号参数转换为无符号数<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number35.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number36.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number37.jpg" alt></p>
<ol>
<li>扩展一个数字的位 将一个无符号数转换为一个更大的数据类型，只需要<br>在前面添加0。将一个补码数字转换成一个更大的数据类型，只需要在开头添<br>加符号位。一个数据大小到另一个数据大小的转换一般默认是先改变大小，<br>然后改变符号<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">short sx=<span class="number">-12345</span>;</span><br><span class="line"><span class="keyword">unsigned</span> uy=ux;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">unsigned</span> uy=(<span class="keyword">unsigned</span>)(<span class="keyword">int</span>)sx;</span><br></pre></td></tr></table></figure></li>
<li>截断数字 将一个w位的数截断为一个k位的数，只需要高位截断w-k位 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number38.jpg" alt></li>
<li>无符号数加法 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number39.jpg" alt></li>
<li>有符号数加法 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number40.jpg" alt></li>
<li>补码的非 -X=X=-2^(w-1)?-2^(w-1):-X</li>
<li>无符号乘法 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number41.jpg" alt></li>
<li>有符号乘法 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number42.jpg" alt></li>
</ol>
<h3 id="二进制小数和IEEE浮点数"><a href="#二进制小数和IEEE浮点数" class="headerlink" title="二进制小数和IEEE浮点数"></a>二进制小数和IEEE浮点数</h3><p>二进制表示法可以对形如V=x*2^y的有理数进行编码，二进制小数不像整数一<br>样只要位数足够就可以表示所有整数，仅考虑有限长度的编码，二进制小数无<br>法精确表示任意小数，比如0.2，只能增加二进制长度提高表示的精度 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number25.jpg" alt><br>对于一个形如x/2^k的小数，使用x的二进制表示，然后把二进制小数点插入<br>从右边算起的第k个位置，例如25/16，25表示为11001，小数点从右算第4位</p>
<ol>
<li>IEEE浮点数标准 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number43.jpg" alt></li>
<li>单精度浮点数s exp frac分别为1位 k=8位 n=23位，得到一个32位表示</li>
<li>双精度浮点数s exp frac分别为1位 k=11位 n=52位，得到一个64位表示 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number44.jpg" alt></li>
<li>根据阶码数值可以分为三种情况 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number45.jpg" alt></li>
<li>NaN Not a Number</li>
<li>规格化的值 阶码的值=E-Bias，其中e是无符号数，Bias=2^(k-1)-1，尾<br>数为M=1+f，这种方式也叫隐含的以1开头</li>
<li>非规格化的值 阶码的值=1-Bias，尾数的值=f，不包含隐含的开头1</li>
<li>特殊值 阶码全为1，小数域全为0时表示无穷，s=0是正无穷，s=1是负无穷</li>
<li><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number47.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number48.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number49.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number50.jpg" alt></li>
</ol>
<h2 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h2><p>汇编代码与机器密切相关，而高级语言屏蔽了机器之间的差别，接下来<br>会介绍两种机器语言</p>
<ul>
<li>Intel IA32  Intel处理器系列熟称x86，每个后继处理器的设计都<br>是向后兼容的，也就是较早版本编译的代码可以在新的处理器上运行<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number197.jpg" alt></li>
<li>x86-64  IA32在64位上的扩展，是由AMD公司开发出来的</li>
</ul>
<ol>
<li>汇编语言 汇编语言的主体是汇编指令，汇编指令和机器指令的差别<br>在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式 </li>
<li>汇编语言指令是机器指令的一种符号表示，而不同的CPU有不同的机<br>器指令系统，也就有不同的汇编语言，所以汇编语言程序与机器有密切<br>关系，所以除了同系列不同型号的CPU有之间的汇编语言程序有一定程度<br>的可移植性，其他类型的CPU无法移植。是机器代码的文本表示</li>
<li>高级语言 高级语言与计算机的硬件结构和指令系统无关，抽象级别<br>较高。用高级语言编写的程序可以在不同的机器上编译和执行，而汇编<br>代码与特定的机器密切相关</li>
<li>汇编语言操作的对象不是具体的数据，而是寄存器或者存储器，也就<br>是说汇编语言直接与寄存器和存储器打交道，因此汇编语言的执行速度<br>比高级语言快。</li>
</ol>
<h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -O1 -o p p1.c p2.c</span><br></pre></td></tr></table></figure>
<ul>
<li>-01表示一级优化，提高优化级别会使程序运行更快，但是编译时间会<br>变长。采用更高级别的优化产生的代码会严重变形，一般使用-O2较好</li>
<li>编译器产生两个汇编文件p1.s p2.s，汇编器将两个汇编文件转化为目<br>标代码文件p1.o p2.o，目标代码文件是机器代码的一种形式，包含指令<br>的二进值表示但是没有填入地址的全局值，最后链接器将两个文件与实现<br>库函数的代码合并成可执行文件p，p是处理器执行的代码格式</li>
</ul>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number124.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number127.jpg" alt></p>
<ol>
<li>机器级体系结构 它定义的处理器的状态、指令的格式以及每条指令对<br>状态的影响 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number198.jpg" alt></li>
<li>机器级程序使用的地址是虚拟地址，提供的存储器模型看上去是一个<br>非常大的字节数组，存储器系统的实际实现是将多个硬件存储器和操作<br>系统软件结合起来</li>
<li>c语言提供的模型可以在存储器中声明和分配各种数据类型的对象，但<br>是机器代码只是简单地将存储器看成一个很大的按字节寻址的数组</li>
<li>c语言中的聚合数据类型，例如数组和结构，在机器代码中用连续的一<br>组字节来表示。即使是标量数据类型，汇编代码也不区分有符号或无符号整<br>数，不区分各种类型的指针，甚至不区分指针和整数</li>
</ol>
<ul>
<li>程序计数器指示将要执行的下一条指令在存储器中的地址</li>
<li>整数寄存器文件 可以存储一些地址或者整数的数据。有的用来记录某些<br>重要的程序状态，有的用来保存临时数据，比如局部变量和函数的返回值</li>
<li>条件码寄存器 保存最近执行的算术或者逻辑指令的状态信息，它们用来<br>实现控制或者数据流中的条件变化，比如用来实现if和while语句</li>
<li>浮点寄存器 存储浮点数据</li>
</ul>
<h3 id="程序存储器"><a href="#程序存储器" class="headerlink" title="程序存储器"></a>程序存储器</h3><ol>
<li>包括程序的可执行代码，操作系统需要的一些信息，用来管理过程调用<br>和返回的运行时栈，以及用户分配的存储器块（malloc）</li>
<li>程序存储器用虚拟地址来寻址，在任意给定的时刻，只认为有限的虚拟<br>地址是合法的，操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处<br>理器存储器中的物理地址</li>
<li>一条机器指令只执行一个非常基本的操作，例如将存放在寄存器中的两<br>个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指<br>令地址。编译器必须产生这些指令的序列，从而实现程序结构</li>
<li>寻址空间 内存中可独立识别的位置总数</li>
<li>寻址能力 每个内存位置中包含的bit数目</li>
<li>Intel术语 字/word/16-bit 双字/double words/32-bit<br>四字/quad/words/64-bit <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number199.jpg" alt></li>
</ol>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> accum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t= x+y;</span><br><span class="line">    accum += t;</span><br><span class="line">    <span class="keyword">return</span> t;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>反汇编器 根据目标代码产生类似汇编代码的格式 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number200.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -O1 -c code.c</span><br><span class="line">&#x2F;&#x2F;object dump</span><br><span class="line">objdump -d code.o</span><br></pre></td></tr></table></figure>
</li>
<li><p>每条指令的长度在1到15个字节不等，常用的指令字节数较少</p>
</li>
<li><p>设计指令的格式是从某个指定位置开始讲字节唯一解码成机器指令</p>
</li>
<li><p>反汇编器只是基于机器代码文件来确定汇编代码，不需要访问源代码<br>或者汇编代码</p>
</li>
<li><p>生成实际可执行代码需要目标文件中含有一个main函数，程序会从<br>main函数开始执行 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number201.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number202.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反汇编后发现汇编代码与之前的汇编代码基本一样，一个主要的区别<br>就是左边列出的地址不同，另一个区别是链接器确定了存储全局变量<br>accum的地址。这个不是x86-64的机器指令所以看起来不一样</p>
</li>
</ul>
<h3 id="格式的注解"><a href="#格式的注解" class="headerlink" title="格式的注解"></a>格式的注解</h3><ul>
<li>汇编文件中所有以点开头的行都是指导汇编器和链接器的命令，通常可以<br>忽略</li>
<li>我们使用的都是ATT格式的汇编代码，这是GCC、OBJDUMP和其他一些工具<br>的默认格式</li>
</ul>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ol>
<li>大多数GCC生成的汇编代码指令都有一个字符后缀，表明操作数的大小，<br>例如数据传送指令有三个变种</li>
</ol>
<ul>
<li>movb 传送字节</li>
<li>movw 存送字</li>
<li>movl 存送双字</li>
<li>movq 传送四字</li>
</ul>
<ol start="2">
<li>x86-64 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number126.jpg" alt> </li>
</ol>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><ul>
<li>一个IA32中央处理单元包含一组8个存储32位值的寄存器</li>
<li>一个x86-64中央处理单元包含16个存储64位值的寄存器<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number123.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number161.jpg" alt></li>
</ul>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><ol>
<li>大多数指令有一个操作码和一个或多个操作数，操作数指示出执行一个<br>操作中要引用的源数据值，以及放置结果的目标位置</li>
<li>三种不同位置的操作数</li>
</ol>
<ul>
<li>立即数 也就是常数，书写方式是$后面跟标准C表示法表示的整数，比如<br>$-577 $0x1F，直接放在指令中</li>
<li>寄存器 用Ea表示任意寄存器a，用引用R[Ea]表示它的值，这是将寄存器<br>集合看成一个数组R，用寄存器标识符作为索引</li>
<li>存储器引用 它会根据计算的地址访问某个存储器位置，因为将存储器看<br>成一个很大的字节数组用符号Mb[Addr]表示对存储在存储器中从地址Addr<br>开始的b个字节的引用，一般省去b</li>
</ul>
<ol start="3">
<li>寻址模式</li>
</ol>
<ul>
<li>Imm(Eb,Ei,s)是最常用的形式，这样的引用有4个组成部分，一个立即数<br>偏移Imm，一个基址寄存器Eb，一个变址寄存器Ei和一个比例因子s，引用数<br>组元素时会用到这种通用形式，其他形式都是这种通用形式的特殊情况 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number128.jpg" alt></li>
</ul>
<h3 id="数据存送指令"><a href="#数据存送指令" class="headerlink" title="数据存送指令"></a>数据存送指令</h3><p>数据从一个位置复制到另一个位置的指令是最频繁使用的指令。操作数表示<br>的通用性使得一条简单的数据传送指令能够完成在好多机器中要好几条指令<br>才能完成的功能。可以把指令分为指令类，一类指令执行相同的操作，只不<br>过操作数的大小不一样，movq传送4字 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number129.jpg" alt> </p>
<ol>
<li>存送指令的两个操作数不能都指向存储器位置，立即数不能作为目的操作数</li>
<li>栈 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pushl %ebp 等价于</span><br><span class="line">subl $4,%esp</span><br><span class="line">movl %ebp,(%esp)</span><br><span class="line">popl %eax 等价于</span><br><span class="line">movl (%esp),%eax</span><br><span class="line">addl $4,%esp</span><br></pre></td></tr></table></figure>
<img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number136.jpg" alt></li>
</ol>
<h3 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h3><ol>
<li>有效地址 leaq指令实际是movq指令的变形，目的操作数必须是一个寄存器<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number143.jpg" alt> </li>
<li>一元操作和二元操作 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number146.jpg" alt></li>
<li>移位操作  <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number147.jpg" alt> </li>
<li>特殊的算术操作 idivq指令除法结果应该是 R[%rax]<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number204.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number149.jpg" alt> </li>
</ol>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><ol>
<li>除了整数寄存器，CPU还维护一组单个位的条件吗寄存器，用于描述最近的<br>算术或逻辑操作的属性 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number205.jpg" alt></li>
</ol>
<ul>
<li>CF 进位标志 最近的操作使最高位产生进位，可以用于检测无符号数的溢出</li>
<li>ZF 零标志 最近的操作结果是0</li>
<li>SF 符号标志 最近操作得到结果是负数</li>
<li>OF 溢出标志 最近的操作导致一个补码溢出–正溢出或负溢出，两个整数相<br>加最多溢出，不会出现最高位产生进位</li>
</ul>
<ol start="2">
<li>还有两类指令只设置条件吗而不改变其他寄存器 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number206.jpg" alt></li>
<li>访问条件码 条件码通常不会直接读取，常用的方法有三种</li>
</ol>
<ul>
<li>可以根据条件码的某个组合，将一个字节设置为0或者1</li>
<li>可以跳转到程序的某个其他部分</li>
<li>可以有条件传送数据<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number207.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number208.jpg" alt></li>
</ul>
<h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>正常情况指令一条条顺序执行,跳转会切换到一个全新的位置，这些跳转的目的<br>地通常用一个标号指明</p>
<ol>
<li>无条件跳转，跳转的目的地通常用一个标号指明，也是指令的一部分，在<br>产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标<br>（目的指定的地址）编码为跳转指令的一部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> jmp .L1</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">.L1:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>间接跳转，跳转目标是从寄存器或存储器位置中读取出来，写法是 * + 一个<br>操作数指示符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp *%eax #用寄存器的值作为跳转目标</span><br><span class="line">jmp *(%eax) #用寄存器的值作为读地址，从存储器中读取跳转目标</span><br></pre></td></tr></table></figure></li>
<li>有条件跳转 根据条件码的某个组合，或者跳转或者继续执行代码序列中下一<br>条指令的地址 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number162.jpg" alt></li>
<li>PC相关寻址时程序计数器的值是跳转指令后面的那条指令，而不是跳转指<br>令本身，得到反汇编代码后计算跳转地址时要用跳转指令的下一条指令地址<br>加上目标编码 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number209.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number210.jpg" alt></li>
</ol>
<h3 id="条件传送指令"><a href="#条件传送指令" class="headerlink" title="条件传送指令"></a>条件传送指令</h3><p>实现条件操作的传统方式是利用控制的条件转移，但是效率非常低。数据的条件<br>转移是一种替代策略，先计算一个条件操作的两种结果然后根据条件是否满足<br>选择其中一个。v=test-wxpr? then-expr : else-expr  <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number163.jpg" alt>  </p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch语句可以根据一个整数索引值进行多重分支，提高可读性以及能通过跳<br>转表实现分支跳转。跳转表就是一个数组，情况标号跨过一个不连续的区域，<br>有些情况有多个标号，有些情况可能落入其余情况中数组的索引就是一个代<br>码段的地址。优点是执行开关语句的时间与开关情况的数量无关。可以将数<br>组的元素分为几部分，先找defalut，再找重复位置标号，再找没有break<br>的部分并且承接下面的部分 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number211.jpg" alt><br>根据汇编代码前三行可以知道，下界是0上界是7，默认情况标号是.L2，然后<br>在跳转表中寻找跳转标号.L2，可知switch语句情况标号值只有0 2 4 5 7 ，<br>有两个标号重复出现就是.L4，确定2和7跳转一致，.L6部分执行完后没有跳<br>转到.L8，而是继续执行.L3后的部分。尤此可以确定全部内容</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>一个过程就是调用一个函数的过程，包括将数据（形参和返回值）和控制从代<br>码的一部分传递到另一部分，在进入一个过程时还要为局部变量分配空间，退<br>出时释放空间。一个过程就是一个栈帧，有两个指针在两个顶端，%rbp为帧指<br>针（可选），%rsp为栈指针。过程Q也用栈来保存其他不能存放在寄存器中的<br>局部变量</p>
<ul>
<li>寄存器数量有限，只能保存一部分局部变量</li>
<li>有些局部变量是数组或者结构，必须通过数组或结构引用来访问</li>
<li>要对一个局部变量使用地址操作符&amp;，必须能生成一个地址<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number164.jpg" alt></li>
</ul>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><ul>
<li>call Label 过程调用</li>
<li>call *Operand 过程调用</li>
<li>leave 为返回准备栈</li>
<li>ret 从过程调用中返回，也就是从栈中弹出地址并跳转到这个位置</li>
<li>IA32 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number165.jpg" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># leave</span><br><span class="line">movl %ebp,%esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure></li>
<li>x86-64 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number213.jpg" alt></li>
</ul>
<h3 id="寄存器使用惯例"><a href="#寄存器使用惯例" class="headerlink" title="寄存器使用惯例"></a>寄存器使用惯例</h3><p>程序寄存器组是唯一能被所有过程共享的资源。在给定时刻只有一个方法<br>在执行，必须保证一个过程调用者调用另一个过程时，被调用者不会覆盖<br>调用者稍后会使用的寄存器值</p>
<ul>
<li>调用者寄存器 %r10， %r11 调用者在调用之前在帧中保存临时值，可<br>以在被调用的帧中修改</li>
<li>被调用者寄存器 %rbx, %rbp, %r12, %r13, %r14, %r15 被调用者<br>在使用前在帧中保存临时值，在返回之前恢复它们<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number212.jpg" alt></li>
</ul>
<h3 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h3><p>C语言的数组是一种将标量数据聚集成更大数据类型的方式</p>
<h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>对于数据类型T和整数常量N声明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T A[N];</span><br><span class="line">&#x2F;&#x2F;引用指令简化数组访问，比如E是int数组，访问E[i]</span><br><span class="line">&#x2F;&#x2F;E保存在%rdx i保存在%rcx</span><br><span class="line">movl (%rdx,%rcx,4), %rax</span><br></pre></td></tr></table></figure>
<p>首先在内存中分配一个L*N字节的连续区域，L是数据类型T的大小，可以<br>用xA表示起始位置，然后引入标识符A，用A作为指向数组开头的指针，从<br>0到N-1的整数索引来访问数组元素，数组元素i会存放在地址为xA+L*i的<br>地方，xA是起始位置 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number214.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number215.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number216.jpg" alt></p>
<h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><p>C语言提供了两种结合不同类型的对象来创建数据类型的机制：结构和联合</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>用struct声明一个数据类型，将不同类型的对象聚合到一个对象中，结构<br>的所有组成部分都放在存储器中一段连续的区域内，指向结构的指针就是<br>结构第一个字节的地址 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number217.jpg" alt></p>
<h4 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h4><p>用Union声明一个数据类型，结构与struct一样，所有字段的偏移量都是0<br>一个联合的总的大小等于最大字段的大小</p>
<h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>许多计算机对基本数据类型合法地址做出一些限制，要求某种类型对象的地<br>址必须是某个值K（2,4,8）的整数倍 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number218.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number219.jpg" alt><br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number220.jpg" alt></p>
<h3 id="越界访问和缓冲区溢出"><a href="#越界访问和缓冲区溢出" class="headerlink" title="越界访问和缓冲区溢出"></a>越界访问和缓冲区溢出</h3><p>C语言对数组引用不进行边界检查，而且局部变量和状态信息都放在栈中，对<br>越界的数组元素的写操作会破坏存储在栈中的状态信息，一种常见的状态破<br>坏就是缓冲区溢出 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number221.jpg" alt><br>首先是将返回地址0x8048643入栈，然后%ebp的值入栈，所以接下来连续4<br>个字节是bffffc94，然后分别保存三个寄存器的值 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number222.jpg" alt><br>30是字符0的ascall值，前8个字符都正常写入，接下来就会破坏三个保存<br>的寄存器的值，最后字符串的末尾是空字符</p>
<h3 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h3><ol>
<li>栈随机化 程序每次运行时栈的位置都有变化</li>
<li>栈破坏检测 在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝<br>雀值，也称为哨兵值，在程序每次运行时随机产生。在恢复寄存器状态和从<br>函数返回之前程序检查这个金丝雀值是否改变，如果改变那么程序终止 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number223.jpg" alt></li>
<li>限制可执行代码的区域</li>
</ol>
<h2 id="处理器体系结构"><a href="#处理器体系结构" class="headerlink" title="处理器体系结构"></a>处理器体系结构</h2><p>目前学习计算机系统只限于机器语言程序级，处理器必须执行一系列指令<br>每个简单操作比如两数相加都会被编码为一个或多个字节序列组成的二进<br>制格式。一个处理器支持的指令和指令的字节级编码称为它的指令集架构</p>
<h3 id="HCL"><a href="#HCL" class="headerlink" title="HCL"></a>HCL</h3><p>HCL是一种逻辑设计和硬件控制语言</p>
<h2 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h2><p>你能获得的对程序最大的加速比就是当你第一次让它工作起来的时候<br>编写高效程序一般有三个要求</p>
<ol>
<li>选择合适的算法和数据结构</li>
<li>必须编写出编译器能够有效优化以转换成高效可执行代码的源代码</li>
<li>将一个大任务分成多个部分，这些部分可以在多核处理器并行执行</li>
</ol>
<h3 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h3><p>GCC等编译器提供了优化控制，例如制定优化级别，但是也可能使程序<br>更难调试，一般使用优化级别2。编译器必须很小心地对程序只使用安<br>全的优化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2次读*xp 2次读*yp 2次写*xp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">int</span> *xp.<span class="keyword">int</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*xp+=*yp;</span><br><span class="line">	*xp+=*yp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个效率更高，只需要读*xp *yp 写 *xp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle2</span><span class="params">(<span class="keyword">int</span> *xp.<span class="keyword">int</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*xp+=<span class="number">2</span>* *yp;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当xp等于yp时结果就会不一致，编译器不知道twiddle1会如何被<br>调用，不知道xp和yp是否会相等，所以不能用twiddle2这种代码优化<br>这种两个指针指向同一个寄存器位置的情况称为存储器别名使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p和q是否指向同一个位置对结果有影响，这就是一个妨碍优化的因素</span></span><br><span class="line">x=<span class="number">1000</span>;</span><br><span class="line">y=<span class="number">3000</span>;</span><br><span class="line">*q=y;</span><br><span class="line">*p=x;</span><br><span class="line">t1=*q;</span><br></pre></td></tr></table></figure>
<p>第二个妨碍优化的因素是函数调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f()+f()+f()+f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fnu2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>*f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去应该返回相同的结果，而且fun2更高效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内联函数替换优化函数调用"><a href="#内联函数替换优化函数调用" class="headerlink" title="内联函数替换优化函数调用"></a>内联函数替换优化函数调用</h4><p>包含函数调用的代码可以用一个称为内联函数替换，也就是将函数调用<br>替换为函数体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1lin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=counter++;</span><br><span class="line">	t+=counter++;</span><br><span class="line">	t+=counter++;</span><br><span class="line">	t+=counter++;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的转换既减少函数调用的开销也允许对展开的代码进一步优化，例如<br>编译器可以统一funclin中对全局变量counter的更新，产生这个函数的<br>一个优化版本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1opt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">4</span>*counter+<span class="number">6</span>;</span><br><span class="line">	counter=counter+<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h3><p>我们引入度量标准每元素的周期数(CPE)作为一种表示程序性能并指导改进<br>代码的方法。处理器的活动顺序是由时钟控制的，时钟提供了某个频率的规<br>律信号，通常用千兆兹(GHz)，即十亿周期每秒来表示，例如有一个4GHz处<br>理器，表示这个处理器时钟运行频率为4*10^9千兆赫兹</p>
<h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p>在简单模型中存储器系统就是一个线性的字节数组，CPU能够在常数时间<br>访问每个存储器位置，但是并没有反映现代系统实际工作的方式。实际上<br>存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number224.jpg" alt><br>存储器的层次结构对应用程序的性能有巨大的影响。如果程序需要的数据是存<br>储在CPU寄存器中的，那么在指令的执行期间在0个周期内就可以访问，如果<br>存储在高速缓存需要1~30个周期，如果存储在主存需要50~200个周期，如<br>果存储在磁盘则需要几千万个周期</p>
<h3 id="随机访问存储器RAM"><a href="#随机访问存储器RAM" class="headerlink" title="随机访问存储器RAM"></a>随机访问存储器RAM</h3><p>随机访问存储器分为两类：静态和动态。静态SRAM比动态DRAM更快但也更贵，<br>SRAM用来作为高速缓存存储器，既可以在CPU芯片上也可以在片下。DRAM用<br>来作为主存以及图形系统的帧缓冲区，SRAM不会超过几兆字节，DRAM可以<br>达到千兆字节以上 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number225.jpg" alt></p>
<h4 id="增强版DRAM"><a href="#增强版DRAM" class="headerlink" title="增强版DRAM"></a>增强版DRAM</h4><p><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number226.jpg" alt></p>
<h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><p><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number227.jpg" alt></p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number228.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number229.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number230.jpg" alt></p>
<h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><p>一个磁盘可以记录的的最大位数称为最大容量，由以下三个因素决定，销售商<br>以10进制量存储大小</p>
<ul>
<li>记录密度 磁盘1英寸的段中可以放入的位数</li>
<li>磁道密度 从盘片中心出发半径上1英寸的段内可以有的磁道数</li>
<li>面密度 记录密度与磁道密度达的乘积</li>
</ul>
<p>柱面数等于磁道数<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number231.jpg" alt></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接就是将各种代码和数据部分合并为一个单一文件。这个文件可以被加<br>载到存储器中并执行。最重要的是分离编译，独立修改和编译各个模块</p>
<ul>
<li>执行于编译时 在源代码翻译成机器代码时执行</li>
<li>执行于加载时 程序被加载到存储器时执行</li>
<li>执行于运行时 在运行时执行</li>
</ul>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的<br>可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件<br>由各种不同的代码和数据节组成，指令在一个节中，初始化的全局变<br>量在另一个节中，而未初始化的变量在另一个节中。目标文件实际就<br>是字节块的集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -02 -g -o p main.c swap.c</span><br><span class="line">&#x2F;&#x2F;-g生成调试信息</span><br></pre></td></tr></table></figure>
<p>链接器通过以下两步操作生成可执行文件 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number167.jpg" alt></p>
<ol>
<li>符号解析 目标文件定义和引用符号。符号解析的目的是将每个符号<br>引用刚好和一个符号定义联系起来 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number168.jpg" alt></li>
<li>重定位 编译器和汇编器生成从0地址开始的代码和数据节。链接器<br>通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这<br>写符号的引用，使得它们指向这个存储器位置，从而重定位这些节</li>
</ol>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><ul>
<li>可重定位目标文件 包含二进制代码和数据，其形式可以在编译时与<br>其他可重定位目标文件合并起来创建一个可执行目标文件</li>
<li>可执行目标文件 包含二进制代码和数据，可以直接拷贝到存储器<br>中执行</li>
<li>共享目标文件 一种特殊的可重定位目标文件，可以在加载或者运行<br>时被动态地加载到存储器并链接</li>
<li>现代Unix系统使用的是Unix可执行和可链接格式 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number174.jpg" alt></li>
</ul>
<h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><p><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number169.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number170.jpg" alt></p>
<h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><p>每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的<br>信息</p>
<ul>
<li>全局符号 模块m定义的可以被其它模块引用，例如非静态C函数和<br>非静态全局变量</li>
<li>外部符号 由模块m引用但是由其它模块定义的全局符号</li>
<li>本地符号 由模块m专门定义和引用的符号，例如静态属性定义的C<br>函数和全局变量，任何声明带有static属性的全局变量和或者函数都<br>是模块私有的</li>
</ul>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number171.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number172.jpg" alt></p>
<h4 id="程序符号的强弱"><a href="#程序符号的强弱" class="headerlink" title="程序符号的强弱"></a>程序符号的强弱</h4><p>函数名和已初始化的全局变量名是强符号，未初始化的全局变量名<br>是弱符号 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number173.jpg" alt></p>
<ul>
<li>强符号只能被定义一次否则链接出错</li>
<li>若一个符号被定义为一次强符号和多次弱符号，则按强定义为主，<br>对弱符号解析为其强定义符号</li>
<li>若多个弱定义符号则任选其中一个<br>尽量避免使用全局变量</li>
<li>尽量使用本地变量static</li>
<li>全局变量要赋初值</li>
<li>外部全局变量要使用extern</li>
</ul>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><ol>
<li>所有的编译系统都提供一种机制，将所有相关的目标模块打包<br>成为一个单独的文件，称为静态库，它可以用做链接器的输入，当<br>链接器构造一个输出的可执行文件时，它只拷贝静态库里被应用程<br>序引用的目标模块</li>
<li>在Unix系统中，静态库以一种称为存档的特殊文件格式存放在<br>磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，由<br>后缀.a标识，在构建可执行文件时只需指定库文件名，链接器会自<br>动到库中寻找那些应用程序用到的目标模块，并且只把用到的模块<br>从库中拷贝出来 <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number175.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number176.jpg" alt><br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number177.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number178.jpg" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libvector.a addvec.o multvec.o</span><br><span class="line">gcc -static -o p main.o .&#x2F;libvector.a</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><ul>
<li>重定位节和符号定义 链接器将所有相同类型的节合并为同一类型的新<br>的聚合节，链接器将运行时存储器地址赋给新的聚合节</li>
<li>重定位节中的符号引用 链接器修改代码节和数据节中对每个符号的引<br>用，使得它们指向正确的运行时地址<br><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number179.jpg" alt></li>
</ul>
<h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><p><img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number180.jpg" alt> <img src="/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/number181.jpg" alt></p>
<h2 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h2><p>程序计数器假设一个值的序列a0a1a2a3…an-1，其中ak是某个相应指令<br>Ik的地址，每次从ak到ak+1的过渡称为控制转移，这样的控制转移序列叫<br>做处理器的控制流。如果Ik和Ik+1在存储器中是相邻的那么这种流就是平<br>滑流，如果Ik和Ik+1不相邻，例如跳转、调用和返回等就是异常控制流</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常就是控制流中的突变，用来响应处理器状态中的某些变化</p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">https://skysea-gaoming.github.io/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/JavaWeb/"><i class="fa fa-chevron-left">  </i><span>JavaWeb</span></a></div><div class="next-post pull-right"><a href="/2020/02/29/Git/"><span>Git</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/02/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/';
  this.page.identifier = '2020/02/29/计算机系统/';
  this.page.title = '计算机系统';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1603820855526&amp;di=814b302a9516d264731a29c3c1fce803&amp;imgtype=0&amp;src=http%3A%2F%2Fwenhui.whb.cn%2Fu%2Fcms%2Fwww%2F201804%2F16135756wr02.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>