<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Algorithm"><meta name="keywords" content="DataStructure"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Algorithm | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考《算法第四版》"><span class="toc-number">1.</span> <span class="toc-text">参考《算法第四版》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法时间复杂度"><span class="toc-number">2.</span> <span class="toc-text">算法时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#渐进紧确界-Θ"><span class="toc-number">2.1.</span> <span class="toc-text">渐进紧确界 Θ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渐进上界-O"><span class="toc-number">2.2.</span> <span class="toc-text">渐进上界 O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渐进下界-Ω"><span class="toc-number">2.3.</span> <span class="toc-text">渐进下界 Ω</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-number">3.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序"><span class="toc-number">3.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">3.2.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序"><span class="toc-number">3.3.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">3.4.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">3.5.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-number">3.6.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基数排序"><span class="toc-number">3.7.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序"><span class="toc-number">3.8.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉查找树"><span class="toc-number">4.</span> <span class="toc-text">二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本实现过程"><span class="toc-number">4.1.</span> <span class="toc-text">基本实现过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#平衡查找树"><span class="toc-number">4.2.</span> <span class="toc-text">平衡查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3查找树"><span class="toc-number">4.2.1.</span> <span class="toc-text">2-3查找树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治法"><span class="toc-number">5.</span> <span class="toc-text">分治法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯法"><span class="toc-number">6.</span> <span class="toc-text">回溯法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法"><span class="toc-number">7.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-number">8.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图论算法"><span class="toc-number">9.</span> <span class="toc-text">图论算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图的基本构造"><span class="toc-number">9.1.</span> <span class="toc-text">图的基本构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#检测图是否有环"><span class="toc-number">9.1.1.</span> <span class="toc-text">检测图是否有环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检测是否是二分图"><span class="toc-number">9.1.2.</span> <span class="toc-text">检测是否是二分图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有向环"><span class="toc-number">9.1.3.</span> <span class="toc-text">有向环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有向图的强连通性"><span class="toc-number">9.1.4.</span> <span class="toc-text">有向图的强连通性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小生成树"><span class="toc-number">9.1.5.</span> <span class="toc-text">最小生成树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-number">9.2.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union-find算法"><span class="toc-number">9.3.</span> <span class="toc-text">union-find算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NP问题"><span class="toc-number">10.</span> <span class="toc-text">NP问题</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582898893694&amp;di=15958b0625c3bcbdd505353b8b5deaa4&amp;imgtype=0&amp;src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F068c0cbf1b1571976ada2e55a53b3a079e1614c5.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">29</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591954918112&amp;di=2bc6f4358ea0e880687f5ced03157daf&amp;imgtype=0&amp;src=http%3A%2F%2Fyouimg1.c-ctrip.com%2Ftarget%2Ftg%2F620%2F406%2F859%2Fe7db3299a728401eb7b42effae33dadb.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Algorithm</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/02/28/Algorithm/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/02/28/Algorithm/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考《算法第四版》"><a href="#参考《算法第四版》" class="headerlink" title="参考《算法第四版》"></a>参考《算法第四版》</h2><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析<br>T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时<br>间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的<br>增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度</p>
<h3 id="渐进紧确界-Θ"><a href="#渐进紧确界-Θ" class="headerlink" title="渐进紧确界 Θ"></a>渐进紧确界 Θ</h3><p>随着数据规模增大，算法的运行时间主要取决于时间表达式系数最大的那一项。<br>T1(n)=30n4+20n3+40n2+46n+100 T2(n)=1000n3+50n2+78n+10<br>T1(n)=Θ(n4)   T2​(n)=Θ(n3)</p>
<h3 id="渐进上界-O"><a href="#渐进上界-O" class="headerlink" title="渐进上界 O"></a>渐进上界 O</h3><p>设f(n)和g(n)是定义域为自然数集N上的函数。若存在正数c和n0，使得对一切<br>n≥n0都有0≤f(n)≤cg(n)成立，则称f(n)的渐进的上界是g(n)，记作<br>f(n)=O(g(n))。通俗的说n满足一定条件范围内，函数f(n)的阶不高于函数g(n)。<br>例如：设f(n)=n2+n,则<br>f(n)=O(n2)，取c=2,n0=1即可<br>f(n)=O(n3)，取c=1,n0=2即可。显然，O(n2)作为上界更为精确。</p>
<h3 id="渐进下界-Ω"><a href="#渐进下界-Ω" class="headerlink" title="渐进下界 Ω"></a>渐进下界 Ω</h3><p>与渐进上界刚好相反，这个下界的阶越高评估越精确</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ol>
<li>排序算法的稳定性是指：经过排序之后,能使值相同的数据保持原顺序中的<br>相对位置不变 </li>
<li>归并排序的最坏情况，最好情况和平均情况都是O(nlogn); 快速排序的最<br>坏情况是O(n^2)，最好的情况和平均情况是O(nlogn)</li>
<li>外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排<br>序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交<br>换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，<br>即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内<br>存完成排序。然后，对已经排序的子文件进行多路归并排序</li>
<li>稳定排序：冒泡、选择、归并、基数 不稳定排序：希快选堆</li>
<li>堆排序平均执行的时间复杂度和需要附加的存储空间复杂度分别是<br>O(nlogn)和O(1)</li>
<li>master公式的使用 T(n) = a*T(n/b) + O(n^d)<br>1) log(b,a) &gt; d -&gt; 复杂度为O(n^log(b,a))<br>2) log(b,a) = d -&gt; 复杂度为O(n^d * logn)<br>3) log(b,a) &lt; d -&gt; 复杂度为O(n^d)</li>
</ol>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种不稳定（5,5,2）任何情况下时间复杂度都是O(n^2)的排序算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//思想是每次都选择一个最小值排在前面</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> min=i; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(array[j]&lt;min)</span><br><span class="line">				min=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第i个位置要排当前最小值</span></span><br><span class="line">		<span class="keyword">if</span>(min!=i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=array[min];</span><br><span class="line">			array[min]=array[i];</span><br><span class="line">			array[i]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种稳定在最好情况下时间复杂度是O(n)最坏情况下O(n^2)平均情况O(n^2)的排序算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//可以进行优化，如果当前已经有序就结束</span></span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++) <span class="comment">//最多排序次数</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length-i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//按照顺序将前一个和后一个交换位置</span></span><br><span class="line">			<span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp=array[j];</span><br><span class="line">				array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">				array[j+<span class="number">1</span>]=temp;</span><br><span class="line">				flag=<span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//经过一轮交换发现已经有序就可知直接退出</span></span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="keyword">true</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>是稳定排序但是需要空间复杂度O(n)，需要调用logn次开辟栈帧空间，还<br>需要创建一个临时数组，时间复杂度是O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//需要开辟一个一样大小的数组空间</span></span><br><span class="line">	<span class="keyword">int</span>[] tempt=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">	sort(<span class="number">0</span>,array.length-<span class="number">1</span>,array,tempt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> li,<span class="keyword">int</span> lo,<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] tempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//拆分的终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(li&gt;=lo)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="comment">//拆分数组</span></span><br><span class="line">	<span class="keyword">int</span> mid=(li+lo)/<span class="number">2</span>;</span><br><span class="line">	sort(li,mid,array,tempt);</span><br><span class="line">	sort(mid+<span class="number">1</span>,lo,array,tempt);</span><br><span class="line">	<span class="comment">//将有序的两部分合并为一个有序的部分，用tempt保存有序结果</span></span><br><span class="line">	merge(li,mid,lo,array,tempt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> li,<span class="keyword">int</span> mid,<span class="keyword">int</span> lo,<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] tempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=li;</span><br><span class="line">	<span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//合并操作</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=lo)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(array[i]&lt;array[j])</span><br><span class="line">			tempt[index++]=array[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tempt[index++]=array[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		tempt[index++]=array[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=lo)</span><br><span class="line">		tempt[index++]=array[j++];</span><br><span class="line">	index=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//这里必须要将有序结果重新写入array，因为还有更大规模的合并</span></span><br><span class="line">	<span class="keyword">while</span>(li&lt;=lo)</span><br><span class="line">		array[li++]=tempt[index++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是一种不稳定平均时间复杂度为O(nlogn)最好情况O(nlogn)最坏<br>情况O(n^2)空间复杂度为O(logn)(调用栈帧所需空间)的排序算法，最好情<br>况时每次都划分很均匀不需要交换，递归深度就是logn，跟归并排序一样。<br>最环情况时数组为正序或者逆序时需要经过n-1次递归调用，每次划分执<br>只比上一次少一个元素的子序列，每次经过n-i次比较<br>T(n)=n-1+n-2+n-3+…1=n(n-1)/2 时间复杂度O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sort(<span class="number">0</span>,array.length-<span class="number">1</span>,array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> li,<span class="keyword">int</span> lo,<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(li&gt;=lo)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="comment">//根据指定和元素将数组划分为两部分</span></span><br><span class="line">	<span class="keyword">int</span> partcut=part(li,lo,array);</span><br><span class="line">	sort(li,partcut-<span class="number">1</span>,array);</span><br><span class="line">	sort(partcut+<span class="number">1</span>,lo,array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">part</span><span class="params">(<span class="keyword">int</span> li,<span class="keyword">int</span> lo,<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cut=array[li];</span><br><span class="line">	<span class="keyword">int</span> i=li;</span><br><span class="line">	<span class="keyword">int</span> j=lo+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(array[++i]&lt;=cut)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==lo)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(array[--j]&gt;=cut)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==li)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tempt=array[i];</span><br><span class="line">		array[i]=array[j];</span><br><span class="line">		array[j]=tempt;</span><br><span class="line">		<span class="keyword">if</span>(j&lt;=i)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> tempt=array[li];</span><br><span class="line">	array[li]=array[j];</span><br><span class="line">	array[j]=tempt;</span><br><span class="line">	<span class="comment">//索引j处就是要划分的位置</span></span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是一种稳定平均时间复杂度为O(n^2)最好时间复杂度为O(n)最坏<br>时间复杂度为O(n^2)的排序算法，最好情况就是完全有序只需要遍历，最坏<br>情况比如倒序时每次都要交换i次 T(n)=1+2+3+n-1=n(n-1)/2 时间复杂度为O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>&amp;&amp;array[j]&lt;array[j-<span class="number">1</span>];j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=array[j];</span><br><span class="line">			array[j]=array[j-<span class="number">1</span>];</span><br><span class="line">			array[j-<span class="number">1</span>]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的改进，是不稳定的算法，时间复杂度介于O(n)到O(n^2)之间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xhell</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(h&lt;array.length)</span><br><span class="line">		h=<span class="number">3</span>*h+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(h&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;array.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=h&amp;&amp;array[j]&lt;array[j-h];j-=h)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp=array[j];</span><br><span class="line">				array[j]=array[j-h];</span><br><span class="line">				array[j-h]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		h=h/<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>时间复杂度是(n*k),是一种稳定的排序算法，排序时没有进行比较操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">	ArrayList[] list=<span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		list[i]=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(array[i]&gt;max)</span><br><span class="line">			max=array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//k保存最大值的位数</span></span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(max&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		max=max/<span class="number">10</span>;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//从最低位到最高位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">		list[array[i]/t%<span class="number">10</span>].push(array[i]);</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(list[i].size()&gt;<span class="number">0</span>)</span><br><span class="line">				array[index++]=list[i].pop();</span><br><span class="line">		&#125;</span><br><span class="line">		t=t*<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>一个节点的深度：从这个节点到根节点的简单路径的边数</li>
<li>一个节点的高度：从这个节点到叶子节点的最长简单路径的边数</li>
<li>一个树的深度是树中所有节点最大的深度</li>
<li>一个树的高度就是树的深度</li>
<li>深度为d的近似完全二叉树：深度为d-1时是完全二叉树，深度为d的节点<br>都在靠左部分，只有靠左的部分子节点的索引才满足给定条件</li>
<li>堆就是一个近似完全二叉树</li>
<li>给定一个近似二叉树，从最后一个具有子节点的位置开始建堆，建堆时必<br>须保证已经存在左子堆和右子堆，所以不能从根节点开始<br><img src="/2020/02/28/Algorithm/number1.jpg" alt></li>
</ul>
<ol>
<li>任何一个节点的值都大于其子节点的值就是大顶堆</li>
<li>任何一个节点的值都小于其子节点的值就是小顶堆</li>
<li>堆排序思想： 将待排序的数组构建成一个大顶堆，此时已经确定了最大<br>元素，最大元素与末尾元素进行交换，剩余的元素继续构建成一个大顶堆重<br>复之前的操作。如果要得到倒序数组就要构建小顶堆，思想与构建大顶堆的<br>思想一致</li>
<li>构建堆时时间复杂度为O(n)，重建堆的时间复杂度是O(nlogn)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heap</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*一开始要先构建一个大顶堆，应该从中间的元素开始，</span></span><br><span class="line"><span class="comment">	每个元素与其子节点元素进行比较，因为一开始并不是</span></span><br><span class="line"><span class="comment">	一个大顶堆，所以不能直接从根节点开始</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=array.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		sink(array,i,array.length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//堆排序过程，每次都与最大元素进行交换</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=array[i];</span><br><span class="line">		array[i]=array[<span class="number">0</span>];</span><br><span class="line">		array[<span class="number">0</span>]=temp;</span><br><span class="line">		sink(array,<span class="number">0</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*k+<span class="number">1</span>;j&lt;length;j=<span class="number">2</span>*j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当前节点的子节点中较大的那个节点</span></span><br><span class="line">		<span class="keyword">if</span>(j+<span class="number">1</span>&lt;length&amp;&amp;array[j]&lt;array[j+<span class="number">1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="comment">//当前节点与子节点进行比较交换</span></span><br><span class="line">		<span class="keyword">if</span>(array[j]&gt;array[k])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=array[k];</span><br><span class="line">			array[k]=array[j];</span><br><span class="line">			array[j]=temp;</span><br><span class="line">			k=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树是一种能够将链表插入的灵活性和有序数组查找的高效性结合<br>起来的实现符号表功能的数据结构 <img src="/2020/02/28/Algorithm/number2.jpg" alt></p>
<ul>
<li>每个节点的值都大于左子树所有节点的值小于右子树所有节点的值 <img src="/2020/02/28/Algorithm/number3.jpg" alt></li>
</ul>
<h3 id="基本实现过程"><a href="#基本实现过程" class="headerlink" title="基本实现过程"></a>基本实现过程</h3><p>这里采用递归实现所有功能代码，递归实现非常简单明了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node root; <span class="comment">//二叉查找树的根节点</span></span><br><span class="line">	<span class="comment">//二叉查找树的节点数目</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> node.N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过节点值得到相应的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> get(root,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node node,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//这里采用通用方法进行比较，像int这种基本类型直接比较</span></span><br><span class="line">		<span class="keyword">int</span> cmp=value.compareTo(node.value);</span><br><span class="line">		<span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> get(node.right,value);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> get(node.left,value);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//符号表最基本的功能之插入元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root=put(root,value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//一开始不存在树就创建树</span></span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(value,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> cmp=value.compareTo(node.value);</span><br><span class="line">		<span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">			node.right=put(node.right,value);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">			node.left=put(node.left,value);</span><br><span class="line">		<span class="comment">//更新树的节点数目</span></span><br><span class="line">		node.N=size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//得到二叉查找树中节点值最小的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> getmin(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">getmin</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node.left==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		<span class="keyword">return</span> getmin(node.left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//得到二叉查找树中节点值最大的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">getmax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> getmax(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">getmax</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node.right==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		<span class="keyword">return</span> getmax(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除二叉查找树中节点值最小的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletemin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">			root=deletemin(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">deletemin</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node.left==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> node.right;</span><br><span class="line">		node.left=deletemin(node.left);</span><br><span class="line">		x.N=size(x.left)+size(x.right)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除二叉查找树中节点值最大的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletemax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">			root=deletemax(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">deletemax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node.right==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> node.left;</span><br><span class="line">		node.right=deletemin(node.right);</span><br><span class="line">		x.N=size(x.left)+size(x.right)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//符号表最基本功能之删除</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root=delete(root,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">		 	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		 <span class="keyword">int</span> cmp=value.compareTo(node.value);</span><br><span class="line">		 <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">		 	node.right=delete(node.right,value);</span><br><span class="line">		 <span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">		 	node.left=delete(node.left,value);</span><br><span class="line">		 <span class="keyword">else</span></span><br><span class="line">		 &#123;</span><br><span class="line">		 	<span class="comment">//得到要删除的节点，此时有三种情况</span></span><br><span class="line">		 	<span class="comment">//该节点没有右子节点</span></span><br><span class="line">		 	<span class="keyword">if</span>(node.right==<span class="keyword">null</span>)</span><br><span class="line">		 		<span class="keyword">return</span> node.left;</span><br><span class="line">		 	<span class="comment">//该节点没有左子节点</span></span><br><span class="line">		 	<span class="keyword">if</span>(node.left==<span class="keyword">null</span>)</span><br><span class="line">		 		<span class="keyword">return</span> node.right;</span><br><span class="line">		 	<span class="comment">//这个时候将该节点删除后需要用一个子节点替换</span></span><br><span class="line">		 	Node t=node;</span><br><span class="line">		 	<span class="comment">//该节点右子树中的最小节点就是要替换的节点</span></span><br><span class="line">		 	node=min(t.right);</span><br><span class="line">		 	<span class="comment">//更新右子树</span></span><br><span class="line">		 	node.right=deletemin(t.right);</span><br><span class="line">		 	<span class="comment">//左子树不变</span></span><br><span class="line">		 	node.left=t.left;</span><br><span class="line">		 &#125;</span><br><span class="line">		 node.N=size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前序遍历，按照中-&gt;左-&gt;右</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		preprint(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preprint</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		System.out.println(node.value);</span><br><span class="line">		preprint(node.left);</span><br><span class="line">		preprint(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//中序遍历，按照左-&gt;中-&gt;右</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		inprint(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inprint</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		preprint(node.left);</span><br><span class="line">		System.out.println(node.value);</span><br><span class="line">		preprint(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后序遍历，按照左-&gt;右-&gt;中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		postprint(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postprint</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		preprint(node.left);</span><br><span class="line">		preprint(node.right);</span><br><span class="line">		System.out.println(node.value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//层序遍历针对每一层从左到右遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		LinkedList&lt;Node&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		list.add(root);</span><br><span class="line">		<span class="keyword">while</span>(!list.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			Node node=list.pop();</span><br><span class="line">			System.out.println(node.value);</span><br><span class="line">			<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">				list.add(node.left);</span><br><span class="line">			<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">				list.add(node.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="comment">//这里指定int为节点的值类型，实际可以是任何实现Comparable接口的类型</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> Node left;</span><br><span class="line">	<span class="keyword">public</span> Node right;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> N; <span class="comment">//这里保存以该节点为根节点的子树的节点数目</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value,<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value=value;</span><br><span class="line">		<span class="keyword">this</span>.N=N;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h3><p>平衡查找树无论如何构造查找的时间复杂度都在对数级别</p>
<h4 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h4><p>一棵完美的平衡二叉树所有空链接到根节点的距离都是相同的 <img src="/2020/02/28/Algorithm/number4.jpg" alt></p>
<ol>
<li>2-3查找树的查找过程跟普通二叉树的查找过程本质是一样的</li>
<li>2-3查找树的插入过程可以分为两种情况</li>
</ol>
<ul>
<li>查找结束与一个2-结点时只需要将这个2-结点转化为一个3-节点</li>
<li>查找结束与一个3-结点时要考虑到没法插入到这个3-结点，只能暂时将<br>3-结点转化为4-节点，一个4-结点可以转化为3个2-结点 <img src="/2020/02/28/Algorithm/number5.jpg" alt></li>
</ul>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>将一个大问题分解为若干小问题，每个小问题都是相互独立并且与原问题有<br>相同的性质，求解小问题的解合并得到原问题的解，以下算法的具体问题求解<br>代码都已经放在Algorithm666仓库中</p>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法的本质是蛮力法，回溯法常使用深度优先搜索遍历，与蛮力法的区别、<br>在于回溯法会进行剪枝处理，回溯法不一定能够得到最优解</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>使用较为简单的方法找到局部最优，此时并不能保证该解是全局最优但是也<br>是一个不差的解，只解决当前局部问题不关心之前和之后的解，不同的贪心<br>准则可以得到不同的结果</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol>
<li>解决优化问题，将多阶段问题求解转化为一系列单阶段问题求解，找全<br>局最优，只有某些条件满足的问题才能使用动态规划。</li>
<li>状态的无后效性 如果某个阶段状态给定后，则该阶段以后过程的发展<br>不受该阶段以前各阶段状态的影响，也就是受状态具有马尔科父性。适用于<br>动态求解的问题具有状态的无后效性</li>
<li>策略 各个阶段决策的确定后，就组成一个决策序列，该序列称之为一<br>个策略，由某个阶段开始到终止阶段的过程称之为子过程，其对应的某个<br>策略称之为子策略</li>
<li>Bellman最优性原理 求解问题的一个最优策略序列的子策略序列总是<br>最优的，则称该问题满足最优性原理。对具有最优性原理性质的问题而言，<br>如果有一决策序列包含具有非最优的决策子序列，则该决策序列一定不是最优的</li>
<li>动态规划的思想实质是分治思想和解决冗余。与分治法类似的是将原问<br>题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题<br>的解。与分治法不同的是分解的子问题往往不是相互独立的，若用分治法<br>来解有些共同部分被重复计算了很多次，动态规划利用这种子问题的折叠性<br>质，对每一个子问题只解一次</li>
</ol>
<h2 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h2><ul>
<li>图的基本概念</li>
</ul>
<ol>
<li>一个图是由一系列的节点和边组成</li>
<li>节点的度指的是节点连接的边的条数，有向图有出度和入度</li>
<li>简单图指没有多重边且没有自环的图</li>
<li>无向图所有节点度数和为边数的两倍</li>
<li>有向图所有节点入度数等于出度数等于边数</li>
<li>一条路径由一系列的节点组成，并且相邻两个节点之间有一条边相连，<br>简单路径没有重复</li>
<li>树是一个无环连通的无向图</li>
<li>生成树是包含图中所有节点的树</li>
<li>加权图是每条边都有权值的图</li>
<li>环不是简单路径，起点和终点一致</li>
<li>稀疏图 E≈V ，稠密图 E≈V^2</li>
<li>任意两个节点都有边连接（有向图两个方向都有边）称为完全图 </li>
<li>连通分支是图中最大的连通子图</li>
<li>树的任意两个节点都有唯一的连通路径</li>
</ol>
<ul>
<li><p>邻接表<br>使用一个链表数组，对于稀疏图有效，可以节省空间，查找边时比较耗时<br>，矩阵运算不太方便</p>
</li>
<li><p>邻接矩阵<br>使用一个二维数组，对于稠密图有效</p>
</li>
<li><p>图的遍历之BFS<br>使用先进先出的队列，遍历之后可以形成一个BFS树，节点的深度是距离<br>起始点的最短距离  </p>
</li>
<li><p>图的遍历之DFS<br>使用先进后出的栈，遍历之后可以形成一个DFS森林，也就是一系列的DFS树</p>
</li>
</ul>
<h3 id="图的基本构造"><a href="#图的基本构造" class="headerlink" title="图的基本构造"></a>图的基本构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> V;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;Integer&gt;[] adj;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> s;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.V=V;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		adj=(LinkedList&lt;Integer&gt;[])<span class="keyword">new</span> LinkedList[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">			adj[i]=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		edgeTo=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFScount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dfs(i);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFSsearch</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s=s;</span><br><span class="line">		bfs(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSsearch</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s=s;</span><br><span class="line">		dfs(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		id[v]=count;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">			&#123;</span><br><span class="line">				edgeTo[w]=v;</span><br><span class="line">				dfs(w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		markd[v]=<span class="keyword">true</span>;</span><br><span class="line">		list.add(v);</span><br><span class="line">		<span class="keyword">while</span>(!list.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> w=list.pop();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k:adj(w))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!marked[k])</span><br><span class="line">				&#123;</span><br><span class="line">					edgeTo[k]=w;</span><br><span class="line">					marked[k]=<span class="keyword">true</span>;</span><br><span class="line">					list.add(k);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!marked[v])</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		Stack&lt;Integer&gt; path=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=v;x!=s;x=edgeTo[x])</span><br><span class="line">		&#123;</span><br><span class="line">			path.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		path.push(s);</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> marked[w];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> V;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getE</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> E;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		adj[v].add(w);</span><br><span class="line">		adj[w].add(v);</span><br><span class="line">		E++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测图是否有环"><a href="#检测图是否有环" class="headerlink" title="检测图是否有环"></a>检测图是否有环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cycle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cycle</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;V;s++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">				dfs(s,s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">				dfs(w,v);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(w!=u)</span><br><span class="line">			    hasCycle=<span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hasCycle;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测是否是二分图"><a href="#检测是否是二分图" class="headerlink" title="检测是否是二分图"></a>检测是否是二分图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoColor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] color;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isTwocolor=<span class="keyword">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TwoColor</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		color=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;V;s++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">			  dfs(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">			&#123;</span><br><span class="line">				color[w]=!color[v];</span><br><span class="line">				dfs(w);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(color[w]==color[v])</span><br><span class="line">				isTwocolor=<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTwocolor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isTwocolor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有向环"><a href="#有向环" class="headerlink" title="有向环"></a>有向环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; cycle;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] onstack;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; reversepost;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		edgeTo=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		onstack=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		reversepost=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;V;v++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[v])</span><br><span class="line">				dfs(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		onstack[v]=<span class="keyword">true</span>;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(hasCycle)</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!marked[w])</span><br><span class="line">				&#123;</span><br><span class="line">					edgeTo[w]=v;</span><br><span class="line">				   dfs(w);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(onstack[w])</span><br><span class="line">			&#123;</span><br><span class="line">				cycle=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=v;x!=w;x=edgeTo[x])</span><br><span class="line">					cycle.push(x);</span><br><span class="line">				cycle.push(w);</span><br><span class="line">				cycle.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		onstack[v]=<span class="keyword">false</span>;</span><br><span class="line">		reversepost.push(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有向图的强连通性"><a href="#有向图的强连通性" class="headerlink" title="有向图的强连通性"></a>有向图的强连通性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kosara</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Kosara</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		G2=G.reverse();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s:G2.reversepost())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">				&#123;</span><br><span class="line">					dfs(s);</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.v=v;</span><br><span class="line">		<span class="keyword">this</span>.w=w;</span><br><span class="line">		<span class="keyword">this</span>.weight=weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ol>
<li>对于一个有向无环图，拓扑排序就是将所有顶点进行排序<br>，如果ViVj，那么Vi必须排在Vj<br>之前  </li>
<li>对全图进行DFS，记录每个节点的结束时间，以节点结束时<br>间由大到小的顺序输出节点即可</li>
<li>每次都删除入度为0的节点</li>
</ol>
<h3 id="union-find算法"><a href="#union-find算法" class="headerlink" title="union-find算法"></a>union-find算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] sz;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		count=N;</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			id[i]=i;</span><br><span class="line">		sz=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			sz[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(p!=id[p])</span><br><span class="line">			p=id[p];</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=find(p);</span><br><span class="line">		<span class="keyword">int</span> j=find(q);</span><br><span class="line">		<span class="keyword">if</span>(i==j)</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">if</span>(sz[i]&lt;sz[j])</span><br><span class="line">		&#123;</span><br><span class="line">			id[i]=j;</span><br><span class="line">			sz[j]+=sz[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			id[j]=i;</span><br><span class="line">			sz[i]+=sz[j];</span><br><span class="line">		&#125;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><ol>
<li>有些问题能够在多项式级别的算法解出，例如n^2,n^3</li>
<li>NP问题是指能够在多项式时间内检验一个解是否正确的问题</li>
<li>所有NP问题都能在多项式时间内归约成NPC问题</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/02/28/Algorithm/">https://skysea-gaoming.github.io/2020/02/28/Algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStructure/">DataStructure</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/28/Spring/"><i class="fa fa-chevron-left">  </i><span>Spring</span></a></div><div class="next-post pull-right"><a href="/2020/02/28/SpringBoot/"><span>SpringBoot</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/02/28/Algorithm/';
  this.page.identifier = '2020/02/28/Algorithm/';
  this.page.title = 'Algorithm';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1591954918112&amp;di=2bc6f4358ea0e880687f5ced03157daf&amp;imgtype=0&amp;src=http%3A%2F%2Fyouimg1.c-ctrip.com%2Ftarget%2Ftg%2F620%2F406%2F859%2Fe7db3299a728401eb7b42effae33dadb.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>