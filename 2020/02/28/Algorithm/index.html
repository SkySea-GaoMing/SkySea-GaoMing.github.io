<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Algorithm"><meta name="keywords" content="DataStructure"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Algorithm | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#个人简介"><span class="toc-number">1.</span> <span class="toc-text">个人简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考《算法第四版》"><span class="toc-number">2.</span> <span class="toc-text">参考《算法第四版》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法时间复杂度"><span class="toc-number">3.</span> <span class="toc-text">算法时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#渐进紧确界-Θ"><span class="toc-number">3.1.</span> <span class="toc-text">渐进紧确界 Θ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渐进上界-O"><span class="toc-number">3.2.</span> <span class="toc-text">渐进上界 O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渐进下界-Ω"><span class="toc-number">3.3.</span> <span class="toc-text">渐进下界 Ω</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空间复杂度"><span class="toc-number">4.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-number">5.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序"><span class="toc-number">5.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">5.2.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序"><span class="toc-number">5.3.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">5.4.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">5.5.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-number">5.6.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基数排序"><span class="toc-number">5.7.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序"><span class="toc-number">5.8.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">6.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">6.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模拟ArrayList"><span class="toc-number">6.1.1.</span> <span class="toc-text">模拟ArrayList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">6.2.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模拟Stack"><span class="toc-number">6.2.1.</span> <span class="toc-text">模拟Stack</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">6.3.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序队列"><span class="toc-number">6.3.1.</span> <span class="toc-text">顺序队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环队列"><span class="toc-number">6.3.2.</span> <span class="toc-text">循环队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">6.4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单向链表"><span class="toc-number">6.4.1.</span> <span class="toc-text">单向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双端链表"><span class="toc-number">6.4.2.</span> <span class="toc-text">双端链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态链表"><span class="toc-number">6.4.3.</span> <span class="toc-text">静态链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向链表"><span class="toc-number">6.4.4.</span> <span class="toc-text">双向链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树"><span class="toc-number">6.5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本概念"><span class="toc-number">6.5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树"><span class="toc-number">6.5.2.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的存储"><span class="toc-number">6.5.3.</span> <span class="toc-text">二叉树的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的遍历"><span class="toc-number">6.5.4.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉查找树"><span class="toc-number">6.5.5.</span> <span class="toc-text">二叉查找树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#平衡查找树"><span class="toc-number">6.6.</span> <span class="toc-text">平衡查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#平衡查找树-AVL树"><span class="toc-number">6.6.1.</span> <span class="toc-text">平衡查找树(AVL树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B树"><span class="toc-number">6.6.2.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3树"><span class="toc-number">6.6.3.</span> <span class="toc-text">2-3树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#红黑树"><span class="toc-number">6.6.4.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈夫曼树"><span class="toc-number">6.6.5.</span> <span class="toc-text">哈夫曼树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优先队列"><span class="toc-number">6.7.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#堆"><span class="toc-number">6.7.1.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆的算法"><span class="toc-number">6.7.2.</span> <span class="toc-text">堆的算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分治法"><span class="toc-number">7.</span> <span class="toc-text">分治法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯法"><span class="toc-number">8.</span> <span class="toc-text">回溯法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法"><span class="toc-number">9.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-number">10.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图论算法"><span class="toc-number">11.</span> <span class="toc-text">图论算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图的基本构造"><span class="toc-number">11.1.</span> <span class="toc-text">图的基本构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#检测图是否有环"><span class="toc-number">11.1.1.</span> <span class="toc-text">检测图是否有环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检测是否是二分图"><span class="toc-number">11.1.2.</span> <span class="toc-text">检测是否是二分图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有向环"><span class="toc-number">11.1.3.</span> <span class="toc-text">有向环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有向图的强连通性"><span class="toc-number">11.1.4.</span> <span class="toc-text">有向图的强连通性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小生成树"><span class="toc-number">11.1.5.</span> <span class="toc-text">最小生成树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-number">11.2.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#union-find算法"><span class="toc-number">11.3.</span> <span class="toc-text">union-find算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NP问题"><span class="toc-number">12.</span> <span class="toc-text">NP问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希算法"><span class="toc-number">13.</span> <span class="toc-text">哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode"><span class="toc-number">13.0.1.</span> <span class="toc-text">hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希表"><span class="toc-number">13.0.2.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希化"><span class="toc-number">13.0.3.</span> <span class="toc-text">哈希化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正整数"><span class="toc-number">13.0.4.</span> <span class="toc-text">正整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浮点数"><span class="toc-number">13.0.5.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">13.0.6.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#软缓存"><span class="toc-number">13.0.7.</span> <span class="toc-text">软缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冲突"><span class="toc-number">13.1.</span> <span class="toc-text">冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拉链法"><span class="toc-number">13.1.1.</span> <span class="toc-text">拉链法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线性探测法"><span class="toc-number">13.1.2.</span> <span class="toc-text">线性探测法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对于hashCode的要求"><span class="toc-number">13.1.3.</span> <span class="toc-text">对于hashCode的要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见问题"><span class="toc-number">13.1.4.</span> <span class="toc-text">常见问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#脑筋急转弯"><span class="toc-number">14.</span> <span class="toc-text">脑筋急转弯</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1599140437492&amp;di=195fa5a4bc93905108d4f72b9167b0c0&amp;imgtype=0&amp;src=http%3A%2F%2Fphoto.tuchong.com%2F443730%2Ff%2F14505255.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Algorithm</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/02/28/Algorithm/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/02/28/Algorithm/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><p>力扣地址：<a href="https://leetcode-cn.com/u/gao-ming-3/" target="_blank" rel="noopener">https://leetcode-cn.com/u/gao-ming-3/</a><br>牛客地址：高-明 <a href="https://www.nowcoder.com/profile/883461684" target="_blank" rel="noopener">https://www.nowcoder.com/profile/883461684</a></p>
<h2 id="参考《算法第四版》"><a href="#参考《算法第四版》" class="headerlink" title="参考《算法第四版》"></a>参考《算法第四版》</h2><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析<br>T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时<br>间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的<br>增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度</p>
<h3 id="渐进紧确界-Θ"><a href="#渐进紧确界-Θ" class="headerlink" title="渐进紧确界 Θ"></a>渐进紧确界 Θ</h3><p>随着数据规模增大，算法的运行时间主要取决于时间表达式系数最大的那一项。<br>T1(n)=30n4+20n3+40n2+46n+100 T2(n)=1000n3+50n2+78n+10<br>T1(n)=Θ(n4)   T2​(n)=Θ(n3)</p>
<h3 id="渐进上界-O"><a href="#渐进上界-O" class="headerlink" title="渐进上界 O"></a>渐进上界 O</h3><p>设f(n)和g(n)是定义域为自然数集N上的函数。若存在正数c和n0，使得对一切<br>n≥n0都有0≤f(n)≤cg(n)成立，则称f(n)的渐进的上界是g(n)，记作<br>f(n)=O(g(n))。通俗的说n满足一定条件范围内，函数f(n)的阶不高于函数g(n)。<br>例如：设f(n)=n2+n,则<br>f(n)=O(n2)，取c=2,n0=1即可<br>f(n)=O(n3)，取c=1,n0=2即可。显然，O(n2)作为上界更为精确。</p>
<h3 id="渐进下界-Ω"><a href="#渐进下界-Ω" class="headerlink" title="渐进下界 Ω"></a>渐进下界 Ω</h3><p>与渐进上界刚好相反，这个下界的阶越高评估越精确</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))，例如<br>直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就<br>要有O(n)的空间复杂度了，因为每次递归都要存储返回信息</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ol>
<li>排序算法的稳定性是指：经过排序之后,能使值相同的数据保持原顺序中的<br>相对位置不变 </li>
<li>归并排序的最坏情况，最好情况和平均情况都是O(nlogn); 快速排序的最<br>坏情况是O(n^2)，最好的情况和平均情况是O(nlogn)</li>
<li>外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排<br>序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交<br>换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，<br>即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内<br>存完成排序。然后，对已经排序的子文件进行多路归并排序</li>
<li>稳定排序：冒泡、选择、归并、基数 不稳定排序：希快选堆</li>
<li>堆排序平均执行的时间复杂度和需要附加的存储空间复杂度分别是<br>O(nlogn)和O(1)</li>
<li>master公式的使用 T(n) = a*T(n/b) + O(n^d)<br>1) log(b,a) &gt; d -&gt; 复杂度为O(n^log(b,a))<br>2) log(b,a) = d -&gt; 复杂度为O(n^d * logn)<br>3) log(b,a) &lt; d -&gt; 复杂度为O(n^d)</li>
</ol>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种不稳定（5,5,2）任何情况下时间复杂度都是O(n^2)的排序算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//思想是每次都选择一个最小值排在前面</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> min=i; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(array[j]&lt;min)</span><br><span class="line">				min=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第i个位置要排当前最小值</span></span><br><span class="line">		<span class="keyword">if</span>(min!=i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=array[min];</span><br><span class="line">			array[min]=array[i];</span><br><span class="line">			array[i]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种稳定在最好情况下时间复杂度是O(n)最坏情况下O(n^2)平均情况O(n^2)的排序算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//可以进行优化，如果当前已经有序就结束</span></span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++) <span class="comment">//最多排序次数</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length-i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//按照顺序将前一个和后一个交换位置</span></span><br><span class="line">			<span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp=array[j];</span><br><span class="line">				array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">				array[j+<span class="number">1</span>]=temp;</span><br><span class="line">				flag=<span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//经过一轮交换发现已经有序就可知直接退出</span></span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="keyword">true</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>是稳定排序但是需要空间复杂度O(n)，需要调用logn次开辟栈帧空间，还<br>需要创建一个临时数组，时间复杂度是O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//需要开辟一个一样大小的数组空间</span></span><br><span class="line">	<span class="keyword">int</span>[] tempt=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">	sort(<span class="number">0</span>,array.length-<span class="number">1</span>,array,tempt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> li,<span class="keyword">int</span> lo,<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] tempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//拆分的终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(li&gt;=lo)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="comment">//拆分数组</span></span><br><span class="line">	<span class="keyword">int</span> mid=(li+lo)/<span class="number">2</span>;</span><br><span class="line">	sort(li,mid,array,tempt);</span><br><span class="line">	sort(mid+<span class="number">1</span>,lo,array,tempt);</span><br><span class="line">	<span class="comment">//将有序的两部分合并为一个有序的部分，用tempt保存有序结果</span></span><br><span class="line">	merge(li,mid,lo,array,tempt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> li,<span class="keyword">int</span> mid,<span class="keyword">int</span> lo,<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] tempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=li;</span><br><span class="line">	<span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//合并操作</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=lo)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(array[i]&lt;array[j])</span><br><span class="line">			tempt[index++]=array[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tempt[index++]=array[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		tempt[index++]=array[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=lo)</span><br><span class="line">		tempt[index++]=array[j++];</span><br><span class="line">	index=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//这里必须要将有序结果重新写入array，因为还有更大规模的合并</span></span><br><span class="line">	<span class="keyword">while</span>(li&lt;=lo)</span><br><span class="line">		array[li++]=tempt[index++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是一种不稳定平均时间复杂度为O(nlogn)最好情况O(nlogn)最坏<br>情况O(n^2)空间复杂度为O(logn)(调用栈帧所需空间)的排序算法，最好情<br>况时每次都划分很均匀不需要交换，递归深度就是logn，跟归并排序一样。<br>最环情况时数组为正序或者逆序时需要经过n-1次递归调用，每次划分执<br>只比上一次少一个元素的子序列，每次经过n-i次比较<br>T(n)=n-1+n-2+n-3+…1=n(n-1)/2 时间复杂度O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sort(<span class="number">0</span>,array.length-<span class="number">1</span>,array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> li,<span class="keyword">int</span> lo,<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(li&gt;=lo)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="comment">//根据指定和元素将数组划分为两部分</span></span><br><span class="line">	<span class="keyword">int</span> partcut=part(li,lo,array);</span><br><span class="line">	sort(li,partcut-<span class="number">1</span>,array);</span><br><span class="line">	sort(partcut+<span class="number">1</span>,lo,array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">part</span><span class="params">(<span class="keyword">int</span> li,<span class="keyword">int</span> lo,<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cut=array[li];</span><br><span class="line">	<span class="keyword">int</span> i=li;</span><br><span class="line">	<span class="keyword">int</span> j=lo+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(array[++i]&lt;=cut)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==lo)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(array[--j]&gt;=cut)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==li)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tempt=array[i];</span><br><span class="line">		array[i]=array[j];</span><br><span class="line">		array[j]=tempt;</span><br><span class="line">		<span class="keyword">if</span>(j&lt;=i)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> tempt=array[li];</span><br><span class="line">	array[li]=array[j];</span><br><span class="line">	array[j]=tempt;</span><br><span class="line">	<span class="comment">//索引j处就是要划分的位置</span></span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是一种稳定平均时间复杂度为O(n^2)最好时间复杂度为O(n)最坏<br>时间复杂度为O(n^2)的排序算法，最好情况就是完全有序只需要遍历，最坏<br>情况比如倒序时每次都要交换i次 T(n)=1+2+3+n-1=n(n-1)/2 时间复杂度为O(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>&amp;&amp;array[j]&lt;array[j-<span class="number">1</span>];j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=array[j];</span><br><span class="line">			array[j]=array[j-<span class="number">1</span>];</span><br><span class="line">			array[j-<span class="number">1</span>]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的改进，是不稳定的算法，时间复杂度介于O(n)到O(n^2)之间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xhell</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(h&lt;array.length)</span><br><span class="line">		h=<span class="number">3</span>*h+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(h&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;array.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=h&amp;&amp;array[j]&lt;array[j-h];j-=h)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp=array[j];</span><br><span class="line">				array[j]=array[j-h];</span><br><span class="line">				array[j-h]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		h=h/<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>时间复杂度是(n*k),是一种稳定的排序算法，排序时没有进行比较操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">	ArrayList[] list=<span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		list[i]=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(array[i]&gt;max)</span><br><span class="line">			max=array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//k保存最大值的位数</span></span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(max&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		max=max/<span class="number">10</span>;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//从最低位到最高位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">		list[array[i]/t%<span class="number">10</span>].push(array[i]);</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(list[i].size()&gt;<span class="number">0</span>)</span><br><span class="line">				array[index++]=list[i].pop();</span><br><span class="line">		&#125;</span><br><span class="line">		t=t*<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="/2020/02/28/Algorithm/number1.jpg" alt></p>
<ol>
<li>任何一个节点的值都大于其子节点的值就是大顶堆</li>
<li>任何一个节点的值都小于其子节点的值就是小顶堆</li>
<li>堆排序思想： 将待排序的数组构建成一个大顶堆，此时已经确定了最大<br>元素，最大元素与末尾元素进行交换，剩余的元素继续构建成一个大顶堆重<br>复之前的操作。如果要得到倒序数组就要构建小顶堆，思想与构建大顶堆的<br>思想一致</li>
<li>构建堆时时间复杂度为O(n)，一次重建堆的时间复杂度是O(logn)，堆排序的<br>时间复杂度是O(nlogn)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*一开始要先构建一个大顶堆，应该从中间的元素开始，数组的每个</span></span><br><span class="line"><span class="comment">	位置都已经是一个子堆的根节点了，跳关所有大小为1的子堆</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">int</span> N=array.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=array.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		sink(array,i,N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//堆排序过程，每次都与最大元素进行交换</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=array[i];</span><br><span class="line">		array[i]=array[<span class="number">0</span>];</span><br><span class="line">		array[<span class="number">0</span>]=temp;</span><br><span class="line">		sink(array,<span class="number">0</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*k+<span class="number">1</span>;j&lt;length;j=<span class="number">2</span>*j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//当前节点的子节点中较大的那个节点</span></span><br><span class="line">		<span class="keyword">if</span>(j+<span class="number">1</span>&lt;length&amp;&amp;array[j]&lt;array[j+<span class="number">1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="comment">//当前节点与子节点进行比较交换</span></span><br><span class="line">		<span class="keyword">if</span>(array[j]&gt;array[k])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=array[k];</span><br><span class="line">			array[k]=array[j];</span><br><span class="line">			array[j]=temp;</span><br><span class="line">			k=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的<br>数据元素的集合 <img src="/2020/02/28/Algorithm/6.jpg" alt> <img src="/2020/02/28/Algorithm/7.jpg" alt><br><a href="https://www.cnblogs.com/ysocean/p/7889153.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/7889153.html</a><br>一个数据结构必须能实现以下4大功能</p>
<ol>
<li>如何插入一条新的数据项</li>
<li>如何寻找某一特定的数据项</li>
<li>如何删除某一特定的数据项</li>
<li>如何迭代的访问各个数据项，以便进行显示或其他操作</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组几乎能够表示一切的数据结构，数组有两种声明方式，一种是动态另一种是静<br>态，是只能用来存放同一种数据类型的集合。数组也叫做顺序线性表，在内存中是<br>一块连续的存储空间，链表是链式存储的线性表，在内存中空间不连续。线性表应<br>满足的条件是：有且只有一个根结点，除了头尾两个节点以外，每个节点又有一个<br>前节点和一个后节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态</span></span><br><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//静态</span></span><br><span class="line"><span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>数组是通过索引来访问元素，如果知道元素的索引那么查找的效率就是O(1)，如果<br>不知道要查找元素的索引那么查找的效率就是O(n)。关联数组不是数组，是一个抽<br>象的数据结构，包含键值对的序列，例如哈希表</p>
<h4 id="模拟ArrayList"><a href="#模拟ArrayList" class="headerlink" title="模拟ArrayList"></a>模拟ArrayList</h4><p>Java集合中的ArrayList底层就是用数组实现，现在实现数据结构基本的4大功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">	<span class="comment">//封装所以属性</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">	<span class="comment">//数组的有效长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="comment">//数组创建后大小就固定了，扩展性较差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		array=<span class="keyword">new</span> <span class="keyword">int</span>[initialCapacity];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回有效长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">			System.out.print(array[i]+<span class="string">" "</span>);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//暂时不考虑越界问题</span></span><br><span class="line">		array[size++]=value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//知道索引查找值，时间复杂度就是O(1)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//知道值查找索引，时间复杂度就是O(n)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">			<span class="keyword">if</span>(array[i]==value)</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">  		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//时间复杂度是O(n)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;size;j++)</span><br><span class="line">			array[j-<span class="number">1</span>]=array[j];</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		array[i]=value;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈作为一种数据结构是一种只能在一端插入和删除的特殊线性表，按照先进后出的<br>原则存储数据，允许插入和删除的一端是栈顶，另一端是栈底 <img src="/2020/02/28/Algorithm/8.jpg" alt><br>栈这种数据结构具有记忆功能，比如浏览网页时先后进入ABC，那么返回时的网页<br>顺序就是CBA</p>
<h4 id="模拟Stack"><a href="#模拟Stack" class="headerlink" title="模拟Stack"></a>模拟Stack</h4><p>Java集合中的Stack底层就是用数组实现栈这种数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> top=-<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		array=<span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		array[++top]=value;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> array[top--];</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//访问栈顶元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> array[top];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top==-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种在前端删除后端插入的线性表，在队头删除队尾插入，双向队列在两端<br>都可以插入和删除</p>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>必须申请一片连续的存储空间，并设置两个指针进行管理，一个是队头指针front，<br>指向队头元素，另一个是队尾指针rear，指向下一个入队元素的存储位置 <img src="/2020/02/28/Algorithm/9.jpg" alt><br>当rear==front时表示队列中没有任何元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		array=<span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">		front=<span class="number">0</span>;</span><br><span class="line">		rear=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		array[rear++]=value;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		front++;</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>为了使队列空间能够重复使用，无论插入还是删除，当rear+1或者front+1超过<br>所分配的队列空间，就让它指向这片空间的起止位置。当rear=front时有两种<br>情况，一种是队列空间为空，另一种是队列空间已满，为了区别这两种情况一<br>般规定队列最多有MaxSize-1个元素，当队列剩下一个空位置时队列就已经满<br>了，因此判定队列已满的条件就变为 front=(rear+1)%MaxSize <img src="/2020/02/28/Algorithm/10.jpg" alt><br>假设用一个大小为m的数组表示循环队列，当前循环队列的元素个数是确定的：<br>(rear-front+m)%m</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表可以实现栈和队列等数据结构，是一种物理存储单元上非连续、非顺序的存储<br>、结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列<br>结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点<br>包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的<br>指针域</p>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><p>只能向一个方向也就是头结点开始遍历，用head指向头结点。LinkedList底层就<br>是用链表实现，单链表一般用于头部插入和删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="comment">//头结点</span></span><br><span class="line">	<span class="keyword">private</span> Node head;</span><br><span class="line">	    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		Node next;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value=value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在头部添加，可以看成栈入栈操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node node=<span class="keyword">new</span> Node(value);</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			head=node;</span><br><span class="line">		node.next=head;</span><br><span class="line">		head=node;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在头部删除，可以看成栈出栈操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		head=head.next;</span><br><span class="line">		size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找指定元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node node=head;</span><br><span class="line">		<span class="keyword">while</span>(node!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node.value==value)</span><br><span class="line">				<span class="keyword">return</span> node;</span><br><span class="line">			node=node.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除指定元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Node node=head;</span><br><span class="line">		Node pre=head;</span><br><span class="line">		<span class="keyword">while</span>(node!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node.value==value)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			pre=node;</span><br><span class="line">			node=node.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(node==head)</span><br><span class="line">		&#123;</span><br><span class="line">			head=head.next;</span><br><span class="line">			size--;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre.next=node.next;</span><br><span class="line">			size--;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h4><p>对于单向链表，如果要在尾部添加元素必须先遍历到尾部，然后在尾部插入元素，<br>可以添加一个指向尾部元素的指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node head;</span><br><span class="line">	<span class="keyword">private</span> Node tail;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">		Node next;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(value)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value=value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//链表头增加</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node node=<span class="keyword">new</span> Node(value);</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			head=node;</span><br><span class="line">			tail=node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			node.next=head;</span><br><span class="line">			head=node;</span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在链表尾增加，相当于队列增加</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node node=<span class="keyword">new</span> Node(value);</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			head=node;</span><br><span class="line">			tail=node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			tail.next=node;</span><br><span class="line">			tail=node;</span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除头部节点，相当于队列删除</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			head=<span class="keyword">null</span>;</span><br><span class="line">			tail=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			head=head.next;</span><br><span class="line">		&#125;</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>静态链表底层使用数组实现，兼顾了顺序表和链表的优点。数据都存储在数组中，<br>但是存储位置是随机的，数据之间的关系通过游标来指定。插入和删除较快，但<br>是要提前分配一个固定的空间。静态链表中除了数据链表外，还有一条连接空闲<br>位置的链表，叫做备用链表，用来回收数组中未使用或之前使用过的空间，以<br>便添加元素时使用</p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表每个节点数据都有两个指针，一个指向前节点一个指向后节点</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种抽象数据结构，用来描述具有树状结构的性质的数据集合 <img src="/2020/02/28/Algorithm/11.jpg" alt></p>
<ul>
<li>有一个根节点</li>
<li>每个节点有零或多个子节点</li>
<li>每一个非根节点只有一个父节点</li>
<li>除了根节点，每个子节点可以分为多个不相交的子树</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li>度 对于一个节点，拥有的子树数称为节点的度，一棵树的度是所有节点度的<br>最大值</li>
<li>层次 从一棵树的树根开始，树根所在层为第一层，根的孩子节点为第二层，<br>依此类推，一棵树的深度就是树中所有节点层次最大值</li>
<li>有序树 树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，<br>这棵树称为有序树，反之称为无序树。在有序树中，一个结点最左边的子树<br>称为第一个孩子，最右边的称为最后一个孩子</li>
<li>森林 有多个相互独立的树组成的集合叫做森林</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>每个节点最多含有两个子节点的树称为二叉树，然后由衍生出满二叉树和完全二<br>叉树。满二叉树就是除了最后一层外其余层的节点都有两个子节点。完全二叉树<br>是满二叉树更宽松的表示，允许最后一层节点有残缺，但必须都集中在左边<br><img src="/2020/02/28/Algorithm/12.jpg" alt> <img src="/2020/02/28/Algorithm/13.jpg" alt> <img src="/2020/02/28/Algorithm/14.jpg" alt></p>
<h4 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h4><p>二叉树可以使用两种数据结构来存储，一种是数组另一种是链表</p>
<ol>
<li>使用数组只能用来存储完全二叉树，从根节点开始，按照层次从左往右将<br>树中节点存储到数组中，对于索引为i的节点，其子节点的索引分别为2*i+1<br>2*i+2 <img src="/2020/02/28/Algorithm/15.jpg" alt> <img src="/2020/02/28/Algorithm/16.jpg" alt></li>
<li>用数组来表示二叉树有限制，只能表示完全二叉树，而链式存储方式可以<br>存储所有类型的二叉树，三叉链表会添加一个指向父节点的指针域 <img src="/2020/02/28/Algorithm/17.jpg" alt><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val=val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val,Node left,Node right)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val=val;</span><br><span class="line">		<span class="keyword">this</span>.left=left;</span><br><span class="line">		<span class="keyword">this</span>.right=right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树有四种遍历方式</p>
<ol>
<li>先序遍历 根节点-&gt;左子树-&gt;右子树<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displaypre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	displaypre(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displaypre</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	System.out.print(node.val);</span><br><span class="line">	<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">		display(node.left);</span><br><span class="line">	<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">		display(node.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现，可以使用栈这种数据结构实现</span></span><br><span class="line">Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">	stack.push(root);</span><br><span class="line">	<span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		Node node=stack.pop();</span><br><span class="line">		System.out.println(node.val);</span><br><span class="line">		<span class="keyword">if</span>(!node.right)</span><br><span class="line">			stack.push(node.right);</span><br><span class="line">		<span class="keyword">if</span>(!node.left)</span><br><span class="line">			stack.push(node.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>中序遍历 左子树-&gt;根节点-&gt;右子树<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displaymid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	displaymid(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displaymid</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">		display(node.left);</span><br><span class="line">	System.out.print(node.val);</span><br><span class="line">	<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">		display(node.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现，一直遍历左节点入栈，最后取出节点，如果有右子节点继续重复上述操作</span></span><br><span class="line">Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Node node=root;</span><br><span class="line"><span class="keyword">if</span>(node!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(!stack.isEmpty()||node!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(node!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			stack.push(node);</span><br><span class="line">			node=node.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			node=stack.pop();</span><br><span class="line">			System.out.println(node.val);</span><br><span class="line">			node=node.right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>后序遍历 左子树-&gt;右子树-&gt;根节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displaypost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	displaymid(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displaypost</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">		display(node.left);</span><br><span class="line">	<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">		display(node.right);</span><br><span class="line">	System.out.print(node.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line">Node node=root;</span><br><span class="line"><span class="keyword">if</span>(node!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	<span class="comment">//上一次访问的节点</span></span><br><span class="line">	Node pre=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(node!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		stack.push(node);</span><br><span class="line">		node=node.left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		node=stack.pop();</span><br><span class="line">		<span class="comment">//根节点被访问的条件是无右子树或右子树已经被访问</span></span><br><span class="line">		<span class="keyword">if</span>(node.right==<span class="keyword">null</span>||node.right==pre)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(node.val);</span><br><span class="line">			pre=node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			stack.push(node);</span><br><span class="line">			node=node.right;</span><br><span class="line">			<span class="keyword">while</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				stack.push(node);</span><br><span class="line">				node=node.left;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>层次遍历 从上往下从左往右<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">	LinkedList&lt;Node&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	Node node=root;</span><br><span class="line">	list.add(node);</span><br><span class="line">	<span class="keyword">while</span>(!list.isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		node=list.poll();</span><br><span class="line">		System.out.println(node.val);</span><br><span class="line">		<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">			list.add(node.left);</span><br><span class="line">		<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">			list.add(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉查找树是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的<br>实现符号表功能的数据结构,每个节点的值都大于左子树所有节点的值小于右子<br>树所有节点的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里采用递归实现所有功能代码，递归实现非常简单明了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node root; <span class="comment">//二叉查找树的根节点</span></span><br><span class="line">	<span class="comment">//二叉查找树的节点数目</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> node.N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过节点值得到相应的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> get(root,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node node,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//这里采用通用方法进行比较，像int这种基本类型直接比较</span></span><br><span class="line">		<span class="keyword">int</span> cmp=value.compareTo(node.value);</span><br><span class="line">		<span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> get(node.right,value);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> get(node.left,value);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//符号表最基本的功能之插入元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root=put(root,value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//一开始不存在树就创建树</span></span><br><span class="line">		<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(value,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> cmp=value.compareTo(node.value);</span><br><span class="line">		<span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">			node.right=put(node.right,value);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">			node.left=put(node.left,value);</span><br><span class="line">		<span class="comment">//更新树的节点数目</span></span><br><span class="line">		node.N=size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//得到二叉查找树中节点值最小的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> getmin(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">getmin</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node.left==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		<span class="keyword">return</span> getmin(node.left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//得到二叉查找树中节点值最大的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">getmax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> getmax(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">getmax</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node.right==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		<span class="keyword">return</span> getmax(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除二叉查找树中节点值最小的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletemin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">			root=deletemin(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">deletemin</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node.left==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> node.right;</span><br><span class="line">		node.left=deletemin(node.left);</span><br><span class="line">		x.N=size(x.left)+size(x.right)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除二叉查找树中节点值最大的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletemax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">			root=deletemax(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">deletemax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node.right==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> node.left;</span><br><span class="line">		node.right=deletemin(node.right);</span><br><span class="line">		x.N=size(x.left)+size(x.right)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//符号表最基本功能之删除</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		root=delete(root,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		 <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">		 	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		 <span class="keyword">int</span> cmp=value.compareTo(node.value);</span><br><span class="line">		 <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">		 	node.right=delete(node.right,value);</span><br><span class="line">		 <span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">		 	node.left=delete(node.left,value);</span><br><span class="line">		 <span class="keyword">else</span></span><br><span class="line">		 &#123;</span><br><span class="line">		 	<span class="comment">//得到要删除的节点，此时有三种情况</span></span><br><span class="line">		 	<span class="comment">//该节点没有右子节点</span></span><br><span class="line">		 	<span class="keyword">if</span>(node.right==<span class="keyword">null</span>)</span><br><span class="line">		 		<span class="keyword">return</span> node.left;</span><br><span class="line">		 	<span class="comment">//该节点没有左子节点</span></span><br><span class="line">		 	<span class="keyword">if</span>(node.left==<span class="keyword">null</span>)</span><br><span class="line">		 		<span class="keyword">return</span> node.right;</span><br><span class="line">		 	<span class="comment">//这个时候将该节点删除后需要用一个子节点替换</span></span><br><span class="line">		 	Node t=node;</span><br><span class="line">		 	<span class="comment">//该节点右子树中的最小节点就是要替换的节点</span></span><br><span class="line">		 	node=min(t.right);</span><br><span class="line">		 	<span class="comment">//更新右子树</span></span><br><span class="line">		 	node.right=deletemin(t.right);</span><br><span class="line">		 	<span class="comment">//左子树不变</span></span><br><span class="line">		 	node.left=t.left;</span><br><span class="line">		 &#125;</span><br><span class="line">		 node.N=size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h3><p>任何节点的两棵子树的高度相差不大于1的树，在一些极端情况下，二叉<br>查找树会退化为链表，插入的时间复杂度变为O(n)，平衡树的查找能够<br>在对数时间结束。以下内容参考<br><a href="https://www.zhihu.com/question/30527705/answer/260005525" target="_blank" rel="noopener">https://www.zhihu.com/question/30527705/answer/260005525</a></p>
<h4 id="平衡查找树-AVL树"><a href="#平衡查找树-AVL树" class="headerlink" title="平衡查找树(AVL树)"></a>平衡查找树(AVL树)</h4><p>AVL树是最早的平衡二叉树</p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>也叫做B-树，全称是Balance-Tree(平衡多路查找树)，平衡指左边和右边分<br>布均匀，多路指一个父节点可以有多于两个子节点，所有叶子节点都位于同<br>一层用在磁盘文件组织，数据索引和数据库索引</p>
<h4 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h4><p>2-3树是B树的一种，接下来我们先来研究2-3树的一些特性 <img src="/2020/02/28/Algorithm/18.jpg" alt></p>
<ul>
<li>2节点 一个节点两个子树</li>
<li>3节点 两个节点三个子树</li>
<li>查找 比如查找H，整体过程如下：先与M比较，比M小则继续在左子树查找，<br>H在E和J之间，在中子树中继续查找，找到H</li>
<li>插入 可以先和二叉树一样进行一次未命中的查找，然后把新节点挂在树的<br>底部，这样就不能保证所有叶子节点到根节点距离相同。如果为命中查找结<br>束于一个2-节点，那么只需要将这个2-节点转化为3-节点。如果未命中查<br>找结束于一个3-节点，分析如下</li>
</ul>
<ol>
<li>向一个只含有一个3-节点的树中插入节点，首先将这个3-节点转化为4-<br>节点，然后将这个4-节点转化为3个2-节点</li>
<li>向一个父节点为2-节点的3-节点中插入节点，同样先构建一个4-节点，<br>但此时不会为中键创建一个新节点，而是将这个节点移到父节点中，于是<br>父节点就变为了3-节点</li>
<li>向一个父节点为3-节点的3-节点中插入节点，同样先构建一个4-节点，<br>然后将中键插入到父节点中，此时再构建一个4-节点，然后向上不断分解<br>临时的4-节点，知道遇见一个2-节点或者一个3-节点的根</li>
</ol>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>刚刚学习过2-3树，思路和结构都很简单清晰，但是实现比较困难，比如需要维<br>护两种不同节点以及比较转换等操作。红黑树也是一种平衡二叉树，Java源码中<br>HashMap底层用到了红黑树，接下来看一下红黑树是如何实现2-3树的特性</p>
<ul>
<li>每个节点要么是红色要么是黑色</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色</li>
<li>一个红节点的两个子节点是黑色</li>
<li>任何叶子节点到根节点路径上的黑色节点数都相同</li>
<li>红色节点都在左边，这一条只对应当前我要实现的一种红黑树</li>
<li>3-节点就相当于一个红节点与一个黑节点相连，然后红节点连接两个黑节<br>点，将红节点与父节点放在同一位置，就对应于一个2-3树</li>
</ul>
<ol>
<li>旋转 在插入节点等操作总是先默认节点是红色的，所以可能会出现红色<br>节点在右边或者出现两个连续的红节点，这些情况都需要旋转。左旋就是将<br>红节点由左子变为右子，右旋是将红节点由左子变为右子，这种情况对应<br>连续两个红节点，右旋后两个红节点在左右子，然后直接变为黑色父变为<br>红色即可 <img src="/2020/02/28/Algorithm/19.jpg" alt> <img src="/2020/02/28/Algorithm/20.jpg" alt></li>
<li>旋转操作会返回一个节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	Node left,right;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="comment">//true代表红色，false代表黑色</span></span><br><span class="line">	<span class="keyword">boolean</span> color;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val,<span class="keyword">int</span> N,<span class="keyword">boolean</span> color)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val=val;</span><br><span class="line">		<span class="keyword">this</span>.N=N;</span><br><span class="line">		<span class="keyword">this</span>.color=color;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左旋操作，h相当于上图中的x</span></span><br><span class="line"><span class="function">Node <span class="title">rotateLeft</span><span class="params">(Node h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node x=h.right;</span><br><span class="line">	h.right=x.left;</span><br><span class="line">	x.color=h.color;</span><br><span class="line">	h.color=<span class="keyword">true</span>;</span><br><span class="line">	x.N=h.N;</span><br><span class="line">	h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋操作，h相当于上图中的y</span></span><br><span class="line"><span class="function">Node <span class="title">rotateRight</span><span class="params">(Node h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node x=h.left;</span><br><span class="line">	h.left=x.right;</span><br><span class="line">	x.right=h;</span><br><span class="line">	x.color=h.color;</span><br><span class="line">	h.color=<span class="keyword">true</span>;</span><br><span class="line">	x.N=h.N;</span><br><span class="line">	h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋可能导致左右子都是红，这时需要颜色转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	h.color=<span class="keyword">true</span>;</span><br><span class="line">	h.left.color=<span class="keyword">false</span>;</span><br><span class="line">	h.right.color=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>挖个坑<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	root=put(root,val);</span><br><span class="line">	root.color=<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node h,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(h==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Node(val,<span class="number">1</span>,<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">if</span>(val&lt;h.val)</span><br><span class="line">		h.left=put(h.left,val);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(val&gt;<span class="number">0</span>)</span><br><span class="line">		h.right=put(h.right,val);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		h.val=val;</span><br><span class="line">	<span class="keyword">if</span>(h.right&amp;&amp;!h.left)</span><br><span class="line">		h=rotateLeft(h);</span><br><span class="line">	<span class="keyword">if</span>(h.left&amp;&amp;h.left.left)</span><br><span class="line">		h=rotateRight(h);</span><br><span class="line">	<span class="keyword">if</span>(h.left&amp;&amp;h.right)</span><br><span class="line">		flipColors(h);</span><br><span class="line">	h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树</p>
<ul>
<li>一个节点到另一个节点之间的通路叫做路径</li>
<li>节点的带权路径长度 从根节点到该该节点的路径长度乘以节点的权</li>
</ul>
<p>对于有权值的n个节点组成的集合，先取出权值最小的两个节点组成一个二叉树，根<br>节点为左右子节点权值之和，将新节点放入节点集合中重复上述操作 <img src="/2020/02/28/Algorithm/21.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(LinkedList&lt;Node&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node left=list.poll();</span><br><span class="line">            Node right=list.poll();</span><br><span class="line">            Node node=<span class="keyword">new</span> Node(left.weight+right.weight);</span><br><span class="line">            node.left=left;</span><br><span class="line">            node.right=right;</span><br><span class="line">            list.add(node);</span><br><span class="line">            list.sort((o1,o2)-&gt;&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.weight-o2.weight;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        root=list.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addname</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            print(root.left,<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            print(root.right,<span class="string">"1"</span>);</span><br><span class="line">        LinkedList&lt;Node&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Node node=root;</span><br><span class="line">        list.add(node);</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            node=list.poll();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                list.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                list.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node node,String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node.name=name;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">            print(node.left,name+<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">            print(node.right,name+<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Node(<span class="number">7</span>,<span class="string">"a"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="string">"b"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">"c"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">"d"</span>));</span><br><span class="line">        list.sort((o1,o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.weight-o2.weight;</span><br><span class="line">        &#125;);</span><br><span class="line">        Main a=<span class="keyword">new</span> Main();</span><br><span class="line">        a.createTree(list);</span><br><span class="line">        a.print();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String data;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> weight,String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight=weight;</span><br><span class="line">        <span class="keyword">this</span>.data=data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight=weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight-((Node)node).weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" "</span>+data+<span class="string">" "</span>+weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>许多应用程序都需要处理有序元素，但是不一定全部有序。例如只处理当前最大<br>值或者最小值，一台电脑能够同时运行多个程序，每个程序都有一个优先级，<br>并会总是先处理优先级高的程序，这种情况一个合适的数据结构应该支持两<br>中操作：删除最大值和插入元素。这就是优先队列，数组和链表是实现优先<br>队列的最简单方式，但是插入和删除的时间复杂度总有一个是O(N)</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>数据结构二叉堆能很好实现优先队列的基本操作。在二叉堆的数组中，每个元素<br>都要保证大于等于另外两个特定元素。当一棵二叉树的每个节点都大于等于它的<br>两个子节点，被称为堆有序 <img src="/2020/02/28/Algorithm/22.jpg" alt><br>如果用指针来表示堆有序的二叉树，每个元素都需要三个指针来找到它的上下<br>节点，如果使用完全二叉树的话就不需要使用指针，只需要数组就可以完成<br>全部操作，具体方法就是将二叉树的节点按照层次顺序放入数组中，根节点<br>放在索引位置1，它的子节点放在2和3，不使用0位置。这就是二叉堆</p>
<h4 id="堆的算法"><a href="#堆的算法" class="headerlink" title="堆的算法"></a>堆的算法</h4><p>二叉堆中位置为k的节点的父节点位置为k/2，而它的两个子节点位置为2k和<br>2k+1，高效的算法能够实现在对数时间内插入和删除，一棵大小为N的完全<br>二叉树高度不会超过lgN</p>
<ol>
<li>用一个长度为N+1的数组表示一个大小为N的堆，堆的操作会首先进行一些<br>简单的改动，打破堆的状态，然后再遍历堆并按要求将堆恢复，这个过程叫<br>有序化</li>
<li>有序化的过程会遇到两种情况，当某个节点优先级上升需要由下至上恢复<br>堆的顺序，当某个节点优先级下降需要由上至下恢复堆的顺序</li>
<li>插入元素 将新元素插入到数组某位，增加堆的大小并让这个元素上浮到<br>合适位置</li>
<li>删除最大元素 从数组顶端删除最大元素并将最后一个元素放到数组顶端，<br>减少堆的大小并让这个元素下沉到合适位置 </li>
<li>基于堆的优先队列 <img src="/2020/02/28/Algorithm/23.jpg" alt><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] pq;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pq=<span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pq[++N]=val;</span><br><span class="line">		swim(N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max=pq[<span class="number">1</span>];</span><br><span class="line">		pq[<span class="number">1</span>]=pq[N];</span><br><span class="line">		N--;</span><br><span class="line">		sink(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(k&gt;<span class="number">1</span>&amp;&amp;pq[k]&gt;pq[k/<span class="number">2</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> temp=pq[k];</span><br><span class="line">			pq[k]=pq[k/<span class="number">2</span>];</span><br><span class="line">			pq[k/<span class="number">2</span>]=temp;</span><br><span class="line">			k=k/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">2</span>*k&lt;=N)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j=<span class="number">2</span>*k;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;N&amp;&amp;pq[j]&lt;pq[j+<span class="number">1</span>])</span><br><span class="line">				j++;</span><br><span class="line">			<span class="keyword">if</span>(pq[k]&gt;pq[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp=pq[k];</span><br><span class="line">				pq[k]=pq[j];</span><br><span class="line">				pq[j]=temp;</span><br><span class="line">				k=j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>将一个大问题分解为若干小问题，每个小问题都是相互独立并且与原问题有<br>相同的性质，求解小问题的解合并得到原问题的解，以下算法的具体问题求解<br>代码都已经放在Algorithm666仓库中</p>
<h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法的本质是蛮力法，回溯法常使用深度优先搜索遍历，与蛮力法的区别、<br>在于回溯法会进行剪枝处理，回溯法不一定能够得到最优解</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>使用较为简单的方法找到局部最优，此时并不能保证该解是全局最优但是也<br>是一个不差的解，只解决当前局部问题不关心之前和之后的解，不同的贪心<br>准则可以得到不同的结果</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol>
<li>解决优化问题，将多阶段问题求解转化为一系列单阶段问题求解，找全<br>局最优，只有某些条件满足的问题才能使用动态规划。</li>
<li>状态的无后效性 如果某个阶段状态给定后，则该阶段以后过程的发展<br>不受该阶段以前各阶段状态的影响，也就是受状态具有马尔科父性。适用于<br>动态求解的问题具有状态的无后效性</li>
<li>策略 各个阶段决策的确定后，就组成一个决策序列，该序列称之为一<br>个策略，由某个阶段开始到终止阶段的过程称之为子过程，其对应的某个<br>策略称之为子策略</li>
<li>Bellman最优性原理 求解问题的一个最优策略序列的子策略序列总是<br>最优的，则称该问题满足最优性原理。对具有最优性原理性质的问题而言，<br>如果有一决策序列包含具有非最优的决策子序列，则该决策序列一定不是最优的</li>
<li>动态规划的思想实质是分治思想和解决冗余。与分治法类似的是将原问<br>题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题<br>的解。与分治法不同的是分解的子问题往往不是相互独立的，若用分治法<br>来解有些共同部分被重复计算了很多次，动态规划利用这种子问题的折叠性<br>质，对每一个子问题只解一次</li>
</ol>
<h2 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h2><ul>
<li>图的基本概念</li>
</ul>
<ol>
<li>一个图是由一系列的节点和边组成</li>
<li>节点的度指的是节点连接的边的条数，有向图有出度和入度</li>
<li>简单图指没有多重边且没有自环的图</li>
<li>无向图所有节点度数和为边数的两倍</li>
<li>有向图所有节点入度数等于出度数等于边数</li>
<li>一条路径由一系列的节点组成，并且相邻两个节点之间有一条边相连，<br>简单路径没有重复</li>
<li>树是一个无环连通的无向图</li>
<li>生成树是包含图中所有节点的树</li>
<li>加权图是每条边都有权值的图</li>
<li>环不是简单路径，起点和终点一致</li>
<li>稀疏图 E≈V ，稠密图 E≈V^2</li>
<li>任意两个节点都有边连接（有向图两个方向都有边）称为完全图 </li>
<li>连通分支是图中最大的连通子图</li>
<li>树的任意两个节点都有唯一的连通路径</li>
</ol>
<ul>
<li><p>邻接表<br>使用一个链表数组，对于稀疏图有效，可以节省空间，查找边时比较耗时<br>，矩阵运算不太方便</p>
</li>
<li><p>邻接矩阵<br>使用一个二维数组，对于稠密图有效</p>
</li>
<li><p>图的遍历之BFS<br>使用先进先出的队列，遍历之后可以形成一个BFS树，节点的深度是距离<br>起始点的最短距离  </p>
</li>
<li><p>图的遍历之DFS<br>使用先进后出的栈，遍历之后可以形成一个DFS森林，也就是一系列的DFS树</p>
</li>
</ul>
<h3 id="图的基本构造"><a href="#图的基本构造" class="headerlink" title="图的基本构造"></a>图的基本构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> V;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;Integer&gt;[] adj;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> s;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.V=V;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		adj=(LinkedList&lt;Integer&gt;[])<span class="keyword">new</span> LinkedList[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">			adj[i]=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		edgeTo=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFScount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dfs(i);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFSsearch</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s=s;</span><br><span class="line">		bfs(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSsearch</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s=s;</span><br><span class="line">		dfs(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		id[v]=count;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">			&#123;</span><br><span class="line">				edgeTo[w]=v;</span><br><span class="line">				dfs(w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		markd[v]=<span class="keyword">true</span>;</span><br><span class="line">		list.add(v);</span><br><span class="line">		<span class="keyword">while</span>(!list.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> w=list.pop();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k:adj(w))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!marked[k])</span><br><span class="line">				&#123;</span><br><span class="line">					edgeTo[k]=w;</span><br><span class="line">					marked[k]=<span class="keyword">true</span>;</span><br><span class="line">					list.add(k);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!marked[v])</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		Stack&lt;Integer&gt; path=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=v;x!=s;x=edgeTo[x])</span><br><span class="line">		&#123;</span><br><span class="line">			path.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		path.push(s);</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> marked[w];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> V;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getE</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> E;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		adj[v].add(w);</span><br><span class="line">		adj[w].add(v);</span><br><span class="line">		E++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测图是否有环"><a href="#检测图是否有环" class="headerlink" title="检测图是否有环"></a>检测图是否有环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cycle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cycle</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;V;s++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">				dfs(s,s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">				dfs(w,v);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(w!=u)</span><br><span class="line">			    hasCycle=<span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hasCycle;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测是否是二分图"><a href="#检测是否是二分图" class="headerlink" title="检测是否是二分图"></a>检测是否是二分图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoColor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] color;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isTwocolor=<span class="keyword">true</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TwoColor</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		color=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;V;s++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">			  dfs(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[w])</span><br><span class="line">			&#123;</span><br><span class="line">				color[w]=!color[v];</span><br><span class="line">				dfs(w);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(color[w]==color[v])</span><br><span class="line">				isTwocolor=<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTwocolor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isTwocolor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有向环"><a href="#有向环" class="headerlink" title="有向环"></a>有向环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; cycle;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] onstack;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; reversepost;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		edgeTo=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		onstack=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		reversepost=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;V;v++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[v])</span><br><span class="line">				dfs(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		onstack[v]=<span class="keyword">true</span>;</span><br><span class="line">		marked[v]=<span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> w:adj(v))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(hasCycle)</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!marked[w])</span><br><span class="line">				&#123;</span><br><span class="line">					edgeTo[w]=v;</span><br><span class="line">				   dfs(w);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(onstack[w])</span><br><span class="line">			&#123;</span><br><span class="line">				cycle=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> x=v;x!=w;x=edgeTo[x])</span><br><span class="line">					cycle.push(x);</span><br><span class="line">				cycle.push(w);</span><br><span class="line">				cycle.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		onstack[v]=<span class="keyword">false</span>;</span><br><span class="line">		reversepost.push(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有向图的强连通性"><a href="#有向图的强连通性" class="headerlink" title="有向图的强连通性"></a>有向图的强连通性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kosara</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Kosara</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[V];</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[V];</span><br><span class="line">		G2=G.reverse();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s:G2.reversepost())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!marked[s])</span><br><span class="line">				&#123;</span><br><span class="line">					dfs(s);</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.v=v;</span><br><span class="line">		<span class="keyword">this</span>.w=w;</span><br><span class="line">		<span class="keyword">this</span>.weight=weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ol>
<li>对于一个有向无环图，拓扑排序就是将所有顶点进行排序<br>，如果ViVj，那么Vi必须排在Vj<br>之前  </li>
<li>对全图进行DFS，记录每个节点的结束时间，以节点结束时<br>间由大到小的顺序输出节点即可</li>
<li>每次都删除入度为0的节点</li>
</ol>
<h3 id="union-find算法"><a href="#union-find算法" class="headerlink" title="union-find算法"></a>union-find算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] sz;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		count=N;</span><br><span class="line">		id=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			id[i]=i;</span><br><span class="line">		sz=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			sz[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(p!=id[p])</span><br><span class="line">			p=id[p];</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=find(p);</span><br><span class="line">		<span class="keyword">int</span> j=find(q);</span><br><span class="line">		<span class="keyword">if</span>(i==j)</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">if</span>(sz[i]&lt;sz[j])</span><br><span class="line">		&#123;</span><br><span class="line">			id[i]=j;</span><br><span class="line">			sz[j]+=sz[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			id[j]=i;</span><br><span class="line">			sz[i]+=sz[j];</span><br><span class="line">		&#125;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><ol>
<li>有些问题能够在多项式级别的算法解出，例如n^2,n^3</li>
<li>NP问题是指能够在多项式时间内检验一个解是否正确的问题</li>
<li>所有NP问题都能在多项式时间内归约成NPC问题</li>
</ol>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><p>这是一个用C语言实现的方法，作用是返回对象的散列码。Java中有几种集合类，<br>比如Map List一般存放的元素是有序可重复的，Set存放的元素是不可重复的。<br>判断一个元素是否重复一般使用equals方法，如果一个集合中有数亿的元素，<br>那么每新加入一个元素都要与这数亿个元素一起比较效率低下。Java集合采用哈<br>希表来实现查重，当集合要添加一个新元素时，首先调用hashCode方法，然后<br>经过哈希化得到一个在哈希表中的位置，如果这个位置没有元素就直接加入，否<br>则与这个位置的链表上的每个元素通过equals方法进行比较</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表也称为散列表，Hash表是一种根据关键字(key-value)而直接进行访问的<br>数据结构，它是基本数组将关键字映射到数组的某个下标来加快查找速度，但是<br>并不完全是数组，可以看成是数组和链表的结合体最重要的问题就是如何把关键<br>字转换为数组的下标，这个转换的函数为哈希函数，转换的过程叫做哈希化，同<br>时也有多个键散列到相同索引的情况，散列查找的第二步就是解决冲突碰撞问题</p>
<h4 id="哈希化"><a href="#哈希化" class="headerlink" title="哈希化"></a>哈希化</h4><p>散列表是在时间和空间上做出权衡的经典例子。如果没有内存限制，可以直接将<br>键作为数组的索引，所有的查找工作只需要访问内存一次就可以完成。如果没有<br>时间限制，可以使用无序数组并进行顺序查找，这样只需要很小的内存空间。哈<br>希算法在两种极端之间找到了一种平衡，首先就是散列函数的计算，如果有一个<br>能够保存M个键值对的数组，那么就需要将任意键转化为0~M-1的索引范围。散列<br>函数和键的类型有关，每种类型的键都需要一个对应的散列函数</p>
<h4 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h4><p>一般采用整数取余法，选择一个大小为素数M的数组，对于任意整数k计算k%M的<br>余数，M用素数可以均匀地散列散列值</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>将键表示为二进制数然后再使用除留取余数法</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>一种叫Horner方法的经典算法用N次乘法、加法和取余来计算一个字符串的散列值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">&#123;</span><br><span class="line">	hash=(R*hash+s.charAt(i))%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="软缓存"><a href="#软缓存" class="headerlink" title="软缓存"></a>软缓存</h4><p>如果散列值的计算很耗时，那么或许可以将每个键的散列值缓存起来，Java中的<br>String对象的hashCode()方法就使用了软缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="keyword">this</span>.hash;</span><br><span class="line">        <span class="comment">//如果h等于0就计算否则直接返回已经计算的值</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = h = <span class="keyword">this</span>.isLatin1() ? StringLatin1.</span><br><span class="line">            hashCode(<span class="keyword">this</span>.value) : StringUTF16.hashCode(<span class="keyword">this</span>.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>一个散列函数能够将键转化为数组索引，散列算法的第二步就是碰撞处理</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>将大小为M的数组中的每个元素都指向一条链表，链表中的每个结点都存储了散列<br>值为该元素索引的键值对。查找分为两步，首先根据散列值找到对应的链表，然后<br>沿着链表顺序查找相应的键</p>
<h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>用大小为M的数组保存N个键值对，其中M&gt;N。需要依靠数组中的空位解决碰撞冲<br>突，基于这种策略的所有方法统称为开放地址散列表</p>
<ul>
<li>线性探测 一个位置一个位置按顺序查找，但是很容易发生在某个索引位置聚<br>集，就好像围观群众一样在某个地方越来越大</li>
<li>二次探测 二次探测是防止聚集的一种方式，每次不是相邻位置探测而是探测<br>间隔位置。二次探测就是x+1 x-1 x+4 x-4 x+9 x-9</li>
<li>再哈希法 把关键字用不同的哈希函数再一次哈希，用这个结果作为步长<br>stepSize=constant-key%constant，constant是质数并且小与数组容量</li>
<li>设置公共溢出区法 即为所有冲突的关键字建立一个公共的溢出区来存放，<br>在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位<br>置进行比对如果相等，则查找成功如果不相等，则到溢出表去进行顺序查找<br>，如果对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对<br>查找性能来说还是非常高的</li>
</ul>
<h4 id="对于hashCode的要求"><a href="#对于hashCode的要求" class="headerlink" title="对于hashCode的要求"></a>对于hashCode的要求</h4><p>在程序运行期间，如果对象的变化不会导致equals方法的变化，那么hashCode的<br>返回值就不能改变</p>
<ul>
<li>equals返回true那么hashCode值一定相等</li>
<li>hashCode值相等不一定equals返回true</li>
</ul>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol>
<li>负载因子 α=填入表中元素的个数/hash表长度。哈希法的平均查找长度随<br>负载因子的增大而增大</li>
<li>在内存中的数据查找性能较好的是HashMap，在磁盘中查找性能较好的是<br>B+ Tree</li>
<li>开哈希表–链地址法  闭哈希表–开放地址法</li>
</ol>
<h2 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h2><ol>
<li>牛客上有一个题：一个有序数列，序列中的每一个值都能够被2或者3或者5所<br>整除，这个序列的初始值从1开始，但是1并不在这个数列中。求第1500个值是多少？<br>两个牛哥的思路：设x个数，x/2+x/3+x/5-x/6-x/10-x/15+x/30=1500<br>翻译过来是:在x以内,能整除2的有x/2个数,整除3的有x/3个数…但这些数有<br>重复的,需要利用容斥原理去重: A∪B∪C = A+B+C - A∩B - B∩C - C∩A +<br>A∩B∩C</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/02/28/Algorithm/">https://skysea-gaoming.github.io/2020/02/28/Algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStructure/">DataStructure</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/28/Spring/"><i class="fa fa-chevron-left">  </i><span>Spring</span></a></div><div class="next-post pull-right"><a href="/2020/02/28/SpringBoot/"><span>SpringBoot</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/02/28/Algorithm/';
  this.page.identifier = '2020/02/28/Algorithm/';
  this.page.title = 'Algorithm';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1599140437492&amp;di=195fa5a4bc93905108d4f72b9167b0c0&amp;imgtype=0&amp;src=http%3A%2F%2Fphoto.tuchong.com%2F443730%2Ff%2F14505255.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>