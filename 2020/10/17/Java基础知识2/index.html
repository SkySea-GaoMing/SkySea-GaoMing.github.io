<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java基础知识2"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java基础知识2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程概述"><span class="toc-number">2.1.</span> <span class="toc-text">线程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程和进程"><span class="toc-number">2.1.1.</span> <span class="toc-text">线程和进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadAPI解析"><span class="toc-number">2.2.</span> <span class="toc-text">ThreadAPI解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的创建和启动"><span class="toc-number">2.3.</span> <span class="toc-text">线程的创建和启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable和Future"><span class="toc-number">2.4.</span> <span class="toc-text">Callable和Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的生命周期"><span class="toc-number">2.5.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程"><span class="toc-number">2.6.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制线程"><span class="toc-number">2.7.</span> <span class="toc-text">控制线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#join线程"><span class="toc-number">2.7.1.</span> <span class="toc-text">join线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep"><span class="toc-number">2.7.2.</span> <span class="toc-text">sleep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield"><span class="toc-number">2.7.3.</span> <span class="toc-text">yield</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的同步"><span class="toc-number">3.</span> <span class="toc-text">线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性"><span class="toc-number">3.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全问题"><span class="toc-number">3.2.</span> <span class="toc-text">线程安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步操作"><span class="toc-number">3.3.</span> <span class="toc-text">同步操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁"><span class="toc-number">3.4.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">3.5.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized同步机制"><span class="toc-number">3.5.1.</span> <span class="toc-text">synchronized同步机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁"><span class="toc-number">3.5.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-number">3.5.3.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock和synchronized的区别"><span class="toc-number">3.5.4.</span> <span class="toc-text">ReentrantLock和synchronized的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">3.6.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL优化"><span class="toc-number">3.6.1.</span> <span class="toc-text">DCL优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原子类"><span class="toc-number">3.6.2.</span> <span class="toc-text">原子类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池"><span class="toc-number">4.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞队列"><span class="toc-number">4.1.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义阻塞队列"><span class="toc-number">4.1.1.</span> <span class="toc-text">自定义阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的阻塞队列"><span class="toc-number">4.1.2.</span> <span class="toc-text">常见的阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">4.1.3.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">42</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1605784321698&amp;di=835f40a2b6d3b20d5d4c32b6ae74423d&amp;imgtype=0&amp;src=http%3A%2F%2Ft9.baidu.com%2Fit%2Fu%3D390739009%2C2408580797%26fm%3D193)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java基础知识2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/10/17/Java基础知识2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《疯狂Java讲义》  Hacker_ZhiDian的博客</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>建议请先学习我的深入JVM博客2中关于多线程的讲解。<br>之前的程序都是在做单线程的编程，所有的程序都只有一条顺序执行流，也就是<br>都从main()方法开始从上往下执行，如果执行时遇到阻塞，就会一直停留在该<br>处。开发一个服务器程序时，会接收到来自不同的客户端服务，不同的客户端<br>应该互不干扰，也就是有多个顺序执行流</p>
<h3 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h3><p>几乎所以的操作系统都支持同时运行多个任务，一个任务就是一个程序，一个<br>程序就是一个进程，而一个进程又包含很多顺序执行流，也就是包含多线程</p>
<h4 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h4><p>进程是系统进行资源分配的调度的一个独立单位</p>
<ul>
<li>独立性 进程是系统中独立存在的实体，它可以拥有独立的资源，每一个进程<br>都有自己的私有地址空间，在没有经过进程允许的情况下不能访问其他进程</li>
<li>动态性 进程与程序的区别在于，程序是一个静态指令的集合，而进程是在一<br>个正在系统中活动的指令集合，具有生命周期和各种不同状态</li>
<li>并发性 多个进程可以在单个处理器上并发执行，相互之间不影响。也就是<br>说同一时刻只有一个指令执行，但是多个进程指令快速轮换执行。而并行是<br>在多个处理器上多个进程同时执行</li>
</ul>
<p>多线程扩展了多进程的概念，使得同一个进程可以同时并发处理多个线程，线<br>程也被称为轻量级进程，线程是进程的执行单元，当进程被初始化时主线程也<br>被创建。多线程可以共享父进程中的共享变量同时也有自己的资源</p>
<h3 id="ThreadAPI解析"><a href="#ThreadAPI解析" class="headerlink" title="ThreadAPI解析"></a>ThreadAPI解析</h3><p>以下是JDK11对Thread类的英文介绍以及我自己的理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">A thread is a thread of execution in a program. The Java Virtual Machine </span><br><span class="line">allows an application to have multiple threads of execution running concurrently.</span><br><span class="line">Every thread has a priority. Threads with higher priority are executed </span><br><span class="line">in preference to threads with lower priority. Each thread may or may not also </span><br><span class="line">be marked as a daemon. When code running in some thread creates a new </span><br><span class="line">Thread object, the new thread has its priority initially set equal to </span><br><span class="line">the priority of the creating thread, and is a daemon thread if and only if </span><br><span class="line">the creating thread is a daemon.</span><br><span class="line"></span><br><span class="line">Java虚拟机允许多个线程同时运行，每一个线程都有一个优先级，拥有更高优先级的</span><br><span class="line">线程优先执行，每一个线程都有可能被标记为一个守护线程，当在一个线程中又创建</span><br><span class="line">一个新的线程，这个新线程的优先级默认是与创造它的线程相同，如果创造它的是一</span><br><span class="line">个守护线程，那么新线程也是守护线程</span><br><span class="line"></span><br><span class="line">When a Java Virtual Machine starts up, there is usually a single </span><br><span class="line">non-daemon thread (which typically calls the method named main of </span><br><span class="line">	some designated class). The Java Virtual Machine continues to </span><br><span class="line">	execute threads until either of the following occurs:</span><br><span class="line"></span><br><span class="line">当Java虚拟机开始运行的时候，经常会有一条非守护线程也就是主线程执行，当遇到</span><br><span class="line">如下情况虚拟机运行停止</span><br><span class="line"></span><br><span class="line">The exit method of class Runtime has been called and the security manager </span><br><span class="line">has permitted the exit operation to take place.</span><br><span class="line">All threads that are not daemon threads have died, either by returning from </span><br><span class="line">the call to the run method or by throwing an exception that propagates </span><br><span class="line">beyond the run method.</span><br><span class="line"></span><br><span class="line">当Runtime类的exit方法被调用以及安全管理员已经允许exit方法执行</span><br><span class="line">所有的非守护线程都已经正常结束，包括run方法的正常返回或者在run方法中抛出异常</span><br><span class="line"></span><br><span class="line">There are two ways to create a new thread of execution. One is to declare </span><br><span class="line">a class to be a subclass of Thread. This subclass should override the run </span><br><span class="line">method of class Thread. An instance of the subclass can then be allocated </span><br><span class="line">and started. For example, a thread that computes primes larger than a </span><br><span class="line">stated value could be written as follows:</span><br><span class="line"></span><br><span class="line">有两种方式创建一个新的线程，一种方式是声明一个子类继承Thread，这个子类需要</span><br><span class="line">重写run方法，一个子类的实例可以被分配空间并执行start方法，写法如下</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> minPrime;</span><br><span class="line">         PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">             <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">              . . .</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ..</span><br><span class="line">     PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">     p.start();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The other way to create a thread is to declare a class that implements </span><br><span class="line">the Runnable interface. That class then implements the run method. An </span><br><span class="line">instance of the class can then be allocated, passed as an argument when </span><br><span class="line">creating Thread, and started. The same example in this other style looks </span><br><span class="line">like the following:</span><br><span class="line"></span><br><span class="line">另一种方式是声明一个类实现Runnable接口，这个类中实现run方法。创建这个类的实例</span><br><span class="line">并作为参数传递给Thread类然后Thread类执行start方法</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> minPrime;</span><br><span class="line">         PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">             <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">              . . .</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//由此可以看出多个Thread实例可以共用一个target</span></span><br><span class="line">     PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line">     <span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>

<h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>Java用Thread类来代表线程，所有的线程对象都必须是Thread类或其子类的<br>实例。接下来看一下Thread源码内部的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>((ThreadGroup)<span class="keyword">null</span>, (Runnable)<span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), </span><br><span class="line">       	<span class="number">0L</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//target就是实现Runnable接口的类，这是第二种创建方式的构造器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>((ThreadGroup)<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0L</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name, <span class="keyword">long</span> </span></span></span><br><span class="line"><span class="function"><span class="params">   	stackSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(group, target, name, stackSize, (AccessControlContext)<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//这个方法就是为Thread实例命名服务的，Thread-threadInitNumber</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//也可以自定义name</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>((ThreadGroup)<span class="keyword">null</span>, (Runnable)<span class="keyword">null</span>, name, <span class="number">0L</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//线程的优先级默认是NORM_PRIORITY，优先级越高越容易优先执行，当不代表一定优先执行</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">//可以设置线程的优先级，从1到10</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.checkAccess();</span><br><span class="line">       <span class="keyword">if</span> (newPriority &lt;= <span class="number">10</span> &amp;&amp; newPriority &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">           ThreadGroup g;</span><br><span class="line">           <span class="keyword">if</span> ((g = <span class="keyword">this</span>.getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                   newPriority = g.getMaxPriority();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.setPriority0(<span class="keyword">this</span>.priority = newPriority);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//静态方法，获取当前正在执行的线程</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//函数式接口，可以使用Lambda表达式创建对象</span></span><br><span class="line">   <span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a>Callable和Future</h3><p>通过Runnable接口创建多线程时，Thread类的作用就是把run方法包装成线<br>程执行体，Java只能将run方法包装成线程执行体，C#可以将任意方法都包<br>装成线程执行体，因此JDK5开始Java提供Callable接口，提供一个call方<br>法作为线程执行体，call方法比run方法功能更强大</p>
<ul>
<li>call方法可以有返回值</li>
<li>call方法可以声明异常</li>
</ul>
<p>callable不是Runnable 的子接口，所以不能直接作为Thread的 target，而<br>且call有一个返回值。Future 接口来代表callable 接口中call 方法的返回<br>值，并且Future接口提供了一个FutureTask实现类，这个类实现了Runnable<br>接口可以作为target</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型形参类型与返回值类型相同</span></span><br><span class="line">FutureTask&lt;Integer&gt; task=<span class="keyword">new</span> FutureTask&lt;&gt;((Callable&lt;Integer&gt;)()-&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(Thread.currentThread.getName()+i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(Thread.currentThread.getName()+i);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">		<span class="comment">/* 获得返回值，调用该方法将导致程序阻塞，必须等子线程结束才会得到返回</span></span><br><span class="line"><span class="comment">		值，也就是主线程会被阻塞，直到call方法结束并返回为止 */</span></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(task.get());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程被创建并启动后并不是立即进入执行状态也不是一直处于执行状态，线程<br>的生命周期可以分为5个部分 <img src="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/22.jpg" alt> 这张是指点的图 <img src="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/1.jpg" alt></p>
<ol>
<li>新建 只是new一个普通的线程实例对象</li>
<li>就绪 必须调用start方法后线程处于就绪状态，何时运行取决于JVM线程调度</li>
<li>运行 当处于就绪状态的线程获取CPU执行就处于运行状态，在运行过程中可<br>能会中断使其他线程获得执行机会</li>
<li>阻塞 大多数操作系统采用抢占式调度策略</li>
</ol>
<ul>
<li>调用sleep方法线程主动放弃所占用的资源</li>
<li>线程调用一个阻塞IO的方法</li>
<li>线程试图获取一个同步监视器，但是这个监视器被其他线程持有</li>
<li>线程再等待某个通知notify</li>
<li>线程调用suspend方法将线程挂起，一般不用</li>
</ul>
<p>线程由阻塞状态重新进入就绪状态的情况如下</p>
<ul>
<li>调用sleep的线程过了指定时间</li>
<li>线程调用的阻塞式IO方法已经返回</li>
<li>线程成功获得同步监视器</li>
<li>线程等待某个通知时其他线程发出一个通知</li>
<li>处于挂起状态的线程调用resume恢复方法</li>
</ul>
<ol start="5">
<li>死亡 不可以对一个已经死亡的线程再次调用start方法</li>
</ol>
<ul>
<li>run方法正常结束</li>
<li>线程抛出一个未捕获的异常Exception或error</li>
<li>直接调用线程的stop方法来结束一个线程，一般不用</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>在调用start方法之前调用setDaemon(true)就能把一个线程变为守护线程<br>当所有非守护线程都结束后就算守护线程没有执行完也会结束，不要把重要<br>的任务放在守护线程</p>
<h3 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h3><p>Java线程提供了一些便捷的方法控制线程的执行，比如线程的开始start，<br>线程的休眠sleep，线程的停止stop，目前stop方法已经不推荐使用，停<br>止一个线程有三种方式</p>
<ol>
<li>run方法正常结束，有些情况下run方法会一直执行，比如服务端不断接<br>受客户端的请求，可以设置一个标志位控制run方法的结束<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span>(done)</span><br><span class="line">		&#123;</span><br><span class="line">			...</span><br><span class="line">			flag=<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>stop 调用stop会导致调用它的线程释放该线程所有的锁，导致同步数据<br>出现问题。不会再继续执行剩下的代码，并会抛出ThreadDeath异常</li>
<li>interrupt 调用该方法仅仅在线程中打一个标记，并不会立刻停止线程，本质<br>还是通过boolean标志来控制线程的结束。不过要注意，当调用Object类的wait方<br>法或者线程类的join sleep等方法时，如果当前线程已经中断（中断标志标记为<br>true）,调用以上那些方法时将会抛出一个InterruptedException 异常，同时<br>清除线程的中断标志</li>
</ol>
<ul>
<li>Thread.interrupt()，设置当前中断标记为true</li>
<li>Thread.isInterrupted()，检测当前的中断标记</li>
<li>Thread.interrupted()，检测当前的中断标记，然后重置中断标记为false<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Thread.currentThread().isInterrupted() == <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/*任务完成*/</span>) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// do something ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际可能发生的情况，以下是指点的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; Thread.currentThread().isInterrupted() == <span class="keyword">false</span>; </span><br><span class="line">            	i++) &#123;</span><br><span class="line">                <span class="comment">// 如果 i 大于 5 则设置当前线程中断标志为 true，</span></span><br><span class="line">                <span class="comment">// 在此之后 Thread.currentThread().isInterrupted() 方法返回 true</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"i: "</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 在抛出异常的时候会设置当前线程中断标志为 false，</span></span><br><span class="line">                <span class="comment">// 在此之后 Thread.currentThread().isInterrupted() 方法返回 false</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> ; <span class="comment">// 防止死循环，在捕货异常时直接返回结束 run 方法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h4><p>Thread提供了让一个线程等待另一个线程完成的方法–join。当在某个执行<br>流中调用其他线程的join方法时，调用线程将被阻塞，直到被join方法加入<br>的join线程执行完为止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> JoinThread(<span class="string">"新线程"</span>).start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				JoinThread jt=<span class="keyword">new</span> JoinThread(<span class="string">"被join的线程"</span>);</span><br><span class="line">				jt.start();</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 		在main线程的执行流中调用了join方法，所以</span></span><br><span class="line"><span class="comment">			 		main线程被停止，只有两个子线程在执行，当</span></span><br><span class="line"><span class="comment">			 		jt线程执行完后主线程才会继续执行，join方</span></span><br><span class="line"><span class="comment">			 		法也可以加时间参数，过了这个时间方法失效</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				jt.join();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>如果让当前正在执行的线程暂停一段时间，并进入阻塞状态，可是使用Thread<br>的静态方法sleep实现，可以指定一个时间参数，单位是毫秒。在暂停的时间<br>内，即便没有其他线程需要执行该线程也不会执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">			<span class="comment">//主线程暂停1s</span></span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>yield也是一个静态方法，可以让正在执行的线程暂停但是不会阻塞该线程，只<br>是将线程转入就绪状态，让系统线程调度器重新调度一次，很有可能该线程又<br>重新执行</p>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p>先参考深入JVM2中关于Java线程、工作内存和主内存的讲解</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>对于一个操作系统来说，如果一个操作在执行过程中一定不会被打断直到完成这个<br>操作，否则这个操作不会执行，那么这个操作就就有原子性。例如a=1具有原子性，<br>a++和a+=1不具有原子性，需要了解这些代码在JVM虚拟机中具体的指令情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a=a+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>编译.java文件，查看相应的字节码指令。add addd ad三个方法的字节码指令<br>都一样，说明 a++ a+=1 a=a+1 完全等效，set方法只有三条指令，先将常量<br>1 压入操作数栈顶，然后从操作数栈顶取出值写入内存常量池中的#2所在的变<br>量，这只需要一条指令putstatic，可以认为a=1是具有原子性的操作，而a++<br>有多条指令，比如执行了iadd后切换线程，将导致putstatic没有执行没有及<br>时更新a++的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;set #2在常量池中指示a</span><br><span class="line">iconst_1</span><br><span class="line">putstatic #2</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;add</span><br><span class="line">getstatic #2</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">putstatic #2</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;addd</span><br><span class="line">getstatic #2</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">putstatic #2</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ad</span><br><span class="line">getstatic #2</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">putstatic #2</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;get</span><br><span class="line">getstatic #2</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>接下来我用指点的例子分析一下 多次运行的结果 <img src="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/2.jpg" alt> <img src="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/3.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售卖火车票的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">10</span>; <span class="comment">// 10 张火车票</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了第 "</span> </span><br><span class="line">			+ tickets-- + <span class="string">" 张票"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 开启 5 个线程售票</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="string">"窗口"</span> + (i+<span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						sell();</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这些结果看起来没有逻辑，接下来分析一下内部的操作。首先肯定是从1开始创<br>建5个线程，线程1创建完成后休眠切换到线程2以此切换到线程5，线程5的sell<br>方法先执行，当打印的是9，说明线程1在完成ticke–之后线程进行了切换，并<br>且已经把更新的值由工作内存写回主内存，所以线程5拿到更新的值后执行sell<br>方法。第二个结果出现卖相同票的情况，线程3和线程2都是从主内存中拷贝相同<br>的ticket，因为线程3执行完sell方法后并未将更新的ticket值从工作内存写<br>回主内存，导致线程2拿到的依然是主内存中未更新的值</p>
<h3 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h3><p>线程的同步是指一个线程对内存进行操作时，其他线程都不可以对这个内存地址<br>进行操作，直到该线程完成操作，其他线程才可以对内存地址进行操作</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>之前的车票问题主要原因是sell方法不具有原子性，也就是需要同一时刻只有<br>一个线程能进入sell方法，当一个线程执行完sell方法其余线程才可以执行<br>sell方法。所以可以将sell方法加锁，有锁的时候别的线程只能等待该线程<br>执行完sell方法，执行完后就解锁别的线程就可以抢占执行sell</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>首先看一下API文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A reentrant mutual exclusion Lock with the same basic behavior and semantics </span><br><span class="line">as the implicit monitor lock accessed using synchronized methods and statements</span><br><span class="line">, but with extended capabilities.</span><br><span class="line">A ReentrantLock is owned by the thread last successfully locking, but not </span><br><span class="line">yet unlocking it.</span><br><span class="line">A thread invoking lock will return, successfully acquiring the lock, when </span><br><span class="line">the lock is not owned by another thread.</span><br><span class="line">The method will return immediately if the current thread already owns the lock.</span><br><span class="line">This can be checked using methods isHeldByCurrentThread(), and getHoldCount().</span><br></pre></td></tr></table></figure>
<p>ReentrantLock锁由上次成功锁定并且尚未解锁的线程拥有，是一个可重入且<br>独占式的锁。与synchronized关键字相比更加灵活强大，重入锁的意思就是<br>这种锁能反复进入，但是只限于一个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁定几个就要释放几个</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	lock.lock();	</span><br><span class="line">	lock.lock();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock.Sync sync;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> ReentrantLock.NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询当前锁对象是否被任意一个线程拥有</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询当前锁对象是否被当前执行代码的线程拥有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前执行代码的线程尝试获取锁，如果被其他线程获取，则等待其他线程解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与lock方法的区别在于获取失败则不会等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*当前线程获取锁对象，如果锁已经被其他线程获取则等待其他线程解锁</span></span><br><span class="line"><span class="comment">	保证同一时刻只有一个线程获取锁对象</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	takeLock.lock(); </span><br><span class="line">	<span class="keyword">try</span> &#123; </span><br><span class="line">     </span><br><span class="line">  	<span class="comment">// 业务逻辑 </span></span><br><span class="line">     </span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">  	<span class="comment">// 释放锁 </span></span><br><span class="line">  	takeLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来使用ReentrantLock实现抢车票同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">10</span>; <span class="comment">// 10 张火车票</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">/*注意这个地方一定要加if判断，可以把sleep方法去掉测试一下</span></span><br><span class="line"><span class="comment">			例如线程1进入sell方法，此时tickets是1，然后线程切换到线程2</span></span><br><span class="line"><span class="comment">			因为线程2从主内存中中读取的tickets依然是1，所以线程2通过</span></span><br><span class="line"><span class="comment">			while的判断，只不过目前无法进入sell方法，线程1又切回到sell</span></span><br><span class="line"><span class="comment">			方法执行完tickets为0时解锁，此时主内存已经更新为0，所以if判断</span></span><br><span class="line"><span class="comment">			就表示再次从主内存中读取tickets的值此时已经是0所以不会继续</span></span><br><span class="line"><span class="comment">			执行以下操作</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了第 "</span> </span><br><span class="line">			+ tickets-- + <span class="string">" 张票"</span>);</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 开启 5 个线程售票</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="string">"窗口"</span> + (i+<span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						sell();</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized同步机制"><a href="#synchronized同步机制" class="headerlink" title="synchronized同步机制"></a>synchronized同步机制</h4><p>synchronized可以修饰方法、代码块，但是不能修饰变量和构造器，默认实现锁<br>机制，（线程获取锁资源和线程释放锁资源），同步方法的同步监视器是this，<br>而this总代表调用该方法的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于实例方法锁住的是对象，对于静态方法锁住的是类</span></span><br><span class="line"><span class="comment">/*当线程执行到这里的时候会检查调用该方法的对象是否已经被锁住</span></span><br><span class="line"><span class="comment">如果被锁住则等待锁的释放</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//obj就表示当前对象</span></span><br><span class="line">	<span class="keyword">synchronized</span>(obj)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于如何理解锁对象我在网上找到了一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Human a=<span class="keyword">new</span> Human();</span><br><span class="line">        Human b=<span class="keyword">new</span> Human();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.drink();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.sleep();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">": *****eat*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"先执行drink"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">        	<span class="string">": *****drink*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"先执行sleep"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">        	<span class="string">": *****sleep*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上代码会发现输出如下，一开始保证线程A一定先执行，可是在drink中<br>线程中先会休眠10s，但是这时候线程B确没有开始执行，从这可以看出锁的是<br>同一个对象，两个synchronized方法必须有一个先执行完释放锁对象另一个<br>才可以执行。注意接下来的操作每一个都是独立的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先执行drink</span><br><span class="line">该线程B执行了</span><br><span class="line">A: *****drink*****</span><br><span class="line">先执行sleep</span><br><span class="line">B: *****sleep*****</span><br></pre></td></tr></table></figure>
<p>接下来将修饰sleep方法的synchronized关键字去掉，可以发现sleep先执行，<br>说明sleep方法不受锁影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先执行drink</span><br><span class="line">该线程B执行了</span><br><span class="line">先执行sleep</span><br><span class="line">B: *****sleep*****</span><br><span class="line">A: *****drink*****</span><br></pre></td></tr></table></figure>
<p>接下来将sleep方法用staitc修饰，使用static说明锁住的是类而不是对象，两<br>者没有任何关联不冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先执行drink</span><br><span class="line">该线程B执行了</span><br><span class="line">先执行sleep</span><br><span class="line">B: *****sleep*****</span><br><span class="line">A: *****drink*****</span><br></pre></td></tr></table></figure>
<p>接下来线程B用对象b调用sleep方法，a和b是两个对象，synchronized锁住的<br>是对象，不同对象不冲突</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先执行drink</span><br><span class="line">该线程B执行了</span><br><span class="line">先执行sleep</span><br><span class="line">B: *****sleep*****</span><br><span class="line">A: *****drink*****</span><br></pre></td></tr></table></figure>
<p>大家可以吧synchronized换成ReentrantLock，ReentrantLock是锁资源，多<br>个线程共同抢占一个锁资源，跟synchronized本质很像</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>当两个线程相互等待对方释放同步监视器就会导致死锁，死锁一旦发生就不会<br>产生任何异常或错误，只是所有线程处于阻塞状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">		Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		b.last();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">		Thread.sleep();</span><br><span class="line">		a.last();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	A a=<span class="keyword">new</span> A();</span><br><span class="line">	B b=<span class="keyword">new</span> B();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a.foo(b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		b.bar(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		C c=<span class="keyword">new</span> C();</span><br><span class="line">		<span class="keyword">new</span> Thread(c).start();</span><br><span class="line">		c.init();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如先进入主线程main，对象a获得锁，然后sleep切换到副线程，对象b加锁，<br>sleep切换到主线程，由于b已经被加锁所以无法执行b.last方法，线程阻塞<br>切换到副线程，sleep结束后由于a还未解锁所以无法执行a.last方法。<br>Object类提供了一些方法用于实现更精细的线程之间的同步控制，这些方法只<br>能在synchronized修饰的方法或代码块中使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*调用这个方法的线程释放对象锁并陷入无限等待，直到某个线程调用这个</span></span><br><span class="line"><span class="comment">对象的notify或notifyAll方法，线程被唤醒后就进入就绪状态，如果中断</span></span><br><span class="line"><span class="comment">标志为true会抛出IterruptException异常 */</span></span><br><span class="line">Ojbect.wait();</span><br><span class="line"><span class="comment">//唤醒一个调用对象的wait方法而陷入等待的线程，如果有多个线程都在等待，随机唤起一个</span></span><br><span class="line">Object.notify();</span><br><span class="line"><span class="comment">//唤醒所有调用对象的t的wait方法而陷入等待的线程</span></span><br><span class="line">Object.notiryAll();</span><br></pre></td></tr></table></figure>
<p>接下来用指点的例子分析一下以上方法的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 synchronized 和对象的 wait 方法、notifyAll 方法模拟银行账户转账</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] accountBalance; <span class="comment">// 每个账户的余额，为了简便，这里直接假设为 int 类型</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TransferTest</span><span class="params">(<span class="keyword">int</span>[] accountBalance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (accountBalance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 此处应做特殊处理</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 账户信息赋初值</span></span><br><span class="line">		<span class="keyword">this</span>.accountBalance = accountBalance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获得账户的总额</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span>  <span class="title">getAccountSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; accountBalance.length; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"账户"</span> + i + <span class="string">"余额："</span> + accountBalance[i]);</span><br><span class="line">			res += accountBalance[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 进行转账的同步方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fromIndex 转账方账户下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> toIndex 接受方账户下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> money 转账金额</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> </span></span></span><br><span class="line"><span class="function"><span class="params">		money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (money &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 此处应做特殊处理</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"账户"</span> + fromIndex + <span class="string">"想向"</span> + toIndex + <span class="string">"账户转账"</span> </span><br><span class="line">			+ money + <span class="string">"元"</span>);</span><br><span class="line">		<span class="comment">/* 如果转账方账户余额不足，那么调用当前对象的 </span></span><br><span class="line"><span class="comment">		wait 方法使得当前线程释放对象锁陷入无限等待，</span></span><br><span class="line"><span class="comment">		直到其它线程调用了 notify 或者 notifyAll 方法，*/</span></span><br><span class="line">		<span class="keyword">while</span> (accountBalance[fromIndex] &lt; money) &#123;</span><br><span class="line">			System.out.println(<span class="string">"账户余额不足，无法转账！"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 账户余额变更</span></span><br><span class="line">		accountBalance[fromIndex] -= money;</span><br><span class="line">		accountBalance[toIndex] += money;</span><br><span class="line">		System.out.println(<span class="string">"转账成功"</span>);</span><br><span class="line">		notifyAll(); <span class="comment">// 唤醒所有因调用了当前对象的 wait 方法而陷入等待的线程</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">// 转账方、接收方、转账金额</span></span><br><span class="line">					<span class="keyword">int</span> fromAccount;</span><br><span class="line">					<span class="keyword">int</span> toAccount;</span><br><span class="line">					<span class="keyword">int</span> money;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">						fromAccount = random.nextInt(accountBalance.length);</span><br><span class="line">						toAccount = random.nextInt(accountBalance.length);</span><br><span class="line">						<span class="keyword">if</span> (fromAccount == toAccount) &#123;</span><br><span class="line">							j--;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						money = random.nextInt(<span class="number">500</span>);</span><br><span class="line">						transfer(fromAccount, toAccount, money);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	TransferTest test = <span class="keyword">new</span> TransferTest(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, </span><br><span class="line">		<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;);</span><br><span class="line">	test.startTransfer();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"当前账户总余额： "</span> + test.getAccountSum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>ReentrantLock类中提供了一个方法newCondition()来获取Condition实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">	<span class="comment">//与Object的wait方法相同，直到其他线程调用Condition的signal或signalAll</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date var1)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/*唤醒在Lock对象上等待的线程，如果所有线程都在该Lock对象上等待，</span></span><br><span class="line"><span class="comment">     则会选择唤醒其中一个线程</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//唤醒所有等待的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这些方法需要在获取ReentrantLock锁资源的情况下才能使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 ReentrantLock 类和 Condition 类模拟银行账户转账</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTest2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] accountBalance; <span class="comment">// 每个账户的余额，为了简便，这里直接假设为 int 类型</span></span><br><span class="line">	</span><br><span class="line">	ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 创建锁对象</span></span><br><span class="line">	Condition con = lock.newCondition();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TransferTest2</span><span class="params">(<span class="keyword">int</span>[] accountBalance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (accountBalance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 此处应做特殊处理</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 账户信息赋初值</span></span><br><span class="line">		<span class="keyword">this</span>.accountBalance = accountBalance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获得账户的总额</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span>  <span class="title">getAccountSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; accountBalance.length; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"账户"</span> + i + <span class="string">"余额："</span> + accountBalance[i]);</span><br><span class="line">			res += accountBalance[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 进行转账的同步方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fromIndex 转账方账户下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> toIndex 接受方账户下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> money 转账金额</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 当前线程尝试获取锁资源</span></span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (money &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 此处应做特殊处理</span></span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"账户"</span> + fromIndex + <span class="string">"想向"</span> + toIndex + </span><br><span class="line">				<span class="string">"账户转账"</span> + money + <span class="string">"元"</span>);</span><br><span class="line">			<span class="comment">/* 如果转账方账户余额不足，那么调用 con 对象的 </span></span><br><span class="line"><span class="comment">			await 方法使得当前线程释放对象锁陷入无限等待，</span></span><br><span class="line"><span class="comment">			 直到其它线程调用了 con 对象的 signal 或者 signalAll 方法，*/</span></span><br><span class="line">			<span class="keyword">while</span> (accountBalance[fromIndex] &lt; money) &#123;</span><br><span class="line">				System.out.println(<span class="string">"账户余额不足，无法转账！"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					con.await();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 账户余额变更</span></span><br><span class="line">			accountBalance[fromIndex] -= money;</span><br><span class="line">			accountBalance[toIndex] += money;</span><br><span class="line">			System.out.println(<span class="string">"转账成功"</span>);</span><br><span class="line">			con.signalAll(); </span><br><span class="line">			<span class="comment">// 唤醒所有因调用了 con 对象的 await 方法而陷入等待的线程</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock(); <span class="comment">// 当前线程释放锁资源</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="comment">// 转账方、接收方、转账金额</span></span><br><span class="line">					<span class="keyword">int</span> fromAccount;</span><br><span class="line">					<span class="keyword">int</span> toAccount;</span><br><span class="line">					<span class="keyword">int</span> money;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">						fromAccount = random.nextInt(accountBalance.length);</span><br><span class="line">						toAccount = random.nextInt(accountBalance.length);</span><br><span class="line">						<span class="keyword">if</span> (fromAccount == toAccount) &#123;</span><br><span class="line">							j--;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						money = random.nextInt(<span class="number">500</span>);</span><br><span class="line">						transfer(fromAccount, toAccount, money);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	TransferTest2 test = <span class="keyword">new</span> TransferTest2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, </span><br><span class="line">		<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;);</span><br><span class="line">	test.startTransfer();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"当前账户总余额： "</span> + test.getAccountSum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h4><p>ReentrantLock比synchronized更加灵活，必须手动加锁解锁，而灵活之处<br>在于ReentrantLock有一个tryLock方法，这个方法也会尝试获取锁，但是<br>获取失败也不会阻塞，而是直接返回锁的结果，这样就可以在线程获取锁资<br>源失败的时候让这个线程做别的事而不是一直等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果在参数给定的时间内成功获取锁资源，那么执行相关任务</span></span><br><span class="line"><span class="keyword">if</span> (lock.tryLock() || lock.tryLock(time, unit)) &#123;</span><br><span class="line">	<span class="comment">// do something...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>用volatile修饰的变量，在线程中被修改后会立刻同步到主内存中，保证在任<br>意时刻，某个线程从主内存获取的值是最新的，之前在深入JVM2中分析了不能<br>实现同步，这里就不再解释了。volatile的另一个作用就是防止指令重排序，<br>指令重排序就是在Java编译期间编译器可能基于优化程序的目的对目的代码<br>中翻译成的机器指令进行重排序，线程内表现为串行（多个任务，一个接着<br>一个执行）的语义，在多线程的环境下指令重排可能导致错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处变量要用 volatile 关键字修饰，避免因指令重排序导致错误</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> isInitialized = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方法在线程 A 中执行，在里面进行程序初始化的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 进行初始化操作 ......、</span></span><br><span class="line">	</span><br><span class="line">	isInitialized = <span class="keyword">true</span>; </span><br><span class="line">	<span class="comment">// 初始化完成之后设置初始化完成标志为 true，即表示程序初始化完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方法在线程 B 执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!isInitialized) &#123;</span><br><span class="line">		sleep(); <span class="comment">// 继续等待初始化完成</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化完成之后开始执行任务</span></span><br><span class="line">	executeTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用volatile修饰可能导致isInitialized=true在初始化之前被调<br>用</p>
<h4 id="DCL优化"><a href="#DCL优化" class="headerlink" title="DCL优化"></a>DCL优化</h4><p>DCL Double-Check-Lock 是单例模式的一种实现 <img src="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/4.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (SingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">					singleTon = <span class="keyword">new</span> SingleTon();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleTon;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个Singleton包含三个字节码指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new &#x2F;&#x2F; 为新建的对象分配内存空间，并将地址压入操作数栈顶</span><br><span class="line">dup &#x2F;&#x2F; 复制操作数栈顶值，并将其压入栈顶</span><br><span class="line">invokespecial &#x2F;&#x2F; 调用实例初始化方法&lt;init&gt;:()，初始化对象</span><br></pre></td></tr></table></figure>
<p>然后putstatic指令将创建的对象赋值给静态引用singleTon，这时singleTon<br>就不为 null ，如果不加 volatile 则可能导致指令重排序， putstatic  在<br>invokespecial之前执行，然后立即切换线程，这时线程获取的singleTon已经<br>不为null，但是此时还未执行初始化操作，可能导致返回的对象有异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new &#x2F;&#x2F; 为新建的对象分配内存空间，并将地址压入操作数栈顶</span><br><span class="line">dup &#x2F;&#x2F; 复制操作数栈顶值，并将其压入栈顶</span><br><span class="line">putstatic &#x2F;&#x2F; 将静态引用 singleTon 指向新建的对象</span><br><span class="line">invokespecial &#x2F;&#x2F; 调用实例初始化方法&lt;init&gt;:()，初始化对象</span><br></pre></td></tr></table></figure>
<p>如果加上volatile就会禁止指令重排序</p>
<h4 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h4><p>JDK5中引入了AtomicInteger AtomicLong AtomicReference等特殊的原子类<br>保证使用这些类时可以不主动加入额外的同步手段来保证程序的正确性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AtomicInteger 类的使用，AtomicInteger 类本身对其中的一些操作提供了多线程程序的同步控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger value = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value.get();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 数字递增方法，每次把 value 的值递增 2 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evevIncreament</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		value.addAndGet(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 新建 10 个子线程用于进行累加操作</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">						evevIncreament();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 主线程不断取 value 的值，如果是奇数，那么打印并退出程序</span></span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			value = getValue();</span><br><span class="line">			<span class="keyword">if</span> (value % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(value);</span><br><span class="line">				System.exit(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	AtomicIntegerTest.startTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是可以使线程陷入阻塞状态的存储队列。JDK5提供了一个BlockingQueue<br>接口，这个接口是Queue的子接口，不是用于存储而是用做线程同步的工具，该<br>接口具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果<br>该队列已满，则该线程被阻塞。当消费者线程从BlockingQueue中取出元素时<br>如果该队列为空则线程被阻塞，程序的两个线程通过交替向BlockingQueue<br>中放入元素、取出元素可以很好地控制线程的通信 <img src="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/5.jpg" alt><br>BlockingQueue提供了两个支持阻塞的方法 <img src="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/6.jpg" alt></p>
<ul>
<li>put(E e) 将元素e放入队列中，如果队列中元素已满则阻塞生产者线程</li>
<li>take() 从队列头部取出元素，如果队列为空则阻塞消费者线程</li>
</ul>
<h4 id="自定义阻塞队列"><a href="#自定义阻塞队列" class="headerlink" title="自定义阻塞队列"></a>自定义阻塞队列</h4><p>指点是真的强</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义阻塞队列实现生产者、消费者模式：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义的阻塞队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object[] elements = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 当前元素个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> elementsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 阻塞队列的锁资源</span></span><br><span class="line">        <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 队列已满的线程阻塞控制器</span></span><br><span class="line">        Condition fullLock = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 队列为空的线程阻塞控制</span></span><br><span class="line">        Condition emptyLock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomBlockingQueue</span><span class="params">(<span class="keyword">int</span> elementsCount)</span> </span>&#123;</span><br><span class="line">            elements = <span class="keyword">new</span> Object[elementsCount];</span><br><span class="line">            fullLock = lock.newCondition();</span><br><span class="line">            emptyLock = lock.newCondition();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 向队列末尾插入新元素的方法，如果队列元素已满，那么阻塞当前线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T ele)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ele == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"插入元素不能为空！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 构造同步块</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果当前队列已满，那么阻塞当前生产者线程</span></span><br><span class="line">                    <span class="keyword">while</span> (elementsCount == elements.length) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"队列已满，元素插入失败，线程被阻塞！"</span>);</span><br><span class="line">                        fullLock.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将元素插入队列末尾</span></span><br><span class="line">                    elements[elementsCount++] = ele;</span><br><span class="line">                    <span class="comment">// 队列中已经有元素，唤醒所有阻塞的消费者线程</span></span><br><span class="line">                    emptyLock.signalAll();</span><br><span class="line">                    System.out.println(<span class="string">"插入元素，当前队列元素数量："</span> </span><br><span class="line">                    	+ elementsCount);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从阻塞队列中取出元素的方法，如果队列中没有元素，那么阻塞当前线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="comment">// 构造同步块</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前队列已空，那么阻塞当前消费者线程</span></span><br><span class="line">                <span class="keyword">while</span> (elementsCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"队列已空，元素取出失败，线程被阻塞！"</span>);</span><br><span class="line">                    emptyLock.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 队列中已经有剩余空间，唤醒所有阻塞的生产者线程</span></span><br><span class="line">                fullLock.signalAll();</span><br><span class="line">                T ele = (T) elements[--elementsCount];</span><br><span class="line">                System.out.println(<span class="string">"取出元素，当前队列元素数量："</span> + </span><br><span class="line">                	elementsCount);</span><br><span class="line">                <span class="comment">// 将队列中元素的引用置为 null，有利于 GC 回收这个对象</span></span><br><span class="line">                elements[elementsCount] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> ele;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟产品的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String productName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.productName = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录产品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> productCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个容量为 5 的自定义阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CustomBlockingQueue&lt;Product&gt; queue = </span><br><span class="line">            <span class="keyword">new</span> CustomBlockingQueue&lt;Product&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建生产者线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread productThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Product pro = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pro = <span class="keyword">new</span> Product(<span class="string">"产品"</span> + (++productCount));</span><br><span class="line">                    queue.put(pro);</span><br><span class="line">                    System.out.println(pro.productName + <span class="string">" 存入成功！"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建消费者线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread customThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Product pro = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pro = queue.take();</span><br><span class="line">                    <span class="keyword">if</span> (pro != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(pro.productName + <span class="string">" 取出成功！"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        productThread.start();</span><br><span class="line">        customThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h4><p><img src="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/7.jpg" alt> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">数组构成的有界阻塞队列，即储存元素的数据结构是数组，按照先进先出的顺序</span><br><span class="line">对元素排序，创建时需要指定队列的最大容量，默认情况不保证线程公平的访问</span><br><span class="line">原则，公平即先被阻塞的线程在唤醒后先获得锁资源继续未完成的操作</span><br><span class="line">ArrayBlockingQueue queue &#x3D; new ArrayBlockingQueue(1000, true); </span><br><span class="line"></span><br><span class="line">链表构成的有界阻塞队列，即储存元素的数据结构是链表，有一个特点是对于</span><br><span class="line">生产者和消费者分别用两个锁资源来控制生产者线程和消费者线程，即允许生</span><br><span class="line">产者线程和消费者线程在同一时刻对队列进行操作</span><br><span class="line">LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">支持按某个优先级对元素进行排序的无界阻塞队列，默认情况下使用升序排序，</span><br><span class="line">通过自定义compareTo方法实现元素自定义排序，或者创建队列的时候传入</span><br><span class="line">参数Compare来对元素排序</span><br><span class="line">PriorityBlockingQueue</span><br><span class="line"></span><br><span class="line">使用优先队列实现的无界阻塞队列，存储的元素必须实现Delay接口，按照</span><br><span class="line">getDelay方法的返回值进行排序</span><br><span class="line">DelayQueue</span><br><span class="line"></span><br><span class="line">不储存元素的阻塞队列，每个生产者线程必须等待另一个消费者线程的执行，</span><br><span class="line">每个消费者个线程必须等待另一个生产者线程的执行，因此队列中没有元素</span><br><span class="line">SynchronousQueue</span><br><span class="line"></span><br><span class="line">由链表组成的无界阻塞队列</span><br><span class="line">LinkedTransferQueue </span><br><span class="line"></span><br><span class="line">由链表构成的双向阻塞队列</span><br><span class="line">LinkedBlockingDeque</span><br></pre></td></tr></table></figure>
<p>刚刚提到ArrayBlockingQueue时有一个公平原则，注意notify调用后锁对象<br>依然由调用notify的那个线程持有，原先被阻塞的线程必须等到锁对象释放才<br>可以抢占锁资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">wa</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"开始等待"</span>);</span><br><span class="line">            wait();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"等待结束"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ov</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"准备唤起"</span>);</span><br><span class="line">            notify();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"唤起线程"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+</span><br><span class="line">            	<span class="string">"唤起后wa执行了吗"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                wa();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                ov();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"线程2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleTon a=<span class="keyword">new</span> SingleTon();</span><br><span class="line">        a.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程1开始等待</span><br><span class="line">线程2准备唤起</span><br><span class="line">线程2唤起线程</span><br><span class="line">线程2唤起后wa执行了吗</span><br><span class="line">线程1等待结束</span><br></pre></td></tr></table></figure>

<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>接下来分析一下ArrayBlockingQueue的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//存储元素的数组</span></span><br><span class="line">	<span class="keyword">final</span> Object[] items;</span><br><span class="line">	<span class="comment">//取下标</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="comment">//存下标</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">//控制消费者线程唤起和阻塞</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">//控制生产者线程唤起和阻塞</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    	<span class="comment">//先检查与元素是否为空</span></span><br><span class="line">        Objects.requireNonNull(e);</span><br><span class="line">        ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//如果当前线程为中断则获取该锁</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">this</span>.count == <span class="keyword">this</span>.items.length) &#123;</span><br><span class="line">                <span class="keyword">this</span>.notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.enqueue(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        items[<span class="keyword">this</span>.putIndex] = e;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.putIndex == items.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.putIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++<span class="keyword">this</span>.count;</span><br><span class="line">        <span class="comment">//插入操作一定保证数组是有元素的，这时唤起消费者线程</span></span><br><span class="line">        <span class="keyword">this</span>.notEmpty.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        Object var2;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">this</span>.count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            var2 = <span class="keyword">this</span>.dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        E e = items[<span class="keyword">this</span>.takeIndex];</span><br><span class="line">        items[<span class="keyword">this</span>.takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.takeIndex == items.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.takeIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --<span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.itrs.elementDequeued();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出操作保证数组一定不会满，唤醒生产者线程</span></span><br><span class="line">        <span class="keyword">this</span>.notFull.signal();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>接下来使用ArrayBlockingQueue来实现消费者和生产者线程，用了一下指定<br>的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayBlockingQueue 类的使用，使用 ArrayBlockingQueue 实现生产者、消费者问题：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> productCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 模拟产品的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String productName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.productName = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个容量为 5 的公平阻塞队列，</span></span><br><span class="line">    <span class="comment">// 公平即为先被阻塞的线程在被唤醒后可以先得到锁资源继续上次未完成的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Product&gt; queue = <span class="keyword">new</span> </span><br><span class="line">    ArrayBlockingQueue&lt;Product&gt;(<span class="number">5</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 创建生产者线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread productThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Product pro = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pro = <span class="keyword">new</span> Product(<span class="string">"产品"</span> + (++productCount));</span><br><span class="line">                    <span class="comment">// 插入元素到队尾</span></span><br><span class="line">                    queue.put(pro);</span><br><span class="line">                    System.out.println(pro.productName + <span class="string">" 存入成功！"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建消费者线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread customThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Product pro = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 取出队头元素</span></span><br><span class="line">                    pro = queue.take();</span><br><span class="line">                    <span class="keyword">if</span> (pro != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(pro.productName + <span class="string">" 取出成功！"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        productThread.start();</span><br><span class="line">        customThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CustomBlockingQueueTest.startTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/">https://skysea-gaoming.github.io/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/30/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863/"><i class="fa fa-chevron-left">  </i><span>Java基础知识3</span></a></div><div class="next-post pull-right"><a href="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/"><span>深入JVM2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/';
  this.page.identifier = '2020/10/17/Java基础知识2/';
  this.page.title = 'Java基础知识2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1605784321698&amp;di=835f40a2b6d3b20d5d4c32b6ae74423d&amp;imgtype=0&amp;src=http%3A%2F%2Ft9.baidu.com%2Fit%2Fu%3D390739009%2C2408580797%26fm%3D193)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>