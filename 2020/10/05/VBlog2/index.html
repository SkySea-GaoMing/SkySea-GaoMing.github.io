<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="VBlog2"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>VBlog2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RBAC"><span class="toc-number">1.1.</span> <span class="toc-text">RBAC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RBAC的组成"><span class="toc-number">1.1.1.</span> <span class="toc-text">RBAC的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安全原则"><span class="toc-number">1.1.2.</span> <span class="toc-text">安全原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RBAC的功能模块"><span class="toc-number">1.1.3.</span> <span class="toc-text">RBAC的功能模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RBAC的执行流程"><span class="toc-number">1.1.4.</span> <span class="toc-text">RBAC的执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Shiro实现用户信息加密与登录认证"><span class="toc-number">1.2.</span> <span class="toc-text">使用Shiro实现用户信息加密与登录认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用户信息加密"><span class="toc-number">1.2.1.</span> <span class="toc-text">用户信息加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加盐加密"><span class="toc-number">1.2.2.</span> <span class="toc-text">加盐加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#核心代码"><span class="toc-number">1.2.3.</span> <span class="toc-text">核心代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Shiro认证登录"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用Shiro认证登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shiro的核心概念"><span class="toc-number">1.2.5.</span> <span class="toc-text">Shiro的核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shiro配置与登录验证"><span class="toc-number">1.2.6.</span> <span class="toc-text">Shiro配置与登录验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户认证方案与完善的访问拦截"><span class="toc-number">1.3.</span> <span class="toc-text">用户认证方案与完善的访问拦截</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#登出功能开发"><span class="toc-number">1.3.1.</span> <span class="toc-text">登出功能开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完善的访问拦截"><span class="toc-number">1.3.2.</span> <span class="toc-text">完善的访问拦截</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#认证方案"><span class="toc-number">1.3.3.</span> <span class="toc-text">认证方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session"><span class="toc-number">1.3.4.</span> <span class="toc-text">session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#token"><span class="toc-number">1.3.5.</span> <span class="toc-text">token</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端存储方案"><span class="toc-number">1.3.6.</span> <span class="toc-text">客户端存储方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后端登录拦截"><span class="toc-number">1.3.7.</span> <span class="toc-text">后端登录拦截</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前端配置"><span class="toc-number">1.3.8.</span> <span class="toc-text">前端配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rememberMe"><span class="toc-number">1.3.9.</span> <span class="toc-text">rememberMe</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态加载后台菜单"><span class="toc-number">1.4.</span> <span class="toc-text">动态加载后台菜单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#后端实现"><span class="toc-number">1.4.1.</span> <span class="toc-text">后端实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表的设计"><span class="toc-number">1.4.2.</span> <span class="toc-text">表的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pojo"><span class="toc-number">1.4.3.</span> <span class="toc-text">pojo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#菜单查询接口（树查询结构）"><span class="toc-number">1.4.4.</span> <span class="toc-text">菜单查询接口（树查询结构）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前端实现"><span class="toc-number">1.4.5.</span> <span class="toc-text">前端实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后台页面设计"><span class="toc-number">1.4.6.</span> <span class="toc-text">后台页面设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据处理"><span class="toc-number">1.4.7.</span> <span class="toc-text">数据处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#添加路由与渲染菜单"><span class="toc-number">1.4.8.</span> <span class="toc-text">添加路由与渲染菜单</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#功能级访问控制的实现"><span class="toc-number">1.5.</span> <span class="toc-text">功能级访问控制的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库与后端准备"><span class="toc-number">1.5.1.</span> <span class="toc-text">数据库与后端准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service"><span class="toc-number">1.5.2.</span> <span class="toc-text">Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shiro实现"><span class="toc-number">1.5.3.</span> <span class="toc-text">Shiro实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编写基于URL的过滤器"><span class="toc-number">1.5.4.</span> <span class="toc-text">编写基于URL的过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#授权操作"><span class="toc-number">1.5.5.</span> <span class="toc-text">授权操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后台角色、权限与菜单分配"><span class="toc-number">1.6.</span> <span class="toc-text">后台角色、权限与菜单分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#角色、权限分配"><span class="toc-number">1.6.1.</span> <span class="toc-text">角色、权限分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用户信息表与行数据获取"><span class="toc-number">1.6.2.</span> <span class="toc-text">用户信息表与行数据获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#角色分配"><span class="toc-number">1.6.3.</span> <span class="toc-text">角色分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#博客功能开发"><span class="toc-number">1.7.</span> <span class="toc-text">博客功能开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mavon-editor-编辑器"><span class="toc-number">1.7.1.</span> <span class="toc-text">mavon-editor 编辑器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#功能设计"><span class="toc-number">1.7.2.</span> <span class="toc-text">功能设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文章列表"><span class="toc-number">1.7.3.</span> <span class="toc-text">文章列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文章详情"><span class="toc-number">1.7.4.</span> <span class="toc-text">文章详情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文章管理"><span class="toc-number">1.7.5.</span> <span class="toc-text">文章管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编辑器"><span class="toc-number">1.7.6.</span> <span class="toc-text">编辑器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库设计"><span class="toc-number">1.7.7.</span> <span class="toc-text">数据库设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编辑器的引入与改造"><span class="toc-number">1.7.8.</span> <span class="toc-text">编辑器的引入与改造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后端"><span class="toc-number">1.7.9.</span> <span class="toc-text">后端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文章列表页面"><span class="toc-number">1.7.10.</span> <span class="toc-text">文章列表页面</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">VBlog2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/10/05/VBlog2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/10/05/VBlog2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>承接我的上一篇博客VBlog。在这里感谢 Evan-Nightly的教程<br><a href="https://learner.blog.csdn.net/article/details/88925013" target="_blank" rel="noopener">https://learner.blog.csdn.net/article/details/88925013</a><br><a href="https://github.com/Antabot/White-Jotter" target="_blank" rel="noopener">https://github.com/Antabot/White-Jotter</a></p>
<h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>参考 <a href="https://shuwoom.com" target="_blank" rel="noopener">https://shuwoom.com</a><br>RBAC模型 Role-Based Access Control: 基于角色的访问控制模型。RBAC<br>认为授权过程可以抽象概括为：Who可以对What进行How的操作，并对这个逻<br>辑表达式判断是否为true的求解过程</p>
<h4 id="RBAC的组成"><a href="#RBAC的组成" class="headerlink" title="RBAC的组成"></a>RBAC的组成</h4><p>三部分：用户、角色和权限。通过定义角色的权限，并对用户授予某个角色来<br>控制用户的权限，实现了用户和权限的逻辑分离，极大方便权限的管理。以<br>下是一些常见名词</p>
<ul>
<li>User 每个用户都有一个唯一的UID识别，并授予不同的角色</li>
<li>Role 不同的角色具有不同的权限</li>
<li>Permission 访问权限</li>
<li>用户-角色映射 用户和角色之间的映射关系</li>
<li>角色-权限映射 角色和权限之间的映射</li>
</ul>
<p><img src="/2020/10/05/VBlog2/20.jpg" alt><br>管理员和普通用户被授予不同的权限，普通用户只能去修改和查看个人信息，<br>而不能创建用户和冻结用户，而管理员被授予所有权限，所以可以做任何操<br>作 <img src="/2020/10/05/VBlog2/21.jpg" alt></p>
<h4 id="安全原则"><a href="#安全原则" class="headerlink" title="安全原则"></a>安全原则</h4><p>RBAC支持三个安全原则：最小权限原则、责任分离原则和数据抽象原则</p>
<ul>
<li>最小权限原则 RBAC可以将角色配置成其完成任务所需的最小权限集合</li>
<li>责任分离原则 可以通过调用相互独立互斥的角色共同完成敏感任务，例<br>如要求一个记账员和财务管理员共同参与同一过账操作</li>
<li>数据抽象原则 可以通过权限的抽象来体现，例如财务操作用借款、存款<br>等抽象权限，而不是使用典型的读、写、执行权限</li>
</ul>
<h4 id="RBAC的功能模块"><a href="#RBAC的功能模块" class="headerlink" title="RBAC的功能模块"></a>RBAC的功能模块</h4><p><img src="/2020/10/05/VBlog2/22.jpg" alt></p>
<h4 id="RBAC的执行流程"><a href="#RBAC的执行流程" class="headerlink" title="RBAC的执行流程"></a>RBAC的执行流程</h4><p><img src="/2020/10/05/VBlog2/23.jpg" alt></p>
<h3 id="使用Shiro实现用户信息加密与登录认证"><a href="#使用Shiro实现用户信息加密与登录认证" class="headerlink" title="使用Shiro实现用户信息加密与登录认证"></a>使用Shiro实现用户信息加密与登录认证</h3><p>这一部分主要是两方面的内容</p>
<ul>
<li>用户信息加密思路</li>
<li>使用Shiro完成加密与认证功能</li>
</ul>
<h4 id="用户信息加密"><a href="#用户信息加密" class="headerlink" title="用户信息加密"></a>用户信息加密</h4><p>我们之前的用户信息都是明文存储在数据库中的，这样有三大弊端</p>
<ol>
<li>不安全 很多应用脱库后用户密码全网流传</li>
<li>用户也不希望我们知道他们的密码，我上不了你的号，但是我知道你的号<br>在干什么</li>
<li>如果用户在各个应用使用相同的密码，一个地方密码被盗则一连串被盗</li>
</ol>
<p>所以我们要对用户信息进行加密，主要是用于验证的敏感信息，比如密码，<br>而且这种加密最好是不可逆的，明文密码只有用户知道</p>
<h4 id="加盐加密"><a href="#加盐加密" class="headerlink" title="加盐加密"></a>加盐加密</h4><p>关于Hash算法可以参考我之前的博客。加盐是提高Hash算法安全性的一个常用<br>手段，本质是在密码后面加一段随机的字符串，然后再hash</p>
<ol>
<li>用户注册时，输入用户名密码，向后台发送请求</li>
<li>后台将密码加上随机生成的盐并hash，再将hash后的值存入数据库中，盐<br>也作为单独的字段存起来</li>
<li>用户登录时输入用户名密码，向后台发送请求，每个用户都有一个自己的盐</li>
<li>后台根据用户名查询出盐，和密码组合并hash，将得到的值和数据库中存<br>储的密码比对，若一致则通过验证</li>
</ol>
<p>加盐为什么能够提高安全性？一个hash值可以对应无数个输入，如果不加盐找<br>到一个和明文密码hash结果相同的输入相对容易，但是在有盐的情况下如果不<br>知道盐想要找到明文密码就很难了。如果有人能够拿到以hash值存储的密码，<br>也是有可能拿到盐，但是不同的用户盐不同，即时很多用户使用相同的密码，<br>存储在数据库的hash值也不同，在加盐的基础上，我们还可以设置hash的迭<br>代次数，进一步加大破解难度</p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><p>首先在数据库的user表中添加salt字段，并相应在user类中添加salt属性与<br>get set方法。现在先在result类中创建ResultFactory类，具体代码可以<br>看Evan的源码，然后开发register方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"api/register"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(@RequestBody User requestUser)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String username=requestUser.getUsername();</span><br><span class="line">        String password=requestUser.getPassword();</span><br><span class="line">        username = HtmlUtils.htmlEscape(username);</span><br><span class="line">        requestUser.setUsername(username);</span><br><span class="line">        <span class="comment">//这里判断是否已经注册过这个用户名</span></span><br><span class="line">        <span class="keyword">boolean</span> exist=userservice.isExist(username);</span><br><span class="line">        <span class="keyword">if</span>(exist)</span><br><span class="line">        &#123;</span><br><span class="line">            String message=<span class="string">"用户名已被使用"</span>;</span><br><span class="line">            <span class="comment">//400</span></span><br><span class="line">            <span class="keyword">return</span> ResultFactory.buildFailResult(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成盐，默认长度是16位。生成随机的byte数组，又转换为base64编码并返回</span></span><br><span class="line">        String salt = <span class="keyword">new</span> SecureRandomNumberGenerator().nextBytes().toString();</span><br><span class="line">        <span class="comment">//设置hash算法迭代次数</span></span><br><span class="line">        <span class="keyword">int</span> times=<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//得到hash后的密码</span></span><br><span class="line">        String encodePassword=<span class="keyword">new</span> SimpleHash(<span class="string">"md5"</span>,password,salt,times).</span><br><span class="line">        toString();</span><br><span class="line">        <span class="comment">//存储用户信息，包括salt和hash后的密码</span></span><br><span class="line">        requestUser.setSalt(salt);</span><br><span class="line">        requestUser.setPassword(encodePassword);</span><br><span class="line">        <span class="comment">//存储用户信息</span></span><br><span class="line">        userservice.add(requestUser);</span><br><span class="line">        <span class="comment">//将数据返回</span></span><br><span class="line">        <span class="keyword">return</span> ResultFactory.buildSuccessResult(requestUser);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为了实现注册，前端再写一个注册页面，可以和登录页面保持风格统一，创建<br>Register.vue，代码放在ElementUi中的Register</p>
<h4 id="使用Shiro认证登录"><a href="#使用Shiro认证登录" class="headerlink" title="使用Shiro认证登录"></a>使用Shiro认证登录</h4><p>之前的登录方式就是简单粗暴地使用明文对比的方式进行验证，使用Shiro后<br>一切都会改变。接下来就应该修改登录操作，注册操作会增加用户，登录操作<br>时验证用户</p>
<h4 id="Shiro的核心概念"><a href="#Shiro的核心概念" class="headerlink" title="Shiro的核心概念"></a>Shiro的核心概念</h4><p>关于Shiro有三个基本的核心概念：Subject、SecurityManager和Realms</p>
<ul>
<li>Subject 现在在于软件交互的东西，这个东西可能是你我他，负责存储与修改<br>当前用户的信息和状态，使用Shiro实现我们设计的各种功能，实际就是在调用<br>Subject的API</li>
<li>SecurityManager 管理所有的Subject，只需要配置一次即可</li>
<li>Realm 是Shiro和安全数据之间的桥梁，也就是说Realm负责从数据源中获取<br>数据并加工后传给SecurityManager</li>
</ul>
<p>Shiro还有四大功能：Authentication（认证）、Authorization（授权）、<br>Session Management（会话管理）、Cryptography（加密）</p>
<h4 id="Shiro配置与登录验证"><a href="#Shiro配置与登录验证" class="headerlink" title="Shiro配置与登录验证"></a>Shiro配置与登录验证</h4><p>首先添加maven依赖，可以参考我的SpringBoot博客，配置的顺序如下</p>
<ul>
<li>创建Realm并重写获取认证与授权信息的方法</li>
<li>创建配置类，包括创建并配置 SecurityManager 等</li>
</ul>
<p>新建realm包，创建WJRealm类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WJRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Userservice userservice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单重写获取授权信息方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    	PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        SimpleAuthorizationInfo s = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取认证信息，即根据token中的用户名从数据库中获取密码、盐等并返回</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    	AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    	<span class="comment">//principal就是主体的标识属性，比如用户名邮箱等</span></span><br><span class="line">        String userName = token.getPrincipal().toString();</span><br><span class="line">        <span class="comment">//在数据库中查询是否存在该用户</span></span><br><span class="line">        User user = userservice.getByName(userName);</span><br><span class="line">        <span class="comment">//如果存在该用户则查询出正确的密码</span></span><br><span class="line">        String passwordInDB = user.getPassword();</span><br><span class="line">        <span class="comment">//获取该用户相应的盐</span></span><br><span class="line">        String salt = user.getSalt();</span><br><span class="line">        <span class="comment">//接下来Shiro内部帮我们验证密码是否正确</span></span><br><span class="line">        SimpleAuthenticationInfo authenticationInfo = </span><br><span class="line">        <span class="keyword">new</span> SimpleAuthenticationInfo(userName, passwordInDB, </span><br><span class="line">        	ByteSource.Util.bytes(salt), getName());</span><br><span class="line">        <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleAuthenticationInfo中的salt非得存储成byte[]，不过这里的byte[]<br>并不是我们当初随机生成的那个，而是随机生成的byte[]按base64<br>编码成String又按UTF-8编码成的byte[]</p>
<p>接下来分析一下登录验证的过程，首先编写一个shiro的配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor <span class="title">getLifecycleBeanProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = </span><br><span class="line">        	<span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = </span><br><span class="line">        	<span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        securityManager.setRealm(getWJRealm());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WJRealm <span class="title">getWJRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WJRealm wjRealm = <span class="keyword">new</span> WJRealm();</span><br><span class="line">        wjRealm.setCredentialsMatcher(hashedCredentialsMatcher());</span><br><span class="line">        <span class="keyword">return</span> wjRealm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashedCredentialsMatcher <span class="title">hashedCredentialsMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashedCredentialsMatcher hashedCredentialsMatcher = </span><br><span class="line">        	<span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        hashedCredentialsMatcher.setHashAlgorithmName(<span class="string">"md5"</span>);</span><br><span class="line">        hashedCredentialsMatcher.setHashIterations(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> hashedCredentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> </span><br><span class="line">    AuthorizationAttributeSourceAdvisor </span><br><span class="line">    authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor </span><br><span class="line">        authorizationAttributeSourceAdvisor = </span><br><span class="line">        	<span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改使用Shiro验证登录的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logincontroller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Userservice userservice;</span><br><span class="line">    <span class="comment">//处理post请求</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value=<span class="string">"api/hellologin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@RequestBody User requestUser)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String username = requestUser.getUsername();</span><br><span class="line">        <span class="comment">//获取当前用户</span></span><br><span class="line">        Subject subject= SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//封装用户的登录数据</span></span><br><span class="line">        UsernamePasswordToken usernamePasswordToken=<span class="keyword">new</span> UsernamePasswordToken</span><br><span class="line">        (username,requestUser.getPassword());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	<span class="comment">//执行登录的方法，Shiro内部帮我们进行验证操作</span></span><br><span class="line">            subject.login(usernamePasswordToken);</span><br><span class="line">            <span class="keyword">return</span> ResultFactory.buildSuccessResult(username);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(AuthenticationException e)</span><br><span class="line">        &#123;</span><br><span class="line">            String message=<span class="string">"账户密码错误"</span>;</span><br><span class="line">            <span class="keyword">return</span> ResultFactory.buildFailResult(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终Shiro通过Realm重写的doGetAuthenticationInfo方法获取验证信息，<br>再根据配置类里定义的CredentialsMatcher(HashedCredentialsMatcher)<br>执行如下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken </span></span></span><br><span class="line"><span class="function"><span class="params">	token, AuthenticationInfo info)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取传送的密码加盐算取hash值</span></span><br><span class="line">    Object tokenHashedCredentials = </span><br><span class="line">    <span class="keyword">this</span>.hashProvidedCredentials(token,info);</span><br><span class="line">    <span class="comment">//获取数据库中hash后的密码</span></span><br><span class="line">    Object accountCredentials = <span class="keyword">this</span>.getCredentials(info);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.equals(tokenHashedCredentials, accountCredentials);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再分析equals方法发现最终调用的是java.security.MessageDigest<br>包中的isEqual()方法，也就是比较两个hash值是否相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">byte</span>[] digesta, <span class="keyword">byte</span>[] digestb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digesta == digestb) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (digesta == <span class="keyword">null</span> || digestb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (digesta.length != digestb.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// time-constant comparison</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digesta.length; i++) &#123;</span><br><span class="line">        result |= digesta[i] ^ digestb[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步要解决的问题如下</p>
<ul>
<li>每次重启浏览器都要重新登录</li>
<li>没有登出功能</li>
<li>拦截交由前端判断，判断的依据是localStorage中是否存在用户信息，这<br>种信息完全可以伪造，比如在控制台输入window.localStorage.setItem<br>(‘user’, JSON.stringify({“name”:”哈哈哈”})); 就可以绕过登录</li>
</ul>
<h3 id="用户认证方案与完善的访问拦截"><a href="#用户认证方案与完善的访问拦截" class="headerlink" title="用户认证方案与完善的访问拦截"></a>用户认证方案与完善的访问拦截</h3><p>这个部分的内容如下</p>
<ul>
<li>登出功能开发</li>
<li>用户认证机制详解</li>
<li>通过前后端的配合实现完善的访问拦截</li>
<li>进一步分析Shiro的工作机制</li>
</ul>
<h4 id="登出功能开发"><a href="#登出功能开发" class="headerlink" title="登出功能开发"></a>登出功能开发</h4><p>按照过去的登录验证方法，服务器并不会记录登录成功的状态，用户完全可以<br>不用登录自行构造请求访问后端的各种资源，前后端分离项目必须将前端拦截<br>和后端拦截结合起来才能实现真正意义上的访问控制。引入shiro安全框架后<br>拥有对登录状态进行管理的能力，这时才能实现真正的登录登出</p>
<ol>
<li><p>后端 之前已经实现登入，登出代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"api/logout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//Shiro帮助实现登出</span></span><br><span class="line">        subject.logout();</span><br><span class="line">        String message = <span class="string">"成功登出"</span>;</span><br><span class="line">        <span class="keyword">return</span> ResultFactory.buildSuccessResult(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这部分核心是subject.logout()，默认Subject接口是由DelegatingSubject<br>类实现的，该方法会清除session、principals，并把authenticated设置为false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.clearRunAsIdentitiesInternal();</span><br><span class="line">            <span class="keyword">this</span>.securityManager.logout(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.session = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.principals = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.authenticated = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于登出功能不需要被拦截，所以还需要修改配置类MyWebConfigurer的<br>addInterceptors()方法，后端拦截器的代码参考Evan</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(getLoginIntercepter())</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/index.html"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/api/login"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/api/logout"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前端 前端要做的事有两件，一是显示，二是逻辑。在顶部的导航栏增加<br>一个登出按钮 <img src="/2020/10/05/VBlog2/1.jpg" alt><br>在NavMenu中修改，写在el-menu标签即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"el-icon-switch-button"</span> @click=<span class="string">"logout"</span> </span><br><span class="line">style=<span class="string">"float:right;font-size: 40px;color: #222;padding: 10px"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/i&gt;</span></span><br></pre></td></tr></table></figure>
<p>调整样式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.el-icon-switch-button</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">outline</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在methods中编写logout方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">logout () &#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">this</span>.$axios.get(<span class="string">'/logout'</span>).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resp.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 前后端状态保持一致</span></span><br><span class="line">      _this.$store.commit(<span class="string">'logout'</span>)</span><br><span class="line">      _this.$router.replace(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在store中定义logout方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logout (state) &#123;</span><br><span class="line">  state.user = []</span><br><span class="line">  <span class="built_in">window</span>.localStorage.removeItem(<span class="string">'user'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登出功能已经开发完毕</p>
</li>
</ol>
<h4 id="完善的访问拦截"><a href="#完善的访问拦截" class="headerlink" title="完善的访问拦截"></a>完善的访问拦截</h4><p>目前登录登出的状态没问题，但是依然可以通过在控制台输入类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">'user'</span>, <span class="built_in">JSON</span>.stringify(&#123;<span class="string">"name"</span>:<span class="string">"哈哈哈"</span>&#125;));</span><br></pre></td></tr></table></figure>
<p>的命令来绕过前端的前置导航守卫，所以要想真正实现登录拦截，必须在后端也判断<br>用户是否登录以及是谁登录，而这就需要前端向后端发送用户信息</p>
<h4 id="认证方案"><a href="#认证方案" class="headerlink" title="认证方案"></a>认证方案</h4><p>先说最简单的认证方案，即前端再每次请求时都加上用户名和密码，交由后端验证，<br>这种方式有两个弊端</p>
<ul>
<li>一是要每次请求都要查询数据库，导致服务器压力过大，因为之前使用localStorage<br>已经不管用了，所以必须查询数据库中用户密码是否对应</li>
<li>二是安全性不能确保，如果信息被截取，攻击者就可以一直利用用户名密码登录</li>
</ul>
<p>为了在某种程度上解决上述两个问题，有两种改进方案 session和token</p>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>许多语言在网络编程模块中都有会话机制，即session。利用session可以管理用户<br>状态，比如控制会话存在的时间，在会话中保存属性等。作用方式如下</p>
<ul>
<li>服务器接收第一个请求，生成session对象，通过响应头告诉客户端在cookie<br>中放入sessionId</li>
<li>客户端之后发送请求时，会带上sessionId的cookie</li>
<li>服务器通过sessionId获取session，进而获得当前用户状态（是否登录）等信息</li>
</ul>
<p>也就是说客户端只需要在登录的时候发送一次用户名密码，此后只需要在发送请求<br>时带上sessionId，服务器就可以验证用户是否登录。session存储在闪存中，在<br>用户量较少时访问效率较高，但一个服务器存储了上百万session就很难顶。同时<br>由于同一用户的多次请求需要访问到同一服务器，不能做简单集群，需要通过一<br>些策略来扩展</p>
<h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p>虽然session能够比较全面地管理用户状态，但这种方式毕竟占用了较多服务器资<br>源，所以有人想出一种无须在服务器端保存用户状态（简称无状态）的方案，即<br>使用token来做验证，常见的误区如下</p>
<ul>
<li>生成方面，使用随机算法生成的字符串、设备mac地址甚至sessionId作为<br>token,虽然字面上都可以成为令牌，但是毫无意义</li>
<li>验证方面，把token存储在session或数据库中，比对前端传来的token与存储<br>的token是否一致</li>
</ul>
<p>简单来说，一个真正的token本身是携带了一些信息的，比如用户id、过期时间等<br>， 这些信息通过签名算法防止伪造，也可以使用加密算法进一步提高安全性，但<br>一般没有人会在token存密码，作用流程与session相似，注意token无需服务器<br>存储</p>
<ol>
<li>用户使用用户密码登录，服务器通过验证，根据用户名（或者用户id）通过<br>预先设置的算法生成token，其中也可以封装其他信息，并将token返回给客户<br>端</li>
<li>客户端接收到token，并在之后发送请求时带上它</li>
<li>服务器对token进行解密验证</li>
</ol>
<h4 id="客户端存储方案"><a href="#客户端存储方案" class="headerlink" title="客户端存储方案"></a>客户端存储方案</h4><p>无论是明文用户密码，还是sessionId和token，都可以用三种方式存储，即cookie<br>localStorage和sessionStorage。当cookie和local/sessionStorage分工又不，<br>cookie可以作为传递的参数，并可通过后端进行控制，local/sessionStorage则<br>主要用于客户端中保存数据，其传输需要借助cookie或其他方式完成 <img src="/2020/10/05/VBlog2/2.jpg" alt></p>
<p>通常来说在可以使用cookie的场景下作为验证用途进行传输的用户名密码、sessionId<br>和token直接放在cookie中即可，而后端传来的其它信息可以根据需要放在local/<br>session Storage中，作为全局变量之类进行处理</p>
<h4 id="后端登录拦截"><a href="#后端登录拦截" class="headerlink" title="后端登录拦截"></a>后端登录拦截</h4><p>shiro的安全管理实际上是基于会话实现的。之前分析了subject.login()的底层<br>实现，该过程还会产生session，并自动把sessionId设置到cookie。之前说过靠<br>前端拦截很容易被绕过，想要实现靠谱的拦截必须由后端验证用户登录状态。这个<br>思路就是前端带上sesssionId发送请求交由后端验证，但是前后端分离的情况下<br>需要额外的配置解决跨域问题。默认的情况下跨域的cookie是被禁止的，后端不<br>能设置，前端也不能发送，所以两边都要设置</p>
<ol>
<li>首先编写拦截器LoginInterceptor，主要修改preHandle方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest </span></span></span><br><span class="line"><span class="function"><span class="params">	httpServletRequest, HttpServletResponse httpServletResponse, </span></span></span><br><span class="line"><span class="function"><span class="params">	Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/* 放行options请求，否则无法让前端带上自定义的header信息，导致 </span></span><br><span class="line"><span class="comment">    sessionID改变，shiro验证失败 */</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.OPTIONS.toString().equals(httpServletRequest.</span><br><span class="line">    	getMethod())) &#123;</span><br><span class="line">        httpServletResponse.setStatus(HttpStatus.NO_CONTENT.value());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    <span class="comment">// 使用 shiro 验证</span></span><br><span class="line">    <span class="keyword">if</span> (!subject.isAuthenticated()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于跨域问题会先发出一个 options 请求试探，这个请求是不带cookie信息的，<br>所以shiro无法获取到sessionId，将导致认证失败。之后为了允许跨域的cookie<br>需要在配置类MyWebConfigurer做一些修改，主要是addCorsMappings方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">            .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">            .allowedOrigins(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">            .allowedMethods(<span class="string">"POST"</span>, <span class="string">"GET"</span>, <span class="string">"PUT"</span>, <span class="string">"OPTIONS"</span>, <span class="string">"DELETE"</span>)</span><br><span class="line">            .allowedHeaders(<span class="string">"*"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里注意，在allowCredentials(true) ，即允许跨域使用cookie的情况下，<br>allowedOrigins() 不能使用通配符 *，这也是出于安全上的考虑</li>
</ol>
<h4 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h4><p>为了让前端能够带上cookie，需要通过axios主动开启withCredentials功能，<br>即在main.js中添加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这样前端每次请求都会带上sessionId，shiro就可以通过sessionId获取登录<br>状态并执行是否登录的判断。目前后端接口的拦截实现了当页面的拦截还未实现<br>仍然可以伪造参数绕过前端路由的限制，访问本来需要登录才能访问的页面，<br>所以接下来修改router.beforeEach方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.meta.requireAuth) &#123;</span><br><span class="line">      <span class="keyword">if</span> (store.state.user) &#123;</span><br><span class="line">        axios.get(<span class="string">'/authentication'</span>).then(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (resp) next()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next(&#123;</span><br><span class="line">          path: <span class="string">'login'</span>,</span><br><span class="line">          query: &#123;<span class="attr">redirect</span>: to.fullPath&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>即在访问每个页面前都向后端发送一个请求，目的是经由拦截器验证服务器端的<br>登录状态，防止上述情况的发生，后端接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"api/authentication"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">authentication</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"身份认证成功"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rememberMe"><a href="#rememberMe" class="headerlink" title="rememberMe"></a>rememberMe</h4><p><img src="/2020/10/05/VBlog2/25.jpg" alt><br>cookie的生命周期如果未特别设置则与浏览器保持一致，关闭浏览器后sessionId<br>就会消失，再次发送请求shiro就会认为用户已经变更，有时需要保持登录状态，<br>不然每次都需要重新登录。所以shiro提供了rememberMe机制，rememberMe不<br>是单纯设置cookie存活时间，而是又单独保存一种新的状态，之所以这样设计<br>也是基于一种安全考虑，把记住我的状态和实际登录状态做出区分这样就可以<br>控制用户在访问不太敏感的页面时无需重新登录，而访问类似于购物车、订单<br>之类的页面时必须重新登录。接下来修改shiro配置类，添加两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CookieRememberMeManager <span class="title">rememberMeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CookieRememberMeManager cookieRememberMeManager = </span><br><span class="line">    <span class="keyword">new</span> CookieRememberMeManager();</span><br><span class="line">    cookieRememberMeManager.setCookie(rememberMeCookie());</span><br><span class="line">    cookieRememberMeManager.setCipherKey(<span class="string">"EVANNIGHTLY_WAOU"</span>.getBytes());</span><br><span class="line">    <span class="keyword">return</span> cookieRememberMeManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleCookie <span class="title">rememberMeCookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleCookie simpleCookie = <span class="keyword">new</span> SimpleCookie(<span class="string">"rememberMe"</span>);</span><br><span class="line">    simpleCookie.setMaxAge(<span class="number">259200</span>);</span><br><span class="line">    <span class="keyword">return</span> simpleCookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在登录方法中设置UsernamePasswordToken的rememberMe属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">UsernamePasswordToken usernamePasswordToken = <span class="keyword">new</span> UsernamePasswordToken</span><br><span class="line">(username, requestUser.getPassword());</span><br><span class="line">usernamePasswordToken.setRememberMe(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    subject.login(usernamePasswordToken);</span><br><span class="line">    ···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这时再看登录方法的响应头，发现多了一条rememberMe的设置 <img src="/2020/10/05/VBlog2/24.jpg" alt><br>在拦截器 LoginInterceptor 中进行具体的判断逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!subject.isAuthenticated() &amp;&amp; !subject.isRemembered()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态加载后台菜单"><a href="#动态加载后台菜单" class="headerlink" title="动态加载后台菜单"></a>动态加载后台菜单</h3><p>这一部分的主要内容就是实现按照用户角色动态加载后台管理页面的菜单，重点<br>如下</p>
<ul>
<li>如何设计数据库以建立用户-角色-菜单之间的联系</li>
<li>如何查询与处理树结构的数据</li>
<li>Vue如何实现动态加载路由</li>
</ul>
<h4 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h4><p>实现动态加载菜单功能的第一步，就是就是根据当前用户查询出可访问菜单信息<br>的接口</p>
<h4 id="表的设计"><a href="#表的设计" class="headerlink" title="表的设计"></a>表的设计</h4><p>基于之前的RBAC原则，应该设计一张角色表，用角色去对应菜单，同时为了建立<br>用户与角色、角色与菜单之间的关系，又需要两张中间表 <img src="/2020/10/05/VBlog2/3.jpg" alt><br>新创建的表用没有使用外键，admin_menu表的结构解释如下 <img src="/2020/10/05/VBlog2/4.jpg" alt></p>
<h4 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h4><p>需要创建 AdminUserRole、AdminRole、AdminRoleMenu、AdminMenu四个PO，<br>数据库中不存在的字段需要用@Transient标注，注意windows下默认不区分<br>mysql字段大小写，而linux区分，所以数据库字段不推荐大小写混用（最<br>好都小写），而Java属性一般采用小驼峰法命名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个注解的功能是帮我们提供set get方法</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminMenu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> String name_zh;</span><br><span class="line">    <span class="keyword">private</span> String icon_cls;</span><br><span class="line">    <span class="keyword">private</span> String component;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> parentId;</span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    List&lt;AdminMenu&gt; children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="菜单查询接口（树查询结构）"><a href="#菜单查询接口（树查询结构）" class="headerlink" title="菜单查询接口（树查询结构）"></a>菜单查询接口（树查询结构）</h4><p>根据用户查询出对应菜单的步骤是</p>
<ul>
<li>利用shiro获取当前用户登录的id</li>
<li>根据用户id查询出该用户对应的所有角色id，这里一个用户应该可以对应多个<br>角色，每个角色也可对应多个菜单</li>
<li>根据这些角色的id，查询出所有可访问的菜单项</li>
<li>根据parentId把子菜单放进父菜单对象中，整理返回有正确层级关系的菜单数据</li>
</ul>
<p>为了实现这个接口，我们需要新增AdminUserRoleDAO、AdminRoleMenuDAO、<br>AdminMenuDAO 三个数据库访问对象并编写Service对象<br>在AdminMenuService中需要实现一个根据当前用户查询出所有菜单项的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整合查询出的菜单数据的思路如下</p>
<ul>
<li>遍历菜单项，根据每一项的id查询出该项所有的子项，并放进children属性</li>
<li>剔除掉所有的子项，只保留第一层的父项。比如c是b的子项，b是a的子项，<br>只需要保留a就行，因为a包含b和c<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMenus</span><span class="params">(List&lt;AdminMenu&gt; menus)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (AdminMenu menu : menus) &#123;</span><br><span class="line">	    List&lt;AdminMenu&gt; children = getAllByParentId(menu.getId());</span><br><span class="line">	    menu.setChildren(children);</span><br><span class="line">	&#125;</span><br><span class="line">	Iterator&lt;AdminMenu&gt; iterator = menus.iterator();</span><br><span class="line">	<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	    AdminMenu menu = iterator.next();</span><br><span class="line">	    <span class="keyword">if</span> (menu.getParentId() != <span class="number">0</span>) &#123;</span><br><span class="line">	        iterator.remove();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h4><p>前端要做的事情就是处理后端传来的数据，并传递给路由和导航菜单，以<br>实现动态渲染</p>
<h4 id="后台页面设计"><a href="#后台页面设计" class="headerlink" title="后台页面设计"></a>后台页面设计</h4><p>需要创建的组件如下图 <img src="/2020/10/05/VBlog2/5.jpg" alt><br>这是首页的图片 <img src="/2020/10/05/VBlog2/6.jpg" alt></p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>之前设计 AdminMenu 表，实际上包含了前端路由（router）与导航菜单需要的信<br>息，从后台传来的数据，需要被整理成路由能够识别的格式。导航菜单倒是无所谓，<br>赋给相应的属性就行，进行格式转换的方法如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formatRoutes = <span class="function">(<span class="params">routes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> fmtRoutes = []</span><br><span class="line">  routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (route.children) &#123;</span><br><span class="line">      route.children = formatRoutes(route.children)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fmtRoute = &#123;</span><br><span class="line">      path: route.path,</span><br><span class="line">      component: <span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>([<span class="string">'./components/admin/'</span> + route.component + <span class="string">'.vue'</span>], resolve)</span><br><span class="line">      &#125;,</span><br><span class="line">      name: route.name,</span><br><span class="line">      nameZh: route.nameZh,</span><br><span class="line">      iconCls: route.iconCls,</span><br><span class="line">      children: route.children</span><br><span class="line">    &#125;</span><br><span class="line">    fmtRoutes.push(fmtRoute)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> fmtRoutes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入的参数routes代表从后端获取的菜单列表。遍历这个列表，首先判断<br>一条菜单项是否包含子项，如果包含则进行递归处理。然后就是把路由的属性<br>和菜单项的属性对应起来，component是一个对象需要根据名称做出解析</p>
<h4 id="添加路由与渲染菜单"><a href="#添加路由与渲染菜单" class="headerlink" title="添加路由与渲染菜单"></a>添加路由与渲染菜单</h4><p>首先需要考虑什么时候去请求接口并渲染菜单。如果访问每个页面都加载一次<br>有点太浪费，如果只在后台主页面渲染时加载一次那么就不能再主页面进行<br>刷新操作，因此可以继续利用全局守卫，在用户登录且访问/admin开头的<br>路径时请求菜单信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line">    if (store.state.user.username &amp;&amp; to.path.startsWith(&#39;&#x2F;admin&#39;)) &#123;</span><br><span class="line">        initAdminMenu(router, store)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 已登录状态下访问 login 页面直接跳转到后台首页</span><br><span class="line">    if (store.state.username &amp;&amp; to.path.startsWith(&#39;&#x2F;login&#39;)) &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &#39;admin&#x2F;dashboard&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (to.meta.requireAuth) &#123;</span><br><span class="line">      if (store.state.user.username) &#123;</span><br><span class="line">        axios.get(&#39;&#x2F;authentication&#39;).then(resp &#x3D;&gt; &#123;</span><br><span class="line">          if (resp) next()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        next(&#123;</span><br><span class="line">          path: &#39;login&#39;,</span><br><span class="line">          query: &#123;redirect: to.fullPath&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为了保证用户确实登录，仍需要向后台发送一个验证请求<br>initAdminMenu 用于执行请求，调用格式化方法并向路由表中添加信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const initAdminMenu &#x3D; (router, store) &#x3D;&gt; &#123;</span><br><span class="line">  if (store.state.adminMenus.length &gt; 0) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  axios.get(&#39;&#x2F;menu&#39;).then(resp &#x3D;&gt; &#123;</span><br><span class="line">    if (resp &amp;&amp; resp.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">      var fmtRoutes &#x3D; formatRoutes(resp.data)</span><br><span class="line">      router.addRoutes(fmtRoutes)</span><br><span class="line">      store.commit(&#39;initAdminMenu&#39;, fmtRoutes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断store中有没有菜单数据，如果有说明是正常跳转，无需重新加载，<br>第一次进入或进行刷新时需要重新加载。记得在store.state里添加变量<br>adminMenu: []，同时在 mutations 里添加如下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initAdminMenu (state, menus) &#123;</span><br><span class="line">  state.adminMenus &#x3D; menus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个menus就是上面的fmtRoutes。当然也可以把数据放进localStorage，<br>在登出时清空就行。接下来编写菜单组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-menu</span><br><span class="line">      :default-active&#x3D;&quot;&#39;&#x2F;admin&#x2F;users&#39;&quot;</span><br><span class="line">      class&#x3D;&quot;el-menu-admin&quot;</span><br><span class="line">      router</span><br><span class="line">      mode&#x3D;&quot;vertical&quot;</span><br><span class="line">      background-color&#x3D;&quot;#545c64&quot;</span><br><span class="line">      text-color&#x3D;&quot;#fff&quot;</span><br><span class="line">      active-text-color&#x3D;&quot;#ffd04b&quot;&gt;</span><br><span class="line">      &lt;div style&#x3D;&quot;height: 80px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;template v-for&#x3D;&quot;(item,i) in adminMenus&quot;&gt;</span><br><span class="line">        &lt;!--index 没有用但是必需字段且为 string --&gt;</span><br><span class="line">        &lt;el-submenu :key&#x3D;&quot;i&quot; :index&#x3D;&quot;i + &#39;&#39;&quot; style&#x3D;&quot;text-align: left&quot;&gt;</span><br><span class="line">          &lt;span slot&#x3D;&quot;title&quot; style&#x3D;&quot;font-size: 17px;&quot;&gt;</span><br><span class="line">            &lt;i :class&#x3D;&quot;item.iconCls&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">            &#123;&#123;item.nameZh&#125;&#125;</span><br><span class="line">          &lt;&#x2F;span&gt;</span><br><span class="line">          &lt;el-menu-item v-for&#x3D;&quot;child in item.children&quot; </span><br><span class="line">          :key&#x3D;&quot;child.path&quot; :index&#x3D;&quot;child.path&quot;&gt;</span><br><span class="line">            &lt;i :class&#x3D;&quot;child.icon&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">            &#123;&#123; child.nameZh &#125;&#125;</span><br><span class="line">          &lt;&#x2F;el-menu-item&gt;</span><br><span class="line">        &lt;&#x2F;el-submenu&gt;</span><br><span class="line">      &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;el-menu&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      name: &#39;AdminMenu&#39;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        adminMenus () &#123;</span><br><span class="line">          return this.$store.state.adminMenus</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>利用element的导航栏组件，进行两层循环渲染所需要的菜单。&lt;\el-submenu&gt;<br>代表一个有子菜单的菜单项，&lt;\el-menu-item&gt; 则代表单独的菜单项，如果<br>有三个层级的话就是&lt;\el-submenu&gt;套&lt;\el-submenu&gt;再套&lt;\el-menu-item&gt;<br>接下来登录显示结果如下 <img src="/2020/10/05/VBlog2/26.jpg" alt><br>点击用户信息菜单，跳转到相应路由并加载 <img src="/2020/10/05/VBlog2/27.jpg" alt><br>使用editor登录只有用户内容管理菜单 <img src="/2020/10/05/VBlog2/28.jpg" alt><br>接下来会完善一下各个板块</p>
<ul>
<li>开发用户角色、角色菜单分配组件</li>
<li>迁移图书管理功能</li>
<li>完成其它模块的基础界面</li>
<li>实现功能级权限并开发分配组件</li>
</ul>
<h3 id="功能级访问控制的实现"><a href="#功能级访问控制的实现" class="headerlink" title="功能级访问控制的实现"></a>功能级访问控制的实现</h3><p>这部分主要是功能级访问控制的实现方式，之所以要实现这个粒度的访问控制，<br>是因为仅仅对菜单进行控制是不够的。如果不想让内容管理员角色查看用户列<br>表的权限，可以通过对菜单的控制，让这个角色无法加载用户信息组件，但<br>在会话持续状态下，该角色仍然可以向后台展示用户列表的接口发送请求，<br>获取所有的用户信息，也就是说虽然初始加载时不会有用户信息，但是可<br>以构建请求获取用户信息</p>
<ul>
<li>设计数据库表（功能表与角色-功能表）</li>
<li>完善新表对应的 pojo、DAO、service 类</li>
<li>编写shiro过滤器并配置过滤条件</li>
</ul>
<p>运行情况 <img src="/2020/10/05/VBlog2/7.jpg" alt>  用户信息 <img src="/2020/10/05/VBlog2/8.jpg" alt><br>角色配置 <img src="/2020/10/05/VBlog2/9.jpg" alt>  图书管理 <img src="/2020/10/05/VBlog2/10.jpg" alt></p>
<h4 id="数据库与后端准备"><a href="#数据库与后端准备" class="headerlink" title="数据库与后端准备"></a>数据库与后端准备</h4><p>这部分内容涉及到的表 <img src="/2020/10/05/VBlog2/11.jpg" alt><br>除了两张新建的表admin_permission和admin_role_permission外，还对<br>user进行扩充。权限表的设计如下</p>
<ul>
<li>name 即权限的名称，推荐使用英文</li>
<li>desc_ 即对权限功能的具体描述</li>
<li>url 即权限对应的接口，是实现功能控制的关键</li>
</ul>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>AdminPermissionService中需要实现一个根据当前用户获取所有权限的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以实现一个方法用于判断用户请求接口是否在权限列表中，如果没有对应<br>权限则说明不需要维护</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了实现上述功能，可以在Controller中查询所有用户接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/api/admin/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Shiro实现"><a href="#Shiro实现" class="headerlink" title="Shiro实现"></a>Shiro实现</h4><p>之前我们在做登录拦截的时候使用了拦截器，即Interceptor。由于Shiro的<br>权限机制要靠它自身提供的过滤器实现，所以我们现在弃用之前的拦截器，<br>首先在MyWebConfigurer中删除addInterceptors方法和相关类</p>
<h4 id="编写基于URL的过滤器"><a href="#编写基于URL的过滤器" class="headerlink" title="编写基于URL的过滤器"></a>编写基于URL的过滤器</h4><p>首先自定义一个过滤器，PathMatchingFilter是Shiro提供的路径过滤器，<br>我们可以通过继承它来编写过滤放行条件，即判断是否具有相应权限。判断<br>的逻辑为</p>
<ul>
<li>首先判断当前会话对应的用户是否登录，如果未登录直接false</li>
<li>第二步判断访问的接口是否有对应的权限，如果没有视为不需要权限即<br>可访问，直接true</li>
<li>如果需要权限查询出当前用户对应的所有权限，遍历并与需要访问的接<br>口进行比对，如果存在相应权限则true，否则false</li>
</ul>
<p>新建一个filter包，编写URLPathMatchingFilter类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gm.wj.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gm.wj.service.AdminPermissionService;</span><br><span class="line"><span class="keyword">import</span> com.gm.wj.util.SpringContextUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.filter.PathMatchingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLPathMatchingFilter</span> <span class="keyword">extends</span> <span class="title">PathMatchingFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AdminPermissionService adminPermissionService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onPreHandle</span><span class="params">(ServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">    	ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse httpServletResponse = (HttpServletResponse) </span><br><span class="line">        response;</span><br><span class="line">        <span class="comment">// 放行 options 请求</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.OPTIONS.toString().equals((httpServletRequest).</span><br><span class="line">        	getMethod())) &#123;</span><br><span class="line">            httpServletResponse.setStatus(HttpStatus.NO_CONTENT.value());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">			在 Shiro 的配置文件中，我们不能把 URLPathMatchingFilter用 </span></span><br><span class="line"><span class="comment">			@Bean 被 Spring 管理起来。 原因是 Shiro 存在 bug, 这个也是</span></span><br><span class="line"><span class="comment">			过滤器，ShiroFilterFactoryBean 也是过滤器，当他们都出现的</span></span><br><span class="line"><span class="comment">			时候，默认的什么 anno,authc 过滤器就失效了。所以不能把他声</span></span><br><span class="line"><span class="comment">			明为@Bean。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==adminPermissionService) &#123;</span><br><span class="line">            adminPermissionService = SpringContextUtils.getContext().</span><br><span class="line">            getBean(AdminPermissionService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String requestAPI = getPathWithinApplication(request);</span><br><span class="line">        System.out.println(<span class="string">"访问接口："</span> + requestAPI);</span><br><span class="line"></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!subject.isAuthenticated()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"需要登录"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断访问接口是否需要过滤（数据库中是否有对应信息）</span></span><br><span class="line">        <span class="keyword">boolean</span> needFilter = adminPermissionService.needFilter(requestAPI);</span><br><span class="line">        <span class="keyword">if</span> (!needFilter) &#123;</span><br><span class="line">            System.out.println(<span class="string">"接口："</span> + requestAPI + <span class="string">"无需权限"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"验证访问权限："</span> + requestAPI);</span><br><span class="line">            <span class="comment">// 判断当前用户是否有相应权限</span></span><br><span class="line">            <span class="keyword">boolean</span> hasPermission = <span class="keyword">false</span>;</span><br><span class="line">            String username = subject.getPrincipal().toString();</span><br><span class="line">            Set&lt;String&gt; permissionAPIs = </span><br><span class="line">            adminPermissionService.listPermissionURLsByUser(username);</span><br><span class="line">            <span class="keyword">for</span> (String api : permissionAPIs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (api.equals(requestAPI)) &#123;</span><br><span class="line">                    hasPermission = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasPermission) &#123;</span><br><span class="line">                System.out.println(<span class="string">"访问权限："</span> + requestAPI + <span class="string">"验证成功"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"当前用户没有访问接口"</span> + requestAPI + </span><br><span class="line">                	<span class="string">"的权限"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们无法在URLPathMatchingFilter中使用@Autowired注入<br>AdminPermissionService类，所以需要借助一个工具类利用<br>Spring应用上下文获取AdminPermissionService的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gm.wj.util;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContextUtils</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext context)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringContextUtils.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再配置类ShiroConfiguration中增加获取过滤器的方法，注意这里<br>不能使用@Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URLPathMatchingFilter <span class="title">getURLPathMatchingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> URLPathMatchingFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编写shiroFilter方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">    ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> </span><br><span class="line">    ShiroFilterFactoryBean();</span><br><span class="line">    shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String &gt; filterChainDefinitionMap = <span class="keyword">new</span> </span><br><span class="line">    LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">    Map&lt;String, Filter&gt; customizedFilter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置自定义过滤器名称为 url</span></span><br><span class="line">    customizedFilter.put(<span class="string">"url"</span>, getURLPathMatchingFilter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*对管理接口的访问启用自定义拦截（url 规则），即执行 </span></span><br><span class="line"><span class="comment">    URLPathMatchingFilter 中定义的过滤方法*/</span></span><br><span class="line">    filterChainDefinitionMap.put(<span class="string">"/api/admin/**"</span>, <span class="string">"url"</span>);</span><br><span class="line">    <span class="comment">// 启用自定义过滤器</span></span><br><span class="line">    shiroFilterFactoryBean.setFilters(customizedFilter);</span><br><span class="line">    filterChainDefinitionMap.put(<span class="string">"/api/authentication"</span>, <span class="string">"authc"</span>);</span><br><span class="line">    shiroFilterFactoryBean.setFilterChainDefinitionMap(</span><br><span class="line">    	filterChainDefinitionMap);</span><br><span class="line">    <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="授权操作"><a href="#授权操作" class="headerlink" title="授权操作"></a>授权操作</h4><p>写好Service之后</p>
<ul>
<li>在Realm中配置授权信息</li>
<li>为需要控制的接口添加注解</li>
<li>编写异常处理类（统一处理未授权的异常）</li>
</ul>
<p>在WJRealm中重写获取授权信息的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前用户的所有权限</span></span><br><span class="line">    String username = principalCollection.getPrimaryPrincipal().</span><br><span class="line">    toString();</span><br><span class="line">    Set&lt;String&gt; permissions = adminPermissionService.</span><br><span class="line">    listPermissionURLsByUser(username);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将权限放入授权信息中</span></span><br><span class="line">    SimpleAuthorizationInfo s = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">    s.setStringPermissions(permissions);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选用注解的方式控制用户信息查询权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"/api/admin/user"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/api/admin/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后编写一个处理所有未授权异常的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gm.wj.exception;</span><br><span class="line"><span class="keyword">import</span> com.gm.wj.result.Result;</span><br><span class="line"><span class="keyword">import</span> com.gm.wj.result.ResultFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.UnauthorizedException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span> <span class="title">handleAuthorizationException</span>(<span class="title">UnauthorizedException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        String message = <span class="string">"权限认证失败"</span>;</span><br><span class="line">        <span class="keyword">return</span> ResultFactory.buildFailResult(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后台角色、权限与菜单分配"><a href="#后台角色、权限与菜单分配" class="headerlink" title="后台角色、权限与菜单分配"></a>后台角色、权限与菜单分配</h3><p>这部分主要在实现菜单和功能访问控制的情况下，如何编写角色、权限、菜单<br>分配功能的接口和页面，本质是增删查改，表单表格</p>
<ul>
<li>如何使用 element-ui 的树组件</li>
<li>如何接收并处理没有实体类型对应的数据</li>
<li>Vue 如何不刷新清除路由记录</li>
</ul>
<h4 id="角色、权限分配"><a href="#角色、权限分配" class="headerlink" title="角色、权限分配"></a>角色、权限分配</h4><p>角色分配，也就是给用户指定角色。根据我们之前的数据库设计，本质是更新<br>admin_user_role表</p>
<h4 id="用户信息表与行数据获取"><a href="#用户信息表与行数据获取" class="headerlink" title="用户信息表与行数据获取"></a>用户信息表与行数据获取</h4><p>首先要有一个组件负责展示查询出来的用户信息，并提供编辑操作的入口。<br>element的table组件提供了表格能用到的很多功能，比如排序、筛选、选<br>择、懒加载等等 <img src="/2020/10/05/VBlog2/29.jpg" alt><br>前端表格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table</span><br><span class="line">  :data&#x3D;&quot;users&quot;</span><br><span class="line">  stripe&gt;</span><br><span class="line">  &lt;el-table-column</span><br><span class="line">    prop&#x3D;&quot;id&quot;</span><br><span class="line">    label&#x3D;&quot;id&quot;</span><br><span class="line">    width&#x3D;&quot;100&quot;&gt;</span><br><span class="line">  &lt;&#x2F;el-table-column&gt;</span><br><span class="line">  &lt;el-table-column</span><br><span class="line">    prop&#x3D;&quot;username&quot;</span><br><span class="line">    label&#x3D;&quot;用户名&quot;</span><br><span class="line">    fit&gt;</span><br><span class="line">  &lt;&#x2F;el-table-column&gt;</span><br><span class="line">  </span><br><span class="line">  ······</span><br><span class="line">  </span><br><span class="line">  &lt;el-table-column</span><br><span class="line">    label&#x3D;&quot;操作&quot;</span><br><span class="line">    width&#x3D;&quot;120&quot;&gt;</span><br><span class="line">    &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">      &lt;el-button</span><br><span class="line">        @click&#x3D;&quot;editUser(scope.row)&quot;</span><br><span class="line">        type&#x3D;&quot;text&quot;</span><br><span class="line">        size&#x3D;&quot;small&quot;&gt;</span><br><span class="line">        编辑</span><br><span class="line">      &lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;el-button</span><br><span class="line">        type&#x3D;&quot;text&quot;</span><br><span class="line">        size&#x3D;&quot;small&quot;&gt;</span><br><span class="line">        移除</span><br><span class="line">      &lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">  &lt;&#x2F;el-table-column&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br></pre></td></tr></table></figure>
<p>通过data绑定表格对应的数据，并通过 prop 指定列对应的字段。若想对表<br>格里某一行的数据进行操作，就要想办法获取当前的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column</span><br><span class="line">  label&#x3D;&quot;操作&quot;</span><br><span class="line">  width&#x3D;&quot;120&quot;&gt;</span><br><span class="line">  &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">    &lt;el-button</span><br><span class="line">      @click&#x3D;&quot;editUser(scope.row)&quot;</span><br><span class="line">      type&#x3D;&quot;text&quot;</span><br><span class="line">      size&#x3D;&quot;small&quot;&gt;</span><br><span class="line">      编辑</span><br><span class="line">    &lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table-column&gt;</span><br></pre></td></tr></table></figure>
<p>scope.row 便是点击编辑按钮所获取到的该行的数据。这里实际上利用的是作<br>用域插槽，通过 &lt;\el-table-column&gt; 组件获取到了数据。通过点击事件触<br>发editUser方法并传入了该行的数据，弹出对话框，并通过表单组件实现单<br>用户信息的显示与修改 <img src="/2020/10/05/VBlog2/30.jpg" alt></p>
<h4 id="角色分配"><a href="#角色分配" class="headerlink" title="角色分配"></a>角色分配</h4><p>用户和角色是多对多关系，所以这里使用多选框组件。为了正确显示用户对应<br>的角色，我们需要先把所有的角色信息查询出来，再根据用户信息选中相应<br>的角色，查询出所有角色的方法很简单，在mounted()方法中调用即可。关<br>键是如何选中当前用户对应的角色。查询用户的角色有两种思路</p>
<ol>
<li>可以以用户名或id为参数向后端发送请求，查询出对应的角色值并返回</li>
<li>改造后端查询用户信息的接口，直接在查询用户信息时就把角色信息查<br>询出来</li>
</ol>
<p>为了前后端传递参数更方便一点，这里采用第二种方法，使用这种方法需要在<br>User实体类中添加属性来存放角色信息，但是由于数据库中并没有相应定义<br>，所以我们要加上@Transient注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line">List&lt;AdminRole&gt; roles;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter and setter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;AdminRole&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> roles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;AdminRole&gt; roles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.roles = roles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应地在Userservice中修改列出所有用户的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users =  userDAO.list();</span><br><span class="line">    List&lt;AdminRole&gt; roles;</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        roles = adminRoleService.listRolesByUser(user.getUsername());</span><br><span class="line">        user.setRoles(roles);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AdminRoleService中添加listRolesByUser()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;AdminRole&gt; <span class="title">listRolesByUser</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> uid = userService.findByUsername(username).getId();</span><br><span class="line">    List&lt;Integer&gt; rids = adminUserRoleService.listAllByUid(uid)</span><br><span class="line">            .stream().map(AdminUserRole::getRid).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> adminRoleDAO.findAllById(rids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样查询出的用户就带角色信息了</p>
<h3 id="博客功能开发"><a href="#博客功能开发" class="headerlink" title="博客功能开发"></a>博客功能开发</h3><p>这部分主要讲解如何开发博客系统</p>
<ul>
<li>如何使用开源编辑器</li>
<li>Vue如何在不同页面传递参数</li>
</ul>
<h4 id="mavon-editor-编辑器"><a href="#mavon-editor-编辑器" class="headerlink" title="mavon-editor 编辑器"></a>mavon-editor 编辑器</h4><p>目前常见的文本编辑器有两种，富文本编辑器和markdown编辑器。markdown<br>编辑器的本质就是把输入源转化成html代码。富文本编辑器是一种可内嵌于<br>浏览器，所见即所得的文本编辑器</p>
<h4 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h4><p>博客功能可以分为三个部分：文章展示、文章管理和编辑器，文章展示又可以<br>分为文章列表和文章详情两部分 <img src="/2020/10/05/VBlog2/13.jpg" alt><br>虽然编辑器提供预览功能，但一般在前台不需要向用户展示markdown原文，<br>所以单独写一个文章详情页渲染html，有两种思路</p>
<ul>
<li>第一种在数据库中仅保存markdown语法的文本，在需要使用时解析为html<br>并在前台渲染</li>
<li>第二种是html markdown均保存在数据库中，需要使用时取出html并在前台<br>渲染</li>
</ul>
<p>第一种的好处是节省传输的数据量与数据库空间，坏处就是需要自己编写解析<br>方法，相当于又重写一遍编辑器，而且难以保证解析出来的样式跟原编辑器一<br>致，所以目前使用第二种方法</p>
<h4 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h4><p>展示文章的题目、摘要、封面等信息，提供文章详情页入口，主要是前端设计与<br>分页功能实现，后期可以扩展分页标签、检索、归档等功能，还可以在侧边栏<br>加入作者简介等信息 <img src="/2020/10/05/VBlog2/14.jpg" alt></p>
<h4 id="文章详情"><a href="#文章详情" class="headerlink" title="文章详情"></a>文章详情</h4><p>这个页面用于展示文章的具体内容，也就是渲染从数据库中取出的html <img src="/2020/10/05/VBlog2/15.jpg" alt></p>
<h4 id="文章管理"><a href="#文章管理" class="headerlink" title="文章管理"></a>文章管理</h4><p>后台的管理页面，提供查看、发布、修改文章的入口以及删除功能，需要内容管理<br>权限 <img src="/2020/10/05/VBlog2/16.jpg" alt></p>
<h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><p>核心页面，在开源编辑器的基础上，添加了标题、摘要及封面设置功能 <img src="/2020/10/05/VBlog2/17.jpg" alt></p>
<h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>为了保存文章相关的信息，设计jotter_article表 <img src="/2020/10/05/VBlog2/18.jpg" alt><br>目前包含的字段是 id、标题、文章 html、md 原文、文章摘要、文章标题和发文日期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table jotter_article</span><br><span class="line">(</span><br><span class="line">   id int primary key,</span><br><span class="line">   article_title varchar(255),</span><br><span class="line">   article_content_html longtext,</span><br><span class="line">   article_content_md longtext,</span><br><span class="line">   article_abstract varchar(255),</span><br><span class="line">   article_cover varchar(255),</span><br><span class="line">   article_date datetime</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="编辑器的引入与改造"><a href="#编辑器的引入与改造" class="headerlink" title="编辑器的引入与改造"></a>编辑器的引入与改造</h4><p>在项目根目录执行如下命令安装mavon-editor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mavon-editor --save</span><br></pre></td></tr></table></figure>
<p>然后在main.js中全局注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import mavonEditor from &#39;mavon-editor&#39;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Vue.use(mavonEditor)</span><br></pre></td></tr></table></figure>
<p>在admin/content文件夹下新建ArticleEditor.vue组件，该组件的主体就是<br>mavon-editor编辑器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;mavon-editor</span><br><span class="line">    v-model&#x3D;&quot;article.articleContentMd&quot;</span><br><span class="line">    style&#x3D;&quot;height: 100%;&quot;</span><br><span class="line">    ref&#x3D;md</span><br><span class="line">    @save&#x3D;&quot;saveArticles&quot;</span><br><span class="line">    fontSize&#x3D;&quot;16px&quot;&gt;</span><br><span class="line">  &lt;&#x2F;mavon-editor&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;Editor&#39;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        article: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>接下来进行一些改造</p>
<ul>
<li>第一步添加标题输入栏</li>
<li>第二步插入自定义工具，提供摘要与封面录入功能</li>
<li>第三步编写save方法，与后端交互</li>
</ul>
<p>添加el-input实现输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-input</span><br><span class="line">       v-model&#x3D;&quot;article.articleTitle&quot;</span><br><span class="line">       style&#x3D;&quot;margin: 10px 0px;font-size: 18px;&quot;</span><br><span class="line">       placeholder&#x3D;&quot;请输入标题&quot;&gt;&lt;&#x2F;el-input&gt;</span><br></pre></td></tr></table></figure>
<p>设置type class和title属性，弄一个添加摘要和封面的按钮</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type&#x3D;&quot;button&quot;</span><br><span class="line">		class&#x3D;&quot;op-icon el-icon-document&quot;</span><br><span class="line">		:title&#x3D;&quot;&#39;摘要&#x2F;封面&#39;&quot;</span><br><span class="line">		slot&#x3D;&quot;left-toolbar-after&quot;</span><br><span class="line">		@click&#x3D;&quot;dialogVisible &#x3D; true&quot;&gt;&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<p>注意图片上传这个组件需要单独设置属性才能带上cookie，不带cookie<br>后端就拿不到sessionId，就会被shiro拦截</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-upload</span><br><span class="line">    class&#x3D;&quot;img-upload&quot;</span><br><span class="line">    ref&#x3D;&quot;upload&quot;</span><br><span class="line">    action&#x3D;&quot;http:&#x2F;&#x2F;localhost:8443&#x2F;api&#x2F;admin&#x2F;content&#x2F;books&#x2F;covers&quot;</span><br><span class="line">    with-credentials</span><br><span class="line">    :on-preview&#x3D;&quot;handlePreview&quot;</span><br><span class="line">    :on-remove&#x3D;&quot;handleRemove&quot;</span><br><span class="line">    :before-remove&#x3D;&quot;beforeRemove&quot;</span><br><span class="line">    :on-success&#x3D;&quot;handleSuccess&quot;</span><br><span class="line">    multiple</span><br><span class="line">    :limit&#x3D;&quot;1&quot;</span><br><span class="line">    :on-exceed&#x3D;&quot;handleExceed&quot;</span><br><span class="line">    :file-list&#x3D;&quot;fileList&quot;&gt;</span><br><span class="line">    &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;点击上传&lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;div slot&#x3D;&quot;tip&quot; class&#x3D;&quot;el-upload__tip&quot;&gt;只能上传jpg&#x2F;png文件，且不超过500kb&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;el-upload&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/05/VBlog2/19.jpg" alt></p>
<h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>controller中保存对应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"api/admin/content/article"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveArticle</span><span class="params">(@RequestBody JotterArticle article)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//jotterArticleService.addOrUpdate(article);</span></span><br><span class="line">    <span class="keyword">return</span> ResultFactory.buildSuccessResult(<span class="string">"保存成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端路由写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/admin/content/editor'</span>,</span><br><span class="line">  name: <span class="string">'Editor'</span>,</span><br><span class="line">  component: Editor,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    requireAuth: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文章列表页面"><a href="#文章列表页面" class="headerlink" title="文章列表页面"></a>文章列表页面</h4><p>这部分主要涉及分页问题，图书馆的页面分页可以靠前端实现，也可以靠后端<br>实现。Spring Data提供了页码、页面尺寸等信息，</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/10/05/VBlog2/">https://skysea-gaoming.github.io/2020/10/05/VBlog2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/"><i class="fa fa-chevron-left">  </i><span>深入JVM2</span></a></div><div class="next-post pull-right"><a href="/2020/09/22/Algorithm-1/"><span>算法总结2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/10/05/VBlog2/';
  this.page.identifier = '2020/10/05/VBlog2/';
  this.page.title = 'VBlog2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>