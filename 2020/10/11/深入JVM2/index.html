<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入JVM2"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>深入JVM2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能监控、故障处理工具"><span class="toc-number">2.</span> <span class="toc-text">性能监控、故障处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jps"><span class="toc-number">2.1.</span> <span class="toc-text">jps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstat"><span class="toc-number">2.2.</span> <span class="toc-text">jstat</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要选项"><span class="toc-number">2.2.1.</span> <span class="toc-text">主要选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行样例"><span class="toc-number">2.2.2.</span> <span class="toc-text">执行样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jinfo"><span class="toc-number">2.3.</span> <span class="toc-text">jinfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmp"><span class="toc-number">2.4.</span> <span class="toc-text">jmp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要选项-1"><span class="toc-number">2.4.1.</span> <span class="toc-text">主要选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jhat"><span class="toc-number">2.5.</span> <span class="toc-text">jhat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack"><span class="toc-number">2.6.</span> <span class="toc-text">jstack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要选项-2"><span class="toc-number">2.7.</span> <span class="toc-text">主要选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础工具总结"><span class="toc-number">2.8.</span> <span class="toc-text">基础工具总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可视化故障处理工具"><span class="toc-number">2.9.</span> <span class="toc-text">可视化故障处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VisualVM"><span class="toc-number">2.9.1.</span> <span class="toc-text">VisualVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#样例展示"><span class="toc-number">2.9.2.</span> <span class="toc-text">样例展示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调优案例分析与实战"><span class="toc-number">3.</span> <span class="toc-text">调优案例分析与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#大内存硬件上的程序部署策略"><span class="toc-number">3.1.</span> <span class="toc-text">大内存硬件上的程序部署策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集群间同步导致的内存溢出"><span class="toc-number">3.2.</span> <span class="toc-text">集群间同步导致的内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆外内存导致的溢出错误"><span class="toc-number">3.3.</span> <span class="toc-text">堆外内存导致的溢出错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外部命令导致系统缓慢"><span class="toc-number">3.4.</span> <span class="toc-text">外部命令导致系统缓慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器虚拟机进程崩溃"><span class="toc-number">3.5.</span> <span class="toc-text">服务器虚拟机进程崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不恰当数据结构导致内存占用过大"><span class="toc-number">3.6.</span> <span class="toc-text">不恰当数据结构导致内存占用过大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#由Windows虚拟内存导致的长时间停顿"><span class="toc-number">3.7.</span> <span class="toc-text">由Windows虚拟内存导致的长时间停顿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#由安全点导致的长时间停顿"><span class="toc-number">3.8.</span> <span class="toc-text">由安全点导致的长时间停顿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机字节码执行引擎"><span class="toc-number">4.</span> <span class="toc-text">虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行引擎的概述"><span class="toc-number">4.1.</span> <span class="toc-text">执行引擎的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时栈帧结构"><span class="toc-number">4.2.</span> <span class="toc-text">运行时栈帧结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量表"><span class="toc-number">4.3.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作数栈"><span class="toc-number">4.4.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态连接"><span class="toc-number">4.5.</span> <span class="toc-text">动态连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法返回地址"><span class="toc-number">4.6.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法调用"><span class="toc-number">4.7.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态分派"><span class="toc-number">4.8.</span> <span class="toc-text">静态分派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态分派"><span class="toc-number">4.9.</span> <span class="toc-text">动态分派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态类型语言"><span class="toc-number">4.10.</span> <span class="toc-text">动态类型语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于栈的字节码解释执行引擎"><span class="toc-number">4.11.</span> <span class="toc-text">基于栈的字节码解释执行引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载及执行子系统的案例与实战"><span class="toc-number">5.</span> <span class="toc-text">类加载及执行子系统的案例与实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端编译与优化"><span class="toc-number">6.</span> <span class="toc-text">前端编译与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Javac编译器"><span class="toc-number">6.1.</span> <span class="toc-text">Javac编译器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后端编译与优化"><span class="toc-number">7.</span> <span class="toc-text">后端编译与优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型与线程"><span class="toc-number">8.</span> <span class="toc-text">Java内存模型与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件的效率与一致性"><span class="toc-number">8.1.</span> <span class="toc-text">硬件的效率与一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存模型"><span class="toc-number">8.2.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主内存和工作内存"><span class="toc-number">8.2.1.</span> <span class="toc-text">主内存和工作内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存间交互操作"><span class="toc-number">8.3.</span> <span class="toc-text">内存间交互操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">8.4.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#指令重排序"><span class="toc-number">8.4.1.</span> <span class="toc-text">指令重排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#针对long和double型变量的特殊情况"><span class="toc-number">8.5.</span> <span class="toc-text">针对long和double型变量的特殊情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性、可见性与有序性"><span class="toc-number">8.6.</span> <span class="toc-text">原子性、可见性与有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性"><span class="toc-number">8.6.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可见性"><span class="toc-number">8.6.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序性"><span class="toc-number">8.6.3.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#先行发生原则"><span class="toc-number">8.6.4.</span> <span class="toc-text">先行发生原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java与线程"><span class="toc-number">8.7.</span> <span class="toc-text">Java与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的实现"><span class="toc-number">8.7.1.</span> <span class="toc-text">线程的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核线程实现"><span class="toc-number">8.7.2.</span> <span class="toc-text">内核线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用户线程实现"><span class="toc-number">8.7.3.</span> <span class="toc-text">用户线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#混合实现"><span class="toc-number">8.7.4.</span> <span class="toc-text">混合实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的实现-1"><span class="toc-number">8.7.5.</span> <span class="toc-text">线程的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#状态转换"><span class="toc-number">8.7.6.</span> <span class="toc-text">状态转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全与锁优化"><span class="toc-number">9.</span> <span class="toc-text">线程安全与锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java语言的线程安全"><span class="toc-number">9.1.</span> <span class="toc-text">Java语言的线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不可变"><span class="toc-number">9.1.1.</span> <span class="toc-text">不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绝对线程安全"><span class="toc-number">9.1.2.</span> <span class="toc-text">绝对线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相对线程安全"><span class="toc-number">9.1.3.</span> <span class="toc-text">相对线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程兼容"><span class="toc-number">9.1.4.</span> <span class="toc-text">线程兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程对立"><span class="toc-number">9.1.5.</span> <span class="toc-text">线程对立</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收器"><span class="toc-number">10.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的分类"><span class="toc-number">10.1.</span> <span class="toc-text">垃圾回收器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评估GC的性能指标"><span class="toc-number">10.2.</span> <span class="toc-text">评估GC的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#吞吐量"><span class="toc-number">10.2.1.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#暂停时间"><span class="toc-number">10.2.2.</span> <span class="toc-text">暂停时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#吞吐量VS暂停时间"><span class="toc-number">10.2.3.</span> <span class="toc-text">吞吐量VS暂停时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器发展史"><span class="toc-number">10.3.</span> <span class="toc-text">垃圾收集器发展史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的组合关系"><span class="toc-number">10.4.</span> <span class="toc-text">垃圾回收器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看默认垃圾收集器"><span class="toc-number">10.5.</span> <span class="toc-text">查看默认垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial回收器"><span class="toc-number">10.5.1.</span> <span class="toc-text">Serial回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew回收器"><span class="toc-number">10.5.2.</span> <span class="toc-text">ParNew回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel回收器"><span class="toc-number">10.5.3.</span> <span class="toc-text">Parallel回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS回收器"><span class="toc-number">10.6.</span> <span class="toc-text">CMS回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMOS的特点"><span class="toc-number">10.6.1.</span> <span class="toc-text">CMOS的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">10.6.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-区域化分代式"><span class="toc-number">10.7.</span> <span class="toc-text">G1:区域化分代式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的特点"><span class="toc-number">10.7.1.</span> <span class="toc-text">G1的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的参数设置"><span class="toc-number">10.7.2.</span> <span class="toc-text">G1的参数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的使用场景"><span class="toc-number">10.7.3.</span> <span class="toc-text">G1的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Region"><span class="toc-number">10.7.4.</span> <span class="toc-text">Region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的垃圾回收过程"><span class="toc-number">10.7.5.</span> <span class="toc-text">G1的垃圾回收过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#记忆集与写屏障"><span class="toc-number">10.7.6.</span> <span class="toc-text">记忆集与写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1回收过程"><span class="toc-number">10.7.7.</span> <span class="toc-text">G1回收过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器总结"><span class="toc-number">10.8.</span> <span class="toc-text">垃圾回收器总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC日志分析"><span class="toc-number">10.9.</span> <span class="toc-text">GC日志分析</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">深入JVM2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/10/11/深入JVM2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解JVM虚拟机》第三版，在此感谢宋红康老师的JVM教程。承接上一篇博客<br>《深入JVM》</p>
<h2 id="性能监控、故障处理工具"><a href="#性能监控、故障处理工具" class="headerlink" title="性能监控、故障处理工具"></a>性能监控、故障处理工具</h2><p>恰当使用虚拟机故障处理、分析的工具可以提升我们分析数据、定位并解决<br>问题的效率  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/363.jpg" alt></p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>JVM Process Status Tool 虚拟机进程状况工具。可以列出正在运行的虚拟机<br>进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID</p>
<ul>
<li>jps -q 只输出LVMID，省略主类名称</li>
<li>jps -m 输出虚拟机进程启动时传递给主类main()函数的参数</li>
<li>jps -l 输出主类的全名，如果进程执行的是JAR包，则输出JAR路径</li>
<li>jps -v 输出虚拟机进程启动时的JVM参数</li>
</ul>
<p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/364.jpg" alt>  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/365.jpg" alt></p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>JVM Statistics Monitoring Tool 用于监视虚拟机各种运行状态信息的命<br>令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、<br>即时编译等运行时数据。命令格式如下<br>jstat [ option vmid [interval[s|ms] \[count] ]]<br>参数interval和count分别代表查询间隔和次数，如果省略这两个参数说明只<br>查询一次。假设需要每250毫秒查询一次进程2764垃圾收集情况，一共查询20<br>次，那么命令如下<br>jstat -gc 2764 250 20</p>
<h4 id="主要选项"><a href="#主要选项" class="headerlink" title="主要选项"></a>主要选项</h4><p>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收<br>集、运行期编译状况 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/1.jpg" alt></p>
<h4 id="执行样例"><a href="#执行样例" class="headerlink" title="执行样例"></a>执行样例</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/2.jpg" alt> 查询结果如下</p>
<ol>
<li>S0和S1分别代表Survivor0和Survivor1，都未占用空间</li>
<li>E代表Eden，占用了20%的空间</li>
<li>O代表老年代，未占用空间</li>
<li>YGC和YGCT分别代表Young GC和耗时，执行0次耗时0s</li>
<li>FGC和FGCT分别代表Full GC和耗时，执行0次耗时0s</li>
<li>GCT代表所有GC总耗时，耗时0s</li>
</ol>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>Configuration Info for Java 的作用是实时查看和调整虚拟机各项参数，<br>使用jps命令的-v参数可以查看虚拟机启动时显示指定的参数列表。当如果想<br>知道未被显示指定的参数的系统默认值，可以使用jinfo的-flag选项进行查<br>询，如果是JDK6或以上的版本，也可以使用 java -XX:PrintFlagsFinal<br>查看参数默认值。命令格式如下<br>jinfo [option] pid</p>
<h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><p>Memroy Mao for Java 用于生成堆转储快照（dump文件），还可以查询<br>finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用<br>的是哪种收集器等。命令格式如下<br>jmap [option] vmid</p>
<h4 id="主要选项-1"><a href="#主要选项-1" class="headerlink" title="主要选项"></a>主要选项</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/3.jpg" alt> </p>
<h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>JVM Heap Analysis Tool 与jmap搭配使用，来分析jmap生成的堆转储<br>快照。但一般不会使用</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>Stack Trace for Java 用于生成虚拟机当前时刻的线程快照。线程快照<br>就是当前虚拟机每一条线程正在执行的方法堆栈集合，生成线程快照的目<br>的通常是定位线程出现长时间停顿的原因，比如线程间死锁、死循环、请<br>求外部资源导致的长时间挂起，命令格式如下<br>jstack [option] vmid</p>
<h3 id="主要选项-2"><a href="#主要选项-2" class="headerlink" title="主要选项"></a>主要选项</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/4.jpg" alt></p>
<ul>
<li>-F 当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li>-l 除堆栈外，显示关于锁的附加信息</li>
<li>-m 如果调用到本地方法的话，可以显示C/C++的堆栈</li>
</ul>
<h3 id="基础工具总结"><a href="#基础工具总结" class="headerlink" title="基础工具总结"></a>基础工具总结</h3><ol>
<li>基础工具 用于支持基本的程序创建和运行<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/5.jpg" alt></li>
<li>安全 用于程序签名、设置安全测试等<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/6.jpg" alt></li>
<li>国际化 用于创建本地语言文件<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/7.jpg" alt></li>
<li>远程方法调用 用于跨Web或网络的服务交互<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/8.jpg" alt></li>
<li>部署工具 用于程序打包、发布和部署<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/9.jpg" alt></li>
<li>性能监控和故障处理 用于监控分析Java虚拟机运行信息，排查问题<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/10.jpg" alt></li>
<li>REPL和脚本工具<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/11.jpg" alt></li>
</ol>
<h3 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h3><p>JDK中除了附带大量的命令行工具外，还提供了几个功能集成度更高的可视化<br>工具。接下来着重介绍一下VisualVm</p>
<h4 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h4><p>All-in-one Java Troubleshooting Tool 是功能最强大的运行监视和故<br>障处理程序之一，并且可以通过插件扩展功能 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/12.jpg" alt></p>
<h4 id="样例展示"><a href="#样例展示" class="headerlink" title="样例展示"></a>样例展示</h4><ol>
<li>选择一个需要监视的程序就可以进入程序的主界面 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/13.jpg" alt></li>
<li>生成、浏览堆转储快照 在VisualVM中生成堆转储快照文件</li>
</ol>
<ul>
<li>在应用程序窗口中右键单击应用程序节点，然后选择堆Dump <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/14.jpg" alt></li>
</ul>
<p>生成堆转储快照文件后，应用程序页签会在该堆的应用程序下增加一个以 [he<br>ap-dump]开头的子节点。可以点击节点右键另存为磁盘文件，否则当进程结束<br>生成的快照文件会被自动处理</p>
<h2 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h2><p>这部分除了知识和工具外，还需要经验</p>
<h3 id="大内存硬件上的程序部署策略"><a href="#大内存硬件上的程序部署策略" class="headerlink" title="大内存硬件上的程序部署策略"></a>大内存硬件上的程序部署策略</h3><h3 id="集群间同步导致的内存溢出"><a href="#集群间同步导致的内存溢出" class="headerlink" title="集群间同步导致的内存溢出"></a>集群间同步导致的内存溢出</h3><h3 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h3><h3 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h3><h3 id="服务器虚拟机进程崩溃"><a href="#服务器虚拟机进程崩溃" class="headerlink" title="服务器虚拟机进程崩溃"></a>服务器虚拟机进程崩溃</h3><h3 id="不恰当数据结构导致内存占用过大"><a href="#不恰当数据结构导致内存占用过大" class="headerlink" title="不恰当数据结构导致内存占用过大"></a>不恰当数据结构导致内存占用过大</h3><h3 id="由Windows虚拟内存导致的长时间停顿"><a href="#由Windows虚拟内存导致的长时间停顿" class="headerlink" title="由Windows虚拟内存导致的长时间停顿"></a>由Windows虚拟内存导致的长时间停顿</h3><h3 id="由安全点导致的长时间停顿"><a href="#由安全点导致的长时间停顿" class="headerlink" title="由安全点导致的长时间停顿"></a>由安全点导致的长时间停顿</h3><h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="执行引擎的概述"><a href="#执行引擎的概述" class="headerlink" title="执行引擎的概述"></a>执行引擎的概述</h3><ol>
<li>虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区<br>别是物理机的执行引擎是建立在处理器、缓存、指令集合操作系统层面上，<br>而虚拟机的执行引擎是由软件自行实现，因此不受物理条件制约地定制指<br>令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式</li>
<li>JVM的主要任务是负责装载字节码到其内部，但字节码并不能直接运行在<br>操作系统上，因为字节码指令并非等价于本地机器指令，其内部包含的仅仅<br>只是一些能够被JVM所识别的字节码指令、符号表以及其它辅助信息</li>
<li>执行引擎的任务就是将字节码指令编译为对应平台的本地机器指令，也就<br>是将高级语言翻译成机器语言</li>
<li>执行引擎在执行字节码的时候，通过会有解释执行（通过解释器执行）和<br>编译执行（通过即时编译器产生本地代码）两种选择</li>
</ol>
<h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元，栈帧则是用于支持虚拟机进行方法<br>调用和方法执行背后的数据结构，栈帧中存储了方法的局部变量表、操作数栈<br>、动态连接和方法返回地址</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局<br>部变量。局部变量表以变量槽为最小单位，实例方法局部变量表中第0位索引<br>的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键<br>字this来访问</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也被称为操作栈，这是一个后入先出的栈</p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引<br>用是为了支持方法调用过程中的动态连接。常量池中有大量的符号引用，字节<br>码中的方法调用指令就以常量池中的符号引用为参数，这些符号引用一部分<br>在类加载阶段或者第一次使用就会转化为直接引用，这种转化成为静态解析<br>另一部分在运行期间转化为直接引用，称为动态连接</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法退出的过程实际上就等同于把当前栈帧出栈，恢复上层方法的局部变量表<br>和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈中，调整PC计数<br>器的值以指向方法调用指令后面的一条指令</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>调用不同类型的方法，字节码指令集设计了不同的指令</p>
<ul>
<li>invokestatic 调用静态方法</li>
<li>invokespecial 调用实例构造器、私有方法和父类中的方法</li>
<li>invokevirtual 调用虚方法</li>
<li>invokeinterface 调用接口方法，运行时确定一个实现该接口的对象</li>
<li>invokedynamic 现在运行时动态解析调用点限定符所引用的方法</li>
</ul>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>乍一看我会认为分别输出man和woman，然而结果都是guy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human guy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"guy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Man guy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Woman guy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        TT a=<span class="keyword">new</span> TT();</span><br><span class="line">        a.say(man);</span><br><span class="line">        a.say(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么虚拟机会执行Human的重载版本？对于以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man=<span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<p>Human称为变量的静态类型，Man称为变量的实际类型。虚拟机重载的时候是<br>根据参数的静态类型而不是实际类型作为判断依据，所有依赖静态类型来决<br>定方法执行版本的分派动作，都称为静态分派</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        man.say();</span><br><span class="line">        woman.say();</span><br><span class="line">        man=<span class="keyword">new</span> Woman();</span><br><span class="line">        man.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然选择调用的方法版本是不可能再根据静态类型决定，因为静态类型同样是<br>Human的两个变量man和woman在调用say()时产生不同行为，因为这两个变量<br>实际类型不同</p>
<h3 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h3><p>动态类型语言的关键特性是它的类型检查的主体过程是在运行器而不是编译器</p>
<h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><p>Java虚拟机的执行引擎在执行Java代码的时候都有解释执行和编译执行两种<br>选择</p>
<h2 id="类加载及执行子系统的案例与实战"><a href="#类加载及执行子系统的案例与实战" class="headerlink" title="类加载及执行子系统的案例与实战"></a>类加载及执行子系统的案例与实战</h2><p>主流的Java Web服务器，如Tomcat Jetty WebLogic等都实现自己的类加载<br>器，而且一般都不止一个，Web服务器需要解决如下问题</p>
<ul>
<li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以实现相互隔<br>离。服务器应当保证两个独立应用程序的类库可以相互独立使用</li>
<li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以相互共享</li>
<li>服务器需要尽可能保证自身的安全不受部署的Web应用影响</li>
</ul>
<h2 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h2><p>编译期是一个很模糊的概念，可能指前端编译器将.java文件转变为.class文<br>件，也可能指Java虚拟机的即时编译器（常称为JIT编译器，Just In Time<br>Compiler）运行期将字节码转变为本地机器码，还可能指使用静态的提前编<br>译器（常称AOT Ahead Of Time Compiler）直接把程序编译成与目标机器<br>指令集相关的二进制代码的过程</p>
<ul>
<li>前端编译器 JDK的Javac、Eclipse JDT中的增量式编译器</li>
<li>即时编译器 HotSpot虚拟机的C1、C2编译器，Graal编译器</li>
<li>提前编译器 JDK的Jaotc,GCJ,JET</li>
</ul>
<h3 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h3><p>这个编译器本身是由Java实现</p>
<h2 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h2><p>把Class文件转换为与本地基础设施相关的二进制机器码，都可以视为整个编<br>译过程的后端，《Java虚拟机规范》并没有规定后端编译器的实现细节，但是<br>后端编译器性能的好坏、代码优化质量的高低确是衡量一款商用虚拟机优秀<br>与否的关键指标之一</p>
<h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><p>多线程处理在现代计算机操作系统中几乎是一项必备的功能。一个很重要的原<br>因就是计算机的运算速度与它的存储和通信子系统的速度差距太大，如果不<br>希望处理器在大部分时间都处于等待其他资源的空闲状态，就可以让计算机<br>同时处理多个任务。一个服务端要同时对多个客户端提供服务，衡量一个服<br>务性能的好坏，每秒事务处理数（Transactions Per Second）是重要的<br>指标之一，TPS代表一秒内服务端平均能响应的请求总数</p>
<h3 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h3><p>绝大多数的运算任务都不可能只靠处理器计算就能完成，处理器至少要与内<br>存交互，如读取运算数据、存储运算结果。由于计算机的存储设备与处理器<br>的运算速度有几个数量级的差距，所以使用高速缓存作为缓冲：将运算需<br>要的数据复制到缓存中，让运算快速进行，运算结束后再从缓存同步到内<br>存之中。当高速缓存引入了一个问题：缓存一致性。在多路处理器系统中<br>每个处理器都有自己的高速缓存，而它们又共享同一主内存，这种系统<br>称为共享内存多核系统，当多个处理器的运算任务都涉及同一块主内存<br>区域时，将可能导致各自的内存数据不一致 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/24.jpg" alt><br>如果发生这种情况，那么同步到主内存时该以谁的缓存数据为准？为了<br>解决这个问题，需要各个处理器访问缓存时都遵循一些协议，在读写时<br>要根据协议来进行操作，比如MISI MESI MOSI Synapse Firefly</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>C和C++直接使用物理硬件和操作系统的内存模型，《Java虚拟机规范》<br>曾试图定义一种Java内存模型来屏蔽各种硬件和操作系统的内存访问<br>差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果<br>，必须保证让Java的并发内存访问操作不会产生歧义</p>
<h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><p>Java内存模型的主要目的就是定义程序中各种变量的访问规则，即关<br>注在虚拟机中把变量存储到内存和从内存中取出变量值这样的底层细<br>节，这里的变量包括实例字段、静态字段和构成数组对象的元素，不<br>包括局部变量和方法参数，因为后者是线程私有的，不会被共享也<br>就不存在同步问题。<br>Java内存还规定了所有变量都存储在主内存中，每条线程还有自己的<br>工作内存（可以与处理器高速缓存类比），线程的工作内存还保存了<br>该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工<br>作内存中进行，而不能直接读写子内存的数据，不同的线程也无法访<br>问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来<br>完成 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/25.jpg" alt></p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷<br>贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内<br>存模型定义了以下8种操作来完成。Java虚拟机实现时必须保证下面提及<br>的每一种操作都是原子的、不可再分的</p>
<ul>
<li>lock 作用于主内存的变量，把一个变量标识为一条线程独占的状态</li>
<li>unlock 作用于主内存的变量，把一个处于锁定状态的变量释放出来释<br>放后的变量才可以被其他线程锁定</li>
<li>read 作用于主内存的变量，把一个变量的值从主内存传输到线程的工<br>作内存，以便随后的load动作使用</li>
<li>load 作用于工作内存的变量，把read操作从主内存中得到的变量值放<br>入工作内存的变量副本中</li>
<li>use 作用于工作内存的变量，把工作内存中一个变量的值传递给执行引<br>擎，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>
<li>assign 作用于工作内存的变量，把一个从执行引擎接收到的值赋给工<br>作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个<br>操作</li>
<li>store 作用于工作内存的变量，把工作内存中一个变量的值传递到主内<br>存中，以便随后的write操作</li>
<li>write 作用于主内存的变量，把store操作从工作内存中得到的变量的<br>值放入主内存的变量中</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存，就要按照read和load的执行<br>操作，如果要把变量从工作内存同步回主内存，则要按照store和write<br>的执行顺序。Java内存模型还规定了执行上述8种基本操作时必须满足如<br>下规则</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃最近的assign操作，即变量在工作内存中改变了以<br>后必须把该变化同步回主内存</li>
<li>不允许一个线程无原因地（没有发生assign操作）把数据从线程的工作<br>内存同步回主内存中</li>
<li>一个变量同一时刻只允许一条线程对其进行lock操作，当lock操作可以<br>被同一条线程重复执行多次，多次执行lock后只有执行相同次数的unlock<br>操作才会被解锁</li>
<li>如果对一个变量执行lock操作，那么会清空工作内存中此变量的值，在<br>执行引擎使用这个变量之前，需要重新load或assign操作以初始化变量<br>的值</li>
<li>如果对一个变量事先没有被lock操作锁定，那么不允许执行unlock操作<br>也不允许unlock一个被其他线程锁定的变量</li>
<li>对一个变量执行unlock操作之前，必须把此变量同步回主内存中（执行<br>store write）</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>当一个变量被定义为volatile之后，它将具有两项特性：第一项是保证此<br>变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量<br>的值，新值对于其他线程来说是立即可知的，而普通变量不能做到这一点<br>普通变量的值在线程间传递均需要主内存来完成，比如线程A修改一个普<br>通变量的值，然后向主内存回写，另一条线程B在线程A回写完成再对主<br>内存进行读取操作，新变量值才会对线程B可见<br>volatile变量在各个线程的工作内存中是不存在一致性问题的（每次使用<br>前都要先刷新，执行引擎看不到不一致的情况，因此认为不存在一致性问<br>题），但是Java里面的运算操作符并非原子操作，这导致volatile变量<br>的运算在并发下一样是不安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT=<span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads=<span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;THREADS_COUNT;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            threads[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)</span><br><span class="line">                        increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">2</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预计的结果应该是200000，而在IDEA实际显示的结果是197403，问题就出在<br>自增运算race++中，查看字节码指令 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/15.jpg" alt><br>getstatic 指令把 race 的值取到操作数栈顶，volatile 关键字保证了race的<br>值在此时是正确的，但是在 iconst_1 、 iadd 这些指令的时候，其他线程可能<br>已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic<br>指令执行后就把较小的race值同步回主内存中。由于volatile变量只能保证可见<br>性，在不符合以下两条规则的场景中，仍然要通过加锁（syschronized java.<br>util.concurrent中的锁或原子类）来保证原子性</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
<li>当用synchronized修饰的方法执行时， 普通的方法时仍然可以访问<br>synchronized 方法中的变量的</li>
</ul>
<p>以下场景很适合使用volatile变量来控制并发，当shutdown()方法被调用时，能<br>保证所有线程中执行doWork()方法都立即停下来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shutdownRequested=<span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!shutdownRequested)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//代码的业务逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅会保证<br>在该方法执行过程中所有依赖赋值结果的地方都能获得正确结果，但不能保证<br>变量赋值操作的顺序与程序代码的执行顺序一致，因为在同一个线程的方法执<br>行过程中无法感知这点，这就是Java内存模型中描述的所谓线程内表现为串<br>行的语义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">//模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">//将initialized设置为true，通知其他线程配置使用</span></span><br><span class="line">configOptions=<span class="keyword">new</span> HashMap();</span><br><span class="line">configText=readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText,configOptions);</span><br><span class="line">initialized=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">//等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span>(!initialized)</span><br><span class="line">	sleep();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程A中初始化好的配置信息</span></span><br><span class="line">dosomethingWithConfig();</span><br></pre></td></tr></table></figure>
<p>如果定义initialized变量时没有使用volatile修饰，就可能由于指令重排序<br>的优化导致线程A最后一条代码 initialized=true被提前执行，这样在线程<br>B使用配置信息的代码就可能出现错误，volatile关键字能避免此类情况的发<br>生。volatile屏蔽指令重排序的语义在JDK5才被修复，以下是一段标准的双<br>锁检测单例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">			</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">					instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov $0x3375cdb0,%esi</span><br><span class="line">mov %eax,0x150(%esi)</span><br><span class="line">shr $0x9,%esi</span><br><span class="line">movb $0x0,0x1104800(%esi)</span><br><span class="line">&#x2F;&#x2F;注意如果使用volatile就会多一行</span><br><span class="line">lock addl $0x0,(%esp)</span><br></pre></td></tr></table></figure>
<p>这个操作的作用相当于一个内存屏障（指重排序时不能把后面的指令重排序到内存<br>屏障之前的位置），只有一个处理器访问内存时，并不需要内存屏障，但如果有多<br>个处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一<br>致性。lock的作用是将本处理器的缓存写入内存，该写入动作会引起别的处理器或<br>别的内核无效化其缓存，这种操作相当于对缓存中的变量做一次前面介绍的Java<br>内存模式中的store和write操作，通过这样一个空操作让前面volatile变量的<br>修改对其他处理器立即可见。之前有个问题就是一个处理器访问内存时并不需要<br>内存屏障这句话，一个处理器也会存在指令重排序，但是为什么不会出现问题，<br>我查了一下，有一种解释是单个处理器的情况下无需考虑线程安全，所谓的多<br>线程实际都是串行执行，并不存在真正的并发执行</p>
<h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>指令重排序是指处理器采用允许多条指令不按程序规定的顺序分开发送给各个相<br>应的电路单元进行处理，但并不是任意重排，处理器必须能够正确处理指令依<br>赖情况保障程序能得出正确的执行结果。比如指令1把地址A中的值加10，指令<br>2把地址A中的值乘以2，指令3把地址B中的值减去3，这是指令1和指令2是有<br>依赖的，它们之间的顺序不能重排，但是指令3可以任意位置。所以在同一个<br>处理器中，重排序过的代码看起来依然有序，lock指令把修改同步到内存中<br>意味着之前的操作都已经执行完成，这样便形成指令从排序无法越过内存屏<br>障的效果</p>
<h3 id="针对long和double型变量的特殊情况"><a href="#针对long和double型变量的特殊情况" class="headerlink" title="针对long和double型变量的特殊情况"></a>针对long和double型变量的特殊情况</h3><p>对于64位的数据类型，在模型中特别定义了一条宽松的规定，允许虚拟机将<br>没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行<br>，经过测试，目前主流平台下商用的64位Java虚拟机并不会出现非原子性<br>访问行为</p>
<h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个<br>特征来建立的</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>有Java 内存模型来直接保证的原型性变量操作包括 read load assign use<br>store write。基本数据类型的访问和读写都是具备原子性的，synchronized<br>块之间的操作也具备原子性</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性就是指当一个线程修改了共享变量的值时 ，其他线程能够立即得知这个<br>修改。Java 内存模型是通过在变量修改后将新值同步回追内存，在变量读取前<br>从主内存刷新变量值这种依赖主内存作为媒介的方式来实现可见性，valatile<br>保证多线程操作时变量的可见性，普通变量不能保证这一点。除了 volatile<br>Java还有两个关键字能实现可见性：synchronized和 final。同步块的可见<br>性是由“对一个变量执行unlock 操作之前（变量可以放在同步块中），必须<br>保证把此变量同步回主内存中”这条规则获得的。而final的可见性是指：被<br>final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的<br>引用传递出去，那么其他线程能够看到final字段的值，无需同步就能被其<br>他线程访问，还有一点需要注意，对一个变量执行unlock操作之前已经刷<br>新的次数是不确定的，在没有解锁之前如果在代码块的某一地方修改变量<br>的值可能立即刷新回主内存也可能不刷新，但是unlock之前一定会刷新<br>一次</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>如果在本线程内观察，所有的操作都是有序，如果在一个线程观察另一个线程，<br>所有的操作都是无序的，前半句是指线程内似表现为串行的语义，后半句是指<br>指令重排序现象和工作内存与主内存同步延迟现象</p>
<h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如操作A先行<br>发生于操作B，操作A的影响能被操作B观察到，影响包括修改内存中共享变量<br>的值、发送了消息、调用了方法等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下操作在线程A中执行</span></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//以下操作在线程B中执行</span></span><br><span class="line">j=i;</span><br><span class="line"><span class="comment">//以下操作在线程C中执行</span></span><br><span class="line">i=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果线程A中的操作先行发生于线程B，那么可以确定线程B的操作执行后j=1，<br>得出这个结论的依据是线程A已发生，线程C未发生。如果线程C发生在A和B之<br>间则无法确定j的值，因为线程C对变量i的操作可能被B观察到也可能不会。<br>注意时间先后顺序与先行发生原则之间基本没有因果关系</p>
<h3 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><p>并发不一定依赖多线程，但是在Java中谈论并发基本上与线程脱不开关系</p>
<h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>目前线程是Java里进行处理器资源调度的基本单位，每个已经调用过start<br>方法且还未结束的java.lang.Thread类的实例就代表一个线程。Thread类<br>的所有关键方法都被声明为Native，Native方法意味着这个方法没有使用<br>或无法使用平台无关的手段来实现。实现线程主要有三种方式：使用内核<br>线程实现（1:1），使用用户线程实现（1:N），使用用户线程加轻量级<br>进程混合实现（N:M）</p>
<h4 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h4><p>内核线程是直接由操作系统内核支持的线程，这种线程由内核来完成线程<br>切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到<br>各个处理器上，支持多线程的内核称为多线程内核。程序一般不会直接使<br>用内核线程，而是使用内核线程的一种高级接口–轻量级进程。轻量级<br>进程就是通常意义上的线程，每个轻量级进程都由一个内核线程支持，<br>轻量级进程与内核线程之间1:1的关系成为一对一的线程模型 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/16.jpg" alt></p>
<h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><p>使用用户线程实现的方式称为1:N实现，广义上讲一个线程只要不是内核<br>线程，都可以认为是用户线程。狭义上的用户线程指的是完全建立在用户<br>空间的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完<br>成，不需要内核帮助，这种进程与用户线程之间1:N的关系称为一对多<br>的线程模型  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/17.jpg" alt></p>
<h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>将内核线程与用户线程混合使用的实现方式 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/18.jpg" alt></p>
<h4 id="线程的实现-1"><a href="#线程的实现-1" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>以HotSpot虚拟机为例，它的每一个Java线程都是直接映射到一个操作系<br>统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己<br>是不会干涉线程调度，全权交由操作系统处理</p>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>线程状态转换关系 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/19.jpg" alt></p>
<h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><p>《Java并发编程实战》为线程安全做了一个比较恰当的定义：当多线程同时<br>访问一个对象时，如果不用考虑这些对象在运行时环境下的调度和交替执<br>行，也不需要进行额外的同步，或者在调用方进行任何其他的协作操作，<br>调用这个对象的行为都可以获得正确的结果，就称这个对象是线程安全<br>的</p>
<h3 id="Java语言的线程安全"><a href="#Java语言的线程安全" class="headerlink" title="Java语言的线程安全"></a>Java语言的线程安全</h3><p>可以将Java中的数据分为五类</p>
<ul>
<li>不可变</li>
<li>绝对线程安全</li>
<li>相对线程安全</li>
<li>线程兼容</li>
<li>线程对立</li>
</ul>
<h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变的对象一定是线程安全的，如果多线程共享的数据是一个基本数据类型<br>只要定义时使用final修饰就可以保证是不可变的，如果是一个对象，就需要<br>对象自行保证其行为不会对其状态产生任何影响，例如java.lang.String。<br>保证对象行为不影响自己状态的途径有很多种，最简单的一种就是把对象里<br>带有状态的变量都声明为final</p>
<h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>Java API中标注是线程安全的类大多数都不是绝对的线程安全</p>
<h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对线程安全就是通常意义上的线程安全，保证对这个对象单次操作是线程安<br>全的</p>
<h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>对象本身不是线程安全，但是通过在调用端正确使用同步手段来保证对象在并<br>发环境中可以安全使用</p>
<h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>不管调用端是否采取同步措施，都无法在多线程环境中使用并发代码</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="垃圾回收器的分类"><a href="#垃圾回收器的分类" class="headerlink" title="垃圾回收器的分类"></a>垃圾回收器的分类</h3><p>JDK的版本处于高速迭代过程，Java发展至今已经衍生了许多GC版本，<br>Java不同版本的新特性可以从三个方面分析</p>
<ul>
<li>语法层面 Lambda表达式、switch、自动装箱、自动拆箱、enum、&lt;&gt;</li>
<li>API层面 Stream API、新的时间日期、Optional、String、集合框架</li>
<li>底层优化 JVM优化、GC的变化、元空间、静态域、字符串常量池</li>
</ul>
<h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number276.jpg" alt></p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number277.jpg" alt></p>
<h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number278.jpg" alt> </p>
<h4 id="吞吐量VS暂停时间"><a href="#吞吐量VS暂停时间" class="headerlink" title="吞吐量VS暂停时间"></a>吞吐量VS暂停时间</h4><p>在最大吞吐量优先的情况下，降低停顿时间 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number279.jpg" alt></p>
<h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number280.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number281.jpg" alt></p>
<ul>
<li>串行回收器 Serial,Serial Old</li>
<li>并行回收器 ParNew,Scavenge,Parallel Old</li>
<li>并发回收器 CMS,G1</li>
</ul>
<h3 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number282.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number283.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number284.jpg" alt></p>
<h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><ul>
<li>-XX:+PrintCommandLineFlags 查看命令行相关参数</li>
<li>使用命令行 jinfo -flag 相关垃圾回收器参数 进程ID<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number285.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number286.jpg" alt></li>
</ul>
<h4 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number287.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number288.jpg" alt></p>
<ul>
<li>优点 简单高效，对于限定单个CPU的环境来说，Serial收集器由于没有<br>线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率，<br>运行在Client模式下的虚拟机是个不错的选择</li>
<li>-XX:+UseSerialGC 参数可以指定年轻代和老年代都是用串行收集器</li>
<li>对于交互性较强的应用而言，这种垃圾收集器是不能接受的</li>
</ul>
<h4 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h4><p>ParNew收集器除了采用并行回收的方式执行内存回收外，与Serial几乎<br>没有区别，只是针对年轻代的回收 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number289.jpg" alt></p>
<ul>
<li>-XX:+UseParNewGC</li>
<li>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的<br>线程数</li>
</ul>
<h4 id="Parallel回收器"><a href="#Parallel回收器" class="headerlink" title="Parallel回收器"></a>Parallel回收器</h4><p>吞吐量优先，是Java8默认的垃圾收集器 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number290.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number291.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number292.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number293.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number294.jpg" alt></p>
<h3 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number295.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number296.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number297.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number298.jpg" alt></p>
<h4 id="CMOS的特点"><a href="#CMOS的特点" class="headerlink" title="CMOS的特点"></a>CMOS的特点</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number299.jpg" alt><br>CMS收集器的垃圾收集算法是标记-清除算法，会产生垃圾碎片，如果使用<br>Compact整理内存的话，但是还要保证用户线程能够继续执行，用户的运<br>行资源不能受影响，所以标记-清除算法更合适 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number300.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number301.jpg" alt></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number302.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number303.jpg" alt></p>
<h3 id="G1-区域化分代式"><a href="#G1-区域化分代式" class="headerlink" title="G1:区域化分代式"></a>G1:区域化分代式</h3><p>官方给G1设定的目标是在延迟可控的条件下获得尽可能高的吞吐量，所以<br>才担起全功能收集器的重任与期望</p>
<ul>
<li>G1是一个并行回收器，它把堆内存分割为很多不相关的region（物理上<br>不连续），使用不同的region表示各个区</li>
<li>G1避免了在整个Java堆中进行全区域的垃圾收集，G1跟踪各个region里<br>面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要时间的经<br>验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价<br>值最大的region</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的region，所以我们给G1取<br>名垃圾优先<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number304.jpg" alt></li>
</ul>
<h4 id="G1的特点"><a href="#G1的特点" class="headerlink" title="G1的特点"></a>G1的特点</h4><ul>
<li>优点 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number305.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number306.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number307.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number308.jpg" alt></li>
<li>缺点 在用户程序运行时，G1无论是为了垃圾收集产生的内存占用还是程序<br>运行的额外执行负载都要比CMS高</li>
</ul>
<h4 id="G1的参数设置"><a href="#G1的参数设置" class="headerlink" title="G1的参数设置"></a>G1的参数设置</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number309.jpg" alt></p>
<h4 id="G1的使用场景"><a href="#G1的使用场景" class="headerlink" title="G1的使用场景"></a>G1的使用场景</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number310.jpg" alt></p>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number311.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number312.jpg" alt></p>
<h4 id="G1的垃圾回收过程"><a href="#G1的垃圾回收过程" class="headerlink" title="G1的垃圾回收过程"></a>G1的垃圾回收过程</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number313.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number314.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number315.jpg" alt></p>
<h4 id="记忆集与写屏障"><a href="#记忆集与写屏障" class="headerlink" title="记忆集与写屏障"></a>记忆集与写屏障</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number316.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number317.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number318.jpg" alt></p>
<h4 id="G1回收过程"><a href="#G1回收过程" class="headerlink" title="G1回收过程"></a>G1回收过程</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number319.jpg" alt> </p>
<ul>
<li>年轻代GC <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number320.jpg" alt></li>
<li>并发标记过程 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number321.jpg" alt></li>
<li>混合回收 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number322.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number323.jpg" alt></li>
<li>Full GC <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number324.jpg" alt></li>
</ul>
<h3 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number325.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number326.jpg" alt></p>
<h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number327.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number328.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number329.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number330.jpg" alt></p>
<ul>
<li>垃圾回收数据的分析 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number331.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number332.jpg" alt></li>
<li>Minor GC  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number333.jpg" alt></li>
<li>Full GC  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number334.jpg" alt></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/">https://skysea-gaoming.github.io/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/"><i class="fa fa-chevron-left">  </i><span>Java基础知识2</span></a></div><div class="next-post pull-right"><a href="/2020/10/05/VBlog2/"><span>VBlog2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/';
  this.page.identifier = '2020/10/11/深入JVM2/';
  this.page.title = '深入JVM2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>