<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入JVM2"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>深入JVM2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能监控、故障处理工具"><span class="toc-number">2.</span> <span class="toc-text">性能监控、故障处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jps"><span class="toc-number">2.1.</span> <span class="toc-text">jps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstat"><span class="toc-number">2.2.</span> <span class="toc-text">jstat</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要选项"><span class="toc-number">2.2.1.</span> <span class="toc-text">主要选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行样例"><span class="toc-number">2.2.2.</span> <span class="toc-text">执行样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jinfo"><span class="toc-number">2.3.</span> <span class="toc-text">jinfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmp"><span class="toc-number">2.4.</span> <span class="toc-text">jmp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要选项-1"><span class="toc-number">2.4.1.</span> <span class="toc-text">主要选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jhat"><span class="toc-number">2.5.</span> <span class="toc-text">jhat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack"><span class="toc-number">2.6.</span> <span class="toc-text">jstack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要选项-2"><span class="toc-number">2.7.</span> <span class="toc-text">主要选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础工具总结"><span class="toc-number">2.8.</span> <span class="toc-text">基础工具总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可视化故障处理工具"><span class="toc-number">2.9.</span> <span class="toc-text">可视化故障处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VisualVM"><span class="toc-number">2.9.1.</span> <span class="toc-text">VisualVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#样例展示"><span class="toc-number">2.9.2.</span> <span class="toc-text">样例展示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM面试题"><span class="toc-number">3.</span> <span class="toc-text">JVM面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前五章"><span class="toc-number">3.1.</span> <span class="toc-text">前五章</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调优案例分析与实战"><span class="toc-number">4.</span> <span class="toc-text">调优案例分析与实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#大内存硬件上的程序部署策略"><span class="toc-number">4.1.</span> <span class="toc-text">大内存硬件上的程序部署策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集群间同步导致的内存溢出"><span class="toc-number">4.2.</span> <span class="toc-text">集群间同步导致的内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆外内存导致的溢出错误"><span class="toc-number">4.3.</span> <span class="toc-text">堆外内存导致的溢出错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外部命令导致系统缓慢"><span class="toc-number">4.4.</span> <span class="toc-text">外部命令导致系统缓慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器虚拟机进程崩溃"><span class="toc-number">4.5.</span> <span class="toc-text">服务器虚拟机进程崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不恰当数据结构导致内存占用过大"><span class="toc-number">4.6.</span> <span class="toc-text">不恰当数据结构导致内存占用过大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#由Windows虚拟内存导致的长时间停顿"><span class="toc-number">4.7.</span> <span class="toc-text">由Windows虚拟内存导致的长时间停顿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#由安全点导致的长时间停顿"><span class="toc-number">4.8.</span> <span class="toc-text">由安全点导致的长时间停顿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机字节码执行引擎"><span class="toc-number">5.</span> <span class="toc-text">虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行引擎的概述"><span class="toc-number">5.1.</span> <span class="toc-text">执行引擎的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时栈帧结构"><span class="toc-number">5.2.</span> <span class="toc-text">运行时栈帧结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量表"><span class="toc-number">5.3.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作数栈"><span class="toc-number">5.4.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态连接"><span class="toc-number">5.5.</span> <span class="toc-text">动态连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法返回地址"><span class="toc-number">5.6.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法调用"><span class="toc-number">5.7.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态分派"><span class="toc-number">5.8.</span> <span class="toc-text">静态分派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态分派"><span class="toc-number">5.9.</span> <span class="toc-text">动态分派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态类型语言"><span class="toc-number">5.10.</span> <span class="toc-text">动态类型语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于栈的字节码解释执行引擎"><span class="toc-number">5.11.</span> <span class="toc-text">基于栈的字节码解释执行引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载及执行子系统的案例与实战"><span class="toc-number">6.</span> <span class="toc-text">类加载及执行子系统的案例与实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前端编译与优化"><span class="toc-number">7.</span> <span class="toc-text">前端编译与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Javac编译器"><span class="toc-number">7.1.</span> <span class="toc-text">Javac编译器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后端编译与优化"><span class="toc-number">8.</span> <span class="toc-text">后端编译与优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型与线程"><span class="toc-number">9.</span> <span class="toc-text">Java内存模型与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件的效率与一致性"><span class="toc-number">9.1.</span> <span class="toc-text">硬件的效率与一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存模型"><span class="toc-number">9.2.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主内存和工作内存"><span class="toc-number">9.2.1.</span> <span class="toc-text">主内存和工作内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存间交互操作"><span class="toc-number">9.3.</span> <span class="toc-text">内存间交互操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收器"><span class="toc-number">10.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的分类"><span class="toc-number">10.1.</span> <span class="toc-text">垃圾回收器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#评估GC的性能指标"><span class="toc-number">10.2.</span> <span class="toc-text">评估GC的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#吞吐量"><span class="toc-number">10.2.1.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#暂停时间"><span class="toc-number">10.2.2.</span> <span class="toc-text">暂停时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#吞吐量VS暂停时间"><span class="toc-number">10.2.3.</span> <span class="toc-text">吞吐量VS暂停时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器发展史"><span class="toc-number">10.3.</span> <span class="toc-text">垃圾收集器发展史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的组合关系"><span class="toc-number">10.4.</span> <span class="toc-text">垃圾回收器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看默认垃圾收集器"><span class="toc-number">10.5.</span> <span class="toc-text">查看默认垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial回收器"><span class="toc-number">10.5.1.</span> <span class="toc-text">Serial回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew回收器"><span class="toc-number">10.5.2.</span> <span class="toc-text">ParNew回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel回收器"><span class="toc-number">10.5.3.</span> <span class="toc-text">Parallel回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS回收器"><span class="toc-number">10.6.</span> <span class="toc-text">CMS回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMOS的特点"><span class="toc-number">10.6.1.</span> <span class="toc-text">CMOS的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">10.6.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-区域化分代式"><span class="toc-number">10.7.</span> <span class="toc-text">G1:区域化分代式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的特点"><span class="toc-number">10.7.1.</span> <span class="toc-text">G1的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的参数设置"><span class="toc-number">10.7.2.</span> <span class="toc-text">G1的参数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的使用场景"><span class="toc-number">10.7.3.</span> <span class="toc-text">G1的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Region"><span class="toc-number">10.7.4.</span> <span class="toc-text">Region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1的垃圾回收过程"><span class="toc-number">10.7.5.</span> <span class="toc-text">G1的垃圾回收过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#记忆集与写屏障"><span class="toc-number">10.7.6.</span> <span class="toc-text">记忆集与写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1回收过程"><span class="toc-number">10.7.7.</span> <span class="toc-text">G1回收过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器总结"><span class="toc-number">10.8.</span> <span class="toc-text">垃圾回收器总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC日志分析"><span class="toc-number">10.9.</span> <span class="toc-text">GC日志分析</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1602420731963&amp;di=032f7d4d661e3091e66c2accca9403d1&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn19%2Fw1600h924%2F20180314%2F4ac2-fyscsmv6453502.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">深入JVM2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/10/11/深入JVM2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解JVM虚拟机》第三版，在此感谢宋红康老师的JVM教程。承接上一篇博客<br>《深入JVM》</p>
<h2 id="性能监控、故障处理工具"><a href="#性能监控、故障处理工具" class="headerlink" title="性能监控、故障处理工具"></a>性能监控、故障处理工具</h2><p>恰当使用虚拟机故障处理、分析的工具可以提升我们分析数据、定位并解决<br>问题的效率  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/363.jpg" alt></p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>JVM Process Status Tool 虚拟机进程状况工具。可以列出正在运行的虚拟机<br>进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID</p>
<ul>
<li>jps -q 只输出LVMID，省略主类名称</li>
<li>jps -m 输出虚拟机进程启动时传递给主类main()函数的参数</li>
<li>jps -l 输出主类的全名，如果进程执行的是JAR包，则输出JAR路径</li>
<li>jps -v 输出虚拟机进程启动时的JVM参数</li>
</ul>
<p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/364.jpg" alt>  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/365.jpg" alt></p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>JVM Statistics Monitoring Tool 用于监视虚拟机各种运行状态信息的命<br>令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、<br>即时编译等运行时数据。命令格式如下<br>jstat [ option vmid [interval[s|ms] \[count] ]]<br>参数interval和count分别代表查询间隔和次数，如果省略这两个参数说明只<br>查询一次。假设需要每250毫秒查询一次进程2764垃圾收集情况，一共查询20<br>次，那么命令如下<br>jstat -gc 2764 250 20</p>
<h4 id="主要选项"><a href="#主要选项" class="headerlink" title="主要选项"></a>主要选项</h4><p>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收<br>集、运行期编译状况 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/1.jpg" alt></p>
<h4 id="执行样例"><a href="#执行样例" class="headerlink" title="执行样例"></a>执行样例</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/2.jpg" alt> 查询结果如下</p>
<ol>
<li>S0和S1分别代表Survivor0和Survivor1，都未占用空间</li>
<li>E代表Eden，占用了20%的空间</li>
<li>O代表老年代，未占用空间</li>
<li>YGC和YGCT分别代表Young GC和耗时，执行0次耗时0s</li>
<li>FGC和FGCT分别代表Full GC和耗时，执行0次耗时0s</li>
<li>GCT代表所有GC总耗时，耗时0s</li>
</ol>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>Configuration Info for Java 的作用是实时查看和调整虚拟机各项参数，<br>使用jps命令的-v参数可以查看虚拟机启动时显示指定的参数列表。当如果想<br>知道未被显示指定的参数的系统默认值，可以使用jinfo的-flag选项进行查<br>询，如果是JDK6或以上的版本，也可以使用 java -XX:PrintFlagsFinal<br>查看参数默认值。命令格式如下<br>jinfo [option] pid</p>
<h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><p>Memroy Mao for Java 用于生成堆转储快照（dump文件），还可以查询<br>finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用<br>的是哪种收集器等。命令格式如下<br>jmap [option] vmid</p>
<h4 id="主要选项-1"><a href="#主要选项-1" class="headerlink" title="主要选项"></a>主要选项</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/3.jpg" alt> </p>
<h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>JVM Heap Analysis Tool 与jmap搭配使用，来分析jmap生成的堆转储<br>快照。但一般不会使用</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>Stack Trace for Java 用于生成虚拟机当前时刻的线程快照。线程快照<br>就是当前虚拟机每一条线程正在执行的方法堆栈集合，生成线程快照的目<br>的通常是定位线程出现长时间停顿的原因，比如线程间死锁、死循环、请<br>求外部资源导致的长时间挂起，命令格式如下<br>jstack [option] vmid</p>
<h3 id="主要选项-2"><a href="#主要选项-2" class="headerlink" title="主要选项"></a>主要选项</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/4.jpg" alt></p>
<ul>
<li>-F 当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li>-l 除堆栈外，显示关于锁的附加信息</li>
<li>-m 如果调用到本地方法的话，可以显示C/C++的堆栈</li>
</ul>
<h3 id="基础工具总结"><a href="#基础工具总结" class="headerlink" title="基础工具总结"></a>基础工具总结</h3><ol>
<li>基础工具 用于支持基本的程序创建和运行<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/5.jpg" alt></li>
<li>安全 用于程序签名、设置安全测试等<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/6.jpg" alt></li>
<li>国际化 用于创建本地语言文件<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/7.jpg" alt></li>
<li>远程方法调用 用于跨Web或网络的服务交互<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/8.jpg" alt></li>
<li>部署工具 用于程序打包、发布和部署<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/9.jpg" alt></li>
<li>性能监控和故障处理 用于监控分析Java虚拟机运行信息，排查问题<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/10.jpg" alt></li>
<li>REPL和脚本工具<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/11.jpg" alt></li>
</ol>
<h3 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h3><p>JDK中除了附带大量的命令行工具外，还提供了几个功能集成度更高的可视化<br>工具。接下来着重介绍一下VisualVm</p>
<h4 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h4><p>All-in-one Java Troubleshooting Tool 是功能最强大的运行监视和故<br>障处理程序之一，并且可以通过插件扩展功能 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/12.jpg" alt></p>
<h4 id="样例展示"><a href="#样例展示" class="headerlink" title="样例展示"></a>样例展示</h4><ol>
<li>选择一个需要监视的程序就可以进入程序的主界面 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/13.jpg" alt></li>
<li>生成、浏览堆转储快照 在VisualVM中生成堆转储快照文件</li>
</ol>
<ul>
<li>在应用程序窗口中右键单击应用程序节点，然后选择堆Dump <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/14.jpg" alt></li>
</ul>
<p>生成堆转储快照文件后，应用程序页签会在该堆的应用程序下增加一个以 [he<br>ap-dump]开头的子节点。可以点击节点右键另存为磁盘文件，否则当进程结束<br>生成的快照文件会被自动处理</p>
<h2 id="JVM面试题"><a href="#JVM面试题" class="headerlink" title="JVM面试题"></a>JVM面试题</h2><p>以下这些面试题都来源于牛客网，解答也都在牛客网</p>
<h3 id="前五章"><a href="#前五章" class="headerlink" title="前五章"></a>前五章</h3><ol>
<li>谈谈你对JVM的理解<br>JVM的作用，JVM的具体内容，JVM的特点</li>
<li>JVM的最大内存限制</li>
<li>JVM的内存模型</li>
<li>JVM分区<br>这个题与第三题是一个意思</li>
<li>可以给JVM设置一些参数，如Xmx256m表示JVM的最大可用内存？</li>
<li>下列关于JDK、JRE、JVM 关系的描述<br>JDK包含JRE，JRE包含JVM</li>
<li>哪一种算法不属于JVM垃圾回收算法<br>A. 标记清除算法<br>B. 标记整理算法<br>C. 复制算法<br>D. 引用计数法</li>
<li>关于JVM的内存结构描述不正确的是<br>A. JAVA的栈内存不是线程共享的<br>B. 堆内存是用于存储JAVA对象的区域<br>C. PC寄存器也存在内存溢出风险<br>D. 本地方法栈也存在内存溢出风险</li>
<li>JVM内存不包含如下哪个部分<br>A. Stacks<br>B. PC寄存器<br>C. Heap<br>D. Heap Frame</li>
<li>编写一个程序，它能导致JVM抛出一个OOM, 然后捕获和处理这个错误</li>
<li>程序员可以根据需要控制JVM在特定时间进行垃圾回收？</li>
<li>假如某个JAVA进程的JVM参数配置如下：</li>
</ol>
<p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M<br>-XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,<br>请问eden区最终分配的大小是多少？<br>13. JVM的回收算法以及它的回收器是什么？还有CMS采用哪种回收算法？<br>使用CMS怎样解决内存碎片的问题呢<br>14. 可以用于生成JVM进程堆快照的命令是？<br>15. jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件<br>可能有哪些<br>16. 以下哪些jvm的垃圾回收方式采用的是复制算法回收<br>17. JVM的永久代中会发生垃圾回收么？<br>18. -Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3<br>,其最小内存值和Survivor区总大小分别是（）<br>19. 下面哪种情况会导致持久区jvm堆内存溢出？<br>A. 循环上万次的字符串处理<br>B. 在一段代码内申请上百M甚至上G的内存<br>C. 使用CGLib技术直接操作字节码运行，生成大量的动态类<br>D. 不断创建对象</p>
<h2 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h2><p>这部分除了知识和工具外，还需要经验</p>
<h3 id="大内存硬件上的程序部署策略"><a href="#大内存硬件上的程序部署策略" class="headerlink" title="大内存硬件上的程序部署策略"></a>大内存硬件上的程序部署策略</h3><h3 id="集群间同步导致的内存溢出"><a href="#集群间同步导致的内存溢出" class="headerlink" title="集群间同步导致的内存溢出"></a>集群间同步导致的内存溢出</h3><h3 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h3><h3 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h3><h3 id="服务器虚拟机进程崩溃"><a href="#服务器虚拟机进程崩溃" class="headerlink" title="服务器虚拟机进程崩溃"></a>服务器虚拟机进程崩溃</h3><h3 id="不恰当数据结构导致内存占用过大"><a href="#不恰当数据结构导致内存占用过大" class="headerlink" title="不恰当数据结构导致内存占用过大"></a>不恰当数据结构导致内存占用过大</h3><h3 id="由Windows虚拟内存导致的长时间停顿"><a href="#由Windows虚拟内存导致的长时间停顿" class="headerlink" title="由Windows虚拟内存导致的长时间停顿"></a>由Windows虚拟内存导致的长时间停顿</h3><h3 id="由安全点导致的长时间停顿"><a href="#由安全点导致的长时间停顿" class="headerlink" title="由安全点导致的长时间停顿"></a>由安全点导致的长时间停顿</h3><h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="执行引擎的概述"><a href="#执行引擎的概述" class="headerlink" title="执行引擎的概述"></a>执行引擎的概述</h3><ol>
<li>虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区<br>别是物理机的执行引擎是建立在处理器、缓存、指令集合操作系统层面上，<br>而虚拟机的执行引擎是由软件自行实现，因此不受物理条件制约地定制指<br>令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式</li>
<li>JVM的主要任务是负责装载字节码到其内部，但字节码并不能直接运行在<br>操作系统上，因为字节码指令并非等价于本地机器指令，其内部包含的仅仅<br>只是一些能够被JVM所识别的字节码指令、符号表以及其它辅助信息</li>
<li>执行引擎的任务就是将字节码指令编译为对应平台的本地机器指令，也就<br>是将高级语言翻译成机器语言</li>
<li>执行引擎在执行字节码的时候，通过会有解释执行（通过解释器执行）和<br>编译执行（通过即时编译器产生本地代码）两种选择</li>
</ol>
<h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元，栈帧则是用于支持虚拟机进行方法<br>调用和方法执行背后的数据结构，栈帧中存储了方法的局部变量表、操作数栈<br>、动态连接和方法返回地址</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局<br>部变量。局部变量表以变量槽为最小单位，实例方法局部变量表中第0位索引<br>的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键<br>字this来访问</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也被称为操作栈，这是一个后入先出的栈</p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引<br>用是为了支持方法调用过程中的动态连接。常量池中有大量的符号引用，字节<br>码中的方法调用指令就以常量池中的符号引用为参数，这些符号引用一部分<br>在类加载阶段或者第一次使用就会转化为直接引用，这种转化成为静态解析<br>另一部分在运行期间转化为直接引用，称为动态连接</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法退出的过程实际上就等同于把当前栈帧出栈，恢复上层方法的局部变量表<br>和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈中，调整PC计数<br>器的值以指向方法调用指令后面的一条指令</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>调用不同类型的方法，字节码指令集设计了不同的指令</p>
<ul>
<li>invokestatic 调用静态方法</li>
<li>invokespecial 调用实例构造器、私有方法和父类中的方法</li>
<li>invokevirtual 调用虚方法</li>
<li>invokeinterface 调用接口方法，运行时确定一个实现该接口的对象</li>
<li>invokedynamic 现在运行时动态解析调用点限定符所引用的方法</li>
</ul>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>乍一看我会认为分别输出man和woman，然而结果都是guy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human guy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"guy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Man guy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Woman guy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        TT a=<span class="keyword">new</span> TT();</span><br><span class="line">        a.say(man);</span><br><span class="line">        a.say(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么虚拟机会执行Human的重载版本？对于以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man=<span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>
<p>Human称为变量的静态类型，Man称为变量的实际类型。虚拟机重载的时候是<br>根据参数的静态类型而不是实际类型作为判断依据，所有依赖静态类型来决<br>定方法执行版本的分派动作，都称为静态分派</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        man.say();</span><br><span class="line">        woman.say();</span><br><span class="line">        man=<span class="keyword">new</span> Woman();</span><br><span class="line">        man.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然选择调用的方法版本是不可能再根据静态类型决定，因为静态类型同样是<br>Human的两个变量man和woman在调用say()时产生不同行为，因为这两个变量<br>实际类型不同</p>
<h3 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h3><p>动态类型语言的关键特性是它的类型检查的主体过程是在运行器而不是编译器</p>
<h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><p>Java虚拟机的执行引擎在执行Java代码的时候都有解释执行和编译执行两种<br>选择</p>
<h2 id="类加载及执行子系统的案例与实战"><a href="#类加载及执行子系统的案例与实战" class="headerlink" title="类加载及执行子系统的案例与实战"></a>类加载及执行子系统的案例与实战</h2><p>主流的Java Web服务器，如Tomcat Jetty WebLogic等都实现自己的类加载<br>器，而且一般都不止一个，Web服务器需要解决如下问题</p>
<ul>
<li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以实现相互隔<br>离。服务器应当保证两个独立应用程序的类库可以相互独立使用</li>
<li>部署在同一服务器上的两个Web应用程序所使用的Java类库可以相互共享</li>
<li>服务器需要尽可能保证自身的安全不受部署的Web应用影响</li>
</ul>
<h2 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h2><p>编译期是一个很模糊的概念，可能指前端编译器将.java文件转变为.class文<br>件，也可能指Java虚拟机的即时编译器（常称为JIT编译器，Just In Time<br>Compiler）运行期将字节码转变为本地机器码，还可能指使用静态的提前编<br>译器（常称AOT Ahead Of Time Compiler）直接把程序编译成与目标机器<br>指令集相关的二进制代码的过程</p>
<ul>
<li>前端编译器 JDK的Javac、Eclipse JDT中的增量式编译器</li>
<li>即时编译器 HotSpot虚拟机的C1、C2编译器，Graal编译器</li>
<li>提前编译器 JDK的Jaotc,GCJ,JET</li>
</ul>
<h3 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h3><p>这个编译器本身是由Java实现</p>
<h2 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h2><p>把Class文件转换为与本地基础设施相关的二进制机器码，都可以视为整个编<br>译过程的后端，《Java虚拟机规范》并没有规定后端编译器的实现细节，但是<br>后端编译器性能的好坏、代码优化质量的高低确是衡量一款商用虚拟机优秀<br>与否的关键指标之一</p>
<h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><p>多线程处理在现代计算机操作系统中几乎是一项必备的功能。一个很重要的原<br>因就是计算机的运算速度与它的存储和通信子系统的速度差距太大，如果不<br>希望处理器在大部分时间都处于等待其他资源的空闲状态，就可以让计算机<br>同时处理多个任务。一个服务端要同时对多个客户端提供服务，衡量一个服<br>务性能的好坏，每秒事务处理数（Transactions Per Second）是重要的<br>指标之一，TPS代表一秒内服务端平均能响应的请求总数</p>
<h3 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h3><p>绝大多数的运算任务都不可能只靠处理器计算就能完成，处理器至少要与内<br>存交互，如读取运算数据、存储运算结果。由于计算机的存储设备与处理器<br>的运算速度有几个数量级的差距，所以使用高速缓存作为缓冲：将运算需<br>要的数据复制到缓存中，让运算快速进行，运算结束后再从缓存同步到内<br>存之中。当高速缓存引入了一个问题：缓存一致性。在多路处理器系统中<br>每个处理器都有自己的高速缓存，而它们又共享同一主内存，这种系统<br>称为共享内存多核系统，当多个处理器的运算任务都涉及同一块主内存<br>区域时，将可能导致各自的内存数据不一致 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/24.jpg" alt><br>如果发生这种情况，那么同步到主内存时该以谁的缓存数据为准？为了<br>解决这个问题，需要各个处理器访问缓存时都遵循一些协议，在读写时<br>要根据协议来进行操作，比如MISI MESI MOSI Synapse Firefly</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>C和C++直接使用物理硬件和操作系统的内存模型，《Java虚拟机规范》<br>曾试图定义一种Java内存模型来屏蔽各种硬件和操作系统的内存访问<br>差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果<br>，必须保证让Java的并发内存访问操作不会产生歧义</p>
<h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><p>Java内存模型的主要目的就是定义程序中各种变量的访问规则，即关<br>注在虚拟机中把变量存储到内存和从内存中取出变量值这样的底层细<br>节，这里的变量包括实例字段、静态字段和构成数组对象的元素，不<br>包括局部变量和方法参数，因为后者是线程私有的，不会被共享也<br>就不存在同步问题<br>Java内存还规定了所有变量都存储在主内存中，每条线程还有自己的<br>工作内存（可以与处理器高速缓存类比），线程的工作内存还保存了<br>该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工<br>作内存中进行，而不能直接读写子内存的数据，不同的线程也无法访<br>问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来<br>完成 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/25.jpg" alt></p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="垃圾回收器的分类"><a href="#垃圾回收器的分类" class="headerlink" title="垃圾回收器的分类"></a>垃圾回收器的分类</h3><p>JDK的版本处于高速迭代过程，Java发展至今已经衍生了许多GC版本，<br>Java不同版本的新特性可以从三个方面分析</p>
<ul>
<li>语法层面 Lambda表达式、switch、自动装箱、自动拆箱、enum、&lt;&gt;</li>
<li>API层面 Stream API、新的时间日期、Optional、String、集合框架</li>
<li>底层优化 JVM优化、GC的变化、元空间、静态域、字符串常量池</li>
</ul>
<h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number276.jpg" alt></p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number277.jpg" alt></p>
<h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number278.jpg" alt> </p>
<h4 id="吞吐量VS暂停时间"><a href="#吞吐量VS暂停时间" class="headerlink" title="吞吐量VS暂停时间"></a>吞吐量VS暂停时间</h4><p>在最大吞吐量优先的情况下，降低停顿时间 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number279.jpg" alt></p>
<h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number280.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number281.jpg" alt></p>
<ul>
<li>串行回收器 Serial,Serial Old</li>
<li>并行回收器 ParNew,Scavenge,Parallel Old</li>
<li>并发回收器 CMS,G1</li>
</ul>
<h3 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number282.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number283.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number284.jpg" alt></p>
<h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><ul>
<li>-XX:+PrintCommandLineFlags 查看命令行相关参数</li>
<li>使用命令行 jinfo -flag 相关垃圾回收器参数 进程ID<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number285.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number286.jpg" alt></li>
</ul>
<h4 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number287.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number288.jpg" alt></p>
<ul>
<li>优点 简单高效，对于限定单个CPU的环境来说，Serial收集器由于没有<br>线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率，<br>运行在Client模式下的虚拟机是个不错的选择</li>
<li>-XX:+UseSerialGC 参数可以指定年轻代和老年代都是用串行收集器</li>
<li>对于交互性较强的应用而言，这种垃圾收集器是不能接受的</li>
</ul>
<h4 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h4><p>ParNew收集器除了采用并行回收的方式执行内存回收外，与Serial几乎<br>没有区别，只是针对年轻代的回收 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number289.jpg" alt></p>
<ul>
<li>-XX:+UseParNewGC</li>
<li>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的<br>线程数</li>
</ul>
<h4 id="Parallel回收器"><a href="#Parallel回收器" class="headerlink" title="Parallel回收器"></a>Parallel回收器</h4><p>吞吐量优先，是Java8默认的垃圾收集器 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number290.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number291.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number292.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number293.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number294.jpg" alt></p>
<h3 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number295.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number296.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number297.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number298.jpg" alt></p>
<h4 id="CMOS的特点"><a href="#CMOS的特点" class="headerlink" title="CMOS的特点"></a>CMOS的特点</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number299.jpg" alt><br>CMS收集器的垃圾收集算法是标记-清除算法，会产生垃圾碎片，如果使用<br>Compact整理内存的话，但是还要保证用户线程能够继续执行，用户的运<br>行资源不能受影响，所以标记-清除算法更合适 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number300.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number301.jpg" alt></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number302.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number303.jpg" alt></p>
<h3 id="G1-区域化分代式"><a href="#G1-区域化分代式" class="headerlink" title="G1:区域化分代式"></a>G1:区域化分代式</h3><p>官方给G1设定的目标是在延迟可控的条件下获得尽可能高的吞吐量，所以<br>才担起全功能收集器的重任与期望</p>
<ul>
<li>G1是一个并行回收器，它把堆内存分割为很多不相关的region（物理上<br>不连续），使用不同的region表示各个区</li>
<li>G1避免了在整个Java堆中进行全区域的垃圾收集，G1跟踪各个region里<br>面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需要时间的经<br>验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价<br>值最大的region</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的region，所以我们给G1取<br>名垃圾优先<br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number304.jpg" alt></li>
</ul>
<h4 id="G1的特点"><a href="#G1的特点" class="headerlink" title="G1的特点"></a>G1的特点</h4><ul>
<li>优点 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number305.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number306.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number307.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number308.jpg" alt></li>
<li>缺点 在用户程序运行时，G1无论是为了垃圾收集产生的内存占用还是程序<br>运行的额外执行负载都要比CMS高</li>
</ul>
<h4 id="G1的参数设置"><a href="#G1的参数设置" class="headerlink" title="G1的参数设置"></a>G1的参数设置</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number309.jpg" alt></p>
<h4 id="G1的使用场景"><a href="#G1的使用场景" class="headerlink" title="G1的使用场景"></a>G1的使用场景</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number310.jpg" alt></p>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number311.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number312.jpg" alt></p>
<h4 id="G1的垃圾回收过程"><a href="#G1的垃圾回收过程" class="headerlink" title="G1的垃圾回收过程"></a>G1的垃圾回收过程</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number313.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number314.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number315.jpg" alt></p>
<h4 id="记忆集与写屏障"><a href="#记忆集与写屏障" class="headerlink" title="记忆集与写屏障"></a>记忆集与写屏障</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number316.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number317.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number318.jpg" alt></p>
<h4 id="G1回收过程"><a href="#G1回收过程" class="headerlink" title="G1回收过程"></a>G1回收过程</h4><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number319.jpg" alt> </p>
<ul>
<li>年轻代GC <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number320.jpg" alt></li>
<li>并发标记过程 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number321.jpg" alt></li>
<li>混合回收 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number322.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number323.jpg" alt></li>
<li>Full GC <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number324.jpg" alt></li>
</ul>
<h3 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number325.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number326.jpg" alt></p>
<h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><p><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number327.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number328.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number329.jpg" alt><br><img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number330.jpg" alt></p>
<ul>
<li>垃圾回收数据的分析 <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number331.jpg" alt> <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number332.jpg" alt></li>
<li>Minor GC  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number333.jpg" alt></li>
<li>Full GC  <img src="/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/number334.jpg" alt></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/">https://skysea-gaoming.github.io/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/17/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/"><i class="fa fa-chevron-left">  </i><span>Java基础知识2</span></a></div><div class="next-post pull-right"><a href="/2020/10/05/VBlog2/"><span>VBlog2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2020/10/11/%E6%B7%B1%E5%85%A5JVM2/';
  this.page.identifier = '2020/10/11/深入JVM2/';
  this.page.title = '深入JVM2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1602420731963&amp;di=032f7d4d661e3091e66c2accca9403d1&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn19%2Fw1600h924%2F20180314%2F4ac2-fyscsmv6453502.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>