<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux常用命令"><meta name="keywords" content="System"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Linux常用命令 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件管理命令"><span class="toc-number">2.</span> <span class="toc-text">文件管理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cat命令"><span class="toc-number">2.1.</span> <span class="toc-text">cat命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chmod-命令"><span class="toc-number">2.2.</span> <span class="toc-text">chmod 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chown-命令"><span class="toc-number">2.3.</span> <span class="toc-text">chown 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件的操作命令-增删改查"><span class="toc-number">2.3.1.</span> <span class="toc-text">文件的操作命令(增删改查)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-目录树"><span class="toc-number">2.4.</span> <span class="toc-text">Linux 目录树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-基本命令"><span class="toc-number">2.5.</span> <span class="toc-text">Linux 基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#目录切换命令"><span class="toc-number">2.5.1.</span> <span class="toc-text">目录切换命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#目录的操作命令-增删改查"><span class="toc-number">2.5.2.</span> <span class="toc-text">目录的操作命令(增删改查)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#压缩文件的操作命令"><span class="toc-number">2.5.3.</span> <span class="toc-text">压缩文件的操作命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解压压缩包"><span class="toc-number">2.5.4.</span> <span class="toc-text">解压压缩包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-的权限命令"><span class="toc-number">2.5.5.</span> <span class="toc-text">Linux 的权限命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他常用命令"><span class="toc-number">2.6.</span> <span class="toc-text">其他常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#网络通信命令"><span class="toc-number">2.6.1.</span> <span class="toc-text">网络通信命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程上下文切换？"><span class="toc-number">2.7.</span> <span class="toc-text">进程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断上下文切换？"><span class="toc-number">2.8.</span> <span class="toc-text">中断上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么线程切换会有消耗，消耗啥？"><span class="toc-number">2.9.</span> <span class="toc-text">为什么线程切换会有消耗，消耗啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何查看上下文切换情况？"><span class="toc-number">2.10.</span> <span class="toc-text">如何查看上下文切换情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步、互斥和通信的区别？"><span class="toc-number">2.11.</span> <span class="toc-text">进程同步、互斥和通信的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程是什么？"><span class="toc-number">2.12.</span> <span class="toc-text">协程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么是轻量级的线程？"><span class="toc-number">2.13.</span> <span class="toc-text">为什么是轻量级的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程和线程的区别？"><span class="toc-number">2.14.</span> <span class="toc-text">协程和线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux下如何查看tcp连接？"><span class="toc-number">2.15.</span> <span class="toc-text">Linux下如何查看tcp连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络监听需要什么函数？"><span class="toc-number">2.16.</span> <span class="toc-text">网络监听需要什么函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁和信号量的区别？"><span class="toc-number">2.17.</span> <span class="toc-text">互斥锁和信号量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁与自旋锁的区别？"><span class="toc-number">2.18.</span> <span class="toc-text">互斥锁与自旋锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"><span class="toc-number">2.19.</span> <span class="toc-text">sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘坏掉了，操作系统是怎么处理应对的？"><span class="toc-number">2.20.</span> <span class="toc-text">磁盘坏掉了，操作系统是怎么处理应对的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存？"><span class="toc-number">2.21.</span> <span class="toc-text">缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的内存空间分布？"><span class="toc-number">2.22.</span> <span class="toc-text">进程的内存空间分布？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是中断？"><span class="toc-number">2.23.</span> <span class="toc-text">什么是中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU在中断时会干嘛？"><span class="toc-number">2.24.</span> <span class="toc-text">CPU在中断时会干嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断分为几种？"><span class="toc-number">2.25.</span> <span class="toc-text">中断分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何处理中断？"><span class="toc-number">2.26.</span> <span class="toc-text">如何处理中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断程序处理过程？"><span class="toc-number">2.27.</span> <span class="toc-text">中断程序处理过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要内核态-用户态？"><span class="toc-number">2.28.</span> <span class="toc-text">为什么要内核态&#x2F;用户态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fd是什么？"><span class="toc-number">2.29.</span> <span class="toc-text">fd是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用怎么解决阻塞IO-存在的问题？"><span class="toc-number">2.30.</span> <span class="toc-text">多路复用怎么解决阻塞IO 存在的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看内存的命令？"><span class="toc-number">2.31.</span> <span class="toc-text">查看内存的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看日志的命令？"><span class="toc-number">2.32.</span> <span class="toc-text">查看日志的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-查看文件中是否存在某字符"><span class="toc-number">2.33.</span> <span class="toc-text">Linux 查看文件中是否存在某字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux如何分割文件字符串？"><span class="toc-number">2.34.</span> <span class="toc-text">linux如何分割文件字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的消息队列以及区别？"><span class="toc-number">2.35.</span> <span class="toc-text">常用的消息队列以及区别？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Linux常用命令</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/23/Linux2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/23/Linux2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>1</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《鸟哥的Linux私房菜》 《现代操作系统》<br><a href="https://blog.csdn.net/SakuraA6/article/details/108810916" target="_blank" rel="noopener">https://blog.csdn.net/SakuraA6/article/details/108810916</a></p>
<h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>cat命令用于连接文件并打印到标准输出设备上，cat主要有三大功能：<br>-b 对非空输出行号<br>-n 输出所有行号</p>
<ol>
<li>一次显示整个文件:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename</span><br></pre></td></tr></table></figure></li>
<li>从键盘创建一个文件:只能创建新文件，不能编辑已有文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; filename</span><br></pre></td></tr></table></figure></li>
<li>将几个文件合并为一个文件:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h3><p>文件调用权限分为三级:文件拥有者、群组、其他。用于改变linux 系统文件或目<br>录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定<br>法；另一种是包含数字的数字设定法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l log2012.log </span><br><span class="line">-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span><br></pre></td></tr></table></figure>
<p>第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是<br>一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一<br>个目录。从第二个字符开始到第十个字符，3个字符一组，分别表示了3组用户对文<br>件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可<br>执行。权限代号如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r ：读权限，用数字4表示</span><br><span class="line">w ：写权限，用数字2表示</span><br><span class="line">x ：执行权限，用数字1表示</span><br><span class="line">- ：删除权限，用数字0表示</span><br><span class="line">s ：特殊权限</span><br></pre></td></tr></table></figure>
<p>实际例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">增加文件 t.log 所有用户可执行权限</span><br><span class="line">chmod a+x t.log</span><br><span class="line"></span><br><span class="line">给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他</span><br><span class="line">用户分配执行(1)的权限</span><br><span class="line">chmod 751 t.log（或者：chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x t.log)</span><br></pre></td></tr></table></figure>

<h3 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h3><p>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户<br>ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支<br>持通配符</p>
<h4 id="文件的操作命令-增删改查"><a href="#文件的操作命令-增删改查" class="headerlink" title="文件的操作命令(增删改查)"></a>文件的操作命令(增删改查)</h4><ol>
<li>touch 文件名称: 文件的创建（增）</li>
<li>cat/more/less/tail 文件名称 ：文件的查看（查）。命令 tail -f文件<br>可以对某个文件进行动态监控，例如 tomcat 的日志文件，会随着程序的运行<br>，日志会变化，可以使用 tail -f catalina-2016-11-11.log 监控文件的<br>变化</li>
<li>修改文件的内容（改）。输入wq 代表写入内容并退出，即保存；输入q!代<br>表强制退出不保存</li>
<li>rm -rf 文件： 删除文件（删）</li>
</ol>
<h3 id="Linux-目录树"><a href="#Linux-目录树" class="headerlink" title="Linux 目录树"></a>Linux 目录树</h3><ol>
<li>/bin：存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里</li>
<li>/etc：存放系统管理和配置文件</li>
<li>/home：存放所有用户文件的根目录，是用户主目录的基点，比如用户user<br>的主目录就是/home/user，可以用~user 表示</li>
<li>/usr：用于存放系统应用程序</li>
<li>/opt：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把<br>tomcat 等都安装到这里</li>
<li>/proc：虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获<br>取系统信息</li>
<li>/root：超级用户（系统管理员）的主目录</li>
<li>/sbin:存放二进制可执行文件，只有root 才能访问。这里存放的是系统管<br>理员使用的系统级别的管理命令和程序。如ifconfig 等</li>
<li>/dev：用于存放设备文件</li>
<li>/mnt：系统管理员安装临时文件系统的安装点，系统提供这个目录是让用<br>户临时挂载其他的文件系统</li>
<li>/boot：存放用于系统引导时使用的各种文件</li>
<li>/lib：存放着和系统运行相关的库文件</li>
<li>/tmp：用于存放各种临时文件，是公用的临时文件存储点</li>
<li>/var：用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，<br>比方说各种服务的日志文件（系统启动日志等）等</li>
<li>/lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归<br>”的文件（windows 下叫什么.chk）就在这里</li>
</ol>
<h3 id="Linux-基本命令"><a href="#Linux-基本命令" class="headerlink" title="Linux 基本命令"></a>Linux 基本命令</h3><h4 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h4><ol>
<li>cd usr： 切换到该目录下 usr 目录</li>
<li>cd ..： 切换到上一层目录</li>
<li>cd /： 切换到系统根目录</li>
<li>cd ~： 切换到用户主目录</li>
<li>cd -： 切换到上一个操作所在目录</li>
</ol>
<h4 id="目录的操作命令-增删改查"><a href="#目录的操作命令-增删改查" class="headerlink" title="目录的操作命令(增删改查)"></a>目录的操作命令(增删改查)</h4><ol>
<li>mkdir 目录名称： 增加目录</li>
<li>ls/ll（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文<br>件的详细信息）：查看目录信息</li>
<li>find 目录 参数： 寻找目录（查）</li>
</ol>
<ul>
<li>列出当前目录及子目录下所有文件和文件夹: find .</li>
<li>在/home目录下查找以.txt 结尾的文件名:find /home -name “*.txt”，<br>忽略大小写: find /home -iname “*.txt”</li>
<li>当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:find . ( -name<br>*.txt” -o -name “*.pdf” )或find . -name “*.txt” -o -name “*<br>.pdf”</li>
</ul>
<ol start="4">
<li>mv 目录名称 新目录名称： 修改目录的名称（改）。注意：mv 的语法不仅<br>可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作。mv<br>命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后<br>面会介绍到mv 命令的另一个用法</li>
<li>mv 目录名称 目录的新位置： 移动目录的位置—剪切（改）。注意：mv语<br>法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv<br>与cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而cp 对文件进行<br>复制，文件个数增加了</li>
<li>cp -r 目录名称 目录拷贝的目标位置： 拷贝目录（改），-r 代表递归拷<br>贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和<br>压缩包时不用写-r 递归</li>
<li>rm [-rf] 目录 : 删除目录（删）。注意：rm 不仅可以删除目录，也可以<br>删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都<br>直接使用rm -rf 目录/文件/压缩包</li>
</ol>
<h4 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h4><p>Linux 中的打包文件一般是以.tar 结尾的，压缩的文件一般是以.gz 结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般<br>.tar.gz。命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件</p>
<ol>
<li>z：调用 gzip 压缩命令进行压缩</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
</ol>
<p>假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我<br>们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用<br>命令：tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt 或<br>tar -zcvf test.tar.gz /test/</p>
<h4 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h4><p>命令：tar [-xvf] 压缩文件，其中：x：代表解压</p>
<ol>
<li>将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：<br>tar -xvf test.tar.gz</li>
<li>将 /test 下的 test.tar.gz 解压到根目录/usr 下:<br>tar -xvf test.tar.gz -C /usr（- C 代表指定解压的位置）</li>
</ol>
<h4 id="Linux-的权限命令"><a href="#Linux-的权限命令" class="headerlink" title="Linux 的权限命令"></a>Linux 的权限命令</h4><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统<br>用来限制资源访问的机制，在Linux 中权限一般分为读、写和执行，分为三<br>组。分别对应文件的属主，属组和其他用户，通过这样的机制来限制哪些用<br>户、哪些组可以对特定的文件进行什么样的操作</p>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ol>
<li>pwd 显示当前所在位置</li>
<li>sudo + 其他命令：以系统管理者的身份执行指令，也就是说，经由sudo<br>所执行的指令就好像是root 亲自执行</li>
<li>grep 要搜索的字符串 要搜索的文件 –color：搜索命令，–color 代<br>表高亮显示</li>
<li>ps -ef/ps -aux： 这两个命令都是查看当前系统正在运行进程，两者的<br>区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux<br>|grep redis（查看包括redis字符串的进程），也可使用pgrep redis -a</li>
<li>kill -9 进程的pid： 杀死进程（-9 表示强制终止。）</li>
</ol>
<h4 id="网络通信命令"><a href="#网络通信命令" class="headerlink" title="网络通信命令"></a>网络通信命令</h4><ol>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping</li>
<li>查看当前系统的端口使用：netstat -an</li>
</ol>
<h3 id="进程上下文切换？"><a href="#进程上下文切换？" class="headerlink" title="进程上下文切换？"></a>进程上下文切换？</h3><p>进程执行过程中所涉及到的CPU上下文切换，我们称之为特权模式切换。从用<br>户态到内核态的转变就发生一次特权模式切换，如从磁盘上读取一个文件，<br>就发生了一次内核调用，也就发生一次特权模式切换</p>
<ol>
<li>CPU需要将寄存器中的用户态的指令位置保存起来，截至执行内核态的代码</li>
<li>CPU寄存器需要更新为内核态的新位置，最后跳转到内核态执行内核调用。<br>之后再恢复之前的用户态，这样的一次系统调用过程实际上发生了两次CPU上<br>下文切换</li>
</ol>
<p>这不是进程上下文切换，进程上下文切换只是说一个进程切换到另一个进程<br>首先进程的管理是有内核进行管理和调度的。进程的切换只能发生在内核态<br>所以进程的上下文切换不仅仅包括了虚拟内存，栈，全局变量等用户空间<br>资源，还包括了内核态堆栈，寄存器等内核空间状态</p>
<h3 id="中断上下文切换？"><a href="#中断上下文切换？" class="headerlink" title="中断上下文切换？"></a>中断上下文切换？</h3><p>中断是为了快速响应硬件事件的，跟进程上下文不同，中断上下文不涉及进程<br>的用户态。即便打断的是一个用户态的进程，也不需要保存和恢复这个进程的<br>虚拟内存，全局变量等用户态资源。中断上下文只包括内核态中断服务程序执<br>行必需的状态。CPU寄存器，内核堆栈，硬件中断参数</p>
<h3 id="为什么线程切换会有消耗，消耗啥？"><a href="#为什么线程切换会有消耗，消耗啥？" class="headerlink" title="为什么线程切换会有消耗，消耗啥？"></a>为什么线程切换会有消耗，消耗啥？</h3><p>线程切换过程包括：线程上下文的保存和恢复，用户态和内核态的转换，CPU<br>上下文的切换，这些工作都需要CPU去完成</p>
<ol>
<li>CPU上下文切换 CPU寄存器和程序计数器切换</li>
<li>线程上下文切换 涉及线程状态的保存和恢复，包括寄存器、栈等私有数据</li>
<li>特权模式切换 线程的调度是需要内核级别的权限的（操作CPU和内存），<br>也就是说线程的调度工作是在内核态完成的，因此会有一个从用户态到内核态<br>的切换。而且，不管是线程本身的切换还是特权模式的切换，都要进行CPU的<br>上下文切换</li>
</ol>
<h3 id="如何查看上下文切换情况？"><a href="#如何查看上下文切换情况？" class="headerlink" title="如何查看上下文切换情况？"></a>如何查看上下文切换情况？</h3><ol>
<li>vmstat 查看系统的上下文切换情况</li>
<li>pidstat 可以看到具体的某个应用程序的上下文切换情况</li>
</ol>
<h3 id="进程同步、互斥和通信的区别？"><a href="#进程同步、互斥和通信的区别？" class="headerlink" title="进程同步、互斥和通信的区别？"></a>进程同步、互斥和通信的区别？</h3><p>进程之间存在两种基本关系：竞争关系和协作关系。进程的互斥、同步、通信都<br>是基于这两种基本关系而存在的</p>
<ol>
<li>为了解决进程间竞争关系（间接制约关系）而引入进程互斥</li>
<li>为了解决进程间松散的协作关系（直接制约关系）而引入进程同步</li>
<li>为了解决进程间紧密的协作关系而引入进程通信</li>
</ol>
<ul>
<li>资源竞争会产生两个问题：一个是死锁问题，一个是饥饿问题。进程的互斥<br>是解决进程间竞争关系(间接制约关系 ) 的手段。 进程互斥指若干个进程要<br>使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资<br>源的进程必须等待，直到占有资源的进程释放该资源。</li>
<li>某些进程为完成同一任务需要分工协作，这就需要相互协作的进程在某些协<br>调点上协调各自的工作。这种协作进程之间相互等待对方消息或信号的协调关<br>系称为进程同步，也就是说进程同步指两个以上进程基于某个条件来协调它<br>们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进<br>程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号<br>到达才被唤醒</li>
<li>进程之间互相交换信息的工作称之为进程通信IPC，主要是指大量数据的交换</li>
</ul>
<h3 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h3><p>协程是比线程更小的一种执行单元，你可以认为是轻量级的线程，一个线<br>程也可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程<br>序所控制（也就是在用户态执行）</p>
<h3 id="为什么是轻量级的线程？"><a href="#为什么是轻量级的线程？" class="headerlink" title="为什么是轻量级的线程？"></a>为什么是轻量级的线程？</h3><p>协成是基于线程实现的，协程的创建、切换、销毁都是在某个线程中来进行的<br>，协程占用内存少，只需要极少的栈内存（大概是4～5KB），默认情况下，<br>线程栈的大小为1MB</p>
<h3 id="协程和线程的区别？"><a href="#协程和线程的区别？" class="headerlink" title="协程和线程的区别？"></a>协程和线程的区别？</h3><ol>
<li>线程在进行切换的时候，需要将CPU中的寄存器的信息存储起来，然后读<br>入另外一个线程的数据</li>
<li>线程的切换会涉及到用户模式到内核模式的切换，据说每次模式切换都<br>需要执行上千条指令</li>
<li>线程切换时CPU的高速缓存中的数据，也可能失效，需要重新加载</li>
<li>协程在切换的时候，寄存器需要保存和加载的数据量比较小</li>
<li>协程没有用户模式到内核模式的切换操作</li>
<li>更有效率的调度，因为协程是非抢占式的，前一个协程执行完毕或者堵塞<br>，才会让出CPU，而线程则一般使用了时间片的算法，会进行很多没有必要的<br>切换</li>
<li>无需系统自动切换（系统自动切换会浪费很多的资源），而协程是我们用<br>户手动切换，而且是在同一个栈上执行，速度就会非常快而且省资源</li>
</ol>
<h3 id="Linux下如何查看tcp连接？"><a href="#Linux下如何查看tcp连接？" class="headerlink" title="Linux下如何查看tcp连接？"></a>Linux下如何查看tcp连接？</h3><p>netstat -nat|grep -i “80”|wc -l</p>
<h3 id="网络监听需要什么函数？"><a href="#网络监听需要什么函数？" class="headerlink" title="网络监听需要什么函数？"></a>网络监听需要什么函数？</h3><ol>
<li>listen listent函数创建一个监听队列以存放待处理的客户连接，将套接字<br>sockfd指定为被监听的socket</li>
</ol>
<h3 id="互斥锁和信号量的区别？"><a href="#互斥锁和信号量的区别？" class="headerlink" title="互斥锁和信号量的区别？"></a>互斥锁和信号量的区别？</h3><ol>
<li>互斥锁和互斥量是一个意思，互斥锁的作用就是互斥，是用来保护临界区的</li>
<li>信号量是一种更高级的同步机制，mutex（互斥锁）可以说是信号量在仅取<br>值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而<br>不单单是线程间互斥 </li>
</ol>
<h3 id="互斥锁与自旋锁的区别？"><a href="#互斥锁与自旋锁的区别？" class="headerlink" title="互斥锁与自旋锁的区别？"></a>互斥锁与自旋锁的区别？</h3><ol>
<li>重量级锁需要通过操作系统自身的互斥量（mutex lock，也称为互斥锁）<br>来实现，然而这种实现方式需要通过用户态与和核心态的切换来实现，但这个<br>切换的过程会带来很大的性能开销</li>
<li>申请锁时，从用户态进入内核态，申请到后从内核态返回用户态（两次切<br>换），没有申请到时阻塞睡眠在内核态。使用完资源后释放锁，从用户态进入<br>内核态，唤醒阻塞等待锁的进程，返回用户态（又两次切换），被唤醒进程<br>在内核态申请到锁，返回用户态（可能其他申请锁的进程又要阻塞）。所以<br>，使用一次锁，包括申请，持有到释放，当前进程要进行四次用户态与内<br>核态的切换。同时其他竞争锁的进程在这个过程中也要进行一次切换</li>
<li>自旋锁与互斥锁不同的是自旋锁不会引起调用者睡眠。如果自旋锁已经被<br>别的进程保持，调用者就轮询（不断的消耗CPU的时间）是否该自旋锁的保<br>持者已经释放了锁</li>
<li>在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号<br>量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒<br>休眠的线程</li>
</ol>
<h3 id="sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"><a href="#sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？" class="headerlink" title="sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"></a>sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？</h3><ol>
<li>usleep()函数 单位是微秒</li>
</ol>
<h3 id="磁盘坏掉了，操作系统是怎么处理应对的？"><a href="#磁盘坏掉了，操作系统是怎么处理应对的？" class="headerlink" title="磁盘坏掉了，操作系统是怎么处理应对的？"></a>磁盘坏掉了，操作系统是怎么处理应对的？</h3><ol>
<li>磁盘扫描工具扫描磁盘驱动器</li>
</ol>
<h3 id="缓存？"><a href="#缓存？" class="headerlink" title="缓存？"></a>缓存？</h3><p>缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，因此<br>速率很快</p>
<h3 id="进程的内存空间分布？"><a href="#进程的内存空间分布？" class="headerlink" title="进程的内存空间分布？"></a>进程的内存空间分布？</h3><p>用户空间被分为几个段，从高地址到低地址分别为：Stack, Heap, BSS,<br>Data, Text</p>
<ol>
<li>程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码</li>
<li>初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据</li>
<li>未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据</li>
<li>堆 (Heap):存储动态内存分配，需要程序员手工分配，手工释放</li>
<li>栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，<br>用于控制函数的调用和返回。在程序块开始时自动分配内存，结束时自动<br>释放内存</li>
</ol>
<h3 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h3><ol>
<li>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的<br>程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处<br>继续执行原来的程序</li>
<li>中断一般三类，一种是由CPU外部引起的，称为外中断。如I/O中断、时钟中<br>断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，<br>地址越界、浮点溢出）称为内中断，或者（异常，陷入），最后一种是在程序<br>中使用了系统调用引起的</li>
<li>中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中<br>断处理主要由软件实施</li>
</ol>
<h3 id="CPU在中断时会干嘛？"><a href="#CPU在中断时会干嘛？" class="headerlink" title="CPU在中断时会干嘛？"></a>CPU在中断时会干嘛？</h3><p>中断是CPU响应外设需求的一种模式，在外设需要CPU时，会向中断控制器发送<br>中断请求，这时CPU 要保护现场，即把正在运行的程序保存起来，一般是把状<br>态压入堆栈，然后读中断号，启动相应的中断服务程序，服务完成后，载入保<br>护现场，即把堆栈的数据弹出，继续运行之前的程序</p>
<h3 id="中断分为几种？"><a href="#中断分为几种？" class="headerlink" title="中断分为几种？"></a>中断分为几种？</h3><ol>
<li>中断(Interruption)，也称外中断，指来自CPU执行指令以外的事件的发<br>生，如设备发出的I/O 结束中断，表示设备输入/输出处理已经完成，希望处<br>理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序<br>继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动<br>定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们<br>与当前处理机运行的程序无关</li>
<li>异常（陷入），也叫内中断。是由CPU内部事件所引起的中断，例如进程在<br>运算中发生了上溢或者下溢，有如程序出错，如非法指令，地址越界等。通常<br>把这类中断称为内中断或者陷入。若系统发现有陷入事件，CPU也将暂停正在<br>执行的程序，转去执行该陷入事件的处理程序</li>
</ol>
<h3 id="如何处理中断？"><a href="#如何处理中断？" class="headerlink" title="如何处理中断？"></a>如何处理中断？</h3><ol>
<li>屏蔽中断 当处理机正在处理一个中断时，将屏蔽掉所有的中断，即处理机<br>对任何新到的中断请求，都暂时不予理睬，而让他们等待，直到处理机已完成<br>本次中断的处理后，处理机再去检查是否有中断发生，不适合用于对实时性要<br>求较高的中断请求</li>
<li>嵌套中断 当同时有多个不同优先级的中断请求时，CPU优先响应最高优先<br>级的中断请求</li>
</ol>
<h3 id="中断程序处理过程？"><a href="#中断程序处理过程？" class="headerlink" title="中断程序处理过程？"></a>中断程序处理过程？</h3><ol>
<li>测定是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU的现场并退出中断</li>
</ol>
<h3 id="为什么要内核态-用户态？"><a href="#为什么要内核态-用户态？" class="headerlink" title="为什么要内核态/用户态？"></a>为什么要内核态/用户态？</h3><ol>
<li>在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃<br>，比如清内存、设置时钟等</li>
<li>CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作<br>系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令</li>
</ol>
<h3 id="fd是什么？"><a href="#fd是什么？" class="headerlink" title="fd是什么？"></a>fd是什么？</h3><ol>
<li>fd全称是file descriptor，是进程独有的文件描述符表的索引</li>
<li>每当进程用open（）函数打开一个文件，内核便会返回该文件的文件操作<br>符（一个非负的整形值），此后所有对该文件的操作，都会以返回的fd文件<br>操作符为参数</li>
</ol>
<h3 id="多路复用怎么解决阻塞IO-存在的问题？"><a href="#多路复用怎么解决阻塞IO-存在的问题？" class="headerlink" title="多路复用怎么解决阻塞IO 存在的问题？"></a>多路复用怎么解决阻塞IO 存在的问题？</h3><ol>
<li>异步编程框架是说框架内的业务代码与框架的接口是异步的，而框架与操<br>作系统的接口是同步非阻塞</li>
</ol>
<h3 id="查看内存的命令？"><a href="#查看内存的命令？" class="headerlink" title="查看内存的命令？"></a>查看内存的命令？</h3><ol>
<li>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的<br>资源占用状况</li>
<li>pmap -d 5647 可以根据进程查看进程相关信息占用的内存情况</li>
<li>free Linux的free命令是常用来查看内存的命令</li>
</ol>
<h3 id="查看日志的命令？"><a href="#查看日志的命令？" class="headerlink" title="查看日志的命令？"></a>查看日志的命令？</h3><ol>
<li>tail -n 10 test.log 查询日志尾部最后10行的日志</li>
<li>head 跟tail是相反的head是看前多少行日志</li>
</ol>
<h3 id="Linux-查看文件中是否存在某字符"><a href="#Linux-查看文件中是否存在某字符" class="headerlink" title="Linux 查看文件中是否存在某字符"></a>Linux 查看文件中是否存在某字符</h3><ol>
<li>grep “port:8080” pro.sh 查找pro文件中是否包含port:8080 内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep 指定字符串 文件的完整路径</span><br><span class="line">若不清楚字符串的大小写，可以在命令末尾加 -i ，这样查询将忽略字符串的大小写</span><br><span class="line">若需要查询指定字符串在文件中的位置，可以在命令末尾加 -n</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="linux如何分割文件字符串？"><a href="#linux如何分割文件字符串？" class="headerlink" title="linux如何分割文件字符串？"></a>linux如何分割文件字符串？</h3><ol>
<li>cut<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d 指定分隔符，如：按照“：”分割，-d:</span><br><span class="line">-c 提取第n个字节，如：-c5,表示提取每行的第5个字节</span><br><span class="line">-f 指定输出的域</span><br><span class="line">cut –d: -f1,2 &#x2F;&#x2F;按照”:”来分割，并输出第1和2段</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用的消息队列以及区别？"><a href="#常用的消息队列以及区别？" class="headerlink" title="常用的消息队列以及区别？"></a>常用的消息队列以及区别？</h3><p>消息队列是分布式应用间交换信息的重要组件，消息队列可驻留在内存或磁盘<br>上，队列可以存储消息直到它们被应用程序读走</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/23/Linux2/">https://skysea-gaoming.github.io/2021/04/23/Linux2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System/">System</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="fa fa-chevron-left">  </i><span>操作系统总结1</span></a></div><div class="next-post pull-right"><a href="/2021/04/22/Spring4/"><span>Spring4</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/23/Linux2/';
  this.page.identifier = '2021/04/23/Linux2/';
  this.page.title = 'Linux常用命令';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>