<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux2"><meta name="keywords" content="System"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Linux2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程上下文切换？"><span class="toc-number">1.1.</span> <span class="toc-text">进程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程上下文切换？"><span class="toc-number">1.2.</span> <span class="toc-text">线程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断上下文切换？"><span class="toc-number">1.3.</span> <span class="toc-text">中断上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么线程切换会有消耗，消耗啥？"><span class="toc-number">1.4.</span> <span class="toc-text">为什么线程切换会有消耗，消耗啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何查看上下文切换情况？"><span class="toc-number">1.5.</span> <span class="toc-text">如何查看上下文切换情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步、互斥和通信的区别？"><span class="toc-number">1.6.</span> <span class="toc-text">进程同步、互斥和通信的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界资源和临界区的区别？"><span class="toc-number">1.7.</span> <span class="toc-text">临界资源和临界区的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链接和动态链接的区别？"><span class="toc-number">1.8.</span> <span class="toc-text">静态链接和动态链接的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译有哪些阶段？"><span class="toc-number">1.9.</span> <span class="toc-text">编译有哪些阶段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"><span class="toc-number">1.10.</span> <span class="toc-text">进程间通信方式（六种方式，各自的概念，区别都要搞清楚）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道、消息队列、共享内存它们三者哪个开销最小？"><span class="toc-number">1.11.</span> <span class="toc-text">管道、消息队列、共享内存它们三者哪个开销最小？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号与信号量的区别？"><span class="toc-number">1.12.</span> <span class="toc-text">信号与信号量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步的方式"><span class="toc-number">1.13.</span> <span class="toc-text">进程同步的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步的方式？"><span class="toc-number">1.14.</span> <span class="toc-text">线程同步的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址空间是什么？"><span class="toc-number">1.15.</span> <span class="toc-text">地址空间是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是虚拟内存？"><span class="toc-number">1.16.</span> <span class="toc-text">什么是虚拟内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是分页系统"><span class="toc-number">1.17.</span> <span class="toc-text">什么是分页系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页是什么？"><span class="toc-number">1.18.</span> <span class="toc-text">分页是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是页表？"><span class="toc-number">1.19.</span> <span class="toc-text">什么是页表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表项的结构是什么样的？"><span class="toc-number">1.20.</span> <span class="toc-text">页表项的结构是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加速分页过程是怎样的？"><span class="toc-number">1.21.</span> <span class="toc-text">加速分页过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页面置换算法"><span class="toc-number">1.22.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页和分段有什么区别？"><span class="toc-number">1.23.</span> <span class="toc-text">分页和分段有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部性原理？"><span class="toc-number">1.24.</span> <span class="toc-text">局部性原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件描述符是什么？"><span class="toc-number">1.25.</span> <span class="toc-text">文件描述符是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-是什么？"><span class="toc-number">1.26.</span> <span class="toc-text">Socket 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O模型中的输入操作？"><span class="toc-number">1.27.</span> <span class="toc-text">I&#x2F;O模型中的输入操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O模型分为几种？"><span class="toc-number">1.28.</span> <span class="toc-text">I&#x2F;O模型分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式I-O-是什么？"><span class="toc-number">1.29.</span> <span class="toc-text">阻塞式I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞式I-O-是什么？"><span class="toc-number">1.30.</span> <span class="toc-text">非阻塞式I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-多路复用？"><span class="toc-number">1.31.</span> <span class="toc-text">I&#x2F;O 多路复用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-是什么？"><span class="toc-number">1.32.</span> <span class="toc-text">select 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll-是什么？"><span class="toc-number">1.33.</span> <span class="toc-text">poll 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-是什么？"><span class="toc-number">1.34.</span> <span class="toc-text">epoll 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select和poll的区别？"><span class="toc-number">1.35.</span> <span class="toc-text">select和poll的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recvfrom-是什么？"><span class="toc-number">1.36.</span> <span class="toc-text">recvfrom 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Epoll和Poll和Select？"><span class="toc-number">1.37.</span> <span class="toc-text">Epoll和Poll和Select？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式I-O和I-O复用的区别？"><span class="toc-number">1.38.</span> <span class="toc-text">阻塞式I&#x2F;O和I&#x2F;O复用的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号驱动I-O-是什么？"><span class="toc-number">1.39.</span> <span class="toc-text">信号驱动I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步I-O-是什么？"><span class="toc-number">1.40.</span> <span class="toc-text">异步I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步是什么？"><span class="toc-number">1.41.</span> <span class="toc-text">异步是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步的异步的区别？"><span class="toc-number">1.42.</span> <span class="toc-text">同步的异步的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO分为哪几种？"><span class="toc-number">1.43.</span> <span class="toc-text">Java IO分为哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-是什么？"><span class="toc-number">1.44.</span> <span class="toc-text">BIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-是什么？"><span class="toc-number">1.45.</span> <span class="toc-text">NIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-和IO-多路复用的关系？"><span class="toc-number">1.46.</span> <span class="toc-text">NIO 和IO 多路复用的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO-是什么？"><span class="toc-number">1.47.</span> <span class="toc-text">AIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程是什么？"><span class="toc-number">1.48.</span> <span class="toc-text">协程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么是轻量级的线程？"><span class="toc-number">1.49.</span> <span class="toc-text">为什么是轻量级的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程和线程的区别？"><span class="toc-number">1.50.</span> <span class="toc-text">协程和线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux下如何查看tcp连接？"><span class="toc-number">1.51.</span> <span class="toc-text">Linux下如何查看tcp连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络监听需要什么函数？"><span class="toc-number">1.52.</span> <span class="toc-text">网络监听需要什么函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁和信号量的区别？"><span class="toc-number">1.53.</span> <span class="toc-text">互斥锁和信号量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁与自旋锁的区别？"><span class="toc-number">1.54.</span> <span class="toc-text">互斥锁与自旋锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"><span class="toc-number">1.55.</span> <span class="toc-text">sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘坏掉了，操作系统是怎么处理应对的？"><span class="toc-number">1.56.</span> <span class="toc-text">磁盘坏掉了，操作系统是怎么处理应对的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存？"><span class="toc-number">1.57.</span> <span class="toc-text">缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的内存空间分布？"><span class="toc-number">1.58.</span> <span class="toc-text">进程的内存空间分布？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是中断？"><span class="toc-number">1.59.</span> <span class="toc-text">什么是中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU在中断时会干嘛？"><span class="toc-number">1.60.</span> <span class="toc-text">CPU在中断时会干嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断分为几种？"><span class="toc-number">1.61.</span> <span class="toc-text">中断分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何处理中断？"><span class="toc-number">1.62.</span> <span class="toc-text">如何处理中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断程序处理过程？"><span class="toc-number">1.63.</span> <span class="toc-text">中断程序处理过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要内核态-用户态？"><span class="toc-number">1.64.</span> <span class="toc-text">为什么要内核态&#x2F;用户态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用的那三种方式有什么区别？"><span class="toc-number">1.65.</span> <span class="toc-text">多路复用的那三种方式有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fd是什么？"><span class="toc-number">1.66.</span> <span class="toc-text">fd是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用怎么解决阻塞IO-存在的问题？"><span class="toc-number">1.67.</span> <span class="toc-text">多路复用怎么解决阻塞IO 存在的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看内存的命令？"><span class="toc-number">1.68.</span> <span class="toc-text">查看内存的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看日志的命令？"><span class="toc-number">1.69.</span> <span class="toc-text">查看日志的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-查看文件中是否存在某字符"><span class="toc-number">1.70.</span> <span class="toc-text">Linux 查看文件中是否存在某字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux如何分割文件字符串？"><span class="toc-number">1.71.</span> <span class="toc-text">linux如何分割文件字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的消息队列以及区别？"><span class="toc-number">1.72.</span> <span class="toc-text">常用的消息队列以及区别？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Linux2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/23/Linux2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/23/Linux2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《鸟哥的Linux私房菜》 《现代操作系统》<br><a href="https://blog.csdn.net/SakuraA6/article/details/108810916" target="_blank" rel="noopener">https://blog.csdn.net/SakuraA6/article/details/108810916</a></p>
<h3 id="进程上下文切换？"><a href="#进程上下文切换？" class="headerlink" title="进程上下文切换？"></a>进程上下文切换？</h3><p>进程执行过程中所涉及到的CPU上下文切换，我们称之为特权模式切换。从用<br>户态到内核态的转变就发生一次特权模式切换，如从磁盘上读取一个文件，<br>就发生了一次内核调用，也就发生一次特权模式切换</p>
<ol>
<li>CPU需要将寄存器中的用户态的指令位置保存起来，截至执行内核态的代码</li>
<li>CPU寄存器需要更新为内核态的新位置，最后跳转到内核态执行内核调用。<br>之后再恢复之前的用户态，这样的一次系统调用过程实际上发生了两次CPU上<br>下文切换</li>
</ol>
<p>这不是进程上下文切换，进程上下文切换只是说一个进程切换到另一个进程<br>首先进程的管理是有内核进行管理和调度的。进程的切换只能发生在内核态<br>所以进程的上下文切换不仅仅包括了虚拟内存，栈，全局变量等用户空间<br>资源，还包括了内核态堆栈，寄存器等内核空间状态</p>
<h3 id="线程上下文切换？"><a href="#线程上下文切换？" class="headerlink" title="线程上下文切换？"></a>线程上下文切换？</h3><ol>
<li>当进程拥有多个线程时，线程会共享虚拟内存和全局变量等资源，这些资<br>源在上下文切换中不需要修改</li>
<li>线程的上下文切换也需要保存自己的一些数据，比如栈，寄存器。这些在上<br>下文切换时是需要保存的</li>
<li>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</li>
</ol>
<h3 id="中断上下文切换？"><a href="#中断上下文切换？" class="headerlink" title="中断上下文切换？"></a>中断上下文切换？</h3><p>中断是为了快速响应硬件事件的，跟进程上下文不同，中断上下文不涉及进程<br>的用户态。即便打断的是一个用户态的进程，也不需要保存和恢复这个进程的<br>虚拟内存，全局变量等用户态资源。中断上下文只包括内核态中断服务程序执<br>行必需的状态。CPU寄存器，内核堆栈，硬件中断参数</p>
<h3 id="为什么线程切换会有消耗，消耗啥？"><a href="#为什么线程切换会有消耗，消耗啥？" class="headerlink" title="为什么线程切换会有消耗，消耗啥？"></a>为什么线程切换会有消耗，消耗啥？</h3><p>线程切换过程包括：线程上下文的保存和恢复，用户态和内核态的转换，CPU<br>上下文的切换，这些工作都需要CPU去完成</p>
<ol>
<li>CPU上下文切换 CPU寄存器和程序计数器切换</li>
<li>线程上下文切换 涉及线程状态的保存和恢复，包括寄存器、栈等私有数据</li>
<li>特权模式切换 线程的调度是需要内核级别的权限的（操作CPU和内存），<br>也就是说线程的调度工作是在内核态完成的，因此会有一个从用户态到内核态<br>的切换。而且，不管是线程本身的切换还是特权模式的切换，都要进行CPU的<br>上下文切换</li>
</ol>
<h3 id="如何查看上下文切换情况？"><a href="#如何查看上下文切换情况？" class="headerlink" title="如何查看上下文切换情况？"></a>如何查看上下文切换情况？</h3><ol>
<li>vmstat 查看系统的上下文切换情况</li>
<li>pidstat 可以看到具体的某个应用程序的上下文切换情况</li>
</ol>
<h3 id="进程同步、互斥和通信的区别？"><a href="#进程同步、互斥和通信的区别？" class="headerlink" title="进程同步、互斥和通信的区别？"></a>进程同步、互斥和通信的区别？</h3><p>进程之间存在两种基本关系：竞争关系和协作关系。进程的互斥、同步、通信都<br>是基于这两种基本关系而存在的</p>
<ol>
<li>为了解决进程间竞争关系（间接制约关系）而引入进程互斥</li>
<li>为了解决进程间松散的协作关系（直接制约关系）而引入进程同步</li>
<li>为了解决进程间紧密的协作关系而引入进程通信</li>
</ol>
<ul>
<li>资源竞争会产生两个问题：一个是死锁问题，一个是饥饿问题。进程的互斥<br>是解决进程间竞争关系(间接制约关系 ) 的手段。 进程互斥指若干个进程要<br>使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资<br>源的进程必须等待，直到占有资源的进程释放该资源。</li>
<li>某些进程为完成同一任务需要分工协作，这就需要相互协作的进程在某些协<br>调点上协调各自的工作。这种协作进程之间相互等待对方消息或信号的协调关<br>系称为进程同步，也就是说进程同步指两个以上进程基于某个条件来协调它<br>们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进<br>程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号<br>到达才被唤醒</li>
<li>进程之间互相交换信息的工作称之为进程通信IPC，主要是指大量数据的交换</li>
</ul>
<h3 id="临界资源和临界区的区别？"><a href="#临界资源和临界区的区别？" class="headerlink" title="临界资源和临界区的区别？"></a>临界资源和临界区的区别？</h3><ol>
<li>临界资源 临界资源是一次仅允许一个进程使用的共享资源。各进程采取互<br>斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，<br>磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方<br>式，实现对这种资源的共享</li>
<li>临界区 每个进程中访问临界资源的那段代码称为临界区。每次只允许一个<br>进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软<br>件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界<br>资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长<br>，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会<br>被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</li>
<li>临界区是用户态下的对象，即只能在同一进程中实现线程互斥。因无需在用<br>户态和核心态之间切换</li>
</ol>
<h3 id="静态链接和动态链接的区别？"><a href="#静态链接和动态链接的区别？" class="headerlink" title="静态链接和动态链接的区别？"></a>静态链接和动态链接的区别？</h3><ol>
<li>静态链接就是在编译期间，由编译器和连接器将静态库集成到应用程序内<br>，并制作成目标文件以及可以独立运作的可执行文件。静态库一般是一些外<br>部函数与变量的集合</li>
<li>动态链接可以在首次载入的时候执行，也可以在程序开始执行的时候完成<br>。这个是由动态链接器完成，比方标准 C 库(libc.so) 通常就是动态链接<br>的，这样所有的程序可以共享同一个库，而不用分别进行封装</li>
</ol>
<h3 id="编译有哪些阶段？"><a href="#编译有哪些阶段？" class="headerlink" title="编译有哪些阶段？"></a>编译有哪些阶段？</h3><ol>
<li>预处理阶段：处理以 # 开头的预处理命令</li>
<li>编译阶段：翻译成汇编文件</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件</li>
<li>链接阶段：将可重定位目标文件和 printf.o</li>
<li>等单独预编译好的目标文件进行合并，得到最终的可执行目标文件</li>
</ol>
<h3 id="进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"><a href="#进程间通信方式（六种方式，各自的概念，区别都要搞清楚）" class="headerlink" title="进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"></a>进程间通信方式（六种方式，各自的概念，区别都要搞清楚）</h3><p><a href="https://blog.csdn.net/watermelonmk/article/details/109002753" target="_blank" rel="noopener">https://blog.csdn.net/watermelonmk/article/details/109002753</a><br><a href="https://blog.csdn.net/qq_34796146/article/details/107825875" target="_blank" rel="noopener">https://blog.csdn.net/qq_34796146/article/details/107825875</a></p>
<ol>
<li>管道 管道传输数据是单向的，如果想相互通信，我们需要创建两个管道<br>才行。管道这种通信方式效率低，不适合进程间频繁地交换数据，所谓的管<br>道，就是内核里面的一串缓存。从管道的一端写入的数据，实际上是缓存在<br>内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的<br>数据是无格式的流且大小受限</li>
</ol>
<ul>
<li>匿名管道 没有名字标识，匿名管道是特殊文件只存在于内存，没有存在<br>于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无<br>格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上<br>流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于<br>存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立<br>，随着进程终止而消失</li>
<li>命名管道 突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用<br>命名管道的前提，需要在文件系统创建一个类型为p 的设备文件，那么毫<br>无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道<br>还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数<br>据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不<br>支持lseek 之类的文件定位操作</li>
</ul>
<ol start="2">
<li>消息队列 A 进程要给B 进程发送消息，A 进程把数据放在对应的消息<br>队列后就可以正常返回了，B进程需要的时候再去读取数据就可以了。同理<br>，B 进程要给A 进程发送消息也是如此。<br>消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际<br>上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数<br>据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时<br>，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的<br>数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入<br>和读取都需要经过用户态与内核态之间的拷贝过程。消息队列生命周期随<br>内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直<br>存在，如果进程从消息队列中读取了消息体，内核就会把这个消息体删<br>除而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程<br>的结束而销毁</li>
<li>共享内存 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相<br>同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到<br>了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。<br>共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来<br>的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问<br>进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提<br>高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享<br>内存通信，这种方式需要依靠某种同步操作，如互斥锁和信号量等</li>
<li>信号量 信号量其实是一个整型的计数器，主要用于实现进程间的互斥<br>与同步，而不是用于缓存进程间通信的数据</li>
<li>信号 信号是进程间通信机制中唯一的异步通信机制，信号可以在应用<br>进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发<br>生了哪些系统事件</li>
<li>SOCKET 前面提到的方式都是在同一台主机上进行进程间通信，那要想<br>跨网络与不同主机上的进程之间通信，就需要Socket 通信了。可根据创建<br>Socket 的类型不同，分为三种常见的通信方式，一个是基于TCP 协议的<br>通信方式，一个是基于UDP协议的通信方式，一个是本地进程间通信方式</li>
</ol>
<h3 id="管道、消息队列、共享内存它们三者哪个开销最小？"><a href="#管道、消息队列、共享内存它们三者哪个开销最小？" class="headerlink" title="管道、消息队列、共享内存它们三者哪个开销最小？"></a>管道、消息队列、共享内存它们三者哪个开销最小？</h3><p><a href="https://blog.csdn.net/qq_41999455/article/details/105275981" target="_blank" rel="noopener">https://blog.csdn.net/qq_41999455/article/details/105275981</a></p>
<ol>
<li>进程间的通信手段大体可以分为两类：通信类和同步类</li>
<li>本质来讲管道也是一片内存区域，默认大小是65536字节</li>
<li>相比于管道来讲，消息队列机制中，双方是通过消息来通信的，无需花<br>费精力从字节流中解析出完整的消息</li>
<li>消息队列的作用是进程之间传递消息。而信号量的作用是为了同步多个<br>进程的操作</li>
<li>共享内存是所有IPC手段中最快的一种。它之所以快是因为共享内存一旦<br>映射到进程的地址空间，进程之间数据的传递就不须要涉及内核了</li>
<li>共享内存是开销最小的通信方式，源于它和内核的交流比较少，从而降<br>低了开销</li>
</ol>
<h3 id="信号与信号量的区别？"><a href="#信号与信号量的区别？" class="headerlink" title="信号与信号量的区别？"></a>信号与信号量的区别？</h3><ol>
<li>信号事件的来源主要有两种</li>
</ol>
<ul>
<li>硬件来源（如键盘Cltr+C ） 产生SIGINT 信号，表示终止该进程</li>
<li>Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束</li>
<li>软件来源（如kill命令）</li>
</ul>
<p>信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给<br>某一进程，一旦有信号产生一旦有信号发生，进程有三种方式响应信号</p>
<ol>
<li>执行默认操作 Linux 对每种信号都规定了默认操作，例如，上面列表中<br>的SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即<br>终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方<br>便程序员事后进行分析问题在哪里</li>
<li>捕捉信号 我们可以为信号定义一个信号处理函数。当信号发生时，我们就<br>执行相应的信号处理函数</li>
<li>忽略信号 当我们不希望处理某些信号的时候，就可以忽略该信号，不做任<br>何处理。有两个信号是应用进程无法捕捉和忽略的，即SIGKILL 和SEGSTOP，<br>它们用于在任何时候中断或结束某一进程</li>
</ol>
<h3 id="进程同步的方式"><a href="#进程同步的方式" class="headerlink" title="进程同步的方式"></a>进程同步的方式</h3><ol>
<li>信号量 用于进程间传递信号的一个整数值。用于实现进程间的互斥与同步<br>，在信号量上只有三种操作可以进行，这三种操作都是原子操作</li>
</ol>
<ul>
<li>初始化</li>
<li>P操作 可以用于阻塞一个进程</li>
<li>V操作 用于解除阻塞一个进程</li>
</ul>
<p>基本原理是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫<br>在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量</p>
<ol start="2">
<li>管程 管程是由一个或多个过程、一个初始化序列和局部数据组成的软件<br>模块。局部数据变量只能被管程的过程访问，任何外部过程都不能访问。一<br>个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程<br>在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。管<br>程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，<br>并且只有在管程中才能被访问。有两个函数可以操作条件变量</li>
</ol>
<ul>
<li>cwait(c) 调用进程的执行在条件c上阻塞，管程现在可被另一个进程使用</li>
<li>csignal(c) 恢复执行在cwait之后因为某些条件而阻塞的进程。如果有多<br>个这样的进程，选择其中一个，如果没有这样的进程，什么也不做</li>
</ul>
<ol start="3">
<li>消息传递 消息传递的实际功能以一对原语的形式提供</li>
</ol>
<ul>
<li>send(destination,message)</li>
<li>receive(source,message)</li>
</ul>
<p>这是进程间进程消息传递所需要的最小操作集，一个进程以消息的形式给另一<br>个指定的目标进程发送消息，进程通过执行receive原语接收消息，receive<br>原语中指明发送消息的源进程和消息</p>
<h3 id="线程同步的方式？"><a href="#线程同步的方式？" class="headerlink" title="线程同步的方式？"></a>线程同步的方式？</h3><ol>
<li>信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程<br>访问同一个资源，PV操作</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可<br>以方便的实现多线程优先级的比较操作</li>
<li>互斥量 互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核<br>对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程<br>间实现同步，从而实现资源的安全共享</li>
<li>临界区 临界区对应着一个CcriticalSection对象，当线程需要访问保护数<br>据时，调用EnterCriticalSection函数，当对保护数据的操作完成之后，调用<br>LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以<br>夺取临界区对象并访问受保护的数据</li>
</ol>
<h3 id="地址空间是什么？"><a href="#地址空间是什么？" class="headerlink" title="地址空间是什么？"></a>地址空间是什么？</h3><p>引入地址空间的概念就是为了在内存中同时运行多个程序并且互不影响，解决<br>了保护和重定位问题。<br>概念：地址空间是一个进程可以用于寻址内存的一套地址集合。每个进程都有<br>自己的地址空间，并且这个地址空间独立于其他进程的地址空间</p>
<h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>虚拟内存：每个程序有自己的地址空间，把这个空间分割为多块，每一块称为<br>页，每一页都有连续的地址范围，执行时这些页映射到物理内存。但并不是所<br>有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地<br>址空间时，由硬件立刻进行必要的映射，当程序引用到一部分不在物理内存<br>中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失<br>败的命令</p>
<h3 id="什么是分页系统"><a href="#什么是分页系统" class="headerlink" title="什么是分页系统"></a>什么是分页系统</h3><p>程序产生的地址是虚拟地址，构成了一个地址空间。虚拟地址不是被送到<br>内存总线上而是送到内存管理单元MMU，MMU把虚拟地址映射为物理地址。<br>虚拟空间被划分为若干页面，物理地址中页面对应的空间叫做页框。<br>MMU管理地址空间和物理空间的转换，如果一个页面没有被映射就是缺页<br>中断或缺页错误</p>
<h3 id="分页是什么？"><a href="#分页是什么？" class="headerlink" title="分页是什么？"></a>分页是什么？</h3><p>分页机制的思想是:通过映射，可以使连续的线性地址与物理地址相关联，<br>逻辑上连续的线性地址对应的物理地址可以不连续。 分页的作用- 将线<br>性地址转换为物理地址 - 用大小相同的页替换大小不同的段</p>
<h3 id="什么是页表？"><a href="#什么是页表？" class="headerlink" title="什么是页表？"></a>什么是页表？</h3><p>页表存储页和页框的映射表。一个虚拟地址被分为两部分，一部分存储页<br>号，另一部分存储偏移量。一个页面存储16个页，那么需要4位比特来表<br>示在索引定位，所以虚拟地址的前4位就可表示页的索引，后12位是偏<br>移量，页表中第二个子段就是页框号，页框号加上偏移量就是实际的<br>物理地址，页表的第三个字段就是在/不在</p>
<h3 id="页表项的结构是什么样的？"><a href="#页表项的结构是什么样的？" class="headerlink" title="页表项的结构是什么样的？"></a>页表项的结构是什么样的？</h3><p>页框号：该页需要映射到的物理页<br>在/不在位：如果是1表示该表项有效可以使用，如果是0表示对应的虚拟<br>页面不在内存中<br>保护位：一个页运行什么类型的访问，可以使用3位，对应读、写或修改<br>修改位：重新分配页框时如果该页已经被修改需要写回磁盘，如果没有<br>被修改直接丢弃即可，有时也叫脏位<br>访问位：不管读还是写该页面被访问时都会设置访问位，不再使用的页<br>面比正在使用的页面更适合淘汰<br>高速缓存禁止位：保证硬件是不断从设备总读取数据而不是访问旧的被<br>高速缓存的副本时使用</p>
<h3 id="加速分页过程是怎样的？"><a href="#加速分页过程是怎样的？" class="headerlink" title="加速分页过程是怎样的？"></a>加速分页过程是怎样的？</h3><p>大量程序总是对少量页面进行多次访问，可以设置一个小型的硬件设备<br>，将虚拟地址直接映射到物理地址。这种设备就是转换检测缓冲区TLB，<br>有时也称为相连存储器或块表。软失效是页面不在TLB中，需要从内存<br>中获取。硬失效是页面不在内存中，那么必须从磁盘读取。<br>TLB能够加速虚拟地址到物理地址的转换，还有一个问题是处理巨大的<br>虚拟地址空间。有两种解决办法</p>
<ol>
<li>多级页表<br>引入多级页表是避免把全部页表一直保存在内存中。把32位虚拟地址分<br>为10位的PT1域、10位的PT2域和12位的PT3域，顶级页表对应10位的<br>PT1域，有1024个表项，每一个表项都表示4M的块地址范围，二级页<br>表的索引是PT2域</li>
<li>倒排页表<br>每个页框对应一个表项，而不是每个虚拟页面对应一个表项，这样可以<br>节省大量空间，但是从虚拟地址到物理地址的转换会非常困难</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在发送缺页中断时，需要选择一个页面，将其换出内存，如果每次都选择<br>不常使用的页面会提升系统性能，如果一个频繁使用的页面被置换出去会<br>带来不必要的开销</p>
<ol>
<li>最佳 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证<br>获得最低的缺页率</li>
<li>最近最久未使用 虽然无法知道将来要使用的页面情况，但是可以知道过<br>去使用页面的情况。LRU 将最近最久未使用的页面换出。为了实现 LRU，需<br>要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移<br>到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次<br>访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</li>
<li>最近未使用 每个页面都有两个状态位：R 与 M，当页面被访问时设置页<br>面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。优先换出被<br>修改并且没有再被访问的页面</li>
<li>先进先出FIFO 选择换出的页面是最先进入的页面。该算法会将那些经常<br>被访问的页面换出，导致缺页率升高</li>
</ol>
<h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ol>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 </li>
<li>页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间，将用户程序地址空<br>间分为若干固定大小的区域</li>
<li>分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助<br>于共享和保护</li>
<li>段的大小不固定，由它所完成的功能决定，页大大小固定，由系统决定</li>
<li>分段是二维的，如代码段，数据段，堆栈段，这样每个进程有一个二维地址<br>空间，相互独立，互不干扰</li>
</ol>
<h3 id="局部性原理？"><a href="#局部性原理？" class="headerlink" title="局部性原理？"></a>局部性原理？</h3><ol>
<li>时间上的局部性：最近被访问的页在不久的将来还会被访问</li>
<li>空间上的局部性：内存中被访问的页周围的页也很可能被访问</li>
</ol>
<h3 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h3><p>文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打<br>开的文件，对文件所有I/O 操作相关的系统调用都需要通过文件描述符</p>
<ol>
<li>进程级别的文件描述符表：内核为每个进程维护一个文件描述符表，该表<br>记录了文件描述符的相关信息，包括文件描述符、指向打开文件表中记录的<br>指针</li>
<li>系统级别的打开文件表：内核对所有打开文件维护了一个进程共享的打开<br>文件描述表，表中存储了处于打开状态文件的相关信息，包括文件类型、访<br>问权限、文件操作函数等</li>
<li>系统级别的i-node 表：i-node 结构体记录了文件相关的信息，包括文<br>件长度，文件所在设备，文件物理位置，创建、修改和更新时间等，”ls -i”<br>命令可以查看文件i-node 节点</li>
</ol>
<h3 id="Socket-是什么？"><a href="#Socket-是什么？" class="headerlink" title="Socket 是什么？"></a>Socket 是什么？</h3><p>Socket是应用层与TCP/IP协议通信的中间软件抽象层，它是一组接口</p>
<h3 id="I-O模型中的输入操作？"><a href="#I-O模型中的输入操作？" class="headerlink" title="I/O模型中的输入操作？"></a>I/O模型中的输入操作？</h3><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所<br>等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核<br>缓冲区复制到应用进程缓冲区</p>
<ol>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ol>
<h3 id="I-O模型分为几种？"><a href="#I-O模型分为几种？" class="headerlink" title="I/O模型分为几种？"></a>I/O模型分为几种？</h3><ol>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ol>
<h3 id="阻塞式I-O-是什么？"><a href="#阻塞式I-O-是什么？" class="headerlink" title="阻塞式I/O 是什么？"></a>阻塞式I/O 是什么？</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回，<br>在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系<br>统都被阻塞</p>
<ol>
<li>CPU把数据从磁盘读到内核缓冲区</li>
<li>CPU把数据从内核缓冲区拷贝到用户缓冲区</li>
</ol>
<h3 id="非阻塞式I-O-是什么？"><a href="#非阻塞式I-O-是什么？" class="headerlink" title="非阻塞式I/O 是什么？"></a>非阻塞式I/O 是什么？</h3><p>非阻塞IO发出read请求后发现数据没准备好，会继续往下执行，此时应用程<br>序会不断轮询polling内核询问数据是否准备好，当数据没有准备好时，内<br>核立即返回EWOULDBLOCK错误。直到数据被拷贝到应用程序缓冲区，read请<br>求才获取到结果。这里最后一次read 调用获取数据的过程，是一个同步的<br>过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序<br>的缓存区这个过程</p>
<h3 id="I-O-多路复用？"><a href="#I-O-多路复用？" class="headerlink" title="I/O 多路复用？"></a>I/O 多路复用？</h3><ol>
<li>非阻塞情况下无可用数据时，应用程序每次轮询内核看数据是否准备好<br>了也耗费CPU</li>
<li>I/O复用就是不让它轮询，当内核缓冲区数据准备好了，以事件通知当机<br>制告知应用进程数据准备好，应用进程在没有收到数据准备好的事件通知信<br>号时可以忙写其他的工作</li>
<li>I/O就是指的我们网络I/O，多路指多个TCP连接(或多个Channel)，复<br>用指复用一个或少量线程。串起来理解就是很多个网络I/O复用一个或少量<br>的线程来处理这些连接。发明它的目的是尽量多的提高服务器的吞吐能力。<br>实现一个线程监控多个IO请求，哪个IO有请求就把数据从内核拷贝到进程<br>缓冲区，拷贝期间是阻塞的</li>
<li>通过一种机制可以监视多个文件描述符，一旦某个文件描述符就绪（一<br>般是读就绪或者写就绪），就能够通知进程进行相应的读写操作，select<br>poll epoll都是IO 多路复用的一种机制，他们三个本质上都是同步IO，<br>因为 它们都需要在读写事件就绪后自己负责读写操作，也就是读写过程<br>中是阻塞的，而异步IO无需自己进行读写，它只负责发起事件具体的实<br>现由别的完成</li>
<li>使用select 或者poll 等待数据，并且可以等待多个套接字中的任何<br>一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再<br>使用recvfrom 把数据从内核复制到进程中，它可以让单个进程具有处<br>理多个I/O 事件的能力</li>
<li>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event<br>Driven I/O，即事件驱动 I/O</li>
<li>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需<br>要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数<br>量的线程</li>
</ol>
<h3 id="select-是什么？"><a href="#select-是什么？" class="headerlink" title="select 是什么？"></a>select 是什么？</h3><p>该函数会等待多个I/O事件(比如读就绪，写)的任何一个发生，并且只要<br>有一个网络事件发生，select 线程就会执行。如果没有任何一个事件发<br>生则阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int select(int maxfdpl,fd_set *readset,fd_set *writeset,fd_set *exceptset,</span><br><span class="line">	const struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为<br>就绪状态，从而完成 I/O 操作</p>
<h3 id="poll-是什么？"><a href="#poll-是什么？" class="headerlink" title="poll 是什么？"></a>poll 是什么？</h3><p>poll 的功能与select 类似，也是等待一组描述符中的一个成为就绪状态</p>
<h3 id="epoll-是什么？"><a href="#epoll-是什么？" class="headerlink" title="epoll 是什么？"></a>epoll 是什么？</h3><p>epoll 是线程安全的，不仅告诉你sock组里面数据，还会告诉你具体哪个<br>sock有数据，你不用自己去找了</p>
<h3 id="select和poll的区别？"><a href="#select和poll的区别？" class="headerlink" title="select和poll的区别？"></a>select和poll的区别？</h3><ol>
<li>select 会修改描述符，而 poll 不会</li>
</ol>
<h3 id="recvfrom-是什么？"><a href="#recvfrom-是什么？" class="headerlink" title="recvfrom 是什么？"></a>recvfrom 是什么？</h3><p>recvfrom一般用于UDP协议中，但是如果在TCP中connect函数调用后也可以<br>用。用于从（已连接）套接口上接收数据，并捕获数据发送源的地址</p>
<h3 id="Epoll和Poll和Select？"><a href="#Epoll和Poll和Select？" class="headerlink" title="Epoll和Poll和Select？"></a>Epoll和Poll和Select？</h3><p>select/poll/epoll 都是 I/O 多路复用的具体实现</p>
<ol>
<li>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为<br>就绪状态，从而完成 I/O 操作</li>
<li>poll poll 的功能与 select 类似，也是等待一组描述符中的一个成为就<br>绪状态，poll 中的描述符是pollfd 类型的数组</li>
<li>epoll 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注<br>册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将I/O 准<br>备好的描述符加入到一个链表中管理</li>
</ol>
<h3 id="阻塞式I-O和I-O复用的区别？"><a href="#阻塞式I-O和I-O复用的区别？" class="headerlink" title="阻塞式I/O和I/O复用的区别？"></a>阻塞式I/O和I/O复用的区别？</h3><ol>
<li>阻塞式I/O和I/O复用，两个阶段都阻塞，等待数据和将数据复制到用户进<br>程这两个阶段都是阻塞的</li>
<li>虽然第一阶段都是阻塞，但是阻塞式I/O如果要接收更多的连接，就必须创<br>建更多的线程。I/O复用模式下在第一个阶段大量的连接统统都可以过来直接注<br>册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连<br>接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。<br>这就是I/O复用与传统的阻塞式I/O最大的不同</li>
</ol>
<h3 id="信号驱动I-O-是什么？"><a href="#信号驱动I-O-是什么？" class="headerlink" title="信号驱动I/O 是什么？"></a>信号驱动I/O 是什么？</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续<br>执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向<br>应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用<br>recvfrom 将数据从内核复制到应用进程中</p>
<h3 id="异步I-O-是什么？"><a href="#异步I-O-是什么？" class="headerlink" title="异步I/O 是什么？"></a>异步I/O 是什么？</h3><p>真正的异步I/O 是内核数据准备好和数据从内核态拷贝到用户态这两个过<br>程都不用等待，当用户发起aio_read请求后就会自动返回。内核会自动将<br>数据从内核缓冲区拷贝到用户进程空间，应用进程啥都不用管，内核会在<br>所有操作完成之后向应用进程发送信号。<br>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用<br>进程I/O 完成，而信号驱动I/O 的信号是通知应用进程可以开始 I/O</p>
<h3 id="异步是什么？"><a href="#异步是什么？" class="headerlink" title="异步是什么？"></a>异步是什么？</h3><p>对于异步来说，用户进行读或者写后，将立刻返回，由内核去完成数据读取<br>以及拷贝工作，完成后通知用户，并执行回调函数（用户提供的callback<br>），此时数据已从内核拷贝到用户空间，用户线程只需要对数据进行处理<br>即可，不需要关注读写，用户不需要等待内核对数据的复制操作，用户在<br>得到通知时数据已经被复制到用户空间</p>
<h3 id="同步的异步的区别？"><a href="#同步的异步的区别？" class="headerlink" title="同步的异步的区别？"></a>同步的异步的区别？</h3><ol>
<li>同步跟异步的区别在于数据从内核空间拷贝到用户空间是否由用户线程<br>完成，这里又分为同步阻塞跟同步非阻塞两种</li>
<li>同步阻塞 此时一个线程维护一个连接，该线程完成数据到读写跟处理<br>到全部过程，数据读写时时线程是被阻塞的</li>
<li>同步非阻塞 非阻塞的意思是用户线程发出读请求后，读请求不会阻塞<br>当前用户线程，不过用户线程还是要不断的去主动判断数据是否准备OK了<br>。此时还是会阻塞等待内核复制数据到用户进程。他与同步BIO区别是使用<br>一个连接全程等待</li>
<li>同步在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一<br>旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用<br>的结果</li>
<li>异步调用在发出之后，这个调用就直接返回了，所以没有返回结果。换<br>句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<br>调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处<br>理这个调用</li>
</ol>
<h3 id="Java-IO分为哪几种？"><a href="#Java-IO分为哪几种？" class="headerlink" title="Java IO分为哪几种？"></a>Java IO分为哪几种？</h3><ol>
<li>BIO：同步阻塞IO</li>
<li>NIO：同步非阻塞IO</li>
<li>AIO：异步非阻塞IO</li>
</ol>
<h3 id="BIO-是什么？"><a href="#BIO-是什么？" class="headerlink" title="BIO 是什么？"></a>BIO 是什么？</h3><ol>
<li>同步阻塞IO，每个客户端的Socket连接请求，服务端都会对应有个处理<br>线程与之对应，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当<br>于是一个连接一个线程</li>
<li>使用一个独立的线程维护一个socket连接，随着连接数量的增多，对虚<br>拟机造成一定压力</li>
<li>使用流来读取数据，流是阻塞的，当没有可读/可写数据时，线程等待<br>，会造成资源的浪费</li>
</ol>
<h3 id="NIO-是什么？"><a href="#NIO-是什么？" class="headerlink" title="NIO 是什么？"></a>NIO 是什么？</h3><ol>
<li>同步非阻塞，也就是说如果你调用NIO接口去执行IO操作，其实还是同步<br>等待的，但是在底层的IO操作上 ，会对系统内核发起非阻塞IO请求，以非<br>阻塞的形式来执行IO。也就是说，如果底层数据没到位，那么内核返回异常<br>信息，不会阻塞住，但是NIO接口内部会采用非阻塞方式过一会儿再次调用<br>内核发起IO请求，直到成功为止。但是之所以说是同步非阻塞，这里的“同<br>步”指的就是因为在你的Java代码调用NIO接口层面是同步的，你还是要同<br>步等待底层IO操作真正完成了才可以返回，只不过在执行底层IO的时候采<br>用了非阻塞的方式来执行罢了</li>
<li>服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发<br>现某个Socket端口上有数据可读时说明读就绪，则调用该socket连接的相<br>应读操作。如果发现某个 Socket端口上有数据可写时说明写就绪，则调用<br>该socket连接的相应写操作。如果某个端口的Socket连接已经中断，则调<br>用相应的析构方法关闭该端口</li>
<li>每个线程中包含一个Selector对象，它相当于一个通道管理器，可以实<br>现在一个线程中处理多个通道的目的，减少线程的创建数量。远程连接对应<br>一个channel，数据的读写通过buffer均在同一个channel中完成，并且<br>数据的读写是非阻塞的</li>
<li>通道创建后需要注册在selector中，同时需要为该通道注册感兴趣事件<br>（客户端连接服务端事件、服务端接收客户端连接事件、读事件、写事件），<br>selector线程需要采用轮训的方式调用selector的select函数，直到所<br>有注册通道中有兴趣的事件发生，则返回，否则一直阻塞。而后循环处理<br>所有就绪的感兴趣事件。以上步骤解决BIO的两个瓶颈：</li>
</ol>
<ul>
<li>不必对每个连接分别创建线程</li>
<li>数据读写非阻塞</li>
</ul>
<p>Java NIO由以下三个核心部分组成</p>
<ol>
<li>selector：Selector 允许单线程处理多个Channel。如果你的应用打开<br>了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便<br>。要使用Selector，得向Selector注册Channel，然后调用他的select 方<br>法，这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回<br>，线程就可以处理这些事件，事件的例子入有新连接接进来，数据接收等</li>
<li>Channel：基本上所有的IO在NIO中都从一个Channel开始。Channel有点<br>像流，数据可以从channel读到buffer，也可以从buffer写到channel</li>
<li>Buffer：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个<br>容器对象( 含数组)，该对象提供了一组方法，可以更轻松的使用内存块，缓<br>冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变换情况，Channel<br>提供从文件，网络读取数据的渠道，但是读取或者写入的数据都必须经由Buffer</li>
</ol>
<h3 id="NIO-和IO-多路复用的关系？"><a href="#NIO-和IO-多路复用的关系？" class="headerlink" title="NIO 和IO 多路复用的关系？"></a>NIO 和IO 多路复用的关系？</h3><ol>
<li>实际上，如果基于NIO进行网络通信，采取的就是多路复用的IO模型，这个<br>多路复用IO模型针对的是网络通信中的IO场景来说的</li>
<li>简单来说，就是在基于Socket进行网络通信的时候，如果有多个客户端跟<br>你的服务端建立了Socket连接，那你就需要维护多个Socket连接</li>
<li>而所谓的多路复用IO模型，就是说你的Java代码直接通过一个select函数<br>调用，直接会进入一个同步等待的状态。必须在这里同步等待某个Socket连接<br>有请求到来，接着你就要同步等着select函数去对底层的多个Socket 连接<br>进行轮询，不断的查看各个 Socket 连接谁有请求到达，就可以让select<br>函数返回</li>
<li>select函数在底层会通过非阻塞的方式轮询各个Socket，任何一个Socket<br>如果没有数据到达，那么非阻塞的特性会立即返回一个信息，然后select函数<br>可以轮询下一个Socket，不会阻塞在某个Socket上</li>
<li>这就是所谓的“同步非阻塞”，但是因为操作系统把上述工作都封装在一个<br>select函数调用里了，可以对多路Socket连接同时进行监视，所以就把这种<br>模型称之为“IO多路复用”模型</li>
<li>通过这种IO多路复用的模型，就可以用一个线程，调用一个select函数<br>，然后监视大量的客户端连接</li>
</ol>
<h3 id="AIO-是什么？"><a href="#AIO-是什么？" class="headerlink" title="AIO 是什么？"></a>AIO 是什么？</h3><ol>
<li>AIO是异步非阻塞IO，相比NIO更进一步，进程读取数据时只负责发送跟接<br>收指令，数据的准备工作完全由操作系统来处理</li>
<li>可以基于AIO API发起一个请求，比如说接收网络数据，AIO API底层会<br>基于异步IO模型来调用操作系统内核，此时不需要去管这个IO是否成功了，<br>AIO接口会直接返回</li>
<li>BIO、NIO都是同步的，你发起IO请求，都必须同步等待IO操作完成</li>
<li>不过你需要提供一个回调函数给AIO接口，一旦底层系统内核完成了具体<br>的IO请求，比如网络读写之类的，就会回调你提供的回调函数</li>
</ol>
<h3 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h3><p>协程是比线程更小的一种执行单元，你可以认为是轻量级的线程，一个线<br>程也可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程<br>序所控制（也就是在用户态执行）</p>
<h3 id="为什么是轻量级的线程？"><a href="#为什么是轻量级的线程？" class="headerlink" title="为什么是轻量级的线程？"></a>为什么是轻量级的线程？</h3><p>协成是基于线程实现的，协程的创建、切换、销毁都是在某个线程中来进行的<br>，协程占用内存少，只需要极少的栈内存（大概是4～5KB），默认情况下，<br>线程栈的大小为1MB</p>
<h3 id="协程和线程的区别？"><a href="#协程和线程的区别？" class="headerlink" title="协程和线程的区别？"></a>协程和线程的区别？</h3><ol>
<li>线程在进行切换的时候，需要将CPU中的寄存器的信息存储起来，然后读<br>入另外一个线程的数据</li>
<li>线程的切换会涉及到用户模式到内核模式的切换，据说每次模式切换都<br>需要执行上千条指令</li>
<li>线程切换时CPU的高速缓存中的数据，也可能失效，需要重新加载</li>
<li>协程在切换的时候，寄存器需要保存和加载的数据量比较小</li>
<li>协程没有用户模式到内核模式的切换操作</li>
<li>更有效率的调度，因为协程是非抢占式的，前一个协程执行完毕或者堵塞<br>，才会让出CPU，而线程则一般使用了时间片的算法，会进行很多没有必要的<br>切换</li>
<li>无需系统自动切换（系统自动切换会浪费很多的资源），而协程是我们用<br>户手动切换，而且是在同一个栈上执行，速度就会非常快而且省资源</li>
</ol>
<h3 id="Linux下如何查看tcp连接？"><a href="#Linux下如何查看tcp连接？" class="headerlink" title="Linux下如何查看tcp连接？"></a>Linux下如何查看tcp连接？</h3><p>netstat -nat|grep -i “80”|wc -l</p>
<h3 id="网络监听需要什么函数？"><a href="#网络监听需要什么函数？" class="headerlink" title="网络监听需要什么函数？"></a>网络监听需要什么函数？</h3><ol>
<li>listen listent函数创建一个监听队列以存放待处理的客户连接，将套接字<br>sockfd指定为被监听的socket</li>
</ol>
<h3 id="互斥锁和信号量的区别？"><a href="#互斥锁和信号量的区别？" class="headerlink" title="互斥锁和信号量的区别？"></a>互斥锁和信号量的区别？</h3><ol>
<li>互斥锁和互斥量是一个意思，互斥锁的作用就是互斥，是用来保护临界区的</li>
<li>信号量是一种更高级的同步机制，mutex（互斥锁）可以说是信号量在仅取<br>值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而<br>不单单是线程间互斥 </li>
</ol>
<h3 id="互斥锁与自旋锁的区别？"><a href="#互斥锁与自旋锁的区别？" class="headerlink" title="互斥锁与自旋锁的区别？"></a>互斥锁与自旋锁的区别？</h3><ol>
<li>重量级锁需要通过操作系统自身的互斥量（mutex lock，也称为互斥锁）<br>来实现，然而这种实现方式需要通过用户态与和核心态的切换来实现，但这个<br>切换的过程会带来很大的性能开销</li>
<li>申请锁时，从用户态进入内核态，申请到后从内核态返回用户态（两次切<br>换），没有申请到时阻塞睡眠在内核态。使用完资源后释放锁，从用户态进入<br>内核态，唤醒阻塞等待锁的进程，返回用户态（又两次切换），被唤醒进程<br>在内核态申请到锁，返回用户态（可能其他申请锁的进程又要阻塞）。所以<br>，使用一次锁，包括申请，持有到释放，当前进程要进行四次用户态与内<br>核态的切换。同时其他竞争锁的进程在这个过程中也要进行一次切换</li>
<li>自旋锁与互斥锁不同的是自旋锁不会引起调用者睡眠。如果自旋锁已经被<br>别的进程保持，调用者就轮询（不断的消耗CPU的时间）是否该自旋锁的保<br>持者已经释放了锁</li>
<li>在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号<br>量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒<br>休眠的线程</li>
</ol>
<h3 id="sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"><a href="#sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？" class="headerlink" title="sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"></a>sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？</h3><ol>
<li>usleep()函数 单位是微秒</li>
</ol>
<h3 id="磁盘坏掉了，操作系统是怎么处理应对的？"><a href="#磁盘坏掉了，操作系统是怎么处理应对的？" class="headerlink" title="磁盘坏掉了，操作系统是怎么处理应对的？"></a>磁盘坏掉了，操作系统是怎么处理应对的？</h3><ol>
<li>磁盘扫描工具扫描磁盘驱动器</li>
</ol>
<h3 id="缓存？"><a href="#缓存？" class="headerlink" title="缓存？"></a>缓存？</h3><p>缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，因此<br>速率很快</p>
<h3 id="进程的内存空间分布？"><a href="#进程的内存空间分布？" class="headerlink" title="进程的内存空间分布？"></a>进程的内存空间分布？</h3><p>用户空间被分为几个段，从高地址到低地址分别为：Stack, Heap, BSS,<br>Data, Text</p>
<ol>
<li>程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码</li>
<li>初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据</li>
<li>未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据</li>
<li>堆 (Heap):存储动态内存分配，需要程序员手工分配，手工释放</li>
<li>栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，<br>用于控制函数的调用和返回。在程序块开始时自动分配内存，结束时自动<br>释放内存</li>
</ol>
<h3 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h3><ol>
<li>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的<br>程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处<br>继续执行原来的程序</li>
<li>中断一般三类，一种是由CPU外部引起的，称为外中断。如I/O中断、时钟中<br>断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，<br>地址越界、浮点溢出）称为内中断，或者（异常，陷入），最后一种是在程序<br>中使用了系统调用引起的</li>
<li>中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中<br>断处理主要由软件实施</li>
</ol>
<h3 id="CPU在中断时会干嘛？"><a href="#CPU在中断时会干嘛？" class="headerlink" title="CPU在中断时会干嘛？"></a>CPU在中断时会干嘛？</h3><p>中断是CPU响应外设需求的一种模式，在外设需要CPU时，会向中断控制器发送<br>中断请求，这时CPU 要保护现场，即把正在运行的程序保存起来，一般是把状<br>态压入堆栈，然后读中断号，启动相应的中断服务程序，服务完成后，载入保<br>护现场，即把堆栈的数据弹出，继续运行之前的程序</p>
<h3 id="中断分为几种？"><a href="#中断分为几种？" class="headerlink" title="中断分为几种？"></a>中断分为几种？</h3><ol>
<li>中断(Interruption)，也称外中断，指来自CPU执行指令以外的事件的发<br>生，如设备发出的I/O 结束中断，表示设备输入/输出处理已经完成，希望处<br>理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序<br>继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动<br>定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们<br>与当前处理机运行的程序无关</li>
<li>异常（陷入），也叫内中断。是由CPU内部事件所引起的中断，例如进程在<br>运算中发生了上溢或者下溢，有如程序出错，如非法指令，地址越界等。通常<br>把这类中断称为内中断或者陷入。若系统发现有陷入事件，CPU也将暂停正在<br>执行的程序，转去执行该陷入事件的处理程序</li>
</ol>
<h3 id="如何处理中断？"><a href="#如何处理中断？" class="headerlink" title="如何处理中断？"></a>如何处理中断？</h3><ol>
<li>屏蔽中断 当处理机正在处理一个中断时，将屏蔽掉所有的中断，即处理机<br>对任何新到的中断请求，都暂时不予理睬，而让他们等待，直到处理机已完成<br>本次中断的处理后，处理机再去检查是否有中断发生，不适合用于对实时性要<br>求较高的中断请求</li>
<li>嵌套中断 当同时有多个不同优先级的中断请求时，CPU优先响应最高优先<br>级的中断请求</li>
</ol>
<h3 id="中断程序处理过程？"><a href="#中断程序处理过程？" class="headerlink" title="中断程序处理过程？"></a>中断程序处理过程？</h3><ol>
<li>测定是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU的现场并退出中断</li>
</ol>
<h3 id="为什么要内核态-用户态？"><a href="#为什么要内核态-用户态？" class="headerlink" title="为什么要内核态/用户态？"></a>为什么要内核态/用户态？</h3><ol>
<li>在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃<br>，比如清内存、设置时钟等</li>
<li>CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作<br>系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令</li>
</ol>
<h3 id="多路复用的那三种方式有什么区别？"><a href="#多路复用的那三种方式有什么区别？" class="headerlink" title="多路复用的那三种方式有什么区别？"></a>多路复用的那三种方式有什么区别？</h3><ol>
<li>select</li>
</ol>
<ul>
<li>select能监控的描述符个数由内核中的FD_SETSIZE限制，仅为1024，这也<br>是select最大的缺点，因为现在的服务器并发量远远不止1024</li>
<li>每次调用select都会线性扫描所有描述符的状态，在select结束后，用户<br>也要线性扫描fd_set数组才知道哪些描述符准备就绪，等于说每次调用复杂<br>度都是O（n）的，在并发量大的情况下，每次扫描都是相当耗时的，很有可<br>能有未处理的连接等待超时</li>
<li>每次调用select都要在用户空间和内核空间里进行内存复制fd描述符等信息</li>
</ul>
<ol start="2">
<li>poll</li>
</ol>
<ul>
<li>poll使用pollfd结构来存储fd，突破了select中描述符数目的限制</li>
<li>与select的后两点类似，poll仍然需要将pollfd数组拷贝到内核空间，之<br>后依次扫描fd的状态，整体复杂度依然是O（n）的，在并发量大的情况下服<br>务器性能会快速下降</li>
</ul>
<ol start="3">
<li>epoll</li>
</ol>
<ul>
<li>epoll维护的描述符数目不受到限制，而且性能不会随着描述符数目的增加<br>而下降</li>
<li>epoll在传递内核与用户空间的消息时使用了内存共享，而不是内存拷贝，<br>这也使得epoll的效率比poll和select更高</li>
</ul>
<h3 id="fd是什么？"><a href="#fd是什么？" class="headerlink" title="fd是什么？"></a>fd是什么？</h3><ol>
<li>fd全称是file descriptor，是进程独有的文件描述符表的索引</li>
<li>每当进程用open（）函数打开一个文件，内核便会返回该文件的文件操作<br>符（一个非负的整形值），此后所有对该文件的操作，都会以返回的fd文件<br>操作符为参数</li>
</ol>
<h3 id="多路复用怎么解决阻塞IO-存在的问题？"><a href="#多路复用怎么解决阻塞IO-存在的问题？" class="headerlink" title="多路复用怎么解决阻塞IO 存在的问题？"></a>多路复用怎么解决阻塞IO 存在的问题？</h3><ol>
<li>异步编程框架是说框架内的业务代码与框架的接口是异步的，而框架与操<br>作系统的接口是同步非阻塞</li>
</ol>
<h3 id="查看内存的命令？"><a href="#查看内存的命令？" class="headerlink" title="查看内存的命令？"></a>查看内存的命令？</h3><ol>
<li>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的<br>资源占用状况</li>
<li>pmap -d 5647 可以根据进程查看进程相关信息占用的内存情况</li>
<li>free Linux的free命令是常用来查看内存的命令</li>
</ol>
<h3 id="查看日志的命令？"><a href="#查看日志的命令？" class="headerlink" title="查看日志的命令？"></a>查看日志的命令？</h3><ol>
<li>tail -n 10 test.log 查询日志尾部最后10行的日志</li>
<li>head 跟tail是相反的head是看前多少行日志</li>
</ol>
<h3 id="Linux-查看文件中是否存在某字符"><a href="#Linux-查看文件中是否存在某字符" class="headerlink" title="Linux 查看文件中是否存在某字符"></a>Linux 查看文件中是否存在某字符</h3><ol>
<li>grep “port:8080” pro.sh 查找pro文件中是否包含port:8080 内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep 指定字符串 文件的完整路径</span><br><span class="line">若不清楚字符串的大小写，可以在命令末尾加 -i ，这样查询将忽略字符串的大小写</span><br><span class="line">若需要查询指定字符串在文件中的位置，可以在命令末尾加 -n</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="linux如何分割文件字符串？"><a href="#linux如何分割文件字符串？" class="headerlink" title="linux如何分割文件字符串？"></a>linux如何分割文件字符串？</h3><ol>
<li>cut<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d 指定分隔符，如：按照“：”分割，-d:</span><br><span class="line">-c 提取第n个字节，如：-c5,表示提取每行的第5个字节</span><br><span class="line">-f 指定输出的域</span><br><span class="line">cut –d: -f1,2 &#x2F;&#x2F;按照”:”来分割，并输出第1和2段</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用的消息队列以及区别？"><a href="#常用的消息队列以及区别？" class="headerlink" title="常用的消息队列以及区别？"></a>常用的消息队列以及区别？</h3><p>消息队列是分布式应用间交换信息的重要组件，消息队列可驻留在内存或磁盘<br>上，队列可以存储消息直到它们被应用程序读走</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/23/Linux2/">https://skysea-gaoming.github.io/2021/04/23/Linux2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System/">System</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="fa fa-chevron-left">  </i><span>操作系统总结1</span></a></div><div class="next-post pull-right"><a href="/2021/04/22/Spring4/"><span>Spring4</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/23/Linux2/';
  this.page.identifier = '2021/04/23/Linux2/';
  this.page.title = 'Linux2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>