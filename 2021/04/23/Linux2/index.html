<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux2"><meta name="keywords" content="System"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Linux2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程上下文切换？"><span class="toc-number">1.1.</span> <span class="toc-text">进程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程上下文切换？"><span class="toc-number">1.2.</span> <span class="toc-text">线程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断上下文切换？"><span class="toc-number">1.3.</span> <span class="toc-text">中断上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么线程切换会有消耗，消耗啥？"><span class="toc-number">1.4.</span> <span class="toc-text">为什么线程切换会有消耗，消耗啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何查看上下文切换情况？"><span class="toc-number">1.5.</span> <span class="toc-text">如何查看上下文切换情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步、互斥和通信的区别？"><span class="toc-number">1.6.</span> <span class="toc-text">进程同步、互斥和通信的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界资源和临界区的区别？"><span class="toc-number">1.7.</span> <span class="toc-text">临界资源和临界区的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"><span class="toc-number">1.8.</span> <span class="toc-text">进程间通信方式（六种方式，各自的概念，区别都要搞清楚）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道、消息队列、共享内存它们三者哪个开销最小？"><span class="toc-number">1.9.</span> <span class="toc-text">管道、消息队列、共享内存它们三者哪个开销最小？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号与信号量的区别？"><span class="toc-number">1.10.</span> <span class="toc-text">信号与信号量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步的方式"><span class="toc-number">1.11.</span> <span class="toc-text">进程同步的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步的方式？"><span class="toc-number">1.12.</span> <span class="toc-text">线程同步的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件描述符是什么？"><span class="toc-number">1.13.</span> <span class="toc-text">文件描述符是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程是什么？"><span class="toc-number">1.14.</span> <span class="toc-text">协程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么是轻量级的线程？"><span class="toc-number">1.15.</span> <span class="toc-text">为什么是轻量级的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程和线程的区别？"><span class="toc-number">1.16.</span> <span class="toc-text">协程和线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux下如何查看tcp连接？"><span class="toc-number">1.17.</span> <span class="toc-text">Linux下如何查看tcp连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络监听需要什么函数？"><span class="toc-number">1.18.</span> <span class="toc-text">网络监听需要什么函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁和信号量的区别？"><span class="toc-number">1.19.</span> <span class="toc-text">互斥锁和信号量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁与自旋锁的区别？"><span class="toc-number">1.20.</span> <span class="toc-text">互斥锁与自旋锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"><span class="toc-number">1.21.</span> <span class="toc-text">sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘坏掉了，操作系统是怎么处理应对的？"><span class="toc-number">1.22.</span> <span class="toc-text">磁盘坏掉了，操作系统是怎么处理应对的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存？"><span class="toc-number">1.23.</span> <span class="toc-text">缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的内存空间分布？"><span class="toc-number">1.24.</span> <span class="toc-text">进程的内存空间分布？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是中断？"><span class="toc-number">1.25.</span> <span class="toc-text">什么是中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU在中断时会干嘛？"><span class="toc-number">1.26.</span> <span class="toc-text">CPU在中断时会干嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断分为几种？"><span class="toc-number">1.27.</span> <span class="toc-text">中断分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何处理中断？"><span class="toc-number">1.28.</span> <span class="toc-text">如何处理中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断程序处理过程？"><span class="toc-number">1.29.</span> <span class="toc-text">中断程序处理过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要内核态-用户态？"><span class="toc-number">1.30.</span> <span class="toc-text">为什么要内核态&#x2F;用户态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fd是什么？"><span class="toc-number">1.31.</span> <span class="toc-text">fd是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用怎么解决阻塞IO-存在的问题？"><span class="toc-number">1.32.</span> <span class="toc-text">多路复用怎么解决阻塞IO 存在的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看内存的命令？"><span class="toc-number">1.33.</span> <span class="toc-text">查看内存的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看日志的命令？"><span class="toc-number">1.34.</span> <span class="toc-text">查看日志的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-查看文件中是否存在某字符"><span class="toc-number">1.35.</span> <span class="toc-text">Linux 查看文件中是否存在某字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux如何分割文件字符串？"><span class="toc-number">1.36.</span> <span class="toc-text">linux如何分割文件字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的消息队列以及区别？"><span class="toc-number">1.37.</span> <span class="toc-text">常用的消息队列以及区别？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Linux2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/23/Linux2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/23/Linux2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《鸟哥的Linux私房菜》 《现代操作系统》<br><a href="https://blog.csdn.net/SakuraA6/article/details/108810916" target="_blank" rel="noopener">https://blog.csdn.net/SakuraA6/article/details/108810916</a></p>
<h3 id="进程上下文切换？"><a href="#进程上下文切换？" class="headerlink" title="进程上下文切换？"></a>进程上下文切换？</h3><p>进程执行过程中所涉及到的CPU上下文切换，我们称之为特权模式切换。从用<br>户态到内核态的转变就发生一次特权模式切换，如从磁盘上读取一个文件，<br>就发生了一次内核调用，也就发生一次特权模式切换</p>
<ol>
<li>CPU需要将寄存器中的用户态的指令位置保存起来，截至执行内核态的代码</li>
<li>CPU寄存器需要更新为内核态的新位置，最后跳转到内核态执行内核调用。<br>之后再恢复之前的用户态，这样的一次系统调用过程实际上发生了两次CPU上<br>下文切换</li>
</ol>
<p>这不是进程上下文切换，进程上下文切换只是说一个进程切换到另一个进程<br>首先进程的管理是有内核进行管理和调度的。进程的切换只能发生在内核态<br>所以进程的上下文切换不仅仅包括了虚拟内存，栈，全局变量等用户空间<br>资源，还包括了内核态堆栈，寄存器等内核空间状态</p>
<h3 id="线程上下文切换？"><a href="#线程上下文切换？" class="headerlink" title="线程上下文切换？"></a>线程上下文切换？</h3><ol>
<li>当进程拥有多个线程时，线程会共享虚拟内存和全局变量等资源，这些资<br>源在上下文切换中不需要修改</li>
<li>线程的上下文切换也需要保存自己的一些数据，比如栈，寄存器。这些在上<br>下文切换时是需要保存的</li>
<li>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</li>
</ol>
<h3 id="中断上下文切换？"><a href="#中断上下文切换？" class="headerlink" title="中断上下文切换？"></a>中断上下文切换？</h3><p>中断是为了快速响应硬件事件的，跟进程上下文不同，中断上下文不涉及进程<br>的用户态。即便打断的是一个用户态的进程，也不需要保存和恢复这个进程的<br>虚拟内存，全局变量等用户态资源。中断上下文只包括内核态中断服务程序执<br>行必需的状态。CPU寄存器，内核堆栈，硬件中断参数</p>
<h3 id="为什么线程切换会有消耗，消耗啥？"><a href="#为什么线程切换会有消耗，消耗啥？" class="headerlink" title="为什么线程切换会有消耗，消耗啥？"></a>为什么线程切换会有消耗，消耗啥？</h3><p>线程切换过程包括：线程上下文的保存和恢复，用户态和内核态的转换，CPU<br>上下文的切换，这些工作都需要CPU去完成</p>
<ol>
<li>CPU上下文切换 CPU寄存器和程序计数器切换</li>
<li>线程上下文切换 涉及线程状态的保存和恢复，包括寄存器、栈等私有数据</li>
<li>特权模式切换 线程的调度是需要内核级别的权限的（操作CPU和内存），<br>也就是说线程的调度工作是在内核态完成的，因此会有一个从用户态到内核态<br>的切换。而且，不管是线程本身的切换还是特权模式的切换，都要进行CPU的<br>上下文切换</li>
</ol>
<h3 id="如何查看上下文切换情况？"><a href="#如何查看上下文切换情况？" class="headerlink" title="如何查看上下文切换情况？"></a>如何查看上下文切换情况？</h3><ol>
<li>vmstat 查看系统的上下文切换情况</li>
<li>pidstat 可以看到具体的某个应用程序的上下文切换情况</li>
</ol>
<h3 id="进程同步、互斥和通信的区别？"><a href="#进程同步、互斥和通信的区别？" class="headerlink" title="进程同步、互斥和通信的区别？"></a>进程同步、互斥和通信的区别？</h3><p>进程之间存在两种基本关系：竞争关系和协作关系。进程的互斥、同步、通信都<br>是基于这两种基本关系而存在的</p>
<ol>
<li>为了解决进程间竞争关系（间接制约关系）而引入进程互斥</li>
<li>为了解决进程间松散的协作关系（直接制约关系）而引入进程同步</li>
<li>为了解决进程间紧密的协作关系而引入进程通信</li>
</ol>
<ul>
<li>资源竞争会产生两个问题：一个是死锁问题，一个是饥饿问题。进程的互斥<br>是解决进程间竞争关系(间接制约关系 ) 的手段。 进程互斥指若干个进程要<br>使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资<br>源的进程必须等待，直到占有资源的进程释放该资源。</li>
<li>某些进程为完成同一任务需要分工协作，这就需要相互协作的进程在某些协<br>调点上协调各自的工作。这种协作进程之间相互等待对方消息或信号的协调关<br>系称为进程同步，也就是说进程同步指两个以上进程基于某个条件来协调它<br>们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进<br>程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号<br>到达才被唤醒</li>
<li>进程之间互相交换信息的工作称之为进程通信IPC，主要是指大量数据的交换</li>
</ul>
<h3 id="临界资源和临界区的区别？"><a href="#临界资源和临界区的区别？" class="headerlink" title="临界资源和临界区的区别？"></a>临界资源和临界区的区别？</h3><ol>
<li>临界资源 临界资源是一次仅允许一个进程使用的共享资源。各进程采取互<br>斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，<br>磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方<br>式，实现对这种资源的共享</li>
<li>临界区 每个进程中访问临界资源的那段代码称为临界区。每次只允许一个<br>进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软<br>件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界<br>资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长<br>，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会<br>被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</li>
<li>临界区是用户态下的对象，即只能在同一进程中实现线程互斥。因无需在用<br>户态和核心态之间切换</li>
</ol>
<h3 id="进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"><a href="#进程间通信方式（六种方式，各自的概念，区别都要搞清楚）" class="headerlink" title="进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"></a>进程间通信方式（六种方式，各自的概念，区别都要搞清楚）</h3><p><a href="https://blog.csdn.net/watermelonmk/article/details/109002753" target="_blank" rel="noopener">https://blog.csdn.net/watermelonmk/article/details/109002753</a><br><a href="https://blog.csdn.net/qq_34796146/article/details/107825875" target="_blank" rel="noopener">https://blog.csdn.net/qq_34796146/article/details/107825875</a></p>
<ol>
<li>管道 管道传输数据是单向的，如果想相互通信，我们需要创建两个管道<br>才行。管道这种通信方式效率低，不适合进程间频繁地交换数据，所谓的管<br>道，就是内核里面的一串缓存。从管道的一端写入的数据，实际上是缓存在<br>内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的<br>数据是无格式的流且大小受限</li>
</ol>
<ul>
<li>匿名管道 没有名字标识，匿名管道是特殊文件只存在于内存，没有存在<br>于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无<br>格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上<br>流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于<br>存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立<br>，随着进程终止而消失</li>
<li>命名管道 突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用<br>命名管道的前提，需要在文件系统创建一个类型为p 的设备文件，那么毫<br>无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道<br>还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数<br>据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不<br>支持lseek 之类的文件定位操作</li>
</ul>
<ol start="2">
<li>消息队列 A 进程要给B 进程发送消息，A 进程把数据放在对应的消息<br>队列后就可以正常返回了，B进程需要的时候再去读取数据就可以了。同理<br>，B 进程要给A 进程发送消息也是如此。<br>消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际<br>上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数<br>据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时<br>，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的<br>数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入<br>和读取都需要经过用户态与内核态之间的拷贝过程。消息队列生命周期随<br>内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直<br>存在，如果进程从消息队列中读取了消息体，内核就会把这个消息体删<br>除而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程<br>的结束而销毁</li>
<li>共享内存 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相<br>同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到<br>了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。<br>共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来<br>的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问<br>进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提<br>高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享<br>内存通信，这种方式需要依靠某种同步操作，如互斥锁和信号量等</li>
<li>信号量 信号量其实是一个整型的计数器，主要用于实现进程间的互斥<br>与同步，而不是用于缓存进程间通信的数据</li>
<li>信号 信号是进程间通信机制中唯一的异步通信机制，信号可以在应用<br>进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发<br>生了哪些系统事件</li>
<li>SOCKET 前面提到的方式都是在同一台主机上进行进程间通信，那要想<br>跨网络与不同主机上的进程之间通信，就需要Socket 通信了。可根据创建<br>Socket 的类型不同，分为三种常见的通信方式，一个是基于TCP 协议的<br>通信方式，一个是基于UDP协议的通信方式，一个是本地进程间通信方式</li>
</ol>
<h3 id="管道、消息队列、共享内存它们三者哪个开销最小？"><a href="#管道、消息队列、共享内存它们三者哪个开销最小？" class="headerlink" title="管道、消息队列、共享内存它们三者哪个开销最小？"></a>管道、消息队列、共享内存它们三者哪个开销最小？</h3><p><a href="https://blog.csdn.net/qq_41999455/article/details/105275981" target="_blank" rel="noopener">https://blog.csdn.net/qq_41999455/article/details/105275981</a></p>
<ol>
<li>进程间的通信手段大体可以分为两类：通信类和同步类</li>
<li>本质来讲管道也是一片内存区域，默认大小是65536字节</li>
<li>相比于管道来讲，消息队列机制中，双方是通过消息来通信的，无需花<br>费精力从字节流中解析出完整的消息</li>
<li>消息队列的作用是进程之间传递消息。而信号量的作用是为了同步多个<br>进程的操作</li>
<li>共享内存是所有IPC手段中最快的一种。它之所以快是因为共享内存一旦<br>映射到进程的地址空间，进程之间数据的传递就不须要涉及内核了</li>
<li>共享内存是开销最小的通信方式，源于它和内核的交流比较少，从而降<br>低了开销</li>
</ol>
<h3 id="信号与信号量的区别？"><a href="#信号与信号量的区别？" class="headerlink" title="信号与信号量的区别？"></a>信号与信号量的区别？</h3><ol>
<li>信号事件的来源主要有两种</li>
</ol>
<ul>
<li>硬件来源（如键盘Cltr+C ） 产生SIGINT 信号，表示终止该进程</li>
<li>Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束</li>
<li>软件来源（如kill命令）</li>
</ul>
<p>信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给<br>某一进程，一旦有信号产生一旦有信号发生，进程有三种方式响应信号</p>
<ol>
<li>执行默认操作 Linux 对每种信号都规定了默认操作，例如，上面列表中<br>的SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即<br>终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方<br>便程序员事后进行分析问题在哪里</li>
<li>捕捉信号 我们可以为信号定义一个信号处理函数。当信号发生时，我们就<br>执行相应的信号处理函数</li>
<li>忽略信号 当我们不希望处理某些信号的时候，就可以忽略该信号，不做任<br>何处理。有两个信号是应用进程无法捕捉和忽略的，即SIGKILL 和SEGSTOP，<br>它们用于在任何时候中断或结束某一进程</li>
</ol>
<h3 id="进程同步的方式"><a href="#进程同步的方式" class="headerlink" title="进程同步的方式"></a>进程同步的方式</h3><ol>
<li>信号量 用于进程间传递信号的一个整数值。用于实现进程间的互斥与同步<br>，在信号量上只有三种操作可以进行，这三种操作都是原子操作</li>
</ol>
<ul>
<li>初始化</li>
<li>P操作 可以用于阻塞一个进程</li>
<li>V操作 用于解除阻塞一个进程</li>
</ul>
<p>基本原理是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫<br>在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量</p>
<ol start="2">
<li>管程 管程是由一个或多个过程、一个初始化序列和局部数据组成的软件<br>模块。局部数据变量只能被管程的过程访问，任何外部过程都不能访问。一<br>个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程<br>在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。管<br>程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，<br>并且只有在管程中才能被访问。有两个函数可以操作条件变量</li>
</ol>
<ul>
<li>cwait(c) 调用进程的执行在条件c上阻塞，管程现在可被另一个进程使用</li>
<li>csignal(c) 恢复执行在cwait之后因为某些条件而阻塞的进程。如果有多<br>个这样的进程，选择其中一个，如果没有这样的进程，什么也不做</li>
</ul>
<ol start="3">
<li>消息传递 消息传递的实际功能以一对原语的形式提供</li>
</ol>
<ul>
<li>send(destination,message)</li>
<li>receive(source,message)</li>
</ul>
<p>这是进程间进程消息传递所需要的最小操作集，一个进程以消息的形式给另一<br>个指定的目标进程发送消息，进程通过执行receive原语接收消息，receive<br>原语中指明发送消息的源进程和消息</p>
<h3 id="线程同步的方式？"><a href="#线程同步的方式？" class="headerlink" title="线程同步的方式？"></a>线程同步的方式？</h3><ol>
<li>信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程<br>访问同一个资源，PV操作</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可<br>以方便的实现多线程优先级的比较操作</li>
<li>互斥量 互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核<br>对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程<br>间实现同步，从而实现资源的安全共享</li>
<li>临界区 临界区对应着一个CcriticalSection对象，当线程需要访问保护数<br>据时，调用EnterCriticalSection函数，当对保护数据的操作完成之后，调用<br>LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以<br>夺取临界区对象并访问受保护的数据</li>
</ol>
<h3 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h3><p>文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打<br>开的文件，对文件所有I/O 操作相关的系统调用都需要通过文件描述符</p>
<ol>
<li>进程级别的文件描述符表：内核为每个进程维护一个文件描述符表，该表<br>记录了文件描述符的相关信息，包括文件描述符、指向打开文件表中记录的<br>指针</li>
<li>系统级别的打开文件表：内核对所有打开文件维护了一个进程共享的打开<br>文件描述表，表中存储了处于打开状态文件的相关信息，包括文件类型、访<br>问权限、文件操作函数等</li>
<li>系统级别的i-node 表：i-node 结构体记录了文件相关的信息，包括文<br>件长度，文件所在设备，文件物理位置，创建、修改和更新时间等，”ls -i”<br>命令可以查看文件i-node 节点</li>
</ol>
<h3 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h3><p>协程是比线程更小的一种执行单元，你可以认为是轻量级的线程，一个线<br>程也可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程<br>序所控制（也就是在用户态执行）</p>
<h3 id="为什么是轻量级的线程？"><a href="#为什么是轻量级的线程？" class="headerlink" title="为什么是轻量级的线程？"></a>为什么是轻量级的线程？</h3><p>协成是基于线程实现的，协程的创建、切换、销毁都是在某个线程中来进行的<br>，协程占用内存少，只需要极少的栈内存（大概是4～5KB），默认情况下，<br>线程栈的大小为1MB</p>
<h3 id="协程和线程的区别？"><a href="#协程和线程的区别？" class="headerlink" title="协程和线程的区别？"></a>协程和线程的区别？</h3><ol>
<li>线程在进行切换的时候，需要将CPU中的寄存器的信息存储起来，然后读<br>入另外一个线程的数据</li>
<li>线程的切换会涉及到用户模式到内核模式的切换，据说每次模式切换都<br>需要执行上千条指令</li>
<li>线程切换时CPU的高速缓存中的数据，也可能失效，需要重新加载</li>
<li>协程在切换的时候，寄存器需要保存和加载的数据量比较小</li>
<li>协程没有用户模式到内核模式的切换操作</li>
<li>更有效率的调度，因为协程是非抢占式的，前一个协程执行完毕或者堵塞<br>，才会让出CPU，而线程则一般使用了时间片的算法，会进行很多没有必要的<br>切换</li>
<li>无需系统自动切换（系统自动切换会浪费很多的资源），而协程是我们用<br>户手动切换，而且是在同一个栈上执行，速度就会非常快而且省资源</li>
</ol>
<h3 id="Linux下如何查看tcp连接？"><a href="#Linux下如何查看tcp连接？" class="headerlink" title="Linux下如何查看tcp连接？"></a>Linux下如何查看tcp连接？</h3><p>netstat -nat|grep -i “80”|wc -l</p>
<h3 id="网络监听需要什么函数？"><a href="#网络监听需要什么函数？" class="headerlink" title="网络监听需要什么函数？"></a>网络监听需要什么函数？</h3><ol>
<li>listen listent函数创建一个监听队列以存放待处理的客户连接，将套接字<br>sockfd指定为被监听的socket</li>
</ol>
<h3 id="互斥锁和信号量的区别？"><a href="#互斥锁和信号量的区别？" class="headerlink" title="互斥锁和信号量的区别？"></a>互斥锁和信号量的区别？</h3><ol>
<li>互斥锁和互斥量是一个意思，互斥锁的作用就是互斥，是用来保护临界区的</li>
<li>信号量是一种更高级的同步机制，mutex（互斥锁）可以说是信号量在仅取<br>值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而<br>不单单是线程间互斥 </li>
</ol>
<h3 id="互斥锁与自旋锁的区别？"><a href="#互斥锁与自旋锁的区别？" class="headerlink" title="互斥锁与自旋锁的区别？"></a>互斥锁与自旋锁的区别？</h3><ol>
<li>重量级锁需要通过操作系统自身的互斥量（mutex lock，也称为互斥锁）<br>来实现，然而这种实现方式需要通过用户态与和核心态的切换来实现，但这个<br>切换的过程会带来很大的性能开销</li>
<li>申请锁时，从用户态进入内核态，申请到后从内核态返回用户态（两次切<br>换），没有申请到时阻塞睡眠在内核态。使用完资源后释放锁，从用户态进入<br>内核态，唤醒阻塞等待锁的进程，返回用户态（又两次切换），被唤醒进程<br>在内核态申请到锁，返回用户态（可能其他申请锁的进程又要阻塞）。所以<br>，使用一次锁，包括申请，持有到释放，当前进程要进行四次用户态与内<br>核态的切换。同时其他竞争锁的进程在这个过程中也要进行一次切换</li>
<li>自旋锁与互斥锁不同的是自旋锁不会引起调用者睡眠。如果自旋锁已经被<br>别的进程保持，调用者就轮询（不断的消耗CPU的时间）是否该自旋锁的保<br>持者已经释放了锁</li>
<li>在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号<br>量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒<br>休眠的线程</li>
</ol>
<h3 id="sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"><a href="#sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？" class="headerlink" title="sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"></a>sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？</h3><ol>
<li>usleep()函数 单位是微秒</li>
</ol>
<h3 id="磁盘坏掉了，操作系统是怎么处理应对的？"><a href="#磁盘坏掉了，操作系统是怎么处理应对的？" class="headerlink" title="磁盘坏掉了，操作系统是怎么处理应对的？"></a>磁盘坏掉了，操作系统是怎么处理应对的？</h3><ol>
<li>磁盘扫描工具扫描磁盘驱动器</li>
</ol>
<h3 id="缓存？"><a href="#缓存？" class="headerlink" title="缓存？"></a>缓存？</h3><p>缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，因此<br>速率很快</p>
<h3 id="进程的内存空间分布？"><a href="#进程的内存空间分布？" class="headerlink" title="进程的内存空间分布？"></a>进程的内存空间分布？</h3><p>用户空间被分为几个段，从高地址到低地址分别为：Stack, Heap, BSS,<br>Data, Text</p>
<ol>
<li>程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码</li>
<li>初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据</li>
<li>未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据</li>
<li>堆 (Heap):存储动态内存分配，需要程序员手工分配，手工释放</li>
<li>栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，<br>用于控制函数的调用和返回。在程序块开始时自动分配内存，结束时自动<br>释放内存</li>
</ol>
<h3 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h3><ol>
<li>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的<br>程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处<br>继续执行原来的程序</li>
<li>中断一般三类，一种是由CPU外部引起的，称为外中断。如I/O中断、时钟中<br>断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，<br>地址越界、浮点溢出）称为内中断，或者（异常，陷入），最后一种是在程序<br>中使用了系统调用引起的</li>
<li>中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中<br>断处理主要由软件实施</li>
</ol>
<h3 id="CPU在中断时会干嘛？"><a href="#CPU在中断时会干嘛？" class="headerlink" title="CPU在中断时会干嘛？"></a>CPU在中断时会干嘛？</h3><p>中断是CPU响应外设需求的一种模式，在外设需要CPU时，会向中断控制器发送<br>中断请求，这时CPU 要保护现场，即把正在运行的程序保存起来，一般是把状<br>态压入堆栈，然后读中断号，启动相应的中断服务程序，服务完成后，载入保<br>护现场，即把堆栈的数据弹出，继续运行之前的程序</p>
<h3 id="中断分为几种？"><a href="#中断分为几种？" class="headerlink" title="中断分为几种？"></a>中断分为几种？</h3><ol>
<li>中断(Interruption)，也称外中断，指来自CPU执行指令以外的事件的发<br>生，如设备发出的I/O 结束中断，表示设备输入/输出处理已经完成，希望处<br>理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序<br>继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动<br>定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们<br>与当前处理机运行的程序无关</li>
<li>异常（陷入），也叫内中断。是由CPU内部事件所引起的中断，例如进程在<br>运算中发生了上溢或者下溢，有如程序出错，如非法指令，地址越界等。通常<br>把这类中断称为内中断或者陷入。若系统发现有陷入事件，CPU也将暂停正在<br>执行的程序，转去执行该陷入事件的处理程序</li>
</ol>
<h3 id="如何处理中断？"><a href="#如何处理中断？" class="headerlink" title="如何处理中断？"></a>如何处理中断？</h3><ol>
<li>屏蔽中断 当处理机正在处理一个中断时，将屏蔽掉所有的中断，即处理机<br>对任何新到的中断请求，都暂时不予理睬，而让他们等待，直到处理机已完成<br>本次中断的处理后，处理机再去检查是否有中断发生，不适合用于对实时性要<br>求较高的中断请求</li>
<li>嵌套中断 当同时有多个不同优先级的中断请求时，CPU优先响应最高优先<br>级的中断请求</li>
</ol>
<h3 id="中断程序处理过程？"><a href="#中断程序处理过程？" class="headerlink" title="中断程序处理过程？"></a>中断程序处理过程？</h3><ol>
<li>测定是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU的现场并退出中断</li>
</ol>
<h3 id="为什么要内核态-用户态？"><a href="#为什么要内核态-用户态？" class="headerlink" title="为什么要内核态/用户态？"></a>为什么要内核态/用户态？</h3><ol>
<li>在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃<br>，比如清内存、设置时钟等</li>
<li>CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作<br>系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令</li>
</ol>
<h3 id="fd是什么？"><a href="#fd是什么？" class="headerlink" title="fd是什么？"></a>fd是什么？</h3><ol>
<li>fd全称是file descriptor，是进程独有的文件描述符表的索引</li>
<li>每当进程用open（）函数打开一个文件，内核便会返回该文件的文件操作<br>符（一个非负的整形值），此后所有对该文件的操作，都会以返回的fd文件<br>操作符为参数</li>
</ol>
<h3 id="多路复用怎么解决阻塞IO-存在的问题？"><a href="#多路复用怎么解决阻塞IO-存在的问题？" class="headerlink" title="多路复用怎么解决阻塞IO 存在的问题？"></a>多路复用怎么解决阻塞IO 存在的问题？</h3><ol>
<li>异步编程框架是说框架内的业务代码与框架的接口是异步的，而框架与操<br>作系统的接口是同步非阻塞</li>
</ol>
<h3 id="查看内存的命令？"><a href="#查看内存的命令？" class="headerlink" title="查看内存的命令？"></a>查看内存的命令？</h3><ol>
<li>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的<br>资源占用状况</li>
<li>pmap -d 5647 可以根据进程查看进程相关信息占用的内存情况</li>
<li>free Linux的free命令是常用来查看内存的命令</li>
</ol>
<h3 id="查看日志的命令？"><a href="#查看日志的命令？" class="headerlink" title="查看日志的命令？"></a>查看日志的命令？</h3><ol>
<li>tail -n 10 test.log 查询日志尾部最后10行的日志</li>
<li>head 跟tail是相反的head是看前多少行日志</li>
</ol>
<h3 id="Linux-查看文件中是否存在某字符"><a href="#Linux-查看文件中是否存在某字符" class="headerlink" title="Linux 查看文件中是否存在某字符"></a>Linux 查看文件中是否存在某字符</h3><ol>
<li>grep “port:8080” pro.sh 查找pro文件中是否包含port:8080 内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep 指定字符串 文件的完整路径</span><br><span class="line">若不清楚字符串的大小写，可以在命令末尾加 -i ，这样查询将忽略字符串的大小写</span><br><span class="line">若需要查询指定字符串在文件中的位置，可以在命令末尾加 -n</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="linux如何分割文件字符串？"><a href="#linux如何分割文件字符串？" class="headerlink" title="linux如何分割文件字符串？"></a>linux如何分割文件字符串？</h3><ol>
<li>cut<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d 指定分隔符，如：按照“：”分割，-d:</span><br><span class="line">-c 提取第n个字节，如：-c5,表示提取每行的第5个字节</span><br><span class="line">-f 指定输出的域</span><br><span class="line">cut –d: -f1,2 &#x2F;&#x2F;按照”:”来分割，并输出第1和2段</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用的消息队列以及区别？"><a href="#常用的消息队列以及区别？" class="headerlink" title="常用的消息队列以及区别？"></a>常用的消息队列以及区别？</h3><p>消息队列是分布式应用间交换信息的重要组件，消息队列可驻留在内存或磁盘<br>上，队列可以存储消息直到它们被应用程序读走</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/23/Linux2/">https://skysea-gaoming.github.io/2021/04/23/Linux2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System/">System</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="fa fa-chevron-left">  </i><span>操作系统总结1</span></a></div><div class="next-post pull-right"><a href="/2021/04/22/Spring4/"><span>Spring4</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/23/Linux2/';
  this.page.identifier = '2021/04/23/Linux2/';
  this.page.title = 'Linux2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>