<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring4"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Spring4 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP切面"><span class="toc-number">2.</span> <span class="toc-text">AOP切面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实战案例"><span class="toc-number">2.1.</span> <span class="toc-text">实战案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义切面类"><span class="toc-number">2.1.1.</span> <span class="toc-text">定义切面类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将目标类和切面类加入到IOC容器"><span class="toc-number">2.1.2.</span> <span class="toc-text">将目标类和切面类加入到IOC容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试"><span class="toc-number">2.1.3.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">2.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EnableAspectJAutoProxy注解"><span class="toc-number">2.2.</span> <span class="toc-text">@EnableAspectJAutoProxy注解</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Spring4</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/22/Spring4/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/22/Spring4/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>B站颜群老师Spring教程，B站雷丰阳老师Spring教程，《Spring实战》<br><a href="https://zhuanlan.zhihu.com/p/137507309" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/137507309</a><br><a href="https://liayun.blog.csdn.net/article/details/115053350" target="_blank" rel="noopener">https://liayun.blog.csdn.net/article/details/115053350</a></p>
<h2 id="AOP切面"><a href="#AOP切面" class="headerlink" title="AOP切面"></a>AOP切面</h2><p>AOP（Aspect Orient Programming），直译过来就是面向切面编程。AOP<br>是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程<br>序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面 <img src="/2021/04/22/Spring4/1.jpg" alt><br>所谓切面，其实就相当于应用对象间的横切点，我们可以将其单独抽象为<br>单独的模块。总之一句话：AOP是指在程序的运行期间动态地将某段代码<br>切入到指定方法、指定位置进行运行的编程方式。AOP的底层是使用动态<br>代理实现的</p>
<h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p>导入AOP依赖，Spring AOP对面向切面编程做了一些简化操作，我们只<br>需要加上几个核心注解，AOP就能工作起来</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>定义目标类，在com.atguigu.aop 包下创建一个业务逻辑类，用于处理<br>数学计算上的一些逻辑。比如，我们在MathCalculator类中定义了一个<br>除法操作，返回两个整数类型值相除之后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathCalculator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"MathCalculator...div..."</span>);</span><br><span class="line">		<span class="keyword">return</span> i / j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们希望在以上这个业务逻辑类中的除法运算之前，记录一下日志<br>，例如记录一下哪个方法运行了，用的参数是什么，运行结束之后它的<br>返回值又是什么，顺便可以将其打印出来，还有如果运行出异常了，那<br>么就捕获一下异常信息</p>
<h4 id="定义切面类"><a href="#定义切面类" class="headerlink" title="定义切面类"></a>定义切面类</h4><p>创建一个切面类，例如LogAspects，在该切面类中定义几个打印日志的<br>方法，以这些方法来动态地感知MathCalculator类中的div()方法的运<br>行情况。如果需要切面类来动态地感知目标类方法的运行情况，那么就<br>需要使用Spring AOP中的一系列通知方法了。AOP中的通知方法及其对<br>应的注解与含义如下：</p>
<ol>
<li>前置通知（对应的注解是@Before）：在目标方法运行之前运行</li>
<li>后置通知（对应的注解是@After）：在目标方法运行结束之后运行，<br>无论目标方法是正常结束还是异常结束都会执行</li>
<li>返回通知（对应的注解是@AfterReturning）：在目标方法正常返回<br>之后运行</li>
<li>异常通知（对应的注解是@AfterThrowing）：在目标方法运行出现<br>异常之后运行</li>
<li>环绕通知（对应的注解是@Around）：动态代理，我们可以直接手动<br>推进目标方法运行（joinPoint.procced()）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* @Before：在目标方法（即div方法）运行之前切入，</span></span><br><span class="line"><span class="comment">	public int com.meimeixia.aop.MathCalculator.div(int, int)</span></span><br><span class="line"><span class="comment">	这一串就是切入点表达式，指定在哪个方法切入 */</span></span><br><span class="line">	<span class="comment">//*是不区分方法，..是不区分参数</span></span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"public int com.atguigu.aop.MathCalculator.*(..)"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"除法运行......@Before，参数列表是：&#123;&#125;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在目标方法（即div方法）结束时被调用</span></span><br><span class="line">	<span class="meta">@After</span>(<span class="string">"public int com.atguigu.aop.MathCalculator.*(..)"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"除法结束......@After"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在目标方法（即div方法）正常返回了，有返回值，被调用</span></span><br><span class="line">	<span class="meta">@AfterReturning</span>(<span class="string">"public int com.atguigu.aop.MathCalculator.*(..)"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"除法正常返回......@AfterReturning，运行结果是：&#123;&#125;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在目标方法（即div方法）出现异常，被调用</span></span><br><span class="line">	<span class="meta">@AfterThrowing</span>(<span class="string">"public int com.atguigu.aop.MathCalculator.*(..)"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"除法出现异常......异常信息：&#123;&#125;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果切入点表达式都一样的情况下，那么我们可以抽取出一个公共的<br>切入点表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果切入点表达式都一样的情况下，那么我们可以抽取出一个公共的切入点表达式</span></span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.meimeixia.aop.MathCalculator.*(..))"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pointCut()方法就是抽取出来的一个公共的切入点表达式，其实该方<br>法的方法名随便写啥都行，但是方法体中啥都别写。第一种情况，如<br>果是本类引用，那么可以像下面这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果切入点表达式都一样的情况下，那么我们可以抽取出一个公共的切入点表达式</span></span><br><span class="line">        <span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.meimeixia.aop.MathCalculator.*(..))"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"除法运行......@Before，参数列表是：&#123;&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种情况，如果是外部类（即其他的切面类）引用，那么就得在<br>通知注解中写方法的全名了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*最后，千万别忘了一点，那就是必须告诉Spring哪个类是切面类，要做到这一点很</span></span><br><span class="line"><span class="comment">简单，只需要给切面类上加上一个@Aspect注解即可*/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果切入点表达式都一样的情况下，那么我们可以抽取出一个公共的切入点表达式</span></span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.meimeixia.aop.MathCalculator.*(..))"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在目标方法（即div方法）结束时被调用</span></span><br><span class="line">	<span class="comment">// @After("pointCut()")</span></span><br><span class="line">	<span class="meta">@After</span>(<span class="string">"com.meimeixia.aop.LogAspects.pointCut()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"除法结束......@After"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将目标类和切面类加入到IOC容器"><a href="#将目标类和切面类加入到IOC容器" class="headerlink" title="将目标类和切面类加入到IOC容器"></a>将目标类和切面类加入到IOC容器</h4><p>新建一个配置类，例如MainConfigOfAOP，并使用@Configuration注解<br>标注这是一个Spring 的配置类，同时使用@EnableAspectJAutoProxy<br>注解开启基于注解的AOP模式。在该配置类中，使用@Bean注解将业务逻<br>辑类（目标方法所在类）和切面类都加入到IOC容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAOP</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将业务逻辑类（目标方法所在类）加入到容器中</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MathCalculator <span class="title">calculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MathCalculator();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将切面类加入到容器中</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LogAspects <span class="title">logAspects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LogAspects();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>创建一个单元测试类IOCTest_AOP，并在该测试类中创建一个test01()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest_AOP</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = </span><br><span class="line">		<span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfAOP<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="comment">// 不要自己创建这个对象</span></span><br><span class="line">		<span class="comment">// MathCalculator mathCalculator = new MathCalculator();</span></span><br><span class="line">		<span class="comment">// mathCalculator.div(1, 1);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 我们要使用Spring容器中的组件</span></span><br><span class="line">		MathCalculator mathCalculator = applicationContext.getBean(</span><br><span class="line">			MathCalculator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		mathCalculator.div(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 关闭容器</span></span><br><span class="line">		applicationContext.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行了切面类中的方法，并打印出了相关信息，顺序是Before After<br>AfterReturning。但是并没有打印参数列表和运行结果，要想打印出<br>参数列表和运行结果，就需要对LogAspects切面类中的方法进行优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.meimeixia.aop.MathCalculator.*(..))"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 拿到参数列表，即目标方法运行需要的参数列表</span></span><br><span class="line">		Object[] args = joinPoint.getArgs(); </span><br><span class="line">		System.out.println(joinPoint.getSignature().getName() + </span><br><span class="line">			<span class="string">"运行......@Before，参数列表是：&#123;"</span> + Arrays.asList(args) + <span class="string">"&#125;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// returning来指定我们这个方法的参数谁来封装返回值</span></span><br><span class="line">	<span class="meta">@AfterReturning</span>(value=<span class="string">"pointCut()"</span>, returning=<span class="string">"result"</span>) </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123; </span><br><span class="line">	<span class="comment">/*一定要注意：JoinPoint这个参数要写，一定不能写到后面，它必须出</span></span><br><span class="line"><span class="comment">	现在参数列表的第一位，否则Spring也是无法识别的，就会报错*/</span></span><br><span class="line">		System.out.println(joinPoint.getSignature().getName() + </span><br><span class="line">			<span class="string">"正常返回......@AfterReturning，运行结果是：&#123;"</span> + result + <span class="string">"&#125;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果目标方法运行时出现了异常，而我们又想拿到这个异常信息，<br>只须对LogAspects切面类中的logException()方法进行优化即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"pointCut()"</span>, throwing=<span class="string">"exception"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">    System.out.println(joinPoint.getSignature().getName() + </span><br><span class="line">    	<span class="string">"出现异常......异常信息：&#123;"</span> + exception + <span class="string">"&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行了切面类中的方法，并打印出了相关信息，顺序是Before After<br>和异常信息</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>搭建AOP测试环境时，只要牢牢记住以下三点</p>
<ol>
<li>将切面类和业务逻辑组件（目标方法所在类）都加入到容器中，并且<br>要告诉Spring哪个类是切面类（标注了@Aspect注解的那个类）</li>
<li>在切面类上的每个通知方法上标注通知注解，告诉Spring何时何地运<br>行，当然最主要的是要写好切入点表达式，这个切入点表达式可以参照官<br>方文档来写</li>
<li>开启基于注解的AOP模式，即加上@EnableAspectJAutoProxy注解，<br>这是最关键的一点</li>
</ol>
<h3 id="EnableAspectJAutoProxy注解"><a href="#EnableAspectJAutoProxy注解" class="headerlink" title="@EnableAspectJAutoProxy注解"></a>@EnableAspectJAutoProxy注解</h3><p>在配置类上添加@EnableAspectJAutoProxy注解，便能够开启注解版的<br>AOP功能。也就是说，如果要使注解版的AOP功能起作用的话，那么就得<br>需要在配置类上添加@EnableAspectJAutoProxy注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AspectJAutoProxyRegistrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAspectJAutoProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@Import注解给容器中引入了AspectJAutoProxyRegister组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    AspectJAutoProxyRegistrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata </span></span></span><br><span class="line"><span class="function"><span class="params">    	importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><br><span class="line">        (registry);</span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils</span><br><span class="line">        .attributesFor(importingClassMetadata, EnableAspectJAutoProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过ImportBeanDefinitionRegistrar接口实现将自定义的组件添<br>加到IOC容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata </span></span></span><br><span class="line"><span class="function"><span class="params">    	importingClassMetadata, BeanDefinitionRegistry </span></span></span><br><span class="line"><span class="function"><span class="params">    	registry, BeanNameGenerator importBeanNameGenerator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registerBeanDefinitions(importingClassMetadata, registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata </span></span></span><br><span class="line"><span class="function"><span class="params">    	importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，@EnableAspectJAutoProxy注解使用AspectJAutoProxyRegistrar<br>对象自定义组件，并将相应的组件添加到了IOC容器中</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/22/Spring4/">https://skysea-gaoming.github.io/2021/04/22/Spring4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/23/Linux2/"><i class="fa fa-chevron-left">  </i><span>Linux2</span></a></div><div class="next-post pull-right"><a href="/2021/04/21/Spring3/"><span>'Spring3'</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/22/Spring4/';
  this.page.identifier = '2021/04/22/Spring4/';
  this.page.title = 'Spring4';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>