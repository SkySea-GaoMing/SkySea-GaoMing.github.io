<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="高并发项目学习2"><meta name="keywords" content="项目"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>高并发项目学习2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#项目云端部署"><span class="toc-number">1.</span> <span class="toc-text">项目云端部署</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#项目云端部署-1"><span class="toc-number">1.1.</span> <span class="toc-text">项目云端部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#centos下载JDK"><span class="toc-number">1.2.</span> <span class="toc-text">centos下载JDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库环境安装"><span class="toc-number">1.3.</span> <span class="toc-text">数据库环境安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#备份数据库"><span class="toc-number">1.4.</span> <span class="toc-text">备份数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#项目打包"><span class="toc-number">1.5.</span> <span class="toc-text">项目打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deploy启动脚本"><span class="toc-number">1.6.</span> <span class="toc-text">deploy启动脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmeter性能压测"><span class="toc-number">1.7.</span> <span class="toc-text">jmeter性能压测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发容量问题"><span class="toc-number">1.8.</span> <span class="toc-text">并发容量问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot内嵌Tomcat线程优化"><span class="toc-number">1.9.</span> <span class="toc-text">Spring Boot内嵌Tomcat线程优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot内嵌Tomcat网络连接优化"><span class="toc-number">1.10.</span> <span class="toc-text">Spring Boot内嵌Tomcat网络连接优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式扩展"><span class="toc-number">2.</span> <span class="toc-text">分布式扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx反向代理负载均衡"><span class="toc-number">2.1.</span> <span class="toc-text">nginx反向代理负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx反向代理"><span class="toc-number">2.2.</span> <span class="toc-text">Nginx反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx反向代理处理Ajax请求"><span class="toc-number">2.2.1.</span> <span class="toc-text">Nginx反向代理处理Ajax请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#开启Tomcat-Access-Log验证"><span class="toc-number">2.2.2.</span> <span class="toc-text">开启Tomcat Access Log验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式扩展后的效果"><span class="toc-number">2.3.</span> <span class="toc-text">分布式扩展后的效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单机环境"><span class="toc-number">2.3.1.</span> <span class="toc-text">单机环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多机环境"><span class="toc-number">2.3.2.</span> <span class="toc-text">多机环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx高性能原因"><span class="toc-number">2.4.</span> <span class="toc-text">Nginx高性能原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll多路复用"><span class="toc-number">2.4.1.</span> <span class="toc-text">epoll多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#master-worker进程模型"><span class="toc-number">2.4.2.</span> <span class="toc-text">master worker进程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协程机制"><span class="toc-number">2.4.3.</span> <span class="toc-text">协程机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式会话"><span class="toc-number">2.5.</span> <span class="toc-text">分布式会话</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查询优化之多级缓存"><span class="toc-number">3.</span> <span class="toc-text">查询优化之多级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存设计"><span class="toc-number">3.1.</span> <span class="toc-text">缓存设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多级缓存"><span class="toc-number">3.2.</span> <span class="toc-text">多级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis缓存"><span class="toc-number">3.3.</span> <span class="toc-text">redis缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#序列化格式问题"><span class="toc-number">3.3.1.</span> <span class="toc-text">序列化格式问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间序列化格式问题"><span class="toc-number">3.3.2.</span> <span class="toc-text">时间序列化格式问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本地热点缓存"><span class="toc-number">3.3.3.</span> <span class="toc-text">本地热点缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx-Proxy-Cache缓存"><span class="toc-number">3.4.</span> <span class="toc-text">Nginx Proxy Cache缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx-Proxy-Cache缓存效果"><span class="toc-number">3.4.1.</span> <span class="toc-text">Nginx Proxy Cache缓存效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx-lua脚本"><span class="toc-number">3.4.2.</span> <span class="toc-text">Nginx lua脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nginx协程机制"><span class="toc-number">3.4.3.</span> <span class="toc-text">nginx协程机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lua脚本实战"><span class="toc-number">3.4.4.</span> <span class="toc-text">lua脚本实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenResty"><span class="toc-number">3.5.</span> <span class="toc-text">OpenResty</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Shared-dict"><span class="toc-number">3.5.1.</span> <span class="toc-text">Shared dict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shared-dict缓存效果"><span class="toc-number">3.5.2.</span> <span class="toc-text">Shared dict缓存效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis支持"><span class="toc-number">3.5.3.</span> <span class="toc-text">Redis支持</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#页面静态化"><span class="toc-number">4.</span> <span class="toc-text">页面静态化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN"><span class="toc-number">4.1.</span> <span class="toc-text">CDN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cache-controll响应头"><span class="toc-number">4.1.1.</span> <span class="toc-text">cache controll响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择缓存策略"><span class="toc-number">4.1.2.</span> <span class="toc-text">选择缓存策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有效性验证"><span class="toc-number">4.1.3.</span> <span class="toc-text">有效性验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有效性验证-1"><span class="toc-number">4.1.4.</span> <span class="toc-text">有效性验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器三种刷新方式"><span class="toc-number">4.2.</span> <span class="toc-text">浏览器三种刷新方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义缓存策略"><span class="toc-number">4.2.1.</span> <span class="toc-text">自定义缓存策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态资源部署策略"><span class="toc-number">4.2.2.</span> <span class="toc-text">静态资源部署策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全页面静态化"><span class="toc-number">4.3.</span> <span class="toc-text">全页面静态化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#phantomJS"><span class="toc-number">4.3.1.</span> <span class="toc-text">phantomJS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交易优化"><span class="toc-number">5.</span> <span class="toc-text">交易优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#交易验证优化"><span class="toc-number">5.1.</span> <span class="toc-text">交易验证优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用户校验缓存优化"><span class="toc-number">5.1.1.</span> <span class="toc-text">用户校验缓存优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#活动校验缓存优化"><span class="toc-number">5.1.2.</span> <span class="toc-text">活动校验缓存优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#库存扣减优化"><span class="toc-number">5.2.</span> <span class="toc-text">库存扣减优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#索引优化"><span class="toc-number">5.2.1.</span> <span class="toc-text">索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#库存扣减缓存优化"><span class="toc-number">5.2.2.</span> <span class="toc-text">库存扣减缓存优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步数据库库存到缓存"><span class="toc-number">5.2.3.</span> <span class="toc-text">同步数据库库存到缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步缓存库存到数据库（异步扣减库存）"><span class="toc-number">5.2.4.</span> <span class="toc-text">同步缓存库存到数据库（异步扣减库存）</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">高并发项目学习2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/29/高并发项目学习2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="项目云端部署"><a href="#项目云端部署" class="headerlink" title="项目云端部署"></a>项目云端部署</h2><h3 id="项目云端部署-1"><a href="#项目云端部署-1" class="headerlink" title="项目云端部署"></a>项目云端部署</h3><p>使用阿里云服务器</p>
<h3 id="centos下载JDK"><a href="#centos下载JDK" class="headerlink" title="centos下载JDK"></a>centos下载JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;java&#x2F;jdk&#x2F;8u201-b09&#x2F;jdk-8u201-linux-x64.tar.gz</span><br><span class="line">tar -zxvf jdk-8u201-linux-x64.tar.gz</span><br><span class="line">vim &#x2F;etc&#x2F;profile #添加如下语句</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line"></span><br><span class="line">source &#x2F;etc&#x2F;profile #更新配置</span><br><span class="line"></span><br><span class="line">#下载JDK11版本</span><br><span class="line">yum install java-11-openjdk-devel</span><br><span class="line">alternatives --config java</span><br></pre></td></tr></table></figure>
<h3 id="数据库环境安装"><a href="#数据库环境安装" class="headerlink" title="数据库环境安装"></a>数据库环境安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql* #安装数据库</span><br><span class="line">yum install mariadb-server</span><br><span class="line">systemctl start mariadb.service #启动MySQL需要的服务器</span><br><span class="line">ps -ef | grep mysql #查看Mysql进程被启动情况</span><br><span class="line">netstat -anp | grep 3306</span><br><span class="line">mysqladmin -u root password 19991005</span><br><span class="line">mysql -uroot -p19991005 #连接本地Mysql</span><br></pre></td></tr></table></figure>

<h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Windows</span><br><span class="line">mysqldump -uroot -p19991005 soquick &gt; D:\soquick.sql</span><br><span class="line">scp D:\soquick.sql root@8.140.27.241:&#x2F;&#x2F;tmp&#x2F;</span><br><span class="line"># Linux</span><br><span class="line">mysql -uroot -p19991005 &lt; &#x2F;tmp&#x2F;soquick.sql</span><br></pre></td></tr></table></figure>
<h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><p>本项目打成jar包，在服务器直接用java -jar运行。maven打jar包首先需要<br>添加以下属性，以便在打包的时候知道JDK的位置，不然报错</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后添加spring-boot-maven-plugin插件，使打包后的文件能够找到Spring<br>Boot的入口类，即App.java</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后在开发目录执行mvn clean package即会清空target并打成jar包</p>
<h3 id="deploy启动脚本"><a href="#deploy启动脚本" class="headerlink" title="deploy启动脚本"></a>deploy启动脚本</h3><p>有的时候线上环境需要更改一些配置，比如在9090端口部署等等。Spring<br>Boot 支持在线上环境中使用spring.config.additional-location指<br>定线上环境的配置文件，而不是jar包里的配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar soquick.jar --spring.config.addition-location&#x3D;</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;soquick&#x2F;application.properties</span><br></pre></td></tr></table></figure>
<p>新建一个sh文件，即便console界面退出应用程序也不会退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms400m -Xmx400m -XX:NewSize&#x3D;200m -XX:MaxNewSize&#x3D;200m </span><br><span class="line">-jar soquick.jar --spring.config.additional-location&#x3D;</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;soquick&#x2F;application.properties</span><br></pre></td></tr></table></figure>
<p>使用./deploy.sh &amp;即可在后台启动，使用tail -200f nohup.out即可查<br>看项目启动、运行的信息</p>
<h3 id="jmeter性能压测"><a href="#jmeter性能压测" class="headerlink" title="jmeter性能压测"></a>jmeter性能压测</h3><p>本项目使用jmeter来进行并发压测。使用方法简单来说就是新建一个线程组<br>，添加需要压测的接口地址，查看结果树和聚合报告</p>
<ol>
<li>线程组 启动多个并发线程，并发发送一些接口的请求</li>
<li>Http请求 发送http请求</li>
<li>查看结果树 </li>
<li>聚合报告</li>
</ol>
<p>首先添加一个线程组，然后创建http请求，然后添加一个查看结果树，最后<br>需要添加一个聚合报告</p>
<h3 id="并发容量问题"><a href="#并发容量问题" class="headerlink" title="并发容量问题"></a>并发容量问题</h3><ol>
<li>使用pstree -p pid | wc -l命令可以查看Java进程一共维护了多少<br>个线程，在没有压测的时候，Tomcat维护了31个线程（不同机器该值不一<br>定）。而进行压测的时候，Tomcat维护的线程数量猛增至200多个</li>
<li>使用top -H命令可以查看CPU的使用情况，主要关注us，用户进程占用<br>的CPU。sy，内核进程占用的CPU。还有load average，这个很重要，反映<br>了CPU的负载强度</li>
<li>在当前线程数量的情况下，发送100个线程，CPU的压力不算太大，所有<br>请求都得到了处理，而发送5000个线程，大量请求报错，默认的线程数量<br>不够用了，可见可以提高Tomcat维护的线程数</li>
</ol>
<h3 id="Spring-Boot内嵌Tomcat线程优化"><a href="#Spring-Boot内嵌Tomcat线程优化" class="headerlink" title="Spring Boot内嵌Tomcat线程优化"></a>Spring Boot内嵌Tomcat线程优化</h3><p>高并发条件下，就是要榨干服务器的性能，而Spring Boot内嵌Tomcat默<br>认的线程设置比较“温柔”——默认最大等待队列为100，默认最大可连接数<br>为10000，默认最大工作线程数为200，默认最小工作线程数为10 。当请<br>求超过200+100后，会拒绝处理，当连接超过10000 后，会拒绝连接。对<br>于最大连接数，一般默认的10000就行了，而其它三个配置，则需要根据<br>需求进行优化。在application.properties里面进行修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accept-count&#x3D;1000 </span><br><span class="line">server.tomcat.max-threads&#x3D;800</span><br><span class="line">server.tomcat.min-spare-threads&#x3D;100</span><br><span class="line">server.tomcat.max-connections&#x3D;10000（默认）</span><br></pre></td></tr></table></figure>
<ol>
<li>等待队列不是越大越好，一是受到内存的限制，二是大量的出队入队操<br>作耗费CPU性能</li>
<li>最大线程数不是越大越好，因为线程越多，CPU上下文切换的开销越大<br>，存在一个“阈值”，对于一个4核8G的服务器，经验值是800</li>
</ol>
<h3 id="Spring-Boot内嵌Tomcat网络连接优化"><a href="#Spring-Boot内嵌Tomcat网络连接优化" class="headerlink" title="Spring Boot内嵌Tomcat网络连接优化"></a>Spring Boot内嵌Tomcat网络连接优化</h3><p>当然Spring Boot并没有把内嵌Tomcat的所有配置都导出。一些配置需要通<br>过WebServerFactoryCustomizer<ConfigurableWebServerFactory>接<br>口来实现自定义。这里需要自定义KeepAlive长连接的配置，减少客户端和<br>服务器的连接请求次数，避免重复建立连接提高性能</ConfigurableWebServerFactory></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用对应工厂类提供给我们的接口，定制化Tomcat connector</span></span><br><span class="line">        ((TomcatServletWebServerFactory) factory).addConnectorCustomizers(</span><br><span class="line">        	<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) </span><br><span class="line">                	connector.getProtocolHandler();</span><br><span class="line">                <span class="comment">//定制化KeepAlive Timeout为30秒</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">//10000个请求则自动断开</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后重新打包上传</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp soquick-1.0-SNAPSHOT.jar root@101.201.28.68:&#x2F;var&#x2F;www&#x2F;soquick&#x2F;</span><br><span class="line">mv .&#x2F;soquick-1.0-SNAPSHOT.jar .&#x2F;soquick.jar</span><br></pre></td></tr></table></figure>

<h2 id="分布式扩展"><a href="#分布式扩展" class="headerlink" title="分布式扩展"></a>分布式扩展</h2><h3 id="nginx反向代理负载均衡"><a href="#nginx反向代理负载均衡" class="headerlink" title="nginx反向代理负载均衡"></a>nginx反向代理负载均衡</h3><p><img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/1.jpg" alt><br>需要一台数据库服务器，两台选课项目服务器，一台反向代理服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r &#x2F;var&#x2F;www root@172.24.210.135:&#x2F;var&#x2F;</span><br></pre></td></tr></table></figure>
<p>修改数据库权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> root@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'19991005'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h3><p>有三个作用</p>
<ol>
<li>使用nginx作为web服务器</li>
<li>使用nginx作为动静分离服务器</li>
<li>使用nginx作为反向代理服务器</li>
</ol>
<p>安装nginx openresty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp openresty-1.13.6.2.tar.gz root@101.201.51.66:&#x2F;tmp&#x2F;</span><br><span class="line">chmod -R 777 openresty-1.13.6.2.tar.gz</span><br><span class="line">tar -xvzf openresty-1.13.6.2.tar.gz</span><br><span class="line">yum install pcre-devel openssl-devel gcc curl</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>启动nginx 位置在/usr/local/openresty/nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp index.html root@101.201.51.66:&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;html</span><br><span class="line">scp favicon.ico root@101.201.51.66:&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;html</span><br><span class="line">scp -r assets root@101.201.51.66:&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;html</span><br><span class="line">sbin&#x2F;nginx -c conf&#x2F;nginx.conf</span><br><span class="line">netstat -an | grep 8080 #查看是否正常启动</span><br><span class="line">sbin&#x2F;nginx -s reload #修改配置后无缝重启</span><br><span class="line">.&#x2F;bin&#x2F;openresty -s stop</span><br></pre></td></tr></table></figure>

<h4 id="Nginx反向代理处理Ajax请求"><a href="#Nginx反向代理处理Ajax请求" class="headerlink" title="Nginx反向代理处理Ajax请求"></a>Nginx反向代理处理Ajax请求</h4><p>Ajax请求通过Nginx反向代理到两台应用服务器，实现负载分担。在nginx.conf<br>里面添加以下字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream backend_server&#123;</span><br><span class="line">    server miaoshaApp1_ip weight&#x3D;1;</span><br><span class="line">    server miaoshaApp2_ip weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">server&#123;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;backend_server;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样用<a href="http://miaoshaserver访问Nginx服务器，请求会被均衡地代理" target="_blank" rel="noopener">http://miaoshaserver访问Nginx服务器，请求会被均衡地代理</a><br>到下面的两个backend服务器上</p>
<h4 id="开启Tomcat-Access-Log验证"><a href="#开启Tomcat-Access-Log验证" class="headerlink" title="开启Tomcat Access Log验证"></a>开启Tomcat Access Log验证</h4><p>开启这个功能可以查看是哪个IP发过来的请求，在application.properties<br>里面添加，非必须</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.accesslog.enabled&#x3D;true</span><br><span class="line">server.tomcat.accesslog.directory&#x3D;&#x2F;var&#x2F;www&#x2F;soquick&#x2F;tomcat</span><br><span class="line">server.tomcat.accesslog.pattern&#x3D;%h %l %u %t &quot;%r&quot; %s %b %D</span><br></pre></td></tr></table></figure>

<h3 id="分布式扩展后的效果"><a href="#分布式扩展后的效果" class="headerlink" title="分布式扩展后的效果"></a>分布式扩展后的效果</h3><h4 id="单机环境"><a href="#单机环境" class="headerlink" title="单机环境"></a>单机环境</h4><h4 id="多机环境"><a href="#多机环境" class="headerlink" title="多机环境"></a>多机环境</h4><p>发送1000*30个请求，50us，1100TPS</p>
<h3 id="Nginx高性能原因"><a href="#Nginx高性能原因" class="headerlink" title="Nginx高性能原因"></a>Nginx高性能原因</h3><h4 id="epoll多路复用"><a href="#epoll多路复用" class="headerlink" title="epoll多路复用"></a>epoll多路复用</h4><p>在了解epoll多路复用之前，先看看Java BIO模型，也就是Blocking IO<br>阻塞模型。当客户端与服务器建立连接之后，通过Socket.write()向服务<br>器发送数据，只有当数据写完之后，才会发送。如果当Socket缓冲区满了<br>，那就不得不阻塞等待。<br>接下来看看Linux Select模型。该模式下，会监听一定数量的客户端连接<br>，一旦发现有变动，就会唤醒自己，然后遍历这些连接，看哪些连接发生<br>了变化，执行IO操作。相比阻塞式的BIO，效率更高，但是也有个问题，<br>如果10000个连接变动了1个，那么效率将会十分低下。此外，Java NIO<br>，即New IO或者Non-Blocking IO就借鉴了Linux Select模型。<br>而epoll模型，在Linux Select模型之上，新增了回调函数，一旦某个连<br>接发生变化，直接执行回调函数，不用遍历，效率更高</p>
<h4 id="master-worker进程模型"><a href="#master-worker进程模型" class="headerlink" title="master worker进程模型"></a>master worker进程模型</h4><p><img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/2.jpg" alt><br>客户端的请求，并不会被master 进程处理，而是交给下面的worker 进程<br>来处理，多个worker进程通过“抢占”的方式取得处理权。如果某个worker<br>挂了，master会立刻感知到，用一个新的worker代替。这就是Nginx高效<br>率的原因之一，也是可以平滑重启的原理。<br>此外worker进程是单线程的，没有阻塞的情况下效率很高。而epoll模型避<br>免了阻塞。<br>综上epoll机制+master-worker机制使得worker进程可以高效率地执行单<br>线程I/O操作。</p>
<h4 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h4><p>Nginx引入了一种比线程更小的概念，那就是“协程”。协程依附于内存模型<br>，切换开销更小，遇到阻塞，Nginx会立刻剥夺执行权，由于在同一个线<br>程内，也不需要加锁</p>
<h3 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h3><ol>
<li>基于Cookie传输SessionId</li>
<li>基于Token传输类似SessionId</li>
</ol>
<p>在数据库所在的阿里云服务器下载redis</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scp redis-5.0.4.tar.gz root@8.140.27.241:&#x2F;tmp&#x2F;</span><br><span class="line">chmod -R 777 redis-5.0.4.tar.gz</span><br><span class="line">tar -xvzf redis-5.0.4.tar.gz</span><br><span class="line">cd redis-5.0.4</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">cd src</span><br><span class="line">src&#x2F;redis-server .&#x2F;redis.conf &amp; #启动redis</span><br><span class="line">.&#x2F;redis-cli -h 8.140.27.241</span><br><span class="line">ps -ef | grep redis</span><br><span class="line">find &#x2F; -name redis</span><br></pre></td></tr></table></figure>

<p>Spring Boot在Redis存入的SessionId有多项，不够简洁。一般常用UUID<br>生成类似SessionId的唯一登录凭证token，然后将生成的token作为KEY<br>，UserModel作为VALUE存入到Redis服务器</p>
<h2 id="查询优化之多级缓存"><a href="#查询优化之多级缓存" class="headerlink" title="查询优化之多级缓存"></a>查询优化之多级缓存</h2><p>多级缓存有两层含义，一个是缓存，一个是多级。我们知道，内存的速度是<br>磁盘的成百上千倍，高并发下，从磁盘I/O十分影响性能。所谓缓存，就是<br>将磁盘中的热点数据，暂时存到内存里面，以后查询直接从内存中读取，<br>减少磁盘I/O，提高速度。所谓多级，就是在多个层次设置缓存，一个层<br>次没有就去另一个层次查询</p>
<h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><ol>
<li>用快速存取设备，用内存</li>
<li>将缓存推到离用户最近的地方</li>
<li>脏缓存处理</li>
</ol>
<h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><ol>
<li>redis缓存</li>
<li>热点内存本地缓存</li>
<li>nginx proxy cache缓存</li>
<li>nginx lua 缓存</li>
</ol>
<h3 id="redis缓存"><a href="#redis缓存" class="headerlink" title="redis缓存"></a>redis缓存</h3><ol>
<li>单机版</li>
<li>sentinal哨兵模式</li>
<li>集群cluster模式</li>
</ol>
<p>之前的ItemController.getItem接口，来一个Id就调用ItemService去<br>数据库查询一次。ItemService会查三张表，分别是课程信息表item表、<br>课程容量stock表和活动信息表promo，十分影响性能。<br>所以修改ItemController.getItem接口，思路很简单，先从Redis服务<br>器获取，若没有则从数据库查询并存到Redis服务。有的话直接用</p>
<h4 id="序列化格式问题"><a href="#序列化格式问题" class="headerlink" title="序列化格式问题"></a>序列化格式问题</h4><p>采用上述方式，存到Redis里面的VALUE是类似/x05/x32的二进制格式，<br>我们需要自定义RedisTemplate的序列化格式。之前我们在config包下<br>面创建了一个RedisConfig 类，里面没有任何方法，接下来我们编写<br>一个方法</p>
<h4 id="时间序列化格式问题"><a href="#时间序列化格式问题" class="headerlink" title="时间序列化格式问题"></a>时间序列化格式问题</h4><p>但是这样对于日期而言序列化后是一个很长的毫秒数。我们希望是yyyy<br>-MM-dd HH:mm:ss的格式，还需要进一步处理。新建serializer包，<br>里面新建两个类</p>
<h4 id="本地热点缓存"><a href="#本地热点缓存" class="headerlink" title="本地热点缓存"></a>本地热点缓存</h4><p>Redis缓存虽好但是有网络I/O，没有本地缓存快。我们可以在Redis的前<br>面再添加一层“本地热点”缓存。所谓本地，就是利用本地JVM的内存。所<br>谓热点，由于JVM内存有限，仅存放多次查询的数据。<br>本地缓存，说白了就是一个HashMap，但是HashMap不支持并发读写，肯<br>定是不行的。juc包里面的ConcurrentHashMap虽然也能用，但是无法高<br>效处理过期时限、没有淘汰机制等问题，所以这里使用了Google的Guava<br>Cache方案。Guava Cache除了线程安全外，还可以控制超时时间，提供<br>淘汰机制。<br>先导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在service包下新建一个CacheService类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String,Object&gt; commonCache=<span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        commonCache= CacheBuilder.newBuilder()</span><br><span class="line">                <span class="comment">//初始容量</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//最大100个KEY，超过后会按照LRU策略移除</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                <span class="comment">//设置写缓存后多少秒过期，还有根据访问过期即expireAfterAccess</span></span><br><span class="line">                .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">       commonCache.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFromCommonCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地缓存虽快，但是也有缺点：</p>
<ul>
<li>更新麻烦，容易产生脏缓存</li>
<li>受到JVM容量的限制</li>
</ul>
<h3 id="Nginx-Proxy-Cache缓存"><a href="#Nginx-Proxy-Cache缓存" class="headerlink" title="Nginx Proxy Cache缓存"></a>Nginx Proxy Cache缓存</h3><p>通过Redis缓存，避免了MySQL大量的重复查询，提高了部分效率，通过本<br>地缓存，减少了与Redis服务器的网络I/O，提高了大量效率。但实际上，<br>前端（客户端）请求Nginx服务器，Nginx有分发过程，需要去请求后面<br>的两台应用服务器有一定网络I/O，能不能直接把热点数据存放到Nginx<br>服务器上呢？答案是可以的。<br>Nginx Proxy Cache的原理是基于文件系统的，它把后端返回的响应内容<br>，作为文件存放在Nginx指定目录下</p>
<ol>
<li>nginx反向代理前置</li>
<li>依靠文件系统存索引级的文件</li>
<li>依靠内存缓存文件地址</li>
</ol>
<p>在nginx.conf里面配置proxy cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream backend_server&#123;</span><br><span class="line">    server miaoshaApp1_ip weight&#x3D;1;</span><br><span class="line">    server miaoshaApp2_ip weight&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">#申明一个cache缓存节点 evels 表示以二级目录存放</span><br><span class="line">    proxy_cache_path &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;tmp_cache </span><br><span class="line">    levels&#x3D;1:2 keys_zone&#x3D;tmp_cache:100m inactive&#x3D;7d max_size&#x3D;10g;</span><br><span class="line">...</span><br><span class="line">server&#123;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        ···</span><br><span class="line">        #proxy_cache 目录</span><br><span class="line">        proxy_cache tmp_cache;</span><br><span class="line">        proxy_cache_key $uri;</span><br><span class="line">        #只有后端返回以下状态码才缓存</span><br><span class="line">        proxy_cache_valid 200 206 304 302 7d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当多次访问后端商品详情接口时，在nginx/tmp_cache/dir1/dir2<br>下生成了一个文件。cat这个文件发现就是JSON格式的数据</p>
<h4 id="Nginx-Proxy-Cache缓存效果"><a href="#Nginx-Proxy-Cache缓存效果" class="headerlink" title="Nginx Proxy Cache缓存效果"></a>Nginx Proxy Cache缓存效果</h4><p>发现TPS 峰值只有2800左右，平均响应时间225毫秒左右，不升反降，这<br>是为什么呢？原因就是，虽然用户可以直接从 Nginx 服务器拿到缓存的<br>数据，但是这些数据是基于文件系统的，是存放在磁盘上的，有磁盘I/O<br>，虽然减少了一定的网络I/O，但是磁盘I/O并没有内存快，得不偿失，<br>所以不建议使用</p>
<h4 id="Nginx-lua脚本"><a href="#Nginx-lua脚本" class="headerlink" title="Nginx lua脚本"></a>Nginx lua脚本</h4><p>那Nginx有没有一种基于“内存”的缓存策略呢？答案也是有的，可以使用<br>Nginx lua脚本来做缓存。lua也是基于协程机制的</p>
<ol>
<li>依附于线程的内存模型，切换开销小</li>
<li>遇到阻塞则释放执行权，代码同步</li>
<li>无需加锁</li>
</ol>
<p>lua脚本可以挂载在Nginx处理请求的起始、worker进程启动、内容输出等阶段</p>
<h4 id="nginx协程机制"><a href="#nginx协程机制" class="headerlink" title="nginx协程机制"></a>nginx协程机制</h4><ol>
<li>nginx每个工作进程创建一个lua虚拟机</li>
<li>工作进程内的所有协程共享一个vm</li>
<li>每个外部请求由一个lua协程处理，之间数据隔离</li>
<li>lua代码调用io等异步接口，协程被挂起，上下文数据</li>
</ol>
<h4 id="lua脚本实战"><a href="#lua脚本实战" class="headerlink" title="lua脚本实战"></a>lua脚本实战</h4><p>在OpenResty下新建一个lua文件夹，专门用来存放lua脚本。新建一个init.lua</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.log(ngx.ERR, &quot;init lua success&quot;);</span><br></pre></td></tr></table></figure>
<p>在nginx.conf里面添加一个init_by_lua_file的字段，指定上述lua脚本的<br>位置。当Nginx启动的时候就会执行这个lua脚本输出”init lua success”。<br>当然，在Nginx启动的时候，挂载lua脚本并没有什么作用。一般在内容输出阶<br>段，挂载lua脚本。新建一个staticitem.lua，用ngx.say()输出一段字符串<br>。在nginx.conf里面添加一个新的location：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;staticitem&#x2F;get&#123;</span><br><span class="line">    default_type &quot;text&#x2F;html&quot;;</span><br><span class="line">    content_by_lua_file ..&#x2F;lua&#x2F;staticitem.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问/staticitem/get，在页面就会响应出staticitem.lua的内容。<br>新建一个helloworld.lua，使用ngx.exec(“/item/get?id=1”)访问某个<br>URL。同样在nginx.conf里面添加一个helloworldlocation。这样，当访<br>问/helloworld的时候就会跳转到item/get?id=8这个URL上</p>
<h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h3><ol>
<li>OpenResty由Nginx核心加很多第三方模块组成，默认集成了Lua开发环境<br>，使得Nginx可以作为一个Web Server使用</li>
<li>借助于Nginx的事件驱动模型和非阻塞IO，可以实现高性能的Web应用程序</li>
<li>OpenResty提供了大量组件如Mysql、Redis、Memcached等，使在Nginx上<br>开发Web应用更方便更简单</li>
</ol>
<h4 id="Shared-dict"><a href="#Shared-dict" class="headerlink" title="Shared dict"></a>Shared dict</h4><p>OpenResty的Shared dict是一种类似于HashMap的Key-Value内存结构，对<br>所有worker进程可见，并且可以指定LRU淘汰规则。和配置proxy cache一样<br>，我们需要指定一个名为my_cache，大小为128m的lua_shared_dict</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upstream backend_server</span><br><span class="line">···</span><br><span class="line">lua_shared_dict my_cahce 128m;</span><br></pre></td></tr></table></figure>
<p>在lua文件夹下，新建一个itemsharedict.lua脚本，编写两个函数</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_from_cache</span><span class="params">(key)</span></span></span><br><span class="line">	<span class="comment">--类似于拿到缓存对象</span></span><br><span class="line">    <span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line">    <span class="comment">--从缓存对象中，根据key获得值</span></span><br><span class="line">    <span class="keyword">local</span> value = cache_ngx:get(key)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_to_cache</span><span class="params">(key,value,exptime)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> exptime <span class="keyword">then</span> </span><br><span class="line">        exptime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line">    <span class="keyword">local</span> succ,err,forcible = cache_ngx.set(key,value,exptime)</span><br><span class="line">    <span class="keyword">return</span> succ </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然后编写main函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--得到请求的参数，类似Servlet的request.getParameters</span><br><span class="line">local args &#x3D; ngx.req.get_uri_args()</span><br><span class="line">local id &#x3D; args[&quot;id&quot;]</span><br><span class="line">--从缓存里面获取商品信息</span><br><span class="line">local item_model &#x3D; get_from_cache(&quot;item_&quot;..id)</span><br><span class="line">if item_model &#x3D;&#x3D; nil then</span><br><span class="line">    --如果取不到，就请求后端接口</span><br><span class="line">    local resp &#x3D; ngx.location.capture(&quot;&#x2F;item&#x2F;get?id&#x3D;&quot;..id)</span><br><span class="line">    --将后端返回的json响应，存到缓存里面</span><br><span class="line">    item_model &#x3D; resp.body</span><br><span class="line">    set_to_cache(&quot;item_&quot;..id,item_model,1*60)</span><br><span class="line">end</span><br><span class="line">ngx.say(item_model)</span><br></pre></td></tr></table></figure>
<p>新建一个luaitem/get的location，注意default_type是json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;luaitem&#x2F;get&#123;</span><br><span class="line">    default_type &quot;application&#x2F;json&quot;;</span><br><span class="line">    content_by_lua_file ..&#x2F;lua&#x2F;itemsharedict.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Shared-dict缓存效果"><a href="#Shared-dict缓存效果" class="headerlink" title="Shared dict缓存效果"></a>Shared dict缓存效果</h4><p>压测/luaitem/get，峰值TPS在4000左右，平均响应时间150ms左右，比<br>proxy cache要高出不少，跟使用两层缓存效果差不多。<br>使用Ngxin的Shared dict，把压力转移到了Nginx服务器，后面两个Tomcat<br>服务器压力减小。同时减少了与后面两个Tomcat服务器、Redis服务器和数据<br>库服务器的网络I/O，当网络I/O成为瓶颈时，Shared dict不失为一种好方<br>法。最后，Shared dict依然受制于缓存容量和缓存更新问题</p>
<h4 id="Redis支持"><a href="#Redis支持" class="headerlink" title="Redis支持"></a>Redis支持</h4><p>新建一个itemredis.lua</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> args=ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> id=args[<span class="string">"id"</span>]</span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">"resty.redis"</span></span><br><span class="line"><span class="keyword">local</span> cache =redis:new()</span><br><span class="line"><span class="keyword">local</span> ok,err=cache:connect(<span class="string">"172.16.227.230"</span>,<span class="number">6379</span>)</span><br><span class="line">cache:<span class="built_in">select</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">local</span> item_model=cache:get(<span class="string">"item_"</span>..id)</span><br><span class="line"><span class="keyword">if</span> item_model == ngx.null <span class="keyword">or</span> item_model == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> resp =ngx.locatioin.capture(<span class="string">"/item/get?id="</span>..id)</span><br><span class="line">        item_model = resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ngx.say(item_model)</span><br></pre></td></tr></table></figure>

<h2 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h2><p><img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/3.jpg" alt> <img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/4.jpg" alt><br>之前静态资源是直接从Nginx服务器上获取，而现在会先去CDN服务器上<br>获取，如果没有则回源到Nginx服务器上获取</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN是内容分发网络，一般用来存储（缓存）项目的静态资源。访问静态<br>资源，会从离用户最近的CDN服务器上返回静态资源。如果该CDN服务器<br>上没有静态资源，则会执行回源操作，从Nginx服务器上获取静态资源</p>
<h4 id="cache-controll响应头"><a href="#cache-controll响应头" class="headerlink" title="cache controll响应头"></a>cache controll响应头</h4><p>在响应里面有一个cache controll响应头，这个响应头表示客户端是否<br>可以缓存响应。有以下几种缓存策略 <img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/5.jpg" alt></p>
<h4 id="选择缓存策略"><a href="#选择缓存策略" class="headerlink" title="选择缓存策略"></a>选择缓存策略</h4><p>如果不缓存，那就选择no-store。如果需要缓存，但是需要重新验证，则<br>选择no-cache，如果不需要重新验证，则选择private或者public。然后<br>设置max-age，最后添加ETag Header <img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/6.jpg" alt></p>
<h4 id="有效性验证"><a href="#有效性验证" class="headerlink" title="有效性验证"></a>有效性验证</h4><p>如果不缓存，那就选择no-store。如果需要缓存，但是需要重新验证，则<br>选择no-cache，如果不需要重新验证，则选择private或者public。然后<br>设置max-age，最后添加ETag Header <img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/7.jpg" alt></p>
<h4 id="有效性验证-1"><a href="#有效性验证-1" class="headerlink" title="有效性验证"></a>有效性验证</h4><p>ETag：第一次请求资源的时候，服务器会根据资源内容生成一个唯一标示<br>ETag，并返回给浏览器。浏览器下一次请求会把ETag（If-None-Match）<br>发送给服务器，与服务器的ETag进行对比。如果一致就返回一个304响应<br>，即Not Modify，表示浏览器缓存的资源文件依然是可用的，直接使用<br>就行了不用重新请求。请求资源的流程如下 <img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/8.jpg" alt></p>
<h3 id="浏览器三种刷新方式"><a href="#浏览器三种刷新方式" class="headerlink" title="浏览器三种刷新方式"></a>浏览器三种刷新方式</h3><ol>
<li>a标签/回车刷新<br>查看max-age是否有效，有效直接从缓存中获取，无效进入缓存协商逻辑</li>
<li>F5刷新<br>取消max-age或者将其设置为0，直接进入缓存协商逻辑</li>
<li>CTRL+F5强制刷新<br>直接去掉cache-control和协商头，重新请求资源</li>
</ol>
<h4 id="自定义缓存策略"><a href="#自定义缓存策略" class="headerlink" title="自定义缓存策略"></a>自定义缓存策略</h4><p>CDN服务器既充当了浏览器的服务端，又充当了Nginx的客户端。所以它的<br>缓存策略尤其重要。除了按照服务器的max-age，CDN服务器还可以自己设<br>置过期时间。<br>总的规则就是：源站没有配置，遵从CDN控制台的配置；CDN控制台没有配<br>置，遵从服务器提供商的默认配置。源站有配置，CDN控制台有配置，遵从<br>CDN控制台的配置。CDN控制台没有配置，遵从源站配置 <img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/9.jpg" alt></p>
<h4 id="静态资源部署策略"><a href="#静态资源部署策略" class="headerlink" title="静态资源部署策略"></a>静态资源部署策略</h4><p>假如服务器端的静态资源更新了，但是由于客户端的max-age还未失效，<br>用的还是老的资源，文件名又一样，用户不得不使用CTRL+F5强制刷新，<br>才能请求更新的静态资源。解决方法有三种</p>
<ol>
<li>版本号：在静态资源文件后面追加一个版本号，比如a.js?v=1.0。这种<br>方法维护起来十分麻烦，比如只有一个js文件做了修改，那其它html、css<br>文件要不要追加版本号呢？</li>
<li>摘要：对静态资源的内容进行哈希操作，得到一个摘要，比如a.js?v=<br>45edw，维护起来更加方法。但是会导致是先部署js还是先部署html的问题<br>。比如先部署js，那么html页面引用的还是老的js，js直接失效。如果先<br>部署html，那么引用的js又是老版本的js</li>
<li>摘要作为文件名：比如45edw.js，会同时存在新老两个版本，方便回滚</li>
</ol>
<h3 id="全页面静态化"><a href="#全页面静态化" class="headerlink" title="全页面静态化"></a>全页面静态化</h3><p>现在的架构是，用户通过CDN请求到了静态资源，然后静态页面会在加载的<br>时候，发送一个Ajax请求到后端，接收到后端的响应后，再用DOM渲染。也<br>就是每一个用户请求，都有一个请求后端接口并渲染的过程。那能不能取消<br>这个过程直接在服务器端把页面渲染好，返回一个纯html文件给客户端呢？<br>全页面静态化就是在服务端完成html css甚至js的load渲染成纯html文件<br>后直接以静态资源的方式部署在cdn上</p>
<h4 id="phantomJS"><a href="#phantomJS" class="headerlink" title="phantomJS"></a>phantomJS</h4><p>phantomJS就像一个爬虫，会把页面中的JS执行完毕后，返回一个渲染完<br>成的html文件</p>
<h2 id="交易优化"><a href="#交易优化" class="headerlink" title="交易优化"></a>交易优化</h2><p>发送20*200个请求压测createOrder接口，TPS只有280左右，平均响应时<br>间460毫秒。应用服务器us占用高达75%，1分钟的load average高达2.21<br>，可见压力很大。相反，数据库服务器的压力则要小很多。<br>原因在于，在OrderService.createOrder方法里面，首先要去数据库查询<br>商品信息，而在查询商品信息的过程中，又要去查询秒杀活动信息，最后还<br>要查询用户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询商品信息的过程中，也会查询秒杀活动信息。</span></span><br><span class="line">ItemModel itemModel=itemService.getItemById(itemId);</span><br><span class="line"><span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR,</span><br><span class="line">    	<span class="string">"商品信息不存在"</span>);</span><br><span class="line"><span class="comment">//查询用户信息</span></span><br><span class="line">UserModel userModel=userService.getUserById(userId);</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/10.jpg" alt><br>这还没完，最后还要对stock库存表进行-1 update操作，对order_info<br>订单信息表进行添加insert操作，对item商品信息表进行销量+1update<br>操作。仅仅一个下单，就有6次数据库I/O操作，此外，减库存操作还存在<br>行锁阻塞，所以下单接口并发性能很低</p>
<h3 id="交易验证优化"><a href="#交易验证优化" class="headerlink" title="交易验证优化"></a>交易验证优化</h3><p>查询用户信息，是为了用户风控策略。判断用户信息是否存在是最基本的<br>策略，在企业级中，还可以判断用户状态是否异常，是否异地登录等等<br>。用户风控的信息，实际上可以缓存化，放到Redis里面。<br>查询商品信息、活动信息，是为了活动校验策略。商品信息、活动信息，也<br>可以存入缓存中。活动信息，由于具有时效性，需要具备紧急下线的能力<br>，可以编写一个接口，清除活动信息的缓存</p>
<h4 id="用户校验缓存优化"><a href="#用户校验缓存优化" class="headerlink" title="用户校验缓存优化"></a>用户校验缓存优化</h4><p>思路很简单，就是先从Redis里面获取用户信息，没有再去数据库里查，并<br>存到Redis里面。UserService新开一个getUserByIdInCache的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserModel <span class="title">getUserByIdInCache</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    UserModel userModel= (UserModel) redisTemplate.opsForValue().</span><br><span class="line">    get(<span class="string">"user_validate_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(userModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        userModel=<span class="keyword">this</span>.getUserById(id);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"user_validate_"</span>+id,userModel);</span><br><span class="line">        redisTemplate.expire(<span class="string">"user_validate_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="活动校验缓存优化"><a href="#活动校验缓存优化" class="headerlink" title="活动校验缓存优化"></a>活动校验缓存优化</h4><p>跟用户校验类似，ItemService新开一个getItemByIdInCache方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ItemModel <span class="title">getItemByIdInCache</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    ItemModel itemModel=(ItemModel)redisTemplate.opsForValue().get(</span><br><span class="line">    	<span class="string">"item_validate_"</span>+id);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        itemModel=<span class="keyword">this</span>.getItemById(id);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"item_validate_"</span>+id,itemModel);</span><br><span class="line">         redisTemplate.expire(<span class="string">"item_validate_"</span>+id,<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> itemModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库存扣减优化"><a href="#库存扣减优化" class="headerlink" title="库存扣减优化"></a>库存扣减优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><p>之前扣减库存的操作，会执行update stock set stock=stock-#{amount}<br>where item_id = #{itemId} and stock &gt;= #{amount}这条SQL语句。如<br>果where条件的item_id字段没有索引那么会锁表性能很低。<br>所以先查看item_id字段是否有索引，没有的话，使用alter table stock<br>add UNIQUE INDEX item_id_index(item_id)，为item_id字段添加一个<br>唯一索引，这样在修改的时候，只会锁行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> item_stock <span class="keyword">add</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> item_id_index(item_id)</span><br></pre></td></tr></table></figure>

<h4 id="库存扣减缓存优化"><a href="#库存扣减缓存优化" class="headerlink" title="库存扣减缓存优化"></a>库存扣减缓存优化</h4><p>串行话减库存无法避免，之前下单是直接操作数据库，一旦秒杀活动开始，<br>大量的流量涌入扣减库存接口，数据库压力很大。那么可不可以先在缓存中<br>下单？答案是可以的。如果要在缓存中扣减库存，需要解决两个问题，第一<br>个是活动开始前，将数据库的库存信息，同步到缓存中。第二个是下单之后<br>，要将缓存中的库存信息同步到数据库中。这就需要用到异步消息队列——<br>也就是RocketMQ</p>
<h4 id="同步数据库库存到缓存"><a href="#同步数据库库存到缓存" class="headerlink" title="同步数据库库存到缓存"></a>同步数据库库存到缓存</h4><p>PromoService新建一个publishPromo的方法，把数据库的缓存存到Redis<br>里面去</p>
<ol>
<li>活动发布同库存进缓存</li>
<li>下单交易减缓存库存<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过活动id获取活动</span></span><br><span class="line">    PromoDO promoDO=promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    <span class="keyword">if</span>(promoDO.getItemId()==<span class="keyword">null</span> || promoDO.getItemId().intValue()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ItemModel itemModel=itemService.getItemById(promoDO.getItemId());</span><br><span class="line">    <span class="comment">//库存同步到Redis</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span>+itemModel.getId()</span><br><span class="line">    	,itemModel.getStock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里需要注意的是，当我们把库存存到Redis的时候，商品可能被下单，<br>这样数据库的库存和Redis的库存就不一致了。解决方法就是活动未开始<br>的时候，商品是下架状态，不能被下单。在ItemController中添加相应<br>的功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/publishpromo"</span>,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">publishpromo</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line">        promoService.publishPromo(id);</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
最后在ItemService里面修改decreaseStock方法，在Redis里面扣减库存<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 老方法，直接在数据库减</span></span><br><span class="line">    <span class="comment">// int affectedRow=itemStockDOMapper.decreaseStock(itemId,amount);</span></span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (affectedRow &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="同步缓存库存到数据库（异步扣减库存）"><a href="#同步缓存库存到数据库（异步扣减库存）" class="headerlink" title="同步缓存库存到数据库（异步扣减库存）"></a>同步缓存库存到数据库（异步扣减库存）</h4><p>以上的问题是数据库记录不一致，RocketMQ是阿里巴巴在RabbitMQ基础<br>上改进的一个消息中间件，特点如下</p>
<ol>
<li>高性能、高并发、分布式消息中间件</li>
<li>典型应用场景：分布式事务，异步解耦</li>
</ol>
<p>概念模型 <img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/11.jpg" alt> 部署模型 <img src="/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/12.jpg" alt></p>
<p>下载rocketmq</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scp rocketmq-all-4.4.0-bin-release.zip root@8.140.27.241:&#x2F;var&#x2F;www&#x2F;rocketmq&#x2F;</span><br><span class="line">chmod -R 777 *</span><br><span class="line">yum install unzip</span><br><span class="line">unzip rocketmq-all-4.4.0-bin-release.zip</span><br><span class="line">nohup sh bin&#x2F;mqnamesrv &amp;</span><br><span class="line">ps -ef | grep name</span><br><span class="line">netstat -anp | grep 9876</span><br><span class="line">tail -f ~&#x2F;logs&#x2F;rocketmqlogs&#x2F;namesrv.log</span><br><span class="line">nohup .&#x2F;mqbroker -n 8.140.27.241:9876 &amp;</span><br><span class="line">export NAMESRV_ADDR&#x3D;8.140.27.241:9876</span><br><span class="line">nohup sh bin&#x2F;mqbroker -n 8.140.27.241:9876 &amp;</span><br><span class="line">ps -ef | grep mq</span><br><span class="line">tail -f ~&#x2F;logs&#x2F;rocketmqlogs&#x2F;broker.log</span><br><span class="line">#投放消息</span><br><span class="line">sh bin&#x2F;tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line">#消费消费</span><br><span class="line">sh bin&#x2F;tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="line"></span><br><span class="line">#在tools.sh中添加</span><br><span class="line">JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -Djava.ext.dirs&#x3D;$&#123;BASE_DIR&#125;&#x2F;lib:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;</span><br><span class="line">ext:&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jre&#x2F;lib&#x2F;ext&quot;</span><br><span class="line"></span><br><span class="line">.&#x2F;mqadmin updateTopic -n 8.140.27.241:9876 -t stock -c DefaultCluster</span><br><span class="line"></span><br><span class="line"># 1.关闭Nameserver</span><br><span class="line">sh bin&#x2F;mqshutdown namesrv</span><br><span class="line"># 2.关闭Broker</span><br><span class="line">sh bin&#x2F;mqshutdown broker</span><br></pre></td></tr></table></figure>

<p>新建一个mq包，创建两个类：一个生产者一个消费者。然后在pom.xml<br>中导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写asyncReduceStock方法，实现异步扣减库存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncReduceStock</span><span class="params">(Integer itemId, Integer amount)</span>  </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; bodyMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>,itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>,amount);</span><br><span class="line">    <span class="comment">//创建消息</span></span><br><span class="line">    Message message=<span class="keyword">new</span> Message(topicName,<span class="string">"increase"</span>,</span><br><span class="line">                JSON.toJSON(bodyMap).toString().getBytes(Charset.</span><br><span class="line">                	forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        producer.send(message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">      ···</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发送消息失败那么需要把库存恢复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//&gt;0，表示Redis扣减成功</span></span><br><span class="line">    <span class="keyword">if</span>(affectedRow&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//发送消息到消息队列，准备异步扣减</span></span><br><span class="line">        <span class="keyword">boolean</span> mqResult = mqProducer.asyncReduceStock(itemId,amount);</span><br><span class="line">        <span class="keyword">if</span> (!mqResult)&#123;</span><br><span class="line">            <span class="comment">//消息发送失败，需要回滚Redis</span></span><br><span class="line">            redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+</span><br><span class="line">            	itemId,amount.intValue());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Redis扣减失败，回滚</span></span><br><span class="line">        redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+</span><br><span class="line">        	itemId,amount.intValue());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步扣减库存存在的问题</p>
<ol>
<li>如果发送消息失败，只能回滚Redis</li>
<li>消费端从数据库扣减操作执行失败，如何处理（这里默认会成功）</li>
<li>下单失败无法正确回补库存（比如用户取消订单）</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/">https://skysea-gaoming.github.io/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/"><i class="fa fa-chevron-left">  </i><span>运输层总结</span></a></div><div class="next-post pull-right"><a href="/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"><span>Linux总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A02/';
  this.page.identifier = '2021/04/29/高并发项目学习2/';
  this.page.title = '高并发项目学习2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>