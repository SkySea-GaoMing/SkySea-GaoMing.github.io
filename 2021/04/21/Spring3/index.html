<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="'Spring3'"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>'Spring3' | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器"><span class="toc-number">2.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性赋值"><span class="toc-number">2.1.</span> <span class="toc-text">属性赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Value"><span class="toc-number">2.1.1.</span> <span class="toc-text">@Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value注解的用法"><span class="toc-number">2.1.2.</span> <span class="toc-text">@Value注解的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value中-···-和-···-的区别"><span class="toc-number">2.1.3.</span> <span class="toc-text">@Value中#{···}和${···}的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加载配置文件"><span class="toc-number">2.2.</span> <span class="toc-text">加载配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertySource注解概述"><span class="toc-number">2.2.1.</span> <span class="toc-text">@PropertySource注解概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertySources注解概述"><span class="toc-number">2.2.2.</span> <span class="toc-text">@PropertySources注解概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Environment获取值"><span class="toc-number">2.2.3.</span> <span class="toc-text">使用Environment获取值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装配组件"><span class="toc-number">2.3.</span> <span class="toc-text">自动装配组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Autowired注解"><span class="toc-number">2.3.1.</span> <span class="toc-text">@Autowired注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Qualifier注解"><span class="toc-number">2.3.2.</span> <span class="toc-text">@Qualifier注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Primary注解"><span class="toc-number">2.3.3.</span> <span class="toc-text">@Primary注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动装配"><span class="toc-number">2.3.4.</span> <span class="toc-text">自动装配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试-Qualifier注解"><span class="toc-number">2.3.5.</span> <span class="toc-text">测试@Qualifier注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试-Primary注解"><span class="toc-number">2.3.6.</span> <span class="toc-text">测试@Primary注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource注解"><span class="toc-number">2.3.7.</span> <span class="toc-text">@Resource注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inject注解"><span class="toc-number">2.3.8.</span> <span class="toc-text">@Inject注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试-Resource注解"><span class="toc-number">2.3.9.</span> <span class="toc-text">测试@Resource注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试-Inject注解"><span class="toc-number">2.3.10.</span> <span class="toc-text">测试@Inject注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三个注解之间的区别"><span class="toc-number">2.3.11.</span> <span class="toc-text">三个注解之间的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法、构造器位置的自动装配"><span class="toc-number">2.4.</span> <span class="toc-text">方法、构造器位置的自动装配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标注在实例方法上"><span class="toc-number">2.4.1.</span> <span class="toc-text">标注在实例方法上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标注在构造方法上"><span class="toc-number">2.4.2.</span> <span class="toc-text">标注在构造方法上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标注在参数上"><span class="toc-number">2.4.3.</span> <span class="toc-text">标注在参数上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标注在方法位置"><span class="toc-number">2.4.4.</span> <span class="toc-text">标注在方法位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义组件"><span class="toc-number">2.5.</span> <span class="toc-text">自定义组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XxxAware接口概览"><span class="toc-number">2.5.1.</span> <span class="toc-text">XxxAware接口概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XxxAware接口案例"><span class="toc-number">2.5.2.</span> <span class="toc-text">XxxAware接口案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XxxAware原理"><span class="toc-number">2.5.3.</span> <span class="toc-text">XxxAware原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profile注解"><span class="toc-number">2.6.</span> <span class="toc-text">@Profile注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Profile注解概述"><span class="toc-number">2.6.1.</span> <span class="toc-text">@Profile注解概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实战案例"><span class="toc-number">2.6.2.</span> <span class="toc-text">实战案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#环境搭建"><span class="toc-number">2.6.3.</span> <span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据环境注册bean"><span class="toc-number">2.6.4.</span> <span class="toc-text">根据环境注册bean</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">'Spring3'</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/21/Spring3/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/21/Spring3/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>B站颜群老师Spring教程，B站雷丰阳老师Spring教程，《Spring实战》<br><a href="https://zhuanlan.zhihu.com/p/137507309" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/137507309</a><br><a href="https://liayun.blog.csdn.net/article/details/115053350" target="_blank" rel="noopener">https://liayun.blog.csdn.net/article/details/115053350</a></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h3><p>在之前探讨了如何向Spring的IOC容器中注册bean组件，并且还讲解了有<br>关bean组件的生命周期的知识。接下来学习一下@Value注解的用法</p>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p>Spring中的@Value注解可以为bean中的属性赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, </span><br><span class="line">	ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Value &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Value注解可以标注在字段、方法、参数以及注解上，而且在程序运行期间生效</p>
<h4 id="Value注解的用法"><a href="#Value注解的用法" class="headerlink" title="@Value注解的用法"></a>@Value注解的用法</h4><p>第一种是不通过配置文件注入属性的情况，通过@Value注解将外部的<br>值动态注入到bean的属性中</p>
<ol>
<li>注入普通字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"天海"</span>)</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 注入普通字符串</span></span><br></pre></td></tr></table></figure></li>
<li>注入操作系统属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;systemProperties['os.name']&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String systemPropertiesName; <span class="comment">// 注入操作系统属性</span></span><br></pre></td></tr></table></figure></li>
<li>注入其他bean中属性的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;person.name&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String username; <span class="comment">// 注入其他bean中属性的值，即注入person对象的name属性中的值</span></span><br></pre></td></tr></table></figure></li>
<li>注入文件资源<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"classpath:/config.properties"</span>)</span><br><span class="line"><span class="keyword">private</span> Resource resourceFile; <span class="comment">// 注入文件资源</span></span><br></pre></td></tr></table></figure></li>
<li>注入URL资源<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="keyword">private</span> Resource url; <span class="comment">// 注入URL资源</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第二种是通过配置文件注入属性的情况，在项目的src/main/resources<br>目录下新建一个属性文件，例如person.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.nickName</span>=<span class="string">天海</span></span><br></pre></td></tr></table></figure>
<p>新建一个MainConfigOfPropertyValues配置类，并在该类上使用<br>@PropertySource注解读取外部配置文件中的key/value并保存到<br>运行的环境变量中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:/person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfPropertyValues</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载完外部的配置文件以后，接着我们就可以使用${key}取出配置文件<br>中key所对应的值，并将其注入到bean的属性中了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"天海"</span>)</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"#&#123;20-2&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;person.nickName&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String nickName; <span class="comment">// 昵称</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Value中-···-和-···-的区别"><a href="#Value中-···-和-···-的区别" class="headerlink" title="@Value中#{···}和${···}的区别"></a>@Value中#{···}和${···}的区别</h4><p>在这里提供一个测试属性文件advance_value_inject.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.name</span>=<span class="string">server1,server2,server3</span></span><br><span class="line"><span class="meta">author.name</span>=<span class="string">liayun</span></span><br></pre></td></tr></table></figure>
<p>新建一个AdvanceValueInject类，并在该类上使用@PropertySource<br>注解读取外部属性文件中的key/value并保存到运行的环境变量中，即<br>加载外部的advance_value_inject.properties属性文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:/advance_value_inject.properties"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvanceValueInject</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>${···}的用法<br>{}里面的内容必须符合SpEL表达式，通过@Value(“${spelDefault.<br>value}”)我们可以获取属性文件中对应的值，但是如果属性文件中<br>没有这个属性，那么就会报错。不过，我们可以通过赋予默认值来<br>解决这个问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;author.name:meimeixia&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>
上述代码的含义是表示向bean的属性中注入属性文件中的author.name<br>属性所对应的值，如果属性文件中没有author.name这个属性，那么便<br>向bean的属性中注入默认值meimeixia</li>
<li>#{···}的用法<br>{}里面的内容同样也是必须符合SpEL表达式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpEL：调用字符串Hello World的concat方法</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;'Hello World'.concat('!')&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String helloWorld;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SpEL：调用字符串的getBytes方法，然后再调用其length属性</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;'Hello World'.bytes.length&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String helloWorldBytes;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>${···}和#{···}可以混合使用，通过${server.name}从属性文件中获<br>取值并进行替换，然后就变成了执行SpEL表达式{‘server1,server2,<br>server3’.split(‘,’)}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SpEL：传入一个字符串，根据","切分后插入列表中， </span></span><br><span class="line"><span class="comment">#&#123;&#125;和$&#123;&#125;配合使用时，注意不能反过来$&#123;&#125;在外面，而#&#123;&#125;在里面*/</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;'$&#123;server.name&#125;'.split(',')&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; severs;</span><br></pre></td></tr></table></figure>
<p>必须#{}在外面，${}在里面，因为Spring执行${}的时机要早于#{}，<br>当Spring执行外层的${}时，内部的#{}为空，所以会执行失败。小结</p>
<ol>
<li>#{···}：用于执行SpEl表达式，并将内容赋值给属性</li>
<li>${···}：主要用于加载外部属性文件中的值</li>
</ol>
<h3 id="加载配置文件"><a href="#加载配置文件" class="headerlink" title="加载配置文件"></a>加载配置文件</h3><h4 id="PropertySource注解概述"><a href="#PropertySource注解概述" class="headerlink" title="@PropertySource注解概述"></a>@PropertySource注解概述</h4><p>@PropertySource注解是Spring 3.1c 开始引入的配置类注解。通过<br>@PropertySource注解可以将properties 配置文件中的key/value<br>存储到Spring的Environment中，Environment接口提供了方法去读<br>取配置文件中的值，参数是properties配置文件中定义的key值。也<br>可以使用@Value注解用${}占位符为bean的属性注入值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(PropertySources<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">PropertySource</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] value();</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() </span><br><span class="line">    	<span class="keyword">default</span> PropertySourceFactory<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过@PropertySource注解指定多个properties文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:/person.properties"</span>, </span><br><span class="line">	<span class="string">"classpath:/car.properties"</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="PropertySources注解概述"><a href="#PropertySources注解概述" class="headerlink" title="@PropertySources注解概述"></a>@PropertySources注解概述</h4><p>也可以使用@PropertySources注解来指定properties配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PropertySources &#123;</span><br><span class="line">    PropertySource[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySources</span>(value=&#123;</span><br><span class="line">    <span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:/person.properties"</span>&#125;),</span><br><span class="line">    <span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:/car.properties"</span>&#125;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="使用Environment获取值"><a href="#使用Environment获取值" class="headerlink" title="使用Environment获取值"></a>使用Environment获取值</h4><p>使用@PropertySource注解读取外部配置文件中的key/value之后，是将<br>其保存到运行的环境变量中了，所以我们也可以通过运行环境来获取外部<br>配置文件中的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printBeans(applicationContext);</span><br><span class="line">    System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">    </span><br><span class="line">    Person person = (Person) applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    </span><br><span class="line">    ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line">    String property = environment.getProperty(<span class="string">"person.nickName"</span>);</span><br><span class="line">    System.out.println(property);</span><br><span class="line">    <span class="comment">// 关闭容器</span></span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动装配组件"><a href="#自动装配组件" class="headerlink" title="自动装配组件"></a>自动装配组件</h3><h4 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h4><p>@Autowired注解可以对类成员变量、方法和构造函数进行标注，完<br>成自动装配的工作。@Autowired注解可以放在类、接口以及方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, </span><br><span class="line">	ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Autowired注解默认是优先按照类型去容器中找对应的组件，相当于<br>是调用了如下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.getBean(类名<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果找到多个相同类型的组件，那么是将属性名称作为组件的id，到IOC<br>容器中进行查找，这时就相当于是调用了如下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.getBean(<span class="string">"组件的id"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Qualifier注解"><a href="#Qualifier注解" class="headerlink" title="@Qualifier注解"></a>@Qualifier注解</h4><p>@Autowired是根据类型进行自动装配的，如果需要按名称进行装配，那<br>么就需要配合@Qualifier注解来使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, </span><br><span class="line">	ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Qualifier &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Primary注解"><a href="#Primary注解" class="headerlink" title="@Primary注解"></a>@Primary注解</h4><p>在Spring中使用注解时，常常会使用到@Autowired这个注解，它默认是<br>根据类型Type来自动注入的。但有些特殊情况，对同一个接口而言，可能<br>会有几种不同的实现类，而在默认只会采取其中一种实现的情况下，就<br>可以使用@Primary注解来标注优先使用哪一个实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Primary &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>Spring组件的自动装配就是Spring利用依赖注入，也就是我们通常所说的<br>DI，完成对IOC容器中各个组件的依赖关系赋值。<br>创建的BookDao、BookService和BookController为例进行说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 名字默认是类名首字母小写</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试在BookService类中使用@Autowired注解注入的BookDao（最后<br>输出了该BookDao的信息），和我们直接在Spring IOC容器中获取的<br>BookDao是不是同一个对象呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest_Autowired</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = </span><br><span class="line">		<span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfAutowired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		BookService bookService = applicationContext.getBean(BookService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		System.out.println(bookService);</span><br><span class="line">		BookDao bookDao = applicationContext.getBean(BookDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		System.out.println(bookDao);</span><br><span class="line">		applicationContext.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在Spring容器中存在对多个BookDao对象，对BookDao类进行<br>改造，为其加上一个lable字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 名字默认是类名首字母小写</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String lable = <span class="string">"1"</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MainConfigOfAutowired配置类中注入一个BookDao对象，并且显<br>示指定该对象在IOC容器中的bean的名称为bookDao2，并还为该对象<br>的lable字段赋值为2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(&#123;<span class="string">"com.atguigu.service"</span>, <span class="string">"com.atguigu.dao"</span>, </span><br><span class="line">	<span class="string">"com.atguigu.controller"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAutowired</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"bookDao2"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		BookDao bookDao = <span class="keyword">new</span> BookDao();</span><br><span class="line">		bookDao.setLable(<span class="string">"2"</span>);</span><br><span class="line">		<span class="keyword">return</span> bookDao;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的IOC容器中就会注入两个BookDao对象，@Autowired注解默认<br>是优先按照类型去容器中找对应的组件，找到就赋值，如果找到多个相<br>同类型的组件，那么再将属性的名称作为组件的id，到IOC容器中进行<br>查找。如果让@Autowired注解装配bookDao2，只须将BookService类<br>中的bookDao属性的名称全部修改为bookDao2即可</p>
<h4 id="测试-Qualifier注解"><a href="#测试-Qualifier注解" class="headerlink" title="测试@Qualifier注解"></a>测试@Qualifier注解</h4><p>如果IOC容器中存在多个相同类型的组件时，想要显示指定@Autowired注<br>解装配哪个组件，就可以使用@Qualifier注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"bookDao"</span>)</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> BookDao bookDao2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果IOC容器中无相应的组件那么就会抛出异常，如果不希望抛出异<br>常在@Autowired注解里面添加一个属性required=false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"bookDao"</span>)</span><br><span class="line">	<span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> BookDao bookDao2;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-Primary注解"><a href="#测试-Primary注解" class="headerlink" title="测试@Primary注解"></a>测试@Primary注解</h4><p>在Spring中，对同一个接口而言，可能会有几种不同的实现类，而默认<br>只会采取其中一种实现的情况下，就可以使用@Primary注解来标注优先<br>使用哪一个实现类。如果IOC容器中相同类型的组件有多个，那么我们不<br>可避免地就要来回用@Qualifier 注解来指定要装配哪个组件，这还是<br>比较麻烦的，Spring 正是帮我们考虑到了这样一种情况，就提供了这<br>样一个比较强大的注解，即@Primary。可以利用这个注解让Spring进<br>行自动装配的时候，默认使用首选的bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(&#123;<span class="string">"com.meimeixia.service"</span>, <span class="string">"com.meimeixia.dao"</span>, </span><br><span class="line">	<span class="string">"com.meimeixia.controller"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAutowired</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Primary</span></span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"bookDao2"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		BookDao bookDao = <span class="keyword">new</span> BookDao();</span><br><span class="line">		bookDao.setLable(<span class="string">"2"</span>);</span><br><span class="line">		<span class="keyword">return</span> bookDao;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意需要注释掉BookService类中bookDao字段上的@Qualifier注解，<br>这是因为@Qualifier注解为显示指定装配哪个组件，如果使用了该注<br>解，无论是否使用了@Primary注解，都会装配@Qualifier注解标注<br>的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">	<span class="comment">//@Qualifier("bookDao") 要让首选装配起效果，@Qualifier自然就不能用了</span></span><br><span class="line">	<span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Resource注解"><a href="#Resource注解" class="headerlink" title="@Resource注解"></a>@Resource注解</h4><p>@Resource注解是Java规范里面的，也可以说它是JSR250规范里面定义<br>的一个注解。该注解默认按照名称进行装配，名称可以通过name 属性进<br>行指定，如果没有指定name属性，当注解写在字段上时，那么默认取字<br>段名将其作为组件的名称在IOC容器中进行查找，如果注解写在setter<br>方法上，那么默认取属性名进行装配。当找不到与名称匹配的bean时才<br>按照类型进行装配。但是需要注意的一点是，如果name属性一旦指定<br>，那么就只会按照名称进行装配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Repeatable</span>(Resources<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Inject注解"><a href="#Inject注解" class="headerlink" title="@Inject注解"></a>@Inject注解</h4><p>@Inject注解也是Java规范里面的，也可以说它是JSR330规范里面定义<br>的一个注解。该注解默认是根据参数名去寻找bean注入，支持Spring的<br>@Primary注解优先注入，@Inject 注解还可以增加@Named注解指定要<br>注入的bean。要想使用@Inject注解，需要在项目的pom.xml文件中添<br>加如下依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以查看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inject &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试-Resource注解"><a href="#测试-Resource注解" class="headerlink" title="测试@Resource注解"></a>测试@Resource注解</h4><p>使用@Resource 注解也能够自动装配组件，只不过此时自动装配的<br>是lable为1的bookDao，不支持@Primary 注解优先注入的功能的<br>，而且也不能像@Autowired注解一样能添加required=false属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"><span class="comment">//	@Qualifier("bookDao") // 要让首选装配起效果，@Qualifier自然就不能用了</span></span><br><span class="line"><span class="comment">//	@Autowired(required=false)</span></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过@Resource注解的name属性显示指定要装配的组件的名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name=<span class="string">"bookDao2"</span>)</span><br><span class="line"><span class="keyword">private</span> BookDao bookDao;</span><br></pre></td></tr></table></figure>

<h4 id="测试-Inject注解"><a href="#测试-Inject注解" class="headerlink" title="测试@Inject注解"></a>测试@Inject注解</h4><p>用@Inject注解默认输出的是lable为2的bookDao。这是因为@Inject<br>注解和@Autowired注解一样，默认优先装配使用了@Primary 注解标<br>注的组件，不能像@Autowired注解一样能添加required=false属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"><span class="comment">//	@Qualifier("bookDao") // 要让首选装配起效果，@Qualifier自然就不能用了</span></span><br><span class="line"><span class="comment">//	@Autowired(required=false)</span></span><br><span class="line"><span class="comment">//	@Resource(name="bookDao2")</span></span><br><span class="line">	<span class="meta">@Inject</span></span><br><span class="line">	<span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三个注解之间的区别"><a href="#三个注解之间的区别" class="headerlink" title="三个注解之间的区别"></a>三个注解之间的区别</h4><p>三种注解都可以实现bean的自动装配。不同点如下</p>
<ol>
<li>@Autowired是Spring中的专有注解，而@Resource是Java中JSR250<br>规范里面定义的一个注解，@Inject是Java中JSR330规范里面定义的一<br>个注解</li>
<li>@Autowired支持参数required=false，而@Resource和@Inject都<br>不支持</li>
<li>@Autowired和@Inject支持@Primary注解优先注入，而@Resource<br>不支持</li>
<li>@Autowired通过@Qualifier指定注入特定bean，@Resource可以通<br>过参数name指定注入bean，而@Inject需要通过@Named注解指定注入<br>bean</li>
</ol>
<h3 id="方法、构造器位置的自动装配"><a href="#方法、构造器位置的自动装配" class="headerlink" title="方法、构造器位置的自动装配"></a>方法、构造器位置的自动装配</h3><p>@Autowired注解不仅可以标注在字段上，而且还可以标注在构造方法、<br>实例方法以及参数上，新建一个Boss类，在Boss类中有一个Car类的引<br>用，之前讲过可以在car字段上添加@Autowired注解，使其自动装配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认加在IOC容器中的组件，容器启动会调无参构造器创建对象，然后再进行初始化、赋值等操作</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Car car;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标注在实例方法上"><a href="#标注在实例方法上" class="headerlink" title="标注在实例方法上"></a>标注在实例方法上</h4><p>可以将@Autowired注解标注在setter方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当@Autowired注解标注在方法上时，Spring容器在创建当前对象的时<br>候，就会调用相应的方法为对象赋值。如果标注的方法存在参数时，那<br>么方法使用的参数和自定义类型的值，需要从IOC容器中获取</p>
<h4 id="标注在构造方法上"><a href="#标注在构造方法上" class="headerlink" title="标注在构造方法上"></a>标注在构造方法上</h4><p>为Boss类添加一个有参构造方法，然后去除setCar()方法上的@Autowired<br>注解，将@Autowired注解标注在有参构造方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Car car;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">		System.out.println(<span class="string">"Boss...有参构造器"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@Autowired注解标注在构造方法上时，如果组件中只有一个有参<br>构造方法，那么这个有参构造方法上的@Autowired注解可以省略，并<br>且参数位置的组件还是可以自动从IOC容器中获取</p>
<h4 id="标注在参数上"><a href="#标注在参数上" class="headerlink" title="标注在参数上"></a>标注在参数上</h4><p>我们也可以将@Autowired注解标注在参数上，例如，在Boss类中我们<br>将构造方法上的@Autowired注解标注在构造方法的参数上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(@Autowired Car car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">    System.out.println(<span class="string">"Boss...有参构造器"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将@Autowired注解标注在setter方法的参数上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(@Autowired Car car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论@Autowired注解是标注在字段上、实例方法上、构造方法上还是参<br>数上，参数位置的组件都是从IOC容器中获取</p>
<h4 id="标注在方法位置"><a href="#标注在方法位置" class="headerlink" title="标注在方法位置"></a>标注在方法位置</h4><p>@Autowired注解可以标注在某个方法的位置上，新建一个Color类，在<br>Color类中有一个Car类型的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Car car;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Color [car="</span> + car + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainConfigOfAutowired配置类中实例化Color类，此时的Color对<br>象中的Car对象为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color color = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将Car对象作为一个参数传递到MainConfigOfAutowired配置类的<br>color()方法中，并且将该Car对象设置到Color对象中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">    Color color = <span class="keyword">new</span> Color();</span><br><span class="line">    color.setCar(car);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用@Autowired注解来标注color()方法中的car参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">(@Autowired Car car)</span> </span>&#123;</span><br><span class="line">    Color color = <span class="keyword">new</span> Color();</span><br><span class="line">    color.setCar(car);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>自定义组件要想使用Spring容器底层的一些组件，ApplicationContext<br>（IOC容器）、底层的BeanFactory 等等，那么只需要让自定义组件实现<br>XxxAware接口即可。此时，Spring在创建对象的时候，会调用XxxAware<br>接口中定义的方法注入相关的组件</p>
<h4 id="XxxAware接口概览"><a href="#XxxAware接口概览" class="headerlink" title="XxxAware接口概览"></a>XxxAware接口概览</h4><p>之前创建的Dog 类，就实现了ApplicationContextAware 接口，实现<br>该接口的话，需要实现setApplicationContext() 方法。在IOC容器启<br>动并创建Dog 对象时，Spring会调用setApplicationContext()方法<br>，并且会将 ApplicationContext 对象传入到该方法中，我们只需要<br>在Dog 类中定义一个ApplicationContext 类型的成员变量来接收该<br>方法中的参数，便可在Dog类的其他方法中使用ApplicationContext<br>对象了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring中形如XxxAware这样的接口都继承了Aware接口 <img src="/2021/04/21/Spring3/1.jpg" alt></p>
<h4 id="XxxAware接口案例"><a href="#XxxAware接口案例" class="headerlink" title="XxxAware接口案例"></a>XxxAware接口案例</h4><ol>
<li>通过ApplicationContextAware接口我们可以获取到IOC容器</li>
<li>通过BeanNameAware接口获取到当前bean在Spring容器中的名称</li>
<li>通过EmbeddedValueResolverAware接口能够获取到String值解析器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, </span></span><br><span class="line"><span class="class">	<span class="title">BeanNameAware</span>, <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext </span></span></span><br><span class="line"><span class="function"><span class="params">		applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"传入的IOC："</span> + applicationContext);</span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 参数name：IOC容器创建当前对象时，为这个对象起的名字</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"当前bean的名字："</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	  参数resolver：IOC容器启动时会自动地将这个String值的解析器传递</span></span><br><span class="line"><span class="comment">	  过来给我们如果这个String类型的值里面有一些占位符，那么也会帮我</span></span><br><span class="line"><span class="comment">	  们把这些占位符给解析出来，最后返回一个解析后的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver </span></span></span><br><span class="line"><span class="function"><span class="params">		resolver)</span> </span>&#123;</span><br><span class="line">		String resolveStringValue = resolver.resolveStringValue(</span><br><span class="line">			<span class="string">"你好，$&#123;os.name&#125;，我的年龄是#&#123;20*18&#125;"</span>);</span><br><span class="line">		System.out.println(<span class="string">"解析的字符串："</span> + resolveStringValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="XxxAware原理"><a href="#XxxAware原理" class="headerlink" title="XxxAware原理"></a>XxxAware原理</h4><p>XxxAware接口的底层原理是由XxxAwareProcessor实现类实现的<br>，每一个XxxAware 接口都有它自己对应的XxxAwareProcessor<br>实现类。例如ApplicationContextAware 接口的底层原理就是<br>由ApplicationContextAwareProcessor类实现的，其实现了<br>BeanPostProcessor接口，本质上是一个后置处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextAwareProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">    	beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(bean <span class="keyword">instanceof</span> EnvironmentAware) &amp;&amp; </span><br><span class="line">        	!(bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &amp;&amp; </span><br><span class="line">        	!(bean <span class="keyword">instanceof</span> ResourceLoaderAware) &amp;&amp; </span><br><span class="line">        	!(bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &amp;&amp; </span><br><span class="line">        	!(bean <span class="keyword">instanceof</span> MessageSourceAware) &amp;&amp; </span><br><span class="line">        	!(bean <span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//注意这里</span></span><br><span class="line">                <span class="keyword">this</span>.invokeAwareInterfaces(bean);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//这里就把容器作为参数赋值</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">            ((ApplicationContextAware)bean).setApplicationContext(</span><br><span class="line">            	<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Profile注解"><a href="#Profile注解" class="headerlink" title="@Profile注解"></a>@Profile注解</h3><p>在实际的企业开发环境中，往往都会将环境分为开发环境、测试环<br>境和生产环境， 并且每个环境基本上都是互相隔离的，也就是说<br>，开发环境、测试环境和生产环境它们之间是互不相通的。在以前<br>的开发过程中，如果开发人员完成相应的功能模块并通过单元测<br>试后，那么他会通过手动修改配置文件的形式，将项目的配置修<br>改成测试环境，发布到测试环境中进行测试。测试通过后，再将<br>配置修改为生产环境，发布到生产环境中。这样手动修改配置的<br>方式，不仅增加了开发和运维的工作量，而且总是手工修改各<br>项配置文件会很容易出问题</p>
<h4 id="Profile注解概述"><a href="#Profile注解概述" class="headerlink" title="@Profile注解概述"></a>@Profile注解概述</h4><p>在容器中如果存在同一类型的多个组件，那么可以使用@Profile注解<br>标识要获取的是哪一个bean。也可以说@Profile注解是Spring为我们<br>提供的可以根据当前环境，动态地激活和切换一系列组件的功能。这个<br>功能在不同的环境使用不同的变量的情景下特别有用，例如，开发环<br>境、测试环境、生产环境使用不同的数据源，在不改变代码的情况下<br>，可以使用这个注解来动态地切换要连接的数据库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Profile注解不仅可以标注在方法上，也可以标注在配置类上</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;ProfileCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果@Profile注解标注在配置类上，那么只有是在指定的环境的时<br>候，整个配置类里面的所有配置才会生效</li>
<li>如果一个bean上没有使用@Profile注解进行标注，那么这个bean在<br>任何环境下都会被注册到IOC容器中，当然了，前提是在整个配置类生<br>效的情况下</li>
</ol>
<h4 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h4><p>使用@Profile注解实现开发、测试和生产环境的配置和切换。这里以开发<br>过程中要用到的数据源为例（数据源也是一种组件）。我们希望在开发环<br>境中，数据源是连向A数据库的，在测试环境中，数据源是连向B数据库<br>的，而且在这一过程中，测试人员压根就不需要改动任何代码，最终项<br>目上线之后，数据源连向C数据库，而且最重要的一点是在整个过程中<br>，我们不希望改动大量的代码，而实现数据源的切换</p>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>需要在pom.xml文件中添加c3p0数据源和MySQL驱动的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在项目中新建一个配置类，例如MainConfigOfProfile，并在该配置<br>类中模拟开发、测试、生产环境的数据源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfProfile</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"testDataSource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">		dataSource.setPassword(<span class="string">"liayun"</span>);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test"</span>);</span><br><span class="line">		dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"devDataSource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceDev</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">		dataSource.setPassword(<span class="string">"liayun"</span>);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/ssm_crud"</span>);</span><br><span class="line">		dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"prodDataSource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">		dataSource.setPassword(<span class="string">"liayun"</span>);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/scw_0515"</span>);</span><br><span class="line">		dataSource.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该配置类这样写，是一点儿问题都没有的，但你有没有想过这一点，<br>在真实项目开发中，那些数据库连接的相关信息，例如用户名、密码<br>以及MySQL数据库驱动类的全名，这些都是要抽取在一个配置文件中<br>的，在项目的src/main/resources目录下新建一个配置文件，例<br>如dbconfig.properties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.user=root</span><br><span class="line">db.password=liayun</span><br><span class="line">db.driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<p>然后通过之前学习过的注解知识获取以上配置文件中的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/dbconfig.properties"</span>) <span class="comment">// 加载外部的配置文件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfProfile</span> <span class="keyword">implements</span> <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"$&#123;db.user&#125;"</span>)</span><br><span class="line">	<span class="keyword">private</span> String user;</span><br><span class="line">	<span class="keyword">private</span> StringValueResolver valueResolver;</span><br><span class="line">	<span class="keyword">private</span> String dirverClass;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.valueResolver = resolver;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			我们通过该接口能够获取到String值解析器。也就是说，IOC容器启动时</span></span><br><span class="line"><span class="comment">			会自动地将String值的解析器（即StringValueResolver）传递过来</span></span><br><span class="line"><span class="comment">			给我们用，咱们可以用它来解析一些字符串</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		dirverClass = valueResolver.resolveStringValue(<span class="string">"$&#123;db.driverClass&#125;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据环境注册bean"><a href="#根据环境注册bean" class="headerlink" title="根据环境注册bean"></a>根据环境注册bean</h4><p>我们成功搭建环境之后，接下来就是要实现根据不同的环境来向IOC<br>容器中注册相应的bean了。也就是说，我们要实现在开发环境注册开<br>发环境下使用的数据源，在测试环境注册测试环境下使用的数据源<br>，在生产环境注册生产环境下使用的数据源。此时@Profile注解就<br>显示出其强大的特性了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/dbconfig.properties"</span>) <span class="comment">// 加载外部的配置文件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfProfile</span> <span class="keyword">implements</span> <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//测试环境</span></span><br><span class="line">	<span class="meta">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"testDataSource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceTest</span><span class="params">(@Value(<span class="string">"$&#123;db.password&#125;"</span>)</span> String pwd) </span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义了一个环境标识，只有当dev环境被激活以后，我们这个bean才能被注册进来</span></span><br><span class="line">	<span class="meta">@Profile</span>(<span class="string">"dev"</span>) </span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"devDataSource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceDev</span><span class="params">(@Value(<span class="string">"$&#123;db.password&#125;"</span>)</span> String pwd) </span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//生产环境</span></span><br><span class="line">	<span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"prodDataSource"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceProd</span><span class="params">(@Value(<span class="string">"$&#123;db.password&#125;"</span>)</span> String pwd) </span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为不同的数据源添加@Profile注解后，默认是不会向IOC容器中注册<br>bean的，需要我们根据环境显示指定向IOC容器中注册相应的bean。<br>换句话说，通过@Profile 注解加了环境标识的bean，只有这个环境被<br>激活的时候，相应的bean才会被注册到IOC容器中。可以通过@Profile<br>(“default”)注解来标识一个默认的环境</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"default"</span>)</span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"devDataSource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceDev</span><span class="params">(@Value(<span class="string">"$&#123;db.password&#125;"</span>)</span> String pwd) </span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">    dataSource.setUser(user);</span><br><span class="line">    dataSource.setPassword(pwd);</span><br><span class="line">    dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/ssm_crud"</span>);</span><br><span class="line">    dataSource.setDriverClass(dirverClass);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的环境来注册相应的bean有两种方式</p>
<ol>
<li>第一种方式就是根据命令行参数来确定环境，我们在运行程序的时<br>候可以添加相应的命令行参数。例如，如果我们现在的环境是测试环境<br>，那么可以在运行程序的时候添加如下命令行参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#VM options</span><br><span class="line">-Dspring.profiles.active&#x3D;test</span><br></pre></td></tr></table></figure></li>
<li>第二种方式就是通过写代码的方式来激活某种环境，其实主要是通过<br>AnnotationConfigApplicationContext类的无参构造方法来实现</li>
</ol>
<ul>
<li>在bean上加@Profile注解，其value属性值为环境标识，可以自定义</li>
<li>使用AnnotationConfigApplicationContext类的无参构造方法创建容器</li>
<li>设置容器环境，其值为第1步设置的环境标识</li>
<li>设置容器的配置类</li>
<li>刷新容器</li>
</ul>
<p>先在程序中调用AnnotationConfigApplicationContext类的无参构<br>造方法来创建一个IOC容器，然后在容器进行初始化之前，为其设置相<br>应的环境，接着再为容器设置主配置类，最后刷新一下容器。例如，<br>我们将IOC容器设置为测试环境</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 使用无参构造器创建一个IOC容器</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		注意这里不能使用有参构造器，有参构造器里有refresh函数会</span></span><br><span class="line"><span class="comment">		自动加载完成</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	AnnotationConfigApplicationContext applicationContext = </span><br><span class="line">		<span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">	<span class="comment">// 2. 在容器还没启动创建其他bean之前，先设置需要激活的环境（可设置激活多个环境）</span></span><br><span class="line">	applicationContext.getEnvironment().setActiveProfiles(<span class="string">"test"</span>);</span><br><span class="line">	<span class="comment">// 3. 注册主配置类</span></span><br><span class="line">	applicationContext.register(MainConfigOfProfile<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">// 4. 启动刷新容器</span></span><br><span class="line">	applicationContext.refresh();</span><br><span class="line">	String[] namesForType = applicationContext.getBeanNamesForType(</span><br><span class="line">		DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">for</span> (String name : namesForType) &#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭容器</span></span><br><span class="line">	applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Profile注解不仅可以标注在方法上，也可以标注在配置类上。如果标<br>注在配置类上，那么只有是在指定的环境的时候，整个配置类里面的所<br>有配置才会生效。例如我们在MainConfigOfProfile 配置类上标注上<br>@Profile(“dev”)注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">// @Profile注解除了能写到bean上，还能写到类上</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/dbconfig.properties"</span>) <span class="comment">// 加载外部的配置文件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfProfile</span> <span class="keyword">implements</span> <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在test02()方法中指定当前环境为测试环境，而MainConfigOfProfile<br>配置类上标注的注解为@Profile(“dev”)，说明该配置类中的所有配置<br>只有在开发环境下才会生效。所以，此时没有任何数据源注册到IOC容器<br>中，自然控制台中就不会输出任何信息了。如果一个bean 上没有使用<br>@Profile注解进行标注，那么这个bean在任何环境下都会被注册到<br>IOC容器中</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/21/Spring3/">https://skysea-gaoming.github.io/2021/04/21/Spring3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/22/Spring4/"><i class="fa fa-chevron-left">  </i><span>Spring4</span></a></div><div class="next-post pull-right"><a href="/2021/04/20/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"><span>网络安全</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/21/Spring3/';
  this.page.identifier = '2021/04/21/Spring3/';
  this.page.title = ''Spring3'';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>