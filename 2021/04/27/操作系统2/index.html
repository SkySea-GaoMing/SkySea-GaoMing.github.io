<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="操作系统总结2"><meta name="keywords" content="System"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>操作系统总结2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存"><span class="toc-number">1.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是内存"><span class="toc-number">1.1.</span> <span class="toc-text">什么是内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译阶段"><span class="toc-number">1.2.</span> <span class="toc-text">编译阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链接和动态链接的区别"><span class="toc-number">1.3.</span> <span class="toc-text">静态链接和动态链接的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理的作用"><span class="toc-number">1.4.</span> <span class="toc-text">内存管理的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理机制"><span class="toc-number">1.5.</span> <span class="toc-text">内存管理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态分区分配的四种算法"><span class="toc-number">1.6.</span> <span class="toc-text">动态分区分配的四种算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址空间"><span class="toc-number">1.7.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页系统"><span class="toc-number">1.8.</span> <span class="toc-text">分页系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页"><span class="toc-number">1.9.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表"><span class="toc-number">1.10.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表项的结构"><span class="toc-number">1.11.</span> <span class="toc-text">页表项的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加速分页过程"><span class="toc-number">1.12.</span> <span class="toc-text">加速分页过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快表和多级页表"><span class="toc-number">1.13.</span> <span class="toc-text">快表和多级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#快表"><span class="toc-number">1.13.1.</span> <span class="toc-text">快表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多级页表"><span class="toc-number">1.13.2.</span> <span class="toc-text">多级页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页和分段的区别"><span class="toc-number">1.14.</span> <span class="toc-text">分页和分段的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑地址和物理地址"><span class="toc-number">1.15.</span> <span class="toc-text">逻辑地址和物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU寻址"><span class="toc-number">1.16.</span> <span class="toc-text">CPU寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有虚拟地址空间"><span class="toc-number">1.17.</span> <span class="toc-text">为什么要有虚拟地址空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存"><span class="toc-number">2.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存-1"><span class="toc-number">2.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部性原理"><span class="toc-number">2.2.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟存储器"><span class="toc-number">2.3.</span> <span class="toc-text">虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存技术的实现"><span class="toc-number">2.4.</span> <span class="toc-text">虚拟内存技术的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页面置换算法"><span class="toc-number">2.5.</span> <span class="toc-text">页面置换算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO模型"><span class="toc-number">3.</span> <span class="toc-text">IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-是什么？"><span class="toc-number">3.1.</span> <span class="toc-text">Socket 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O模型中的输入操作？"><span class="toc-number">3.2.</span> <span class="toc-text">I&#x2F;O模型中的输入操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O模型分为几种？"><span class="toc-number">3.3.</span> <span class="toc-text">I&#x2F;O模型分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式I-O-是什么？"><span class="toc-number">3.4.</span> <span class="toc-text">阻塞式I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞式I-O-是什么？"><span class="toc-number">3.5.</span> <span class="toc-text">非阻塞式I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-多路复用？"><span class="toc-number">3.6.</span> <span class="toc-text">I&#x2F;O 多路复用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-是什么？"><span class="toc-number">3.7.</span> <span class="toc-text">select 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll-是什么？"><span class="toc-number">3.8.</span> <span class="toc-text">poll 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-是什么？"><span class="toc-number">3.9.</span> <span class="toc-text">epoll 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select和poll的区别？"><span class="toc-number">3.10.</span> <span class="toc-text">select和poll的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recvfrom-是什么？"><span class="toc-number">3.11.</span> <span class="toc-text">recvfrom 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Epoll和Poll和Select？"><span class="toc-number">3.12.</span> <span class="toc-text">Epoll和Poll和Select？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式I-O和I-O复用的区别？"><span class="toc-number">3.13.</span> <span class="toc-text">阻塞式I&#x2F;O和I&#x2F;O复用的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号驱动I-O-是什么？"><span class="toc-number">3.14.</span> <span class="toc-text">信号驱动I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步I-O-是什么？"><span class="toc-number">3.15.</span> <span class="toc-text">异步I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步是什么？"><span class="toc-number">3.16.</span> <span class="toc-text">异步是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步的异步的区别？"><span class="toc-number">3.17.</span> <span class="toc-text">同步的异步的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO分为哪几种？"><span class="toc-number">3.18.</span> <span class="toc-text">Java IO分为哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-是什么？"><span class="toc-number">3.19.</span> <span class="toc-text">BIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-是什么？"><span class="toc-number">3.20.</span> <span class="toc-text">NIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-和IO-多路复用的关系？"><span class="toc-number">3.21.</span> <span class="toc-text">NIO 和IO 多路复用的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO-是什么？"><span class="toc-number">3.22.</span> <span class="toc-text">AIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用的那三种方式有什么区别？"><span class="toc-number">3.23.</span> <span class="toc-text">多路复用的那三种方式有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统"><span class="toc-number">4.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件属性"><span class="toc-number">4.1.</span> <span class="toc-text">文件属性</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">操作系统总结2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/27/操作系统2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存"></a>什么是内存</h3><p>内存可存放数据，程序执行前放入内存中才能被CPU 处理。内存地址从0<br>开始，每个地址对应一个存储单元。按字节编址，每个存储单元占1个字<br>节，按字编址每个存储单元占1个字，16位</p>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><ol>
<li>预处理阶段：处理以 # 开头的预处理命令</li>
<li>编译阶段：翻译成汇编文件</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件</li>
<li>链接阶段：将可重定位目标文件和 printf.o</li>
<li>等单独预编译好的目标文件进行合并，得到最终的可执行目标文件</li>
</ol>
<h3 id="静态链接和动态链接的区别"><a href="#静态链接和动态链接的区别" class="headerlink" title="静态链接和动态链接的区别"></a>静态链接和动态链接的区别</h3><ol>
<li>静态链接就是在编译期间，由编译器和连接器将静态库集成到应用程序内<br>，并制作成目标文件以及可以独立运作的可执行文件。静态库一般是一些外<br>部函数与变量的集合</li>
<li>动态链接可以在首次载入的时候执行，也可以在程序开始执行的时候完成<br>。这个是由动态链接器完成，比方标准 C 库(libc.so) 通常就是动态链接<br>的，这样所有的程序可以共享同一个库，而不用分别进行封装</li>
</ol>
<h3 id="内存管理的作用"><a href="#内存管理的作用" class="headerlink" title="内存管理的作用"></a>内存管理的作用</h3><p>操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，<br>free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理<br>地址、内存空间的扩展等功能也是操作系统内存管理做的事情</p>
<h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><p>简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式<br>是指为一个用户程序分配一个连续的内存空间，常见的如块式管理 。同样地<br>非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内<br>存中，常见的如页式管理和段式管理</p>
<ol>
<li>块式管理 ：远古时代的计算机操系统的内存管理方式。将内存分为几个固<br>定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系<br>统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存<br>很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎<br>片</li>
<li>页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相对<br>相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理<br>通过页表对应逻辑地址和物理地址</li>
<li>段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实<br>际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比<br>一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一<br>组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。<br>段式管理通过段表对应逻辑地址和物理地址</li>
</ol>
<h3 id="动态分区分配的四种算法"><a href="#动态分区分配的四种算法" class="headerlink" title="动态分区分配的四种算法"></a>动态分区分配的四种算法</h3><ol>
<li>首次适应算法</li>
<li>最佳适应算法</li>
<li>最坏适应算法</li>
<li>临近适应算法</li>
</ol>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>引入地址空间的概念就是为了在内存中同时运行多个程序并且互不影响，解决<br>了保护和重定位问题。地址空间是一个进程可以用于寻址内存的一套地址集合<br>。每个进程都有自己的地址空间，并且这个地址空间独立于其他进程的地址空<br>间</p>
<h3 id="分页系统"><a href="#分页系统" class="headerlink" title="分页系统"></a>分页系统</h3><p>程序产生的地址是虚拟地址，构成了一个地址空间。虚拟地址不是被送到<br>内存总线上而是送到内存管理单元MMU，MMU把虚拟地址映射为物理地址。<br>虚拟空间被划分为若干页面，物理地址中页面对应的空间叫做页框。<br>MMU管理地址空间和物理空间的转换，如果一个页面没有被映射就是缺页<br>中断或缺页错误</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页机制的思想是:通过映射，可以使连续的线性地址与物理地址相关联，<br>逻辑上连续的线性地址对应的物理地址可以不连续。 分页的作用- 将线<br>性地址转换为物理地址 - 用大小相同的页替换大小不同的段</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表存储页和页框的映射表。一个虚拟地址被分为两部分，一部分存储页<br>号，另一部分存储偏移量。一个页面存储16个页，那么需要4位比特来表<br>示在索引定位，所以虚拟地址的前4位就可表示页的索引，后12位是偏<br>移量，页表中第二个子段就是页框号，页框号加上偏移量就是实际的<br>物理地址，页表的第三个字段就是在/不在</p>
<h3 id="页表项的结构"><a href="#页表项的结构" class="headerlink" title="页表项的结构"></a>页表项的结构</h3><p>页框号：该页需要映射到的物理页<br>在/不在位：如果是1表示该表项有效可以使用，如果是0表示对应的虚拟<br>页面不在内存中<br>保护位：一个页运行什么类型的访问，可以使用3位，对应读、写或修改<br>修改位：重新分配页框时如果该页已经被修改需要写回磁盘，如果没有<br>被修改直接丢弃即可，有时也叫脏位<br>访问位：不管读还是写该页面被访问时都会设置访问位，不再使用的页<br>面比正在使用的页面更适合淘汰<br>高速缓存禁止位：保证硬件是不断从设备总读取数据而不是访问旧的被<br>高速缓存的副本时使用</p>
<h3 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h3><p>大量程序总是对少量页面进行多次访问，可以设置一个小型的硬件设备<br>，将虚拟地址直接映射到物理地址。这种设备就是转换检测缓冲区TLB，<br>有时也称为相连存储器或块表。软失效是页面不在TLB中，需要从内存<br>中获取。硬失效是页面不在内存中，那么必须从磁盘读取。<br>TLB能够加速虚拟地址到物理地址的转换，还有一个问题是处理巨大的<br>虚拟地址空间。有两种解决办法</p>
<ol>
<li>多级页表<br>引入多级页表是避免把全部页表一直保存在内存中。把32位虚拟地址分<br>为10位的PT1域、10位的PT2域和12位的PT3域，顶级页表对应10位的<br>PT1域，有1024个表项，每一个表项都表示4M的块地址范围，二级页<br>表的索引是PT2域</li>
<li>倒排页表<br>每个页框对应一个表项，而不是每个虚拟页面对应一个表项，这样可以<br>节省大量空间，但是从虚拟地址到物理地址的转换会非常困难</li>
</ol>
<h3 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h3><p>在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快</li>
<li>解决虚拟地址空间大，页表也会很大的问题</li>
</ol>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引<br>入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特<br>殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容。作为页表<br>的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地<br>址转换，读写内存数据时CPU 要访问两次主存。有了快表，有时只要访问<br>一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。<br>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，<br>同时将页表中的该映射表项添加到快表中</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中<br>的一个页</li>
</ol>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空<br>间，特别是那些根本就不需要的页表就不需要保留在内存中</p>
<h3 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h3><p>相同点</p>
<ol>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页<br>和段中的内存是连续的</li>
</ol>
<p>不同点</p>
<ol>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 </li>
<li>页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间，将用户程序地址空<br>间分为若干固定大小的区域</li>
<li>分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助<br>于共享和保护</li>
<li>段的大小不固定，由它所完成的功能决定，页大大小固定，由系统决定</li>
<li>分段是二维的，如代码段，数据段，堆栈段，这样每个进程有一个二维地址<br>空间，相互独立，互不干扰</li>
</ol>
<h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><p>比如在C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个<br>地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实<br>物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内<br>存单元真正的地址</p>
<h3 id="CPU寻址"><a href="#CPU寻址" class="headerlink" title="CPU寻址"></a>CPU寻址</h3><p>现代处理器使用的是一种称为虚拟寻址的寻址方式。使用虚拟寻址，CPU 需要将<br>虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟<br>地址转换为物理地址转换的硬件是CPU 中含有一个被称为内存管理单元的硬件</p>
<h3 id="为什么要有虚拟地址空间"><a href="#为什么要有虚拟地址空间" class="headerlink" title="为什么要有虚拟地址空间"></a>为什么要有虚拟地址空间</h3><p>没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作<br>系统，造成操作系统崩溃</li>
<li>想要同时运行多个程序特别困难</li>
</ol>
<p>通过虚拟地址访问内存有以下优势</p>
<ol>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物<br>理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保<br>存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一<br>进程或操作系统使用的物理内存</li>
</ol>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存：每个程序有自己的地址空间，把这个空间分割为多块，每一块称为<br>页，每一页都有连续的地址范围，执行时这些页映射到物理内存。但并不是所<br>有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地<br>址空间时，由硬件立刻进行必要的映射，当程序引用到一部分不在物理内存<br>中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失<br>败的命令</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol>
<li>时间上的局部性：最近被访问的页在不久的将来还会被访问</li>
<li>空间上的局部性：内存中被访问的页周围的页也很可能被访问</li>
</ol>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>虚拟存储器又叫做虚拟内存，属于同一个概念。<br>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部<br>分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运<br>行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序<br>执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入<br>内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容<br>换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为<br>用户提供了一个比实际内存大的多的存储器——虚拟存储器</p>
<h3 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h3><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的<br>实现有以下三种方式</p>
<ol>
<li>请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而<br>增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚<br>拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入<br>当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面<br>不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页<br>面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中</li>
<li>请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分<br>段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作<br>业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可<br>使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满<br>，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而<br>装入新的段</li>
<li>请求段页式存储管理</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在发送缺页中断时，需要选择一个页面，将其换出内存，如果每次都选择<br>不常使用的页面会提升系统性能，如果一个频繁使用的页面被置换出去会<br>带来不必要的开销</p>
<ol>
<li>最佳 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证<br>获得最低的缺页率</li>
<li>最近最久未使用 虽然无法知道将来要使用的页面情况，但是可以知道过<br>去使用页面的情况。LRU 将最近最久未使用的页面换出。为了实现 LRU，需<br>要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移<br>到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次<br>访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</li>
<li>最近未使用 每个页面都有两个状态位：R 与 M，当页面被访问时设置页<br>面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。优先换出被<br>修改并且没有再被访问的页面</li>
<li>先进先出FIFO 选择换出的页面是最先进入的页面。该算法会将那些经常<br>被访问的页面换出，导致缺页率升高</li>
</ol>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><h3 id="Socket-是什么？"><a href="#Socket-是什么？" class="headerlink" title="Socket 是什么？"></a>Socket 是什么？</h3><p>Socket是应用层与TCP/IP协议通信的中间软件抽象层，它是一组接口</p>
<h3 id="I-O模型中的输入操作？"><a href="#I-O模型中的输入操作？" class="headerlink" title="I/O模型中的输入操作？"></a>I/O模型中的输入操作？</h3><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所<br>等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核<br>缓冲区复制到应用进程缓冲区</p>
<ol>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ol>
<h3 id="I-O模型分为几种？"><a href="#I-O模型分为几种？" class="headerlink" title="I/O模型分为几种？"></a>I/O模型分为几种？</h3><ol>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ol>
<h3 id="阻塞式I-O-是什么？"><a href="#阻塞式I-O-是什么？" class="headerlink" title="阻塞式I/O 是什么？"></a>阻塞式I/O 是什么？</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回，<br>在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系<br>统都被阻塞</p>
<ol>
<li>CPU把数据从磁盘读到内核缓冲区</li>
<li>CPU把数据从内核缓冲区拷贝到用户缓冲区</li>
</ol>
<h3 id="非阻塞式I-O-是什么？"><a href="#非阻塞式I-O-是什么？" class="headerlink" title="非阻塞式I/O 是什么？"></a>非阻塞式I/O 是什么？</h3><p>非阻塞IO发出read请求后发现数据没准备好，会继续往下执行，此时应用程<br>序会不断轮询polling内核询问数据是否准备好，当数据没有准备好时，内<br>核立即返回EWOULDBLOCK错误。直到数据被拷贝到应用程序缓冲区，read请<br>求才获取到结果。这里最后一次read 调用获取数据的过程，是一个同步的<br>过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序<br>的缓存区这个过程</p>
<h3 id="I-O-多路复用？"><a href="#I-O-多路复用？" class="headerlink" title="I/O 多路复用？"></a>I/O 多路复用？</h3><ol>
<li>非阻塞情况下无可用数据时，应用程序每次轮询内核看数据是否准备好<br>了也耗费CPU</li>
<li>I/O复用就是不让它轮询，当内核缓冲区数据准备好了，以事件通知当机<br>制告知应用进程数据准备好，应用进程在没有收到数据准备好的事件通知信<br>号时可以忙写其他的工作</li>
<li>I/O就是指的我们网络I/O，多路指多个TCP连接(或多个Channel)，复<br>用指复用一个或少量线程。串起来理解就是很多个网络I/O复用一个或少量<br>的线程来处理这些连接。发明它的目的是尽量多的提高服务器的吞吐能力。<br>实现一个线程监控多个IO请求，哪个IO有请求就把数据从内核拷贝到进程<br>缓冲区，拷贝期间是阻塞的</li>
<li>通过一种机制可以监视多个文件描述符，一旦某个文件描述符就绪（一<br>般是读就绪或者写就绪），就能够通知进程进行相应的读写操作，select<br>poll epoll都是IO 多路复用的一种机制，他们三个本质上都是同步IO，<br>因为 它们都需要在读写事件就绪后自己负责读写操作，也就是读写过程<br>中是阻塞的，而异步IO无需自己进行读写，它只负责发起事件具体的实<br>现由别的完成</li>
<li>使用select 或者poll 等待数据，并且可以等待多个套接字中的任何<br>一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再<br>使用recvfrom 把数据从内核复制到进程中，它可以让单个进程具有处<br>理多个I/O 事件的能力</li>
<li>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event<br>Driven I/O，即事件驱动 I/O</li>
<li>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需<br>要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数<br>量的线程</li>
</ol>
<h3 id="select-是什么？"><a href="#select-是什么？" class="headerlink" title="select 是什么？"></a>select 是什么？</h3><p>该函数会等待多个I/O事件(比如读就绪，写)的任何一个发生，并且只要<br>有一个网络事件发生，select 线程就会执行。如果没有任何一个事件发<br>生则阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int select(int maxfdpl,fd_set *readset,fd_set *writeset,fd_set *exceptset,</span><br><span class="line">	const struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为<br>就绪状态，从而完成 I/O 操作</p>
<h3 id="poll-是什么？"><a href="#poll-是什么？" class="headerlink" title="poll 是什么？"></a>poll 是什么？</h3><p>poll 的功能与select 类似，也是等待一组描述符中的一个成为就绪状态</p>
<h3 id="epoll-是什么？"><a href="#epoll-是什么？" class="headerlink" title="epoll 是什么？"></a>epoll 是什么？</h3><p>epoll 是线程安全的，不仅告诉你sock组里面数据，还会告诉你具体哪个<br>sock有数据，你不用自己去找了</p>
<h3 id="select和poll的区别？"><a href="#select和poll的区别？" class="headerlink" title="select和poll的区别？"></a>select和poll的区别？</h3><ol>
<li>select 会修改描述符，而 poll 不会</li>
</ol>
<h3 id="recvfrom-是什么？"><a href="#recvfrom-是什么？" class="headerlink" title="recvfrom 是什么？"></a>recvfrom 是什么？</h3><p>recvfrom一般用于UDP协议中，但是如果在TCP中connect函数调用后也可以<br>用。用于从（已连接）套接口上接收数据，并捕获数据发送源的地址</p>
<h3 id="Epoll和Poll和Select？"><a href="#Epoll和Poll和Select？" class="headerlink" title="Epoll和Poll和Select？"></a>Epoll和Poll和Select？</h3><p>select/poll/epoll 都是 I/O 多路复用的具体实现</p>
<ol>
<li>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为<br>就绪状态，从而完成 I/O 操作</li>
<li>poll poll 的功能与 select 类似，也是等待一组描述符中的一个成为就<br>绪状态，poll 中的描述符是pollfd 类型的数组</li>
<li>epoll 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注<br>册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将I/O 准<br>备好的描述符加入到一个链表中管理</li>
</ol>
<h3 id="阻塞式I-O和I-O复用的区别？"><a href="#阻塞式I-O和I-O复用的区别？" class="headerlink" title="阻塞式I/O和I/O复用的区别？"></a>阻塞式I/O和I/O复用的区别？</h3><ol>
<li>阻塞式I/O和I/O复用，两个阶段都阻塞，等待数据和将数据复制到用户进<br>程这两个阶段都是阻塞的</li>
<li>虽然第一阶段都是阻塞，但是阻塞式I/O如果要接收更多的连接，就必须创<br>建更多的线程。I/O复用模式下在第一个阶段大量的连接统统都可以过来直接注<br>册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连<br>接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。<br>这就是I/O复用与传统的阻塞式I/O最大的不同</li>
</ol>
<h3 id="信号驱动I-O-是什么？"><a href="#信号驱动I-O-是什么？" class="headerlink" title="信号驱动I/O 是什么？"></a>信号驱动I/O 是什么？</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续<br>执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向<br>应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用<br>recvfrom 将数据从内核复制到应用进程中</p>
<h3 id="异步I-O-是什么？"><a href="#异步I-O-是什么？" class="headerlink" title="异步I/O 是什么？"></a>异步I/O 是什么？</h3><p>真正的异步I/O 是内核数据准备好和数据从内核态拷贝到用户态这两个过<br>程都不用等待，当用户发起aio_read请求后就会自动返回。内核会自动将<br>数据从内核缓冲区拷贝到用户进程空间，应用进程啥都不用管，内核会在<br>所有操作完成之后向应用进程发送信号。<br>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用<br>进程I/O 完成，而信号驱动I/O 的信号是通知应用进程可以开始 I/O</p>
<h3 id="异步是什么？"><a href="#异步是什么？" class="headerlink" title="异步是什么？"></a>异步是什么？</h3><p>对于异步来说，用户进行读或者写后，将立刻返回，由内核去完成数据读取<br>以及拷贝工作，完成后通知用户，并执行回调函数（用户提供的callback<br>），此时数据已从内核拷贝到用户空间，用户线程只需要对数据进行处理<br>即可，不需要关注读写，用户不需要等待内核对数据的复制操作，用户在<br>得到通知时数据已经被复制到用户空间</p>
<h3 id="同步的异步的区别？"><a href="#同步的异步的区别？" class="headerlink" title="同步的异步的区别？"></a>同步的异步的区别？</h3><ol>
<li>同步跟异步的区别在于数据从内核空间拷贝到用户空间是否由用户线程<br>完成，这里又分为同步阻塞跟同步非阻塞两种</li>
<li>同步阻塞 此时一个线程维护一个连接，该线程完成数据到读写跟处理<br>到全部过程，数据读写时时线程是被阻塞的</li>
<li>同步非阻塞 非阻塞的意思是用户线程发出读请求后，读请求不会阻塞<br>当前用户线程，不过用户线程还是要不断的去主动判断数据是否准备OK了<br>。此时还是会阻塞等待内核复制数据到用户进程。他与同步BIO区别是使用<br>一个连接全程等待</li>
<li>同步在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一<br>旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用<br>的结果</li>
<li>异步调用在发出之后，这个调用就直接返回了，所以没有返回结果。换<br>句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<br>调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处<br>理这个调用</li>
</ol>
<h3 id="Java-IO分为哪几种？"><a href="#Java-IO分为哪几种？" class="headerlink" title="Java IO分为哪几种？"></a>Java IO分为哪几种？</h3><ol>
<li>BIO：同步阻塞IO</li>
<li>NIO：同步非阻塞IO</li>
<li>AIO：异步非阻塞IO</li>
</ol>
<h3 id="BIO-是什么？"><a href="#BIO-是什么？" class="headerlink" title="BIO 是什么？"></a>BIO 是什么？</h3><ol>
<li>同步阻塞IO，每个客户端的Socket连接请求，服务端都会对应有个处理<br>线程与之对应，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当<br>于是一个连接一个线程</li>
<li>使用一个独立的线程维护一个socket连接，随着连接数量的增多，对虚<br>拟机造成一定压力</li>
<li>使用流来读取数据，流是阻塞的，当没有可读/可写数据时，线程等待<br>，会造成资源的浪费</li>
</ol>
<h3 id="NIO-是什么？"><a href="#NIO-是什么？" class="headerlink" title="NIO 是什么？"></a>NIO 是什么？</h3><ol>
<li>同步非阻塞，也就是说如果你调用NIO接口去执行IO操作，其实还是同步<br>等待的，但是在底层的IO操作上 ，会对系统内核发起非阻塞IO请求，以非<br>阻塞的形式来执行IO。也就是说，如果底层数据没到位，那么内核返回异常<br>信息，不会阻塞住，但是NIO接口内部会采用非阻塞方式过一会儿再次调用<br>内核发起IO请求，直到成功为止。但是之所以说是同步非阻塞，这里的“同<br>步”指的就是因为在你的Java代码调用NIO接口层面是同步的，你还是要同<br>步等待底层IO操作真正完成了才可以返回，只不过在执行底层IO的时候采<br>用了非阻塞的方式来执行罢了</li>
<li>服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发<br>现某个Socket端口上有数据可读时说明读就绪，则调用该socket连接的相<br>应读操作。如果发现某个 Socket端口上有数据可写时说明写就绪，则调用<br>该socket连接的相应写操作。如果某个端口的Socket连接已经中断，则调<br>用相应的析构方法关闭该端口</li>
<li>每个线程中包含一个Selector对象，它相当于一个通道管理器，可以实<br>现在一个线程中处理多个通道的目的，减少线程的创建数量。远程连接对应<br>一个channel，数据的读写通过buffer均在同一个channel中完成，并且<br>数据的读写是非阻塞的</li>
<li>通道创建后需要注册在selector中，同时需要为该通道注册感兴趣事件<br>（客户端连接服务端事件、服务端接收客户端连接事件、读事件、写事件），<br>selector线程需要采用轮训的方式调用selector的select函数，直到所<br>有注册通道中有兴趣的事件发生，则返回，否则一直阻塞。而后循环处理<br>所有就绪的感兴趣事件。以上步骤解决BIO的两个瓶颈：</li>
</ol>
<ul>
<li>不必对每个连接分别创建线程</li>
<li>数据读写非阻塞</li>
</ul>
<p>Java NIO由以下三个核心部分组成</p>
<ol>
<li>selector：Selector 允许单线程处理多个Channel。如果你的应用打开<br>了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便<br>。要使用Selector，得向Selector注册Channel，然后调用他的select 方<br>法，这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回<br>，线程就可以处理这些事件，事件的例子入有新连接接进来，数据接收等</li>
<li>Channel：基本上所有的IO在NIO中都从一个Channel开始。Channel有点<br>像流，数据可以从channel读到buffer，也可以从buffer写到channel</li>
<li>Buffer：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个<br>容器对象( 含数组)，该对象提供了一组方法，可以更轻松的使用内存块，缓<br>冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变换情况，Channel<br>提供从文件，网络读取数据的渠道，但是读取或者写入的数据都必须经由Buffer</li>
</ol>
<h3 id="NIO-和IO-多路复用的关系？"><a href="#NIO-和IO-多路复用的关系？" class="headerlink" title="NIO 和IO 多路复用的关系？"></a>NIO 和IO 多路复用的关系？</h3><ol>
<li>实际上，如果基于NIO进行网络通信，采取的就是多路复用的IO模型，这个<br>多路复用IO模型针对的是网络通信中的IO场景来说的</li>
<li>简单来说，就是在基于Socket进行网络通信的时候，如果有多个客户端跟<br>你的服务端建立了Socket连接，那你就需要维护多个Socket连接</li>
<li>而所谓的多路复用IO模型，就是说你的Java代码直接通过一个select函数<br>调用，直接会进入一个同步等待的状态。必须在这里同步等待某个Socket连接<br>有请求到来，接着你就要同步等着select函数去对底层的多个Socket 连接<br>进行轮询，不断的查看各个 Socket 连接谁有请求到达，就可以让select<br>函数返回</li>
<li>select函数在底层会通过非阻塞的方式轮询各个Socket，任何一个Socket<br>如果没有数据到达，那么非阻塞的特性会立即返回一个信息，然后select函数<br>可以轮询下一个Socket，不会阻塞在某个Socket上</li>
<li>这就是所谓的“同步非阻塞”，但是因为操作系统把上述工作都封装在一个<br>select函数调用里了，可以对多路Socket连接同时进行监视，所以就把这种<br>模型称之为“IO多路复用”模型</li>
<li>通过这种IO多路复用的模型，就可以用一个线程，调用一个select函数<br>，然后监视大量的客户端连接</li>
</ol>
<h3 id="AIO-是什么？"><a href="#AIO-是什么？" class="headerlink" title="AIO 是什么？"></a>AIO 是什么？</h3><ol>
<li>AIO是异步非阻塞IO，相比NIO更进一步，进程读取数据时只负责发送跟接<br>收指令，数据的准备工作完全由操作系统来处理</li>
<li>可以基于AIO API发起一个请求，比如说接收网络数据，AIO API底层会<br>基于异步IO模型来调用操作系统内核，此时不需要去管这个IO是否成功了，<br>AIO接口会直接返回</li>
<li>BIO、NIO都是同步的，你发起IO请求，都必须同步等待IO操作完成</li>
<li>不过你需要提供一个回调函数给AIO接口，一旦底层系统内核完成了具体<br>的IO请求，比如网络读写之类的，就会回调你提供的回调函数</li>
</ol>
<h3 id="多路复用的那三种方式有什么区别？"><a href="#多路复用的那三种方式有什么区别？" class="headerlink" title="多路复用的那三种方式有什么区别？"></a>多路复用的那三种方式有什么区别？</h3><ol>
<li>select</li>
</ol>
<ul>
<li>select能监控的描述符个数由内核中的FD_SETSIZE限制，仅为1024，这也<br>是select最大的缺点，因为现在的服务器并发量远远不止1024</li>
<li>每次调用select都会线性扫描所有描述符的状态，在select结束后，用户<br>也要线性扫描fd_set数组才知道哪些描述符准备就绪，等于说每次调用复杂<br>度都是O（n）的，在并发量大的情况下，每次扫描都是相当耗时的，很有可<br>能有未处理的连接等待超时</li>
<li>每次调用select都要在用户空间和内核空间里进行内存复制fd描述符等信息</li>
</ul>
<ol start="2">
<li>poll</li>
</ol>
<ul>
<li>poll使用pollfd结构来存储fd，突破了select中描述符数目的限制</li>
<li>与select的后两点类似，poll仍然需要将pollfd数组拷贝到内核空间，之<br>后依次扫描fd的状态，整体复杂度依然是O（n）的，在并发量大的情况下服<br>务器性能会快速下降</li>
</ul>
<ol start="3">
<li>epoll</li>
</ol>
<ul>
<li>epoll维护的描述符数目不受到限制，而且性能不会随着描述符数目的增加<br>而下降</li>
<li>epoll在传递内核与用户空间的消息时使用了内存共享，而不是内存拷贝，<br>这也使得epoll的效率比poll和select更高</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件就是一组有意义的信息集合</p>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><ol>
<li>文件名 同一目录不允许重名</li>
<li>标识符 唯一用来区分文件</li>
<li>类型 文件的类型</li>
<li>位置 文件的存放路径</li>
<li>大小 文件大小</li>
<li>时间 创建时间、上次修改时间</li>
<li>保护信息 对文件进行保护的访问控制信息</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/">https://skysea-gaoming.github.io/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System/">System</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"><i class="fa fa-chevron-left">  </i><span>Linux总结</span></a></div><div class="next-post pull-right"><a href="/2021/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span>操作系统总结1</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/';
  this.page.identifier = '2021/04/27/操作系统2/';
  this.page.title = '操作系统总结2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>