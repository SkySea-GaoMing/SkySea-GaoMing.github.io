<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="操作系统总结2"><meta name="keywords" content="System"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>操作系统总结2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存"><span class="toc-number">1.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是内存"><span class="toc-number">1.1.</span> <span class="toc-text">什么是内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译阶段"><span class="toc-number">1.2.</span> <span class="toc-text">编译阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链接和动态链接的区别"><span class="toc-number">1.3.</span> <span class="toc-text">静态链接和动态链接的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理的作用"><span class="toc-number">1.4.</span> <span class="toc-text">内存管理的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理机制"><span class="toc-number">1.5.</span> <span class="toc-text">内存管理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态分区分配的四种算法"><span class="toc-number">1.6.</span> <span class="toc-text">动态分区分配的四种算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页系统"><span class="toc-number">1.7.</span> <span class="toc-text">分页系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页"><span class="toc-number">1.8.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快表和多级页表"><span class="toc-number">1.9.</span> <span class="toc-text">快表和多级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#快表"><span class="toc-number">1.9.1.</span> <span class="toc-text">快表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑地址和物理地址"><span class="toc-number">1.10.</span> <span class="toc-text">逻辑地址和物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU寻址"><span class="toc-number">1.11.</span> <span class="toc-text">CPU寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有虚拟地址空间"><span class="toc-number">1.12.</span> <span class="toc-text">为什么要有虚拟地址空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存"><span class="toc-number">2.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存-1"><span class="toc-number">2.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址空间"><span class="toc-number">2.2.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页系统地址映射"><span class="toc-number">2.3.</span> <span class="toc-text">分页系统地址映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表"><span class="toc-number">2.4.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加速分页"><span class="toc-number">2.5.</span> <span class="toc-text">加速分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#快表TLB"><span class="toc-number">2.5.1.</span> <span class="toc-text">快表TLB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多级页表"><span class="toc-number">2.5.2.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#倒排页表"><span class="toc-number">2.5.3.</span> <span class="toc-text">倒排页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部性原理"><span class="toc-number">2.6.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟存储器"><span class="toc-number">2.7.</span> <span class="toc-text">虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存技术的实现"><span class="toc-number">2.8.</span> <span class="toc-text">虚拟内存技术的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页面置换算法"><span class="toc-number">2.9.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分段"><span class="toc-number">2.10.</span> <span class="toc-text">分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页和分段的区别"><span class="toc-number">2.11.</span> <span class="toc-text">分页和分段的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统"><span class="toc-number">3.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO模型"><span class="toc-number">4.</span> <span class="toc-text">IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步"><span class="toc-number">4.1.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞和非阻塞"><span class="toc-number">4.2.</span> <span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户空间和内核空间"><span class="toc-number">4.3.</span> <span class="toc-text">用户空间和内核空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的IO-模型"><span class="toc-number">4.4.</span> <span class="toc-text">常见的IO 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式I-O"><span class="toc-number">4.5.</span> <span class="toc-text">阻塞式I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞式I-O"><span class="toc-number">4.6.</span> <span class="toc-text">非阻塞式I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-多路复用"><span class="toc-number">4.7.</span> <span class="toc-text">I&#x2F;O 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件描述符fd"><span class="toc-number">4.7.1.</span> <span class="toc-text">文件描述符fd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">4.7.2.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-number">4.7.3.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-number">4.7.4.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作模式"><span class="toc-number">4.7.5.</span> <span class="toc-text">工作模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号驱动I-O"><span class="toc-number">4.8.</span> <span class="toc-text">信号驱动I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步I-O"><span class="toc-number">4.9.</span> <span class="toc-text">异步I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用场景"><span class="toc-number">4.10.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式I-O和I-O复用的区别"><span class="toc-number">4.11.</span> <span class="toc-text">阻塞式I&#x2F;O和I&#x2F;O复用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存-IO"><span class="toc-number">4.12.</span> <span class="toc-text">缓存 IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步是什么"><span class="toc-number">4.13.</span> <span class="toc-text">异步是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步的异步的区别"><span class="toc-number">4.14.</span> <span class="toc-text">同步的异步的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用的那三种方式的区别"><span class="toc-number">4.15.</span> <span class="toc-text">多路复用的那三种方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#零拷贝"><span class="toc-number">4.16.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内存映射方式I-O"><span class="toc-number">4.16.1.</span> <span class="toc-text">内存映射方式I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#零拷贝概述"><span class="toc-number">4.16.2.</span> <span class="toc-text">零拷贝概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进阶"><span class="toc-number">4.16.3.</span> <span class="toc-text">进阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#零拷贝技术分类"><span class="toc-number">4.16.4.</span> <span class="toc-text">零拷贝技术分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统-1"><span class="toc-number">5.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件属性"><span class="toc-number">5.1.</span> <span class="toc-text">文件属性</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">操作系统总结2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/27/操作系统2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>1</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存"></a>什么是内存</h3><p>内存可存放数据，程序执行前放入内存中才能被CPU 处理。内存地址从0<br>开始，每个地址对应一个存储单元。按字节编址，每个存储单元占1个字<br>节，按字编址每个存储单元占1个字，16位</p>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><ol>
<li>预处理阶段：处理以 # 开头的预处理命令</li>
<li>编译阶段：翻译成汇编文件</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件</li>
<li>链接阶段：将可重定位目标文件和 printf.o</li>
<li>等单独预编译好的目标文件进行合并，得到最终的可执行目标文件</li>
</ol>
<h3 id="静态链接和动态链接的区别"><a href="#静态链接和动态链接的区别" class="headerlink" title="静态链接和动态链接的区别"></a>静态链接和动态链接的区别</h3><ol>
<li>静态链接就是在编译期间，由编译器和连接器将静态库集成到应用程序内<br>，并制作成目标文件以及可以独立运作的可执行文件。静态库一般是一些外<br>部函数与变量的集合</li>
<li>动态链接可以在首次载入的时候执行，也可以在程序开始执行的时候完成<br>。这个是由动态链接器完成，比方标准 C 库(libc.so) 通常就是动态链接<br>的，这样所有的程序可以共享同一个库，而不用分别进行封装</li>
</ol>
<h3 id="内存管理的作用"><a href="#内存管理的作用" class="headerlink" title="内存管理的作用"></a>内存管理的作用</h3><p>操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，<br>free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理<br>地址、内存空间的扩展等功能也是操作系统内存管理做的事情</p>
<h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><p>简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式<br>是指为一个用户程序分配一个连续的内存空间，常见的如块式管理 。同样地<br>非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内<br>存中，常见的如页式管理和段式管理</p>
<ol>
<li>块式管理 ：远古时代的计算机操系统的内存管理方式。将内存分为几个固<br>定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系<br>统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存<br>很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎<br>片</li>
<li>页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相对<br>相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理<br>通过页表对应逻辑地址和物理地址</li>
<li>段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实<br>际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比<br>一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一<br>组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。<br>段式管理通过段表对应逻辑地址和物理地址</li>
</ol>
<h3 id="动态分区分配的四种算法"><a href="#动态分区分配的四种算法" class="headerlink" title="动态分区分配的四种算法"></a>动态分区分配的四种算法</h3><ol>
<li>首次适应算法</li>
<li>最佳适应算法</li>
<li>最坏适应算法</li>
<li>临近适应算法</li>
</ol>
<h3 id="分页系统"><a href="#分页系统" class="headerlink" title="分页系统"></a>分页系统</h3><p>程序产生的地址是虚拟地址，构成了一个地址空间。虚拟地址不是被送到<br>内存总线上而是送到内存管理单元MMU，MMU把虚拟地址映射为物理地址。<br>虚拟空间被划分为若干页面，物理地址中页面对应的空间叫做页框。<br>MMU管理地址空间和物理空间的转换，如果一个页面没有被映射就是缺页<br>中断或缺页错误</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页机制的思想是:通过映射，可以使连续的线性地址与物理地址相关联，<br>逻辑上连续的线性地址对应的物理地址可以不连续。 分页的作用- 将线<br>性地址转换为物理地址 - 用大小相同的页替换大小不同的段</p>
<h3 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h3><p>在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快</li>
<li>解决虚拟地址空间大，页表也会很大的问题</li>
</ol>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引<br>入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特<br>殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容。作为页表<br>的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地<br>址转换，读写内存数据时CPU 要访问两次主存。有了快表，有时只要访问<br>一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。<br>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，<br>同时将页表中的该映射表项添加到快表中</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中<br>的一个页</li>
</ol>
<h3 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h3><p>比如在C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个<br>地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实<br>物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内<br>存单元真正的地址</p>
<h3 id="CPU寻址"><a href="#CPU寻址" class="headerlink" title="CPU寻址"></a>CPU寻址</h3><p>现代处理器使用的是一种称为虚拟寻址的寻址方式。使用虚拟寻址，CPU 需要将<br>虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟<br>地址转换为物理地址转换的硬件是CPU 中含有一个被称为内存管理单元的硬件</p>
<h3 id="为什么要有虚拟地址空间"><a href="#为什么要有虚拟地址空间" class="headerlink" title="为什么要有虚拟地址空间"></a>为什么要有虚拟地址空间</h3><p>没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作<br>系统，造成操作系统崩溃</li>
<li>想要同时运行多个程序特别困难</li>
</ol>
<p>通过虚拟地址访问内存有以下优势</p>
<ol>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物<br>理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保<br>存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一<br>进程或操作系统使用的物理内存</li>
</ol>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存：每个程序有自己的地址空间，把这个空间分割为多块，每一块称为<br>页，每一页都有连续的地址范围，执行时这些页映射到物理内存。但并不是所<br>有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地<br>址空间时，由硬件立刻进行必要的映射，当程序引用到一部分不在物理内存<br>中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失<br>败的指令。虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存<br>，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存<br>运行大程序成为可能</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>引入地址空间的概念就是为了在内存中同时运行多个程序并且互不影响，解决<br>了保护和重定位问题。地址空间是一个进程可以用于寻址内存的一套地址集合<br>。每个进程都有自己的地址空间，并且这个地址空间独立于其他进程的地址空<br>间</p>
<h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h3><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表存储着<br>页（程序地址空间）和页框（物理内存空间）的映射表。默认页和页框都是4<br>KB。一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量，<br>12位的偏移量可以为一个页内的全部4096个字节</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟地址被划分为虚拟页号和偏移量。对于16位地址和4KB的页面来说，高4位<br>可以指定16个虚拟页面中的一页，低12位确定所选页面中的字节偏移量（0到<br>4095）。虚拟页号可以作为页表的索引，以找到虚拟页面对应的页表项，由页<br>表项找到页框号，把页框号拼接到偏移地址的高位形成物理地址。页表的目的<br>就是把虚拟页面映射为页框。页表项的结构如下</p>
<ol>
<li>页框号：该页需要映射到的物理页</li>
<li>在/不在位：如果是1表示该表项有效可以使用，如果是0表示对应的虚拟<br>页面不在内存中，访问该页面会引起一个缺页中断</li>
<li>保护位：一个页运行什么类型的访问，可以使用3位，对应读、写或修改</li>
<li>修改位：重新分配页框时如果该页已经被修改需要写回磁盘，如果没有<br>被修改直接丢弃即可，有时也叫脏位</li>
<li>访问位：不管读还是写该页面被访问时都会设置访问位，不再使用的页<br>面比正在使用的页面更适合淘汰</li>
<li>高速缓存禁止位：禁止该页面被高速缓存，对于那些映射到设备寄存器<br>而不是常规内存的页面而言，比如操作系统等待IO设备对它刚发出的命令<br>做出响应，保证硬件是不断从设备总读取数据而不是访问旧的被高速缓存<br>的副本时使用</li>
</ol>
<h3 id="加速分页"><a href="#加速分页" class="headerlink" title="加速分页"></a>加速分页</h3><p>加速分页需要解决两个问题</p>
<ol>
<li>虚拟地址到物理地址的映射必须非常快，使用快表解决</li>
<li>如果虚拟地址空间很大，页表也会很大，使用多级页表或倒排页表解决</li>
</ol>
<h4 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h4><p>为了加快虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引<br>入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特<br>殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容。作为页表<br>的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地<br>址转换，读写内存数据时CPU 要访问两次主存。有了快表，有时只要访问<br>一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。<br>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，<br>同时将页表中的该映射表项添加到快表中。软失效是页不在TLB在内存中，<br>硬失效是页不在内存在磁盘中</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中<br>的一个表项</li>
</ol>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>引入多级页表是避免把全部页表一直保存在内存中，通过一个顶级页表为真<br>正有用的页表提供索引，对于没有用到的页表就没有保存在内存中，比如页<br>有上百万个，顶级页表有1024个表项，每个表项表示一个4M的地址范围，<br>每级页表负责若干位的地址转换，这里只需要保存3个二级页表，顶级页<br>表中其余表项都被设置为0，当访问它们时强制产生一个缺页中断</p>
<h4 id="倒排页表"><a href="#倒排页表" class="headerlink" title="倒排页表"></a>倒排页表</h4><p>每个页框对应一个表项，而不是每个虚拟页面对应一个表项，在这种方法中<br>，虚拟地址的页号部分使用一个简单的散列函数映射到散列表中。散列表包<br>含一个指向倒排表的指针，而倒排表中含有页表项。表项记录哪一个（进程<br>，虚拟页面）对定位于该页框，这样可以节省大量空间，但是从虚拟地址<br>到物理地址的转换会非常困难，当进程n访问虚拟页面p时，硬件不再能通<br>过把p当作指向页表的一个索引来查找物理页框。取而代之的是，它必须搜<br>索整个倒排页表来查找某一个表项（n，p）。此外该搜索必须对每一个内<br>存访问操作都要执行一次，而不仅仅是在发生缺页中断时执行。<br>一种解决方法是使用TLB。如果TLB能够记录所有频繁使用的页面，地址转换<br>就可能变得像通常的页表一样快。但是，当发生TLB 失效时，需要用软件搜<br>索整个倒排页表。一个可行的实现该搜索的方法是建立一张散列表，用虚拟<br>地址来散列。当前所有在内存中的具有相同散列值的虚拟页面被链接在一起<br>，如果散列表中的槽数与机器中物理页面数一样多，那么散列表的冲突链<br>的平均长度将会是1个表项，这将会大大提高映射速度。一旦页框号被找<br>到，新的（虚拟页号，物理页框号）对就会被装载到TLB中</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol>
<li>时间上的局部性：最近被访问的页在不久的将来还会被访问</li>
<li>空间上的局部性：内存中被访问的页周围的页也很可能被访问</li>
<li>高速缓存技术：频繁使用的数据放到更高速的缓存器中</li>
</ol>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>虚拟存储器又叫做虚拟内存，属于同一个概念。<br>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部<br>分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运<br>行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序<br>执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入<br>内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容<br>换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为<br>用户提供了一个比实际内存大的多的存储器——虚拟存储器</p>
<h3 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h3><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的<br>实现有以下三种方式</p>
<ol>
<li>请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而<br>增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚<br>拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入<br>当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面<br>不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页<br>面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中</li>
<li>请求分段存储管理 ：建立在分段存储管理之上，增加了请求调段功能、分<br>段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作<br>业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可<br>使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满<br>，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而<br>装入新的段</li>
<li>请求段页式存储管理</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在发送缺页中断时，需要选择一个页面，将其换出内存，如果每次都选择<br>不常使用的页面会提升系统性能，如果一个频繁使用的页面被置换出去会<br>带来不必要的开销，此时如果内存已无空闲空间，系统必须从内存中调出<br>一个页面到磁盘对换区中来腾出空间</p>
<ol>
<li>最佳置换算法OPT 所选择的被换出的页面将是最长时间内不再被访问，<br>通常可以保证获得最低的缺页率，是一种理论上的算法，因为无法知道一个<br>页面多长时间不再被访问</li>
<li>先进先出置换算法FIFO 选择换出的页面是最先进入的页面。该算法会<br>将那些经常被访问的页面换出，导致缺页率升高</li>
<li>最近最久未使用置换算法LRU 需要在内存中维护一个所有页面的链表。<br>当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾<br>的页面是最近最久未访问的</li>
<li>最近未使用NRU 每个页面都有两个状态位：R 与M，当页面被访问时设置<br>页面的R=1，当页面被修改时设置 M=1。其中R 位会定时被清零。优先换出被<br>修改并且没有再被访问的页面</li>
<li>第二次机会置换算法 FIFO算法可能会把经常使用的页面置换出去，为了<br>避免这一问题，对该算法做一个简单的修改：当页面被访问（读或写）时设<br>置该页面的R 位为1。需要替换的时候，检查最老页面的R 位。如果R 位是0<br>，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R 位<br>清0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一<br>样，然后继续从链表的头部开始搜索</li>
<li>时钟置换算法CLOCK 第二次机会算法需要在链表中移动页面，降低了效<br>率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页<br>面。当发生缺页中断时首先检查表针指向的页面，如果R 位是0就淘汰该页<br>面，将新页面插入这个位置，然后将表针前移一个位置，如果R为是1就清<br>除并继续前移，直到找到R位为0的页面</li>
</ol>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一<br>页再与内存进行映射。分段的做法是把每个表分成段，一个段构成一个独立<br>的地址空间。每个段的长度可以不同，并且可以动态增长。分段情况一个地<br>址分为两部分，一个段号和一个段内地址。段是一个逻辑实体，会产生外<br>部碎片</p>
<h3 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h3><p>相同点</p>
<ol>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页<br>和段中的内存是连续的</li>
</ol>
<p>不同点</p>
<ol>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 </li>
<li>页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间，将用户程序地址空<br>间分为若干固定大小的区域</li>
<li>分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助<br>于共享和保护</li>
<li>段的大小不固定，由它所完成的功能决定，页大大小固定，由系统决定</li>
<li>分段是二维的，如代码段，数据段，堆栈段，这样每个进程有一个二维地址<br>空间，相互独立，互不干扰</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>当应用程序发起I/O 调用后，会经历两个步骤：</p>
<ol>
<li>内核等待I/O 将数据加载到内核缓存</li>
<li>内核将数据从内核空间拷贝到用户空间</li>
</ol>
<p>同步和异步，阻塞和非阻塞</p>
<ol>
<li>同步和异步的概念描述的是用户线程与内核的交互方式</li>
<li>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式</li>
</ol>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ol>
<li>同步<br>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li>
<li>异步<br>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就<br>可以继续后续的操作。而异步方法通常会在另外一个线程中，“真实”地执行着。<br>整个过程，不会阻碍调用者的工作。被调用者通过状态来通知调用者，或者通过<br>回调函数来处理这个调用</li>
</ol>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>强调的是程序在等待调用结果（消息，返回值）时的状态.  阻塞调用是指调用<br>结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非<br>阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 对于同步调<br>用来说，很多时候当前线程还是激活的状态，只是从逻辑上当前函数没有返回<br>而已，即同步等待时什么都不干，白白占用着资源。</p>
<h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>我们知道现在操作系统都是采用虚拟存储器，那么对32 位操作系统而言，它<br>的寻址空间（虚拟存储空间）为4G（2的32次方）。操心系统的核心是内核，<br>独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设<br>备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操<br>心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。<br>将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，<br>称为内核空间，将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）<br>，供各个进程使用，称为用户空间。每个进程可以通过系统调用进入内核，<br>因此Linux内核由系统内的所有进程共享。于是从具体进程的角度来看，每<br>个进程可以拥有4G字节的虚拟空间。<br>有了用户空间和内核空间，整个linux内部结构可以分为三部分，从最底层<br>到最上层依次是：硬件–&gt;内核空间–&gt;用户空间。</p>
<ol>
<li>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用<br>户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间<br>中。用户态其所处于占有的处理器是可被抢占的，内核态所占有的处理器是<br>不允许被抢占的</li>
<li>Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。</li>
</ol>
<h3 id="常见的IO-模型"><a href="#常见的IO-模型" class="headerlink" title="常见的IO 模型"></a>常见的IO 模型</h3><p>为了 OS 的安全性等的考虑，进程是无法直接操作 I/O 设备的，其必须通过系<br>统调用请求内核来协助完成I/O动作，而内核会为每个I/O设备维护一个buffer。<br>整个请求过程为： 用户进程发起请求，内核接受到请求后，从I/O设备中获取数<br>据到buffer中，再将buffer中的数据copy到用户进程的地址空间，该用户进程<br>获取到数据后再响应客户端。<br>在整个请求过程中，数据输入至buffer需要时间，而从buffer复制数据至进程<br>也需要时间。因此根据在这两段时间内等待方式的不同，I/O动作可以分为以下<br>五种模式：</p>
<ol>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ol>
<p>IO 多路复用模型，通过减少无效的系统调用，减少了对CPU 资源的消耗。Java中<br>的NIO，有一个非常重要的选择器 (Selector) 的概念，也可以被称为多路复用<br>器。通过它只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，<br>才会为其服务，如果有一个文件描述符就绪，则返回，否则阻塞直到超时</p>
<h3 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h3><p>当用户进程调用了recvfrom这个系统调用，内核就开始了IO的第一个阶段：<br>等待数据准备。对于network io 来说，很多时候数据在一开始还没有到达<br>（比如，还没有收到一个完整的UDP包），这个时候内核就要等待足够的数<br>据到来。而在用户进程这边，整个进程会被阻塞。当内核一直等到数据准备<br>好了，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户<br>进程才解除block的状态，重新运行起来。所以blocking IO 的特点就是<br>在IO执行的两个阶段都被block了。<br>在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系<br>统都被阻塞</p>
<h3 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h3><p>当用户进程调用recvfrom 时，系统不会阻塞用户进程，而是立刻返回一个<br>ewouldblock错误，从用户进程角度讲 ，并不需要等待，而是马上就得到<br>了一个结果。用户进程判断标志是ewouldblock时，就知道数据还没准备好<br>，于是它就可以去做其他的事了，于是它可以再次发送recvfrom，一旦内<br>核中的数据准备好了。并且又再次收到了用户进程的system call，那么<br>它马上就将数据拷贝到了用户内存，然后返回。<br>当一个应用程序在一个循环里对一个非阻塞调用recvfrom，我们称为轮询。<br>应用程序不断轮询内核，看看是否已经准备好了某些操作。这通常是浪费<br>CPU时间，但这种模式偶尔会遇到。</p>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大<br>概就都能明白了。有些地方也称这种IO 方式为event driven IO。我们都知<br>道，select/epoll的好处就在于单个process 就可以同时处理多个网络连<br>接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负<br>责的所有socket，当某个socket有数据到达了，就通知用户进程。<br>当用户进程调用了select，那么整个进程会被block，而同时内核会“监视”<br>所有select负责的socket，当任何一个socket中的数据准备好了，select<br>就会返回。这时候用户进程再调用read操作，将数据从内核拷贝到用户进程。<br>这个图和blocking IO 的图其实并没有太大的不同，事实上，还更差一些。<br>因为这里需要使用两个system call (select和recvfrom)，而blocking<br>IO只调用了一个system call (recvfrom)。但是用select的优势在于它可<br>以同时处理多个connection。（多说一句。所以如果处理的连接数不是很高<br>的话，使用select/epoll的web server不一定比使用multi-threading<br>+blocking IO的web server性能更好，可能延迟还更大。select/epoll<br>的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>在IO multiplexing Model中，实际中对于每一个socket，一般都设置成<br>为non-blocking，但是，如上图所示，整个用户的process其实是一直被<br>block的。只不过process是被select这个函数block，而不是被socket<br>IO给block。<br>recvfrom一般用于UDP协议中，但是如果在TCP中connect函数调用后也可以<br>用。用于从（已连接）套接口上接收数据，并捕获数据发送源的地址。<br>I/O就是指的我们网络I/O，多路指多个TCP连接(或多个Channel)，复用指复<br>用一个或少量线程。串起来理解就是很多个网络I/O复用一个或少量的线程来<br>处理这些连接。发明它的目的是尽量多的提高服务器的吞吐能力。实现一个线<br>程监控多个IO请求，哪个IO有请求就把数据从内核拷贝到进程缓冲区，拷贝<br>期间是阻塞的。</p>
<h4 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h4><p>Linux的内核将所有外部设备都可以看做一个文件来操作。那么我们对与外<br>部设备的操作都可以看做对文件进行操作。我们对一个文件的读写，都通过<br>调用内核提供的系统调用；内核给我们返回一个fd 文件描述符。而对一个<br>socket的读写也会有相应的描述符，称为socketfd(socket描述符）。描<br>述符就是一个数字，指向内核中一个结构体（文件路径，数据区，等一些<br>属性）。那么我们的应用程序对文件的读写就通过对描述符的读写完成。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>基本原理：select函数监视的文件描述符分3类，分别是writefds、readfds<br>、和exceptfds。调用后select 函数会阻塞，直到有描述符就绪（有数据 可<br>读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返<br>回设为null即可），函数返回。成功调用返回结果大于0，出错返回结果为-1<br>，超时返回结果为0。当select函数返回后，可以通过遍历fdset，来找到就<br>绪的描述符。缺点如下</p>
<ol>
<li>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FDSETSIZE<br>设置，32位机默认是1024个，64位机默认是2048。一般来说这个数目和系统内存<br>关系很大，”具体数目可以cat /proc/sys/fs/file-max察看”。32位机默认是<br>1024个。64位机默认是2048</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。当套接<br>字比较多的时候，每次select()都要通过遍历FDSETSIZE个Socket来完成调<br>度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。”如果<br>能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避<br>免了轮询”，这正是epoll与kqueue做的。</li>
<li>需要维护一个用来存放大量fd的数组，这样会使得用户空间和内核空间在<br>传递该结构时复制开销大。</li>
<li>select 会修改描述符，而 poll 不会</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>基本原理：poll本质上和select没有区别，它将用户传入的数组拷贝到内核<br>空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中<br>加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前<br>进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程<br>经历了多次无谓的遍历。<br>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个<br>缺点：</p>
<ol>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这<br>样的复制是不是有意义。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么<br>下次poll时会再次报告该fd。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭<br>了该描述符，会导致调用结果不确定</li>
</ol>
<p>注意：从上面看，select和poll都需要在返回后，通过遍历文件描述符来获<br>取已经就绪的socket。事实上同时连接的大量客户端在一时刻可能只有很少<br>的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于<br>select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文<br>件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的<br>一个事件表中，这样在用户空间和内核空间的copy只需一次。<br>基本原理：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它<br>只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，<br>epoll使用“事件”的就绪通知方式，通过epollctl注册fd，一旦该fd就绪<br>，内核就会采用类似callback的回调机制来激活该fd，epollwait便可以<br>收到通知。<br>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态<br>。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将<br>I/O 准备好的描述符加入到一个链表中管理，进程调用epoll_wait() 便可<br>以得到事件完成的描述符。<br>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区<br>拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。<br>epoll的优点：</p>
<ol>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上<br>能监听约10万个端口）</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。</li>
<li>只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于<br>它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<br>Epoll的效率就会远远高于select和poll。</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll<br>使用mmap减少复制开销</li>
<li>epoll 是线程安全的，不仅告诉你sock组里面数据，还会告诉你具体哪<br>个sock有数据，你不用自己去找了。一个线程调用了epoll_wait() 另一个<br>线程关闭了同一个描述符也不会产生像select 和 poll 的不确定情况</li>
</ol>
<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和ET（edge<br>trigger）</p>
<ol>
<li>LT 模式<br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以<br>不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一<br>种模式，并且同时支持 Blocking 和 No-Blocking。</li>
<li>ET 模式<br>和LT模式不同的是通知之后进程必须立即处理事件，下次再调用epoll_wait()<br>时不会再得到事件到达的通知。<br>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。<br>只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理<br>多个文件描述符的任务饿死</li>
</ol>
<h3 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续<br>执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向<br>应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用<br>recvfrom 将数据从内核复制到应用进程中</p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>一般来说，这些函数通过告诉内核启动操作并在整个操作（包括内核的数<br>据到缓冲区的副本）完成时通知我们。这个模型和前面的信号驱动 I/O模<br>型的主要区别是，在信号驱动的I/O中，内核告诉我们何时可以启动I/O<br>操作，但是异步I/O时，内核告诉我们何时I/O操作完成。<br>当用户进程向内核发起某个操作后，会立刻得到返回，并把所有的任务都<br>交给内核去完成（包括将数据从内核拷贝到用户自己的缓冲区），内核完<br>成之后，只需返回一个信号告诉用户进程已经完成就可以了。<br>异步一定是非阻塞的。应用无需等待数据和复制数据到指定内存中，全都是<br>由后台完成，然后通过回调函数告诉应用。只有用户线程在操作IO的时候根<br>本不去考虑IO的执行全部都交给CPU去完成，而自己只等待一个完成信号的<br>时候，才是真正的异步IO</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>select 应用场景<br>select 的timeout 参数精度为微秒，而poll 和epoll 为毫秒，因此select<br>更加适用于实时性要求比较高的场景，比如核反应堆的控制。select 可移植性<br>更好，几乎被所有主流平台所支持</li>
<li>poll 应用场景<br>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该<br>使用 poll 而不是 select</li>
<li>epoll 应用场景<br>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最<br>好是长连接。需要同时监控小于1000 个描述符，就没有必要使用 epoll，因为<br>这个应用场景下并不能体现 epoll 的优势。<br>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。<br>因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改<br>变都需要通过epoll_ctl()进行系统调用，频繁系统调用降低效率。并且epoll<br>的描述符存储在内核，不容易调试</li>
</ol>
<h3 id="阻塞式I-O和I-O复用的区别"><a href="#阻塞式I-O和I-O复用的区别" class="headerlink" title="阻塞式I/O和I/O复用的区别"></a>阻塞式I/O和I/O复用的区别</h3><ol>
<li>阻塞式I/O和I/O复用，两个阶段都阻塞，等待数据和将数据复制到用户进<br>程这两个阶段都是阻塞的</li>
<li>虽然第一阶段都是阻塞，但是阻塞式I/O如果要接收更多的连接，就必须创<br>建更多的线程。I/O复用模式下在第一个阶段大量的连接统统都可以过来直接注<br>册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连<br>接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。<br>这就是I/O复用与传统的阻塞式I/O最大的不同</li>
</ol>
<h3 id="缓存-IO"><a href="#缓存-IO" class="headerlink" title="缓存 IO"></a>缓存 IO</h3><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。<br>在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的<br>页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核<br>的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。<br>缓存 IO 的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多<br>次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p>
<h3 id="异步是什么"><a href="#异步是什么" class="headerlink" title="异步是什么"></a>异步是什么</h3><p>对于异步来说，用户进行读或者写后，将立刻返回，由内核去完成数据读取<br>以及拷贝工作，完成后通知用户，并执行回调函数（用户提供的callback<br>），此时数据已从内核拷贝到用户空间，用户线程只需要对数据进行处理<br>即可，不需要关注读写，用户不需要等待内核对数据的复制操作，用户在<br>得到通知时数据已经被复制到用户空间</p>
<h3 id="同步的异步的区别"><a href="#同步的异步的区别" class="headerlink" title="同步的异步的区别"></a>同步的异步的区别</h3><ol>
<li>同步跟异步的区别在于数据从内核空间拷贝到用户空间是否由用户线程<br>完成，这里又分为同步阻塞跟同步非阻塞两种</li>
<li>同步阻塞 此时一个线程维护一个连接，该线程完成数据到读写跟处理<br>到全部过程，数据读写时时线程是被阻塞的</li>
<li>同步非阻塞 非阻塞的意思是用户线程发出读请求后，读请求不会阻塞<br>当前用户线程，不过用户线程还是要不断的去主动判断数据是否准备OK了<br>。此时还是会阻塞等待内核复制数据到用户进程。他与同步BIO区别是使用<br>一个连接全程等待</li>
<li>同步在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一<br>旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用<br>的结果</li>
<li>异步调用在发出之后，这个调用就直接返回了，所以没有返回结果。换<br>句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<br>调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处<br>理这个调用</li>
</ol>
<h3 id="多路复用的那三种方式的区别"><a href="#多路复用的那三种方式的区别" class="headerlink" title="多路复用的那三种方式的区别"></a>多路复用的那三种方式的区别</h3><ol>
<li>select</li>
</ol>
<ul>
<li>select能监控的描述符个数由内核中的FD_SETSIZE限制，仅为1024，这也<br>是select最大的缺点，因为现在的服务器并发量远远不止1024</li>
<li>每次调用select都会线性扫描所有描述符的状态，在select结束后，用户<br>也要线性扫描fd_set数组才知道哪些描述符准备就绪，等于说每次调用复杂<br>度都是O（n）的，在并发量大的情况下，每次扫描都是相当耗时的，很有可<br>能有未处理的连接等待超时</li>
<li>每次调用select都要在用户空间和内核空间里进行内存复制fd描述符等信息</li>
</ul>
<ol start="2">
<li>poll</li>
</ol>
<ul>
<li>poll使用pollfd结构来存储fd，突破了select中描述符数目的限制</li>
<li>与select的后两点类似，poll仍然需要将pollfd数组拷贝到内核空间，之<br>后依次扫描fd的状态，整体复杂度依然是O（n）的，在并发量大的情况下服<br>务器性能会快速下降</li>
</ul>
<ol start="3">
<li>epoll</li>
</ol>
<ul>
<li>epoll维护的描述符数目不受到限制，而且性能不会随着描述符数目的增加<br>而下降</li>
<li>epoll在传递内核与用户空间的消息时使用了内存共享，而不是内存拷贝，<br>这也使得epoll的效率比poll和select更高</li>
</ul>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>考虑这样一种常用的情形：你需要将静态内容（类似图片、文件）展示给用户。<br>那么这个情形就意味着你需要先将静态内容从磁盘拷贝出来放到一个内存buf<br>中，然后将这个buf通过socket传输给用户，进而用户或者静态内容的展示。<br>这看起来再正常不过了，但是实际上这是很低效的流程，我们把上面的这种<br>情形抽象成下面的过程：</p>
<ol>
<li>read(file, tmp_buf, len);</li>
<li>write(socket, tmp_buf, len);</li>
</ol>
<p>在这个过程中文件A的经历了4次copy的过程：</p>
<ol>
<li>首先，调用read时，文件A拷贝到了kernel模式；DMA过程中CPU不需要参<br>与数据的读写，而是DMA处理器直接将硬盘数据通过总线传输到内存中</li>
<li>之后，CPU控制将kernel模式数据copy到user模式下；</li>
<li>调用write时，先将user模式下的内容copy到kernel模式下的socket的<br>buffer中；</li>
<li>最后将kernel模式下的socket buffer的数据copy到网卡设备中传送；</li>
</ol>
<p>从上面的过程可以看出，数据白白从kernel模式到user模式走了一圈，浪费<br>了2次copy(第一次，从kernel模式拷贝到user模式；第二次从user模式再<br>拷贝回kernel模式，即上面4次过程的第2和3步骤。)。<br>而且上面的过程中kernel和user模式的上下文的切换也是4次。<br>你可以用一种叫做Zero-Copy的技术来去掉这些无谓的copy。应用程序用零拷<br>贝来请求kernel 直接把disk的data传输给socket，而不是通过应用程序传<br>输。Zero-Copy大大提高了应用程序的性能，并且减少了kernel和user模式<br>上下文的切换。<br>“零拷贝”是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗<br>资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用<br>户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络<br>的方式。这里的零拷贝其实是根据内核状态划分的，在这里没有经过CPU的拷<br>贝，数据在用户态的状态下，经历了零次拷贝，所以才叫做零拷贝，但不是<br>说不拷贝。</p>
<h4 id="内存映射方式I-O"><a href="#内存映射方式I-O" class="headerlink" title="内存映射方式I/O"></a>内存映射方式I/O</h4><p>mmap 是使用的系统调用方法，这种方式的I/O原理就是将用户缓冲区（user<br>buffer）的内存地址和内核缓冲区（kernel buffer）的内存地址做一个映<br>射，也就是说系统在用户态可以直接读取并操作内核空间的数据。</p>
<ol>
<li>mmap()系统调用首先会使用DMA的方式将磁盘数据读取到内核缓冲区，然后<br>通过内存映射的方式，使用户缓冲区和内核读缓冲区的内存地址为同一内存地<br>址，也就是说不需要CPU再将数据从内核读缓冲区复制到用户缓冲区。</li>
<li>当使用write()系统调用的时候，cpu将内核缓冲区（等同于用户缓冲区）<br>的数据直接写入到网络发送缓冲区（socket buffer），然后通过DMA的方式<br>将数据传入到网卡驱动程序中准备发送。</li>
</ol>
<p>可以看到这种内存映射的方式减少了CPU的读写次数，但是用户态到内核态的切<br>换（上下文切换）依旧有四次，同时需要注意在进行这种内存映射的时候，有<br>可能会出现并发线程操作同一块内存区域而导致的严重的数据不一致问题，所<br>以需要进行合理的并发编程来解决这些问题。</p>
<h4 id="零拷贝概述"><a href="#零拷贝概述" class="headerlink" title="零拷贝概述"></a>零拷贝概述</h4><p>Zero-Copy技术省去了将操作系统的read buffer拷贝到程序的buffer，以及<br>从程序buffer 拷贝到socket buffer 的步骤，直接将read buffer 拷贝到<br>socket buffer. Java NIO中的FileChannal.transferTo()方法就是这样<br>的实现，这个实现是依赖于操作系统底层的sendFile()实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void transferTo(long position, long count, WritableByteChannel target);</span><br><span class="line">他底层的调用时系统调用sendFile()方法：</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure>

<p>使用了Zero-Copy技术之后，整个过程如下</p>
<ol>
<li>transferTo()方法使得文件A的内容直接拷贝到一个read buffer（kernel<br>buffer）中；</li>
<li>然后数据(kernel buffer)拷贝到socket buffer中。</li>
<li>最后将socket buffer中的数据拷贝到网卡设备（protocol engine）中传<br>输；这显然是一个伟大的进步：这里把上下文的切换次数从4次减少到2次，同时<br>也把数据copy的次数从4次降低到了3次。</li>
</ol>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>Linux 2.1内核开始引入了sendfile函数，用于将文件通过socket传送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendfile(socket, file, len);</span><br></pre></td></tr></table></figure>
<p>该函数通过一次系统调用完成了文件的传送，减少了原来read/write方式的模<br>式切换。此外更是减少了数据的copy，通过sendfile传送文件只需要一次系统<br>调用，当调用sendfile时</p>
<ol>
<li>首先（通过DMA）将数据从磁盘读取到kernel buffer中；</li>
<li>然后将kernel buffer拷贝到socket buffer中；</li>
<li>最后将socket buffer中的数据copy到网卡设备中发送</li>
</ol>
<p>sendfile与read/write模式相比，少了一次copy。但是从上述过程中也可以发<br>现从kernel buffer中将数据copy到socket buffer是没有必要的。Linux2.4<br>内核对sendfile做了改进</p>
<ol>
<li>将文件拷贝到kernel buffer中；</li>
<li>向socket buffer中追加当前要发生的数据在kernel buffer中的位置和<br>偏移量；</li>
<li>根据socket buffer中的位置和偏移量直接将kernel buffer的数据copy<br>到网卡设备中；</li>
</ol>
<p>经过上述过程，数据只经过了2次copy就从磁盘传送出去了。这个才是真正的<br>Zero-Copy(这里的零拷贝是针对kernel 来讲的，数据在kernel 模式下是<br>Zero-Copy)。正是Linux2.4的内核做了改进，Java中的TransferTo()实现<br>了Zero-Copy，在这种模式下，是没有一次CPU进行数据拷贝的</p>
<h4 id="零拷贝技术分类"><a href="#零拷贝技术分类" class="headerlink" title="零拷贝技术分类"></a>零拷贝技术分类</h4><p>Linux 中的零拷贝技术主要有下面这几种：</p>
<ol>
<li>直接 I/O：对于这种数据传输方式来说，应用程序可以直接访问硬件存储<br>，操作系统内核只是辅助数据传输：这类零拷贝技术针对的是操作系统内核并<br>不需要对数据进行直接处理的情况，数据可以在应用程序地址空间的缓冲区和<br>磁盘之间直接进行传输，完全不需要Linux操作系统内核提供的页缓存的支持。</li>
<li>在数据传输的过程中，避免数据在操作系统内核地址空间的缓冲区和用户<br>应用程序地址空间的缓冲区之间进行拷贝。有的时候，应用程序在数据进行传<br>输的过程中不需要对数据进行访问，那么将数据从 Linux 的页缓存拷贝到用<br>户进程的缓冲区中就可以完全避免，传输的数据在页缓存中就可以得到处理。<br>在某些特殊的情况下，这种零拷贝技术可以获得较好的性能。Linux中提供类<br>似的系统调用主要有 mmap()，sendfile() 以及 splice()。</li>
<li>对数据在 Linux 的页缓存和用户进程的缓冲区之间的传输过程进行优化。<br>该零拷贝技术侧重于灵活地处理数据在用户进程的缓冲区和操作系统的页缓存<br>之间的拷贝操作。这种方法延续了传统的通信方式，但是更加灵活。在Linux中<br>，该方法主要利用了写时复制技术。</li>
</ol>
<h2 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件就是一组有意义的信息集合</p>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><ol>
<li>文件名 同一目录不允许重名</li>
<li>标识符 唯一用来区分文件</li>
<li>类型 文件的类型</li>
<li>位置 文件的存放路径</li>
<li>大小 文件大小</li>
<li>时间 创建时间、上次修改时间</li>
<li>保护信息 对文件进行保护的访问控制信息</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/">https://skysea-gaoming.github.io/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/System/">System</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"><i class="fa fa-chevron-left">  </i><span>Linux总结</span></a></div><div class="next-post pull-right"><a href="/2021/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span>操作系统总结1</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/';
  this.page.identifier = '2021/04/27/操作系统2/';
  this.page.title = '操作系统总结2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>