<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spring2"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Spring2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器"><span class="toc-number">2.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#快速导入一个组件"><span class="toc-number">2.1.</span> <span class="toc-text">快速导入一个组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Import注解概述"><span class="toc-number">2.1.1.</span> <span class="toc-text">@Import注解概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Import注解的使用方式"><span class="toc-number">2.1.2.</span> <span class="toc-text">@Import注解的使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImportSelector"><span class="toc-number">2.1.3.</span> <span class="toc-text">ImportSelector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ImportBeanDefinitionRegistrar"><span class="toc-number">2.1.4.</span> <span class="toc-text">ImportBeanDefinitionRegistrar</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FactoryBean注册组件"><span class="toc-number">2.2.</span> <span class="toc-text">FactoryBean注册组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FactoryBean案例"><span class="toc-number">2.2.1.</span> <span class="toc-text">FactoryBean案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取到FactoryBean对象本身"><span class="toc-number">2.2.2.</span> <span class="toc-text">获取到FactoryBean对象本身</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean注解指定初始化和销毁的方法"><span class="toc-number">2.3.</span> <span class="toc-text">@Bean注解指定初始化和销毁的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bean的生命周期"><span class="toc-number">2.3.1.</span> <span class="toc-text">bean的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义初始化和销毁方法"><span class="toc-number">2.3.2.</span> <span class="toc-text">定义初始化和销毁方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化和销毁方法的使用场景"><span class="toc-number">2.3.3.</span> <span class="toc-text">初始化和销毁方法的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化和销毁方法调用的时机"><span class="toc-number">2.3.4.</span> <span class="toc-text">初始化和销毁方法调用的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多实例Bean"><span class="toc-number">2.3.5.</span> <span class="toc-text">多实例Bean</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管理bean的生命周期"><span class="toc-number">2.4.</span> <span class="toc-text">管理bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#何时调用InitializingBean接口"><span class="toc-number">2.4.1.</span> <span class="toc-text">何时调用InitializingBean接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DisposableBean接口"><span class="toc-number">2.5.</span> <span class="toc-text">DisposableBean接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DisposableBean接口注意事项"><span class="toc-number">2.5.1.</span> <span class="toc-text">DisposableBean接口注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单实例bean"><span class="toc-number">2.5.2.</span> <span class="toc-text">单实例bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多实例bean"><span class="toc-number">2.5.3.</span> <span class="toc-text">多实例bean</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PostConstruct注解和-PreDestroy注解"><span class="toc-number">2.6.</span> <span class="toc-text">@PostConstruct注解和@PreDestroy注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PostConstruct注解"><span class="toc-number">2.6.1.</span> <span class="toc-text">@PostConstruct注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PreDestroy注解"><span class="toc-number">2.6.2.</span> <span class="toc-text">@PreDestroy注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanPostProcessor后置处理器"><span class="toc-number">2.7.</span> <span class="toc-text">BeanPostProcessor后置处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#后置处理器实例"><span class="toc-number">2.7.1.</span> <span class="toc-text">后置处理器实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后置处理器作用"><span class="toc-number">2.7.2.</span> <span class="toc-text">后置处理器作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanPostProcessor的执行流程"><span class="toc-number">2.8.</span> <span class="toc-text">BeanPostProcessor的执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bean的初始化和销毁"><span class="toc-number">2.8.1.</span> <span class="toc-text">bean的初始化和销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanPostProcessor源码解析"><span class="toc-number">2.8.2.</span> <span class="toc-text">BeanPostProcessor源码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanPostProcessor底层使用"><span class="toc-number">2.9.</span> <span class="toc-text">BeanPostProcessor底层使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationContextAwareProcessor类"><span class="toc-number">2.9.1.</span> <span class="toc-text">ApplicationContextAwareProcessor类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanValidationPostProcessor类"><span class="toc-number">2.9.2.</span> <span class="toc-text">BeanValidationPostProcessor类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InitDestroyAnnotationBeanPostProcessor类"><span class="toc-number">2.9.3.</span> <span class="toc-text">InitDestroyAnnotationBeanPostProcessor类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AutowiredAnnotationBeanPostProcessor类"><span class="toc-number">2.9.4.</span> <span class="toc-text">AutowiredAnnotationBeanPostProcessor类</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Spring2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/17/Spring2/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/17/Spring2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>B站颜群老师Spring教程，B站雷丰阳老师Spring教程，《Spring实战》<br><a href="https://zhuanlan.zhihu.com/p/137507309" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/137507309</a><br><a href="https://liayun.blog.csdn.net/article/details/115053350" target="_blank" rel="noopener">https://liayun.blog.csdn.net/article/details/115053350</a></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="快速导入一个组件"><a href="#快速导入一个组件" class="headerlink" title="快速导入一个组件"></a>快速导入一个组件</h3><p>Spring 3.0之前，创建bean 可以通过XML 配置文件与扫描特定包下面的类<br>来将类注入到Spring IOC容器内。而在Spring 3.0之后提供了JavaConfig<br>的方式，也就是将IOC容器里面bean的元信息以Java代码的方式进行描述，<br>然后我们可以通过@Configuration与@Bean这两个注解配合使用来将原来<br>配置在XML文件里面的bean通过Java代码的方式进行描述</p>
<ol>
<li>包扫描+给组件标注注解（@Controller、@Servcie、@Repository、<br>@Component），但这种方式比较有局限性，局限于我们自己写的类</li>
<li>@Bean注解，通常用于导入第三方包中的组件</li>
<li>@Import注解，快速向Spring容器中导入一个组件</li>
</ol>
<h4 id="Import注解概述"><a href="#Import注解概述" class="headerlink" title="@Import注解概述"></a>@Import注解概述</h4><p>@Import注解提供了@Bean 注解的功能，同时还有XML配置文件里面标签组织<br>多个分散的XML文件的功能，当然在这里是组织多个分散的@Configuration<br>，因为一个配置类就约等于一个XML配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Import可以配合Configuration、ImportSelector以及ImportBeanDefinitionRegistrar使用</span></span><br><span class="line"><span class="comment">//也可以把Import当成普通的bean来使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：@Import注解只允许放到类上面，不允许放到方法上</p>
<h4 id="Import注解的使用方式"><a href="#Import注解的使用方式" class="headerlink" title="@Import注解的使用方式"></a>@Import注解的使用方式</h4><p>@Import注解的三种用法主要包括：</p>
<ol>
<li>直接填写class数组的方式</li>
<li>ImportSelector接口的方式，即批量导入，这是重点</li>
<li>ImportBeanDefinitionRegistrar接口方式，即手工注册bean到容器中</li>
</ol>
<p>首先来看第一种方式，创建一个Color类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MainConfig2配置类上添加一个@Import注解，并将Color类填写到该注解中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对配置类中的组件进行统一设置</span></span><br><span class="line"><span class="comment">// 满足当前条件，这个类中配置的所有bean注册才能生效</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;WindowsCondition<span class="class">.<span class="keyword">class</span>&#125;) </span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(<span class="title">Color</span>.<span class="title">class</span>) // @<span class="title">Import</span>快速地导入组件，<span class="title">id</span>默认是组件的全类名</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Import注解还支持同时导入多个类，比如又创建一个Red类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Color<span class="class">.<span class="keyword">class</span>, <span class="title">Red</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<h4 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h4><p>接下来学一下第二种方式，ImportSelector接口是Spring中导入外部配置<br>的核心接口，在Spring Boot的自动化配置和@EnableXXX（功能性注解）<br>都有它的存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*这个参数能够获取到当前标注@Import注解的类的所有注解信息，也就是</span></span><br><span class="line"><span class="comment">	说不仅能获取到@Import注解里面的信息，还能获取到其他注解的信息。*/</span></span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要作用是收集需要导入的配置类，selectImports() 方法的返回值就<br>是我们向Spring 容器中导入的类的全类名。如果该接口的实现类同时实现<br>EnvironmentAware，BeanFactoryAware，BeanClassLoaderAware 或<br>者ResourceLoaderAware，那么在调用其selectImports()方法之前先<br>调用上述接口中对应的方法，如果需要在所有的@Configuration处理完<br>再导入时，那么可以实现DeferredImportSelector接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个MyImportSelector类实现ImportSelector接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回值：就是要导入到容器中的组件的全类名</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		至于使用MyImportSelector类要导入哪些bean，就需要你在MyImportSelector</span></span><br><span class="line"><span class="comment">		类的selectImports()方法中进行设置了，只须在MyImportSelector类的</span></span><br><span class="line"><span class="comment">		selectImports()方法中返回要导入的类的全类名（包名+类名）即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 方法不要返回null值，否则会报空指针异常</span></span><br><span class="line">		<span class="comment">//return new String[]&#123;&#125;;  可以返回一个空数组</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"com.atguigu.bean.Bule"</span>, </span><br><span class="line">		<span class="string">"com.atguigu.bean.Yellow"</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在MainConfig2配置类的@Import注解中，导入MyImportSelector类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对配置类中的组件进行统一设置</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;WindowsCondition<span class="class">.<span class="keyword">class</span>&#125;) </span></span><br><span class="line"><span class="class">// 满足当前条件，这个类中配置的所有<span class="title">bean</span>注册才能生效</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;Color<span class="class">.<span class="keyword">class</span>, <span class="title">Red</span>.<span class="title">class</span>, <span class="title">MyImportSelector</span>.<span class="title">class</span>&#125;) </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h4><p>在该接口中，有一个registerBeanDefinitions()方法，通过该方法，我<br>们可以向Spring容器中注册bean实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		所有实现了该接口的类都会被ConfigurationClassPostProcessor处</span></span><br><span class="line"><span class="comment">		理，ConfigurationClassPostProcessor实现了BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">		接口，所以ImportBeanDefinitionRegistrar中动态注册的bean是优先于依赖</span></span><br><span class="line"><span class="comment">		其的bean初始化的，也能被aop、validator等机制处理</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata </span></span></span><br><span class="line"><span class="function"><span class="params">    	importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建创建一个RainBow类，作为测试ImportBeanDefinitionRegistrar<br>接口的bean来使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RainBow</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建ImportBeanDefinitionRegistrar接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> </span></span><br><span class="line"><span class="class">	<span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * AnnotationMetadata：当前类的注解信息</span></span><br><span class="line"><span class="comment">	 * BeanDefinitionRegistry：BeanDefinition注册类</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 我们可以通过调用BeanDefinitionRegistry接口中的registerBeanDefinition方</span></span><br><span class="line"><span class="comment">	 法，手动注册所有需要添加到容器中的bean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata </span></span></span><br><span class="line"><span class="function"><span class="params">		importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> definition = registry.containsBeanDefinition(</span><br><span class="line">			<span class="string">"com.atguigu.bean.Red"</span>);</span><br><span class="line">		<span class="keyword">boolean</span> definition2 = registry.containsBeanDefinition(</span><br><span class="line">			<span class="string">"com.atguigu.bean.Bule"</span>);</span><br><span class="line">		<span class="keyword">if</span> (definition &amp;&amp; definition2) &#123;</span><br><span class="line">			<span class="comment">// 指定bean的定义信息，包括bean的类型、作用域等等</span></span><br><span class="line">			<span class="comment">// RootBeanDefinition是BeanDefinition接口的一个实现类</span></span><br><span class="line">			RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(</span><br><span class="line">			RainBow<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// bean的定义信息</span></span><br><span class="line">			<span class="comment">// 注册一个bean，并且指定bean的名称</span></span><br><span class="line">			registry.registerBeanDefinition(<span class="string">"rainBow"</span>, beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上registerBeanDefinitions()方法的实现逻辑很简单，就是判断Spring<br>容器中是否同时存在以Red命名的bean和以Bule命名的bean，如果真的同时<br>存在，那么向Spring容器中注入一个以rainBow命名的bean。<br>ImportBeanDefinitionRegistrar需要配合@Configuration和@Import<br>这俩注解，其中，@Configuration注解定义Java格式的Spring配置文件<br>，@Import注解导入实现了ImportBeanDefinitionRegistrar接口的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对配置类中的组件进行统一设置</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;WindowsCondition<span class="class">.<span class="keyword">class</span>&#125;) </span></span><br><span class="line"><span class="class">// 满足当前条件，这个类中配置的所有<span class="title">bean</span>注册才能生效</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;Color<span class="class">.<span class="keyword">class</span>, <span class="title">Red</span>.<span class="title">class</span>, <span class="title">MyImportSelector</span>.<span class="title">class</span>, </span></span><br><span class="line"><span class="class">	<span class="title">MyImportBeanDefinitionRegistrar</span>.<span class="title">class</span>&#125;) </span></span><br><span class="line"><span class="class">// @<span class="title">Import</span>快速地导入组件，<span class="title">id</span>默认是组件的全类名</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FactoryBean注册组件"><a href="#FactoryBean注册组件" class="headerlink" title="FactoryBean注册组件"></a>FactoryBean注册组件</h3><p>可以使用FactoryBean向Spring容器中注册bean，一般情况下，Spring是<br>通过反射机制利用bean的class属性指定实现类来实例化bean的。在某些情<br>况下，实例化bean过程比较复杂，如果按照传统的方式，那么则需要在标<br>签中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的<br>方式可以得到一个更加简单的方案。Spring为此提供了FactoryBean的工<br>厂类接口，用户可以通过实现该接口定制实例化bean的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    String OBJECT_TYPE_ATTRIBUTE = <span class="string">"factoryBeanObjectType"</span>;</span><br><span class="line">    <span class="comment">/*返回由FactoryBean创建的bean实例，如果isSingleton()返回true</span></span><br><span class="line"><span class="comment">    ，那么该实例会放到Spring容器中单实例缓存池中*/</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">//返回FactoryBean创建的bean实例的类型</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    <span class="comment">//返回由FactoryBean创建的bean实例的作用域是singleton还是prototype</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：当配置文件中标签的class属性配置的实现类是FactoryBean<br>时，通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean<br>#getObject()方法所返回的对象，相当于FactoryBean#getObject()代<br>理了getBean()方法</p>
<h4 id="FactoryBean案例"><a href="#FactoryBean案例" class="headerlink" title="FactoryBean案例"></a>FactoryBean案例</h4><p>创建一个ColorFactoryBean类，它得实现FactoryBean接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Spring定义的FactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个Color对象，这个对象会添加到容器中</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ColorFactoryBean...getObject..."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> Color<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// 返回这个对象的类型</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 是单例吗？</span></span><br><span class="line">	<span class="comment">// 如果返回true，那么代表这个bean是单实例，在容器中只会保存一份；</span></span><br><span class="line">	<span class="comment">// 如果返回false，那么代表这个bean是多实例，每次获取都会创建一个新的bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MainConfig2配置类中加入ColorFactoryBean的声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对配置类中的组件进行统一设置</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;WindowsCondition<span class="class">.<span class="keyword">class</span>&#125;) </span></span><br><span class="line"><span class="class">// 满足当前条件，这个类中配置的所有<span class="title">bean</span>注册才能生效</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;Color<span class="class">.<span class="keyword">class</span>, <span class="title">Red</span>.<span class="title">class</span>, <span class="title">MyImportSelector</span>.<span class="title">class</span>, </span></span><br><span class="line"><span class="class">	<span class="title">MyImportBeanDefinitionRegistrar</span>.<span class="title">class</span>&#125;) </span></span><br><span class="line"><span class="class">// @<span class="title">Import</span>快速地导入组件，<span class="title">id</span>默认是组件的全类名</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ColorFactoryBean <span class="title">colorFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ColorFactoryBean();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用@Bean注解向Spring容器中注册的是ColorFactoryBean对象，但<br>是实际上从Spring容器中获取到的bean对象却是调用ColorFactoryBean<br>类中的getObject()方法获取到的Color对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = </span><br><span class="line">    	<span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    String[] definitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : definitionNames) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工厂bean获取的是调用getObject方法创建的对象</span></span><br><span class="line">    Object bean2 = applicationContext.getBean(<span class="string">"colorFactoryBean"</span>);</span><br><span class="line">    System.out.println(<span class="string">"bean的类型："</span> + bean2.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取到FactoryBean对象本身"><a href="#获取到FactoryBean对象本身" class="headerlink" title="获取到FactoryBean对象本身"></a>获取到FactoryBean对象本身</h4><p>只需要在获取工厂Bean本身时，在id前面加上&amp;符号即可，例如&amp;colorFactoryBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = </span><br><span class="line">    	<span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    String[] definitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : definitionNames) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean4 = applicationContext.getBean(<span class="string">"&amp;colorFactoryBean"</span>);</span><br><span class="line">    System.out.println(bean4.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bean注解指定初始化和销毁的方法"><a href="#Bean注解指定初始化和销毁的方法" class="headerlink" title="@Bean注解指定初始化和销毁的方法"></a>@Bean注解指定初始化和销毁的方法</h3><p>接下来是有关bean的生命周期的学习</p>
<h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><p>通常意义上讲的bean的生命周期，指的是bean从创建到初始化，经过一系<br>列的流程，最终销毁的过程。在Spring中，bean 的生命周期是由Spring<br>容器来管理的。在Spring中，我们可以自己来指定bean 的初始化和销毁<br>的方法。我们指定了bean的初始化和销毁方法之后，当容器在bean进行<br>到当前生命周期的阶段时，会自动调用我们自定义的初始化和销毁方法</p>
<h4 id="定义初始化和销毁方法"><a href="#定义初始化和销毁方法" class="headerlink" title="定义初始化和销毁方法"></a>定义初始化和销毁方法</h4><p>第一种定义初始化和销毁方法的方式：通过@Bean注解指定初始化和销毁方<br>法。如果是使用XML配置文件的方式配置bean的话，那么可以在标签中指定<br>bean的初始化和销毁方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"person"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.meimeixia.bean.Person"</span> init-method=<span class="string">"init"</span> </span><br><span class="line">destroy-method=<span class="string">"destroy"</span>&gt;</span><br><span class="line">    &lt;property name="age" value="18"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="name" value="liayun"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>在我们自己写的Person类中，需要存在init()方法和destroy()方法。而<br>且Spring中还规定，这里的init()方法和destroy()方法必须是无参方<br>法，但可以抛出异常，首先创建一个Person类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"car constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"car ... init..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"car ... destroy..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将Car类对象通过注解的方式注册到Spring容器中，具体的做法就<br>是新建一个MainConfigOfLifeCycle类作为Spring的配置类，将Car<br>类对象通过MainConfigOfLifeCycle类注册到Spring容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着新建一个IOCTest_LifeCycle类来测试容器中的Car对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest_LifeCycle</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 创建IOC容器</span></span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = </span><br><span class="line">		<span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		System.out.println(<span class="string">"容器创建完成"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于单实例bean对象来说，在Spring 容器创建完成后，就会对单实例<br>bean进行实例化，此时没有执行init和destroy方法，如果是使用XML<br>文件配置的话，那么我们可以使用如下配置来实现</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.meimeixia.bean.Car"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来使用@Bean注解实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"name"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function">Autowire <span class="title">autowire</span><span class="params">()</span> <span class="keyword">default</span> Autowire.NO</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">autowireCandidate</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">initMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">destroyMethod</span><span class="params">()</span> <span class="keyword">default</span> "<span class="params">(inferred)</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@Bean注解的initMethod属性和destroyMethod属性来指定bean的<br>初始化方法和销毁方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring容器中，先是调用了Car类的构造方法来创建Car对象，接下来便<br>是调用了Car对象的init()方法来进行初始化。但是不会打印销毁信息，<br>bean的销毁方法是在容器关闭的时候被调用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest_LifeCycle</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 创建IOC容器</span></span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = </span><br><span class="line">		<span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		System.out.println(<span class="string">"容器创建完成"</span>);</span><br><span class="line">		<span class="comment">// 关闭容器</span></span><br><span class="line">		applicationContext.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化和销毁方法的使用场景"><a href="#初始化和销毁方法的使用场景" class="headerlink" title="初始化和销毁方法的使用场景"></a>初始化和销毁方法的使用场景</h4><p>一个典型的使用场景就是对于数据源的管理。在配置数据源时，在初始化<br>的时候，会对很多的数据源的属性进行赋值操作，在销毁的时候，我们<br>需要对数据源的连接等信息进行关闭和清理。这个时候，就可以在自定<br>义的初始化和销毁方法中来做这些事情了</p>
<h4 id="初始化和销毁方法调用的时机"><a href="#初始化和销毁方法调用的时机" class="headerlink" title="初始化和销毁方法调用的时机"></a>初始化和销毁方法调用的时机</h4><ol>
<li>bean对象的初始化方法调用的时机：对象创建完成，如果对象中存在<br>一些属性，并且这些属性也都赋好值之后，那么就会调用bean的初始化<br>方法。对于单实例bean来说，在Spring容器创建完成后，Spring 容器<br>会自动调用bean 的初始化方法，对于多实例bean 来说，在每次获取<br>bean对象的时候，调用bean的初始化方法</li>
<li>bean对象的销毁方法调用的时机：对于单实例bean来说，在容器关闭<br>的时候，会调用bean的销毁方法，对于多实例bean来说，Spring容器不<br>会管理这个bean，也就不会自动调用这个bean的销毁方法了</li>
</ol>
<h4 id="多实例Bean"><a href="#多实例Bean" class="headerlink" title="多实例Bean"></a>多实例Bean</h4><p>多实例bean的初始化和销毁方法调用的时机与单实例不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">	<span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在获取多实例bean对象的时候，会创建对象并进行初始化，多实<br>例的bean在容器关闭的时候是不进行销毁的，也就是说你每次获取时，<br>IOC容器帮你创建出对象交还给你，至于要什么时候销毁这是你自己的<br>事，Spring容器压根就不会再管理这些多实例的bean了</p>
<h3 id="管理bean的生命周期"><a href="#管理bean的生命周期" class="headerlink" title="管理bean的生命周期"></a>管理bean的生命周期</h3><p>Spring中提供了一个InitializingBean接口，该接口为bean提供了属性<br>初始化后的处理方法，它只包括afterPropertiesSet方法，凡是继承该<br>接口的类，在bean的属性初始化后都会执行该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">	<span class="comment">//afterPropertiesSet()方法是在属性赋好值之后调用的。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="何时调用InitializingBean接口"><a href="#何时调用InitializingBean接口" class="headerlink" title="何时调用InitializingBean接口"></a>何时调用InitializingBean接口</h4><p>首先定位到AbstractAutowireCapableBeanFactory这个类里面的<br>invokeInitMethods()方法中，来查看Spring加载bean的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, </span></span></span><br><span class="line"><span class="function"><span class="params">	@Nullable RootBeanDefinition mbd)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">//判断bean是否实现了InitializingBean，如果实现了就调用afterPropertiesSet</span></span><br><span class="line">        <span class="keyword">boolean</span> isInitializingBean = bean <span class="keyword">instanceof</span> InitializingBean;</span><br><span class="line">        <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || </span><br><span class="line">        	!mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.trace(</span><br><span class="line">                	<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> </span><br><span class="line">                	+ beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                    	<span class="comment">//调用bean的afterPropertiesSet</span></span><br><span class="line">                        ((InitializingBean)bean).afterPropertiesSet();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PrivilegedActionException var6) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var6.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//调用bean的afterPropertiesSet</span></span><br><span class="line">                ((InitializingBean)bean).afterPropertiesSet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            String initMethodName = mbd.getInitMethodName();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp; (!isInitializingBean </span><br><span class="line">            	|| !<span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp; </span><br><span class="line">            	!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            	<span class="comment">//通过反射的方式调用init-method</span></span><br><span class="line">                <span class="keyword">this</span>.invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>分析上述代码后，我们可以初步得出如下信息</p>
<ol>
<li>Spring为bean提供了两种初始化的方式，实现InitializingBean<br>接口（也就是要实现该接口中的afterPropertiesSet方法），或者在<br>配置文件或@Bean注解中通过init-method来指定，两种方式可以同时<br>使用</li>
<li>实现InitializingBean接口是直接调用afterPropertiesSet()方<br>法，与通过反射调用init-method指定的方法相比，效率相对来说要高<br>点。但是init-method方式消除了对Spring的依赖</li>
<li>如果调用afterPropertiesSet方法时出错，那么就不会调用<br>init-method指定的方法了</li>
</ol>
<p>也就是说Spring 为bean 提供了两种初始化的方式，第一种方式是实现<br>InitializingBean 接口（实现该接口中afterPropertiesSet方法）<br>，第二种方式是在配置文件或@Bean注解中通过init-method来指定，<br>这两种方式可以同时使用，同时使用先调用afterPropertiesSet方<br>法，后执行init-method 指定的方法</p>
<h3 id="DisposableBean接口"><a href="#DisposableBean接口" class="headerlink" title="DisposableBean接口"></a>DisposableBean接口</h3><p>实现DisposableBean 接口的bean在销毁前，Spring将会调用该接口<br>的destroy()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在bean生命周期结束前调用destroy()方法做一些收尾工作，亦可以使用<br>destroy-method。前者与Spring耦合高，使用类型强转.方法名()，效<br>率高，后者耦合低，使用反射，效率相对来说较低</p>
<h4 id="DisposableBean接口注意事项"><a href="#DisposableBean接口注意事项" class="headerlink" title="DisposableBean接口注意事项"></a>DisposableBean接口注意事项</h4><p>多实例bean的生命周期不归Spring容器来管理，这里的DisposableBean<br>接口中的方法是由Spring容器来调用的，所以如果一个多实例bean 实现<br>了DisposableBean接口是没有啥意义的，因为相应的方法根本不会被调<br>用，在XML配置文件中指定了destroy方法，也是没有任何意义的。在多<br>实例bean情况下，Spring是不会自动调用bean的销毁方法的</p>
<h4 id="单实例bean"><a href="#单实例bean" class="headerlink" title="单实例bean"></a>单实例bean</h4><p>创建一个Cat的类来实现InitializingBean和DisposableBean这俩接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 会在容器关闭的时候进行调用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"cat destroy..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 会在bean创建完成，并且属性都赋好值以后进行调用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"cat afterPropertiesSet..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MainConfigOfLifeCycle配置类中通过包扫描的方式将以上类注入<br>到Spring容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.meimeixia.bean"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">	<span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单实例bean情况下，IOC容器创建完成后，会自动调用bean的初始化方<br>法，而在容器销毁前，会自动调用bean的销毁方法</p>
<h4 id="多实例bean"><a href="#多实例bean" class="headerlink" title="多实例bean"></a>多实例bean</h4><p>在多实例bean情况下，Spring不会自动调用bean的销毁方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PostConstruct注解和-PreDestroy注解"><a href="#PostConstruct注解和-PreDestroy注解" class="headerlink" title="@PostConstruct注解和@PreDestroy注解"></a>@PostConstruct注解和@PreDestroy注解</h3><p>在JDK中还提供了两个注解能够在bean 创建完成并且属性赋值完成之后<br>执行一些初始化工作和在容器销毁bean之前通知我们进行一些清理工作</p>
<h4 id="PostConstruct注解"><a href="#PostConstruct注解" class="headerlink" title="@PostConstruct注解"></a>@PostConstruct注解</h4><p>@PostConstruct注解好多人以为是Spring提供的，其实它是Java自己的<br>注解，是JSR-250规范里面定义的一个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostConstruct &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注解被用来修饰一个非静态的void()方法。被@PostConstruct注解修饰<br>的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。<br>被@PostConstruct注解修饰的方法通常在构造函数之后，init()方法之<br>前执行，执行顺序如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor（构造方法）→@Autowired（依赖注入）→@PostConstruct（注释的方法）</span><br></pre></td></tr></table></figure>

<h4 id="PreDestroy注解"><a href="#PreDestroy注解" class="headerlink" title="@PreDestroy注解"></a>@PreDestroy注解</h4><p>@PreDestroy注解同样是Java提供的，它也是JSR-250规范里面定义的一<br>个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PreDestroy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被@PreDestroy 注解修饰的方法会在服务器卸载Servlet 的时候运行，并且<br>只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy<br>注解修饰的方法会在destroy()方法之后，Servlet被彻底卸载之前执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在对象创建完成并且属性赋值完成之后调用</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog...@PostConstruct..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在容器销毁（移除）对象之前调用</span></span><br><span class="line">	<span class="meta">@PreDestroy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog...@PreDestroy..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanPostProcessor后置处理器"><a href="#BeanPostProcessor后置处理器" class="headerlink" title="BeanPostProcessor后置处理器"></a>BeanPostProcessor后置处理器</h3><p>BeanPostProcessor是一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//在bean实例化和属性设置之后，自定义初始化方法之前被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">    	beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//在自定义初始化方法之后被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">    	beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法分别是在Spring容器中的bean初始化前后执行，所以Spring<br>容器中的每一个bean对象初始化前后，都会执行BeanPostProcessor接<br>口的实现类中的这两个方法。当容器中存在多个BeanPostProcessor的<br>实现类时，会按照它们在容器中注册的顺序执行。对于自定义的实现类<br>，还可以让其实现Ordered接口自定义排序</p>
<h4 id="后置处理器实例"><a href="#后置处理器实例" class="headerlink" title="后置处理器实例"></a>后置处理器实例</h4><p>创建一个MyBeanPostProcessor类，实现BeanPostProcessor接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 将后置处理器加入到容器中，这样的话，Spring就能让它工作了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">		beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"postProcessBeforeInitialization..."</span> + beanName + </span><br><span class="line">			<span class="string">"=&gt;"</span> + bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">		beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"postProcessAfterInitialization..."</span> + beanName + </span><br><span class="line">			<span class="string">"=&gt;"</span> + bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以让我们自己写的MyBeanPostProcessor类来实现Ordered接<br>口自定义排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 将后置处理器加入到容器中，这样的话，Spring就能让它工作了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后置处理器作用"><a href="#后置处理器作用" class="headerlink" title="后置处理器作用"></a>后置处理器作用</h4><p>后置处理器可用于bean 对象初始化前后进行逻辑增强。Spring 提供了<br>该接口很多实现类</p>
<ol>
<li>AutowiredAnnotationBeanPostProcessor用于@Autowired注解<br>的实现</li>
<li>AnnotationAwareAspectJAutoProxyCreator用于Spring AOP<br>的动态代理等等</li>
</ol>
<p>我们都知道spring AOP的实现原理是动态代理，最终放入容器的是代理<br>类的对象，而不是bean本身的对象，那么Spring是什么时候做到这一步<br>的呢？就是在AnnotationAwareAspectJAutoProxyCreator后置处理<br>器的postProcessAfterInitialization方法中，即bean对象初始化<br>完成之后，后置处理器会判断该bean是否注册了切面，若是，则生成<br>代理对象注入到容器中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> </span></span><br><span class="line"><span class="class"><span class="title">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, </span></span><br><span class="line"><span class="class"><span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object </span></span></span><br><span class="line"><span class="function"><span class="params">			bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object cacheKey = <span class="keyword">this</span>.getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="BeanPostProcessor的执行流程"><a href="#BeanPostProcessor的执行流程" class="headerlink" title="BeanPostProcessor的执行流程"></a>BeanPostProcessor的执行流程</h3><p>接下来看一下BeanPostProcessor的底层原理</p>
<h4 id="bean的初始化和销毁"><a href="#bean的初始化和销毁" class="headerlink" title="bean的初始化和销毁"></a>bean的初始化和销毁</h4><p>bean的初始化和销毁方法我们可以通过如下四种方式进行指定</p>
<ol>
<li>通过@Bean指定init-method和destroy-method<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过让bean实现InitializingBean和DisposableBean这俩接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"cat destroy..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"cat afterPropertiesSet..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用JSR-250规范里面定义的@PostConstruct和@PreDestroy</li>
</ol>
<ul>
<li>@PostConstruct：在bean创建完成并且属性赋值完成之后，来执行<br>初始化方法</li>
<li>@PreDestroy：在容器销毁bean之前通知我们进行清理工作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在对象创建完成并且属性赋值完成之后调用</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog...@PostConstruct..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在容器销毁（移除）对象之前调用</span></span><br><span class="line">	<span class="meta">@PreDestroy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog...@PreDestroy..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过让bean实现BeanPostProcessor接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 将后置处理器加入到容器中，这样的话，Spring就能让它工作了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">		beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"postProcessBeforeInitialization..."</span> + beanName + </span><br><span class="line">			<span class="string">"=&gt;"</span> + bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">		beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"postProcessAfterInitialization..."</span> + beanName + </span><br><span class="line">			<span class="string">"=&gt;"</span> + bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>通过以上这四种方式，我们就可以对bean的整个生命周期进行控制：</p>
<ol>
<li>bean的实例化：调用bean的构造方法，我们可以在bean的无参构造<br>方法中执行相应的逻辑</li>
<li>bean的初始化：在初始化时，可以通过BeanPostProcesso 的两<br>个方法进行拦截，执行自定义的逻辑，通过@PostConstruct 注解、<br>InitializingBean和init-method来指定bean初始化前后执行的<br>方法，在该方法中咱们可以执行自定义的逻辑</li>
<li>bean的销毁：可以通过@PreDestroy注解、DisposableBean和<br>destroy-method来指定bean在销毁前执行的方法，在该方法中咱<br>们可以执行自定义的逻辑</li>
</ol>
<h4 id="BeanPostProcessor源码解析"><a href="#BeanPostProcessor源码解析" class="headerlink" title="BeanPostProcessor源码解析"></a>BeanPostProcessor源码解析</h4><p>AbstractAutowireCapableBeanFactory类的doCreateBean()方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, </span></span></span><br><span class="line"><span class="function"><span class="params">	@Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">//定位到这里</span></span><br><span class="line">            exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var18) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var18 <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(</span><br><span class="line">            	((BeanCreationException)var18).getBeanName())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (BeanCreationException)var18;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), </span><br><span class="line">            	beanName, <span class="string">"Initialization of bean failed"</span>, var18);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用initializeBean()方法之前，还调用了一个populateBean()方<br>法，populateBean() 方法同样是该类中的方法，它里面的代码比较<br>多，但是逻辑非常简单，populateBean()方法做的工作就是为bean<br>的属性赋值。也就是说，在Spring中会先调用populateBean()方法<br>为bean的属性赋好值，然后再调用initializeBean()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, </span></span></span><br><span class="line"><span class="function"><span class="params">	@Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Object wrappedBean = bean;</span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        	<span class="comment">//在调用invokeInitMethods()方法之前，Spring调用了这个方法</span></span><br><span class="line">            wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInitialization(</span><br><span class="line">            	bean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//注意这里</span></span><br><span class="line">        	<span class="comment">/*</span></span><br><span class="line"><span class="comment">				invokeInitMethods() 方法的作用就是执行初始化方法，这些初始</span></span><br><span class="line"><span class="comment">				化方法包括我们之前讲的：在XML配置文件标签中使用init-method</span></span><br><span class="line"><span class="comment">				属性指定初始化方法，在@Bean注解中使用initMehod属性指定的方</span></span><br><span class="line"><span class="comment">				法，使用@PostConstruct注解标注方法，实现InitializingBean</span></span><br><span class="line"><span class="comment">				接口的方法等。</span></span><br><span class="line"><span class="comment">        	*/</span></span><br><span class="line">            <span class="keyword">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd != <span class="keyword">null</span> ? </span><br><span class="line">            	mbd.getResourceDescription() : <span class="keyword">null</span>, beanName, </span><br><span class="line">            	<span class="string">"Invocation of init method failed"</span>, var6);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        	<span class="comment">//在调用invokeInitMethods()方法之后，Spring又调用了这个方法</span></span><br><span class="line">            wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(</span><br><span class="line">            	wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wrappedBean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先来看看applyBeanPostProcessorsBeforeInitialization()<br>方法中具体执行了哪些逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object </span></span></span><br><span class="line"><span class="function"><span class="params">	existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Object result = existingBean;</span><br><span class="line">        Object current;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">			会遍历所有BeanPostProcessor对象，然后依次执行所有</span></span><br><span class="line"><span class="comment">			BeanPostProcessor对象的postProcessBeforeInitialization()</span></span><br><span class="line"><span class="comment">			方法，一旦BeanPostProcessor对象的postProcessBeforeInitialization()</span></span><br><span class="line"><span class="comment">			方法返回null以后，则后面的BeanPostProcessor对象便不再执行了，而是直接</span></span><br><span class="line"><span class="comment">			退出for循环</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator var4 = <span class="keyword">this</span>.getBeanPostProcessors().iterator(); </span><br><span class="line">        	var4.hasNext(); result = current) &#123;</span><br><span class="line">            BeanPostProcessor processor = (BeanPostProcessor)var4.next();</span><br><span class="line">            current = processor.postProcessBeforeInitialization(result, </span><br><span class="line">            	beanName);</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>经过上面的一系列的跟踪源码分析，我们可以将关键代码的调用过程使用<br>如下伪代码表述出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper); <span class="comment">// 给bean进行属性赋值</span></span><br><span class="line">initializeBean(beanName, exposedObject, mbd)</span><br><span class="line">&#123;</span><br><span class="line">	applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	invokeInitMethods(beanName, wrappedBean, mbd); <span class="comment">// 执行自定义初始化</span></span><br><span class="line">	applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，在Spring中，调用initializeBean()方法之前，调用了<br>populateBean()方法为bean的属性赋值，为bean的属性赋好值之后<br>，再调用initializeBean()方法进行初始化。<br>在initializeBean()中，调用自定义初始化方法invokeInitMethods()<br>之前，调用了applyBeanPostProcessorsBeforeInitialization()方<br>法，applyBeanPostProcessorsAfterInitialization()方法在调用<br>自定义的初始化方法后调用，至此整个bean的初始化过程就这样结束了</p>
<h3 id="BeanPostProcessor底层使用"><a href="#BeanPostProcessor底层使用" class="headerlink" title="BeanPostProcessor底层使用"></a>BeanPostProcessor底层使用</h3><p>依然来看一下BeanPostProcessor的源码，接下来就来分析下<br>BeanPostProcessor接口在Spring中的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在bean初始化之前调用</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">    	beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bean初始化之后调用</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">    	beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContextAwareProcessor类"><a href="#ApplicationContextAwareProcessor类" class="headerlink" title="ApplicationContextAwareProcessor类"></a>ApplicationContextAwareProcessor类</h4><p>ApplicationContextAwareProcessor是BeanPostProcessor接<br>口的一个实现类，这个类的作用是可以向组件中注入IOC容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextAwareProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringValueResolver embeddedValueResolver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationContextAwareProcessor</span><span class="params">(ConfigurableApplicationContext </span></span></span><br><span class="line"><span class="function"><span class="params">    	applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="keyword">this</span>.embeddedValueResolver = <span class="keyword">new</span> EmbeddedValueResolver(</span><br><span class="line">        	applicationContext.getBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">    	beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">			在bean初始化之前，首先对当前bean的类型进行判断，如果当前bean</span></span><br><span class="line"><span class="comment">			的类型不是EnvironmentAware，不是EmbeddedValueResolverAware</span></span><br><span class="line"><span class="comment">			，不是ResourceLoaderAware，不是ApplicationEventPublisherAware</span></span><br><span class="line"><span class="comment">			，不是MessageSourceAware，也不是ApplicationContextAware，</span></span><br><span class="line"><span class="comment">			那么直接返回bean。如果是上面类型中的一种类型，那么最终会调用</span></span><br><span class="line"><span class="comment">			invokeAwareInterfaces()方法，并将bean传递给该方法</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="keyword">if</span> (!(bean <span class="keyword">instanceof</span> EnvironmentAware) &amp;&amp; !(bean </span><br><span class="line">        	<span class="keyword">instanceof</span> EmbeddedValueResolverAware) &amp;&amp; !(bean </span><br><span class="line">        	<span class="keyword">instanceof</span> ResourceLoaderAware) &amp;&amp; !(bean </span><br><span class="line">        	<span class="keyword">instanceof</span> ApplicationEventPublisherAware) &amp;&amp; !(bean </span><br><span class="line">        	<span class="keyword">instanceof</span> MessageSourceAware) &amp;&amp; !(bean </span><br><span class="line">        	<span class="keyword">instanceof</span> ApplicationContextAware)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().</span><br><span class="line">                getAccessControlContext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">this</span>.invokeAwareInterfaces(bean);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//注意这里</span></span><br><span class="line">                <span class="keyword">this</span>.invokeAwareInterfaces(bean);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		判断当前bean属于哪种接口类型，然后将bean强转为哪种接口类型的对象</span></span><br><span class="line"><span class="comment">		，接着调用接口中的方法，将相应的参数传递到接口的方法中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">            ((EnvironmentAware)bean).setEnvironment(</span><br><span class="line">            	<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">            ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(</span><br><span class="line">            	<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">            ((ResourceLoaderAware)bean).setResourceLoader(</span><br><span class="line">            	<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">            ((ApplicationEventPublisherAware)bean).</span><br><span class="line">            setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">            ((MessageSourceAware)bean).setMessageSource(<span class="keyword">this</span>.</span><br><span class="line">            	applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">            ((ApplicationContextAware)bean).setApplicationContext(</span><br><span class="line">            	<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想使用ApplicationContextAwareProcessor类向组件中注<br>入IOC 容器，我们就不得不提Spring 中的另一个接口了，即<br>ApplicationContextAware。如果需要向组件中注入IOC容器<br>，那么可以让组件实现ApplicationContextAware接口。<br>创建一个Dog类，使其实现ApplicationContextAware接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ApplicationContextAwareProcessor这个类的作用是可以帮我们在组件里面注入</span></span><br><span class="line"><span class="comment">   IOC容器，怎么注入呢？我们想要IOC容器的话，比如我们这个Dog组件，只需要实现</span></span><br><span class="line"><span class="comment">   ApplicationContextAware接口就行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在对象创建完成并且属性赋值完成之后调用</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(<span class="string">"dog...@PostConstruct..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在容器销毁（移除）对象之前调用</span></span><br><span class="line">	<span class="meta">@PreDestroy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog...@PreDestroy..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		需要实现ApplicationContextAware接口中的setApplicationContext()方法</span></span><br><span class="line"><span class="comment">		有一个ApplicationContext类型的参数，这个就是IOC容器对象，我们可以在</span></span><br><span class="line"><span class="comment">		Dog类中定义一个ApplicationContext类型的成员变量，然后在</span></span><br><span class="line"><span class="comment">		setApplicationContext()方法中为这个成员变量赋值，此时就</span></span><br><span class="line"><span class="comment">		可以在Dog类中的其他方法中使用ApplicationContext对象了</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext </span></span></span><br><span class="line"><span class="function"><span class="params">		applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123; </span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BeanValidationPostProcessor类"><a href="#BeanValidationPostProcessor类" class="headerlink" title="BeanValidationPostProcessor类"></a>BeanValidationPostProcessor类</h4><p>该类主要是用来为bean进行校验操作的，当我们创建bean，并为bean<br>赋值后，我们可以通过BeanValidationPostProcessor类为bean进<br>行校验操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanValidationPostProcessor</span> <span class="keyword">implements</span> </span></span><br><span class="line"><span class="class">	<span class="title">BeanPostProcessor</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> afterInitialization = <span class="keyword">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		调用doValidate()方法对bean进行校验，只不过在这两个方法中都会对</span></span><br><span class="line"><span class="comment">		afterInitialization这个boolean类型的成员变量进行判断</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">    	beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.afterInitialization) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doValidate(bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">    	beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.afterInitialization) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doValidate(bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="InitDestroyAnnotationBeanPostProcessor类"><a href="#InitDestroyAnnotationBeanPostProcessor类" class="headerlink" title="InitDestroyAnnotationBeanPostProcessor类"></a>InitDestroyAnnotationBeanPostProcessor类</h4><p>该类主要用来处理@PostConstruct注解和@PreDestroy注解，之<br>前创建的Dog类中就使用了@PostConstruct注解和@PreDestroy<br>注解。<br>在Dog类中使用了@PostConstruct注解和@PreDestroy注解来标注<br>方法，Spring怎么就知道什么时候执行@PostConstruct注解标注<br>的方法，什么时候执行@PreDestroy注解标注的方法呢？这就要归<br>功于InitDestroyAnnotationBeanPostProcessor类了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitDestroyAnnotationBeanPostProcessor</span> </span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">DestructionAwareBeanPostProcessor</span>, </span></span><br><span class="line"><span class="class">	<span class="title">MergedBeanDefinitionPostProcessor</span>, <span class="title">PriorityOrdered</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		在进入使用@PostConstruct注解标注的方法之前，Spring调用了</span></span><br><span class="line"><span class="comment">		InitDestroyAnnotationBeanPostProcessor类的</span></span><br><span class="line"><span class="comment">		postProcessBeforeInitialization()方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String </span></span></span><br><span class="line"><span class="function"><span class="params">		beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			首先会找到bean中有关生命周期的注解，比如@PostConstruct</span></span><br><span class="line"><span class="comment">			注解等，找到这些注解之后，则将这些信息赋值给LifecycleMetadata</span></span><br><span class="line"><span class="comment">			类型的变量metadata，之后调用metadata的invokeInitMethods()方</span></span><br><span class="line"><span class="comment">			法，通过反射来调用标注了@PostConstruct注解的方法。这就是为什么</span></span><br><span class="line"><span class="comment">			标注了@PostConstruct注解的方法会被Spring执行的原因</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata metadata = </span><br><span class="line">        <span class="keyword">this</span>.findLifecycleMetadata(bean.getClass());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, </span><br><span class="line">            	<span class="string">"Invocation of init method failed"</span>, var5.getTargetException());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, </span><br><span class="line">            	<span class="string">"Failed to invoke init method"</span>, var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="AutowiredAnnotationBeanPostProcessor类"><a href="#AutowiredAnnotationBeanPostProcessor类" class="headerlink" title="AutowiredAnnotationBeanPostProcessor类"></a>AutowiredAnnotationBeanPostProcessor类</h4><p>该类主要是用于处理标注了@Autowired注解的变量或方法</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/17/Spring2/">https://skysea-gaoming.github.io/2021/04/17/Spring2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/18/Python/"><i class="fa fa-chevron-left">  </i><span>Python</span></a></div><div class="next-post pull-right"><a href="/2021/04/15/RPC/"><span>RPC</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/17/Spring2/';
  this.page.identifier = '2021/04/17/Spring2/';
  this.page.title = 'Spring2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>