<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="RPC"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>RPC | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-number">2.</span> <span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是RPC"><span class="toc-number">2.1.</span> <span class="toc-text">什么是RPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC简要原理"><span class="toc-number">2.2.</span> <span class="toc-text">RPC简要原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见PRC框架"><span class="toc-number">2.3.</span> <span class="toc-text">常见PRC框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么用RPC，不用HTTP"><span class="toc-number">2.4.</span> <span class="toc-text">为什么用RPC，不用HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用TCP和使用HTTP的区别"><span class="toc-number">2.5.</span> <span class="toc-text">使用TCP和使用HTTP的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java"><span class="toc-number">3.</span> <span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用如何在客户端无感（动态代理）"><span class="toc-number">3.1.</span> <span class="toc-text">调用如何在客户端无感（动态代理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理没有实现接口的对象"><span class="toc-number">3.2.</span> <span class="toc-text">代理没有实现接口的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象是怎么在网络中传输的（序列化）"><span class="toc-number">3.3.</span> <span class="toc-text">对象是怎么在网络中传输的（序列化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你的框架实现了哪几种序列化方式"><span class="toc-number">3.4.</span> <span class="toc-text">你的框架实现了哪几种序列化方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty"><span class="toc-number">4.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么-Netty-性能高"><span class="toc-number">4.1.</span> <span class="toc-text">为什么 Netty 性能高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO、NIO-和-AIO"><span class="toc-number">4.2.</span> <span class="toc-text">BIO、NIO 和 AIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty的线程模型"><span class="toc-number">4.3.</span> <span class="toc-text">Netty的线程模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC简单实现"><span class="toc-number">5.</span> <span class="toc-text">RPC简单实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#项目结构"><span class="toc-number">5.1.</span> <span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#modules的作用"><span class="toc-number">5.2.</span> <span class="toc-text">modules的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">5.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用接口"><span class="toc-number">5.4.</span> <span class="toc-text">通用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logger"><span class="toc-number">5.5.</span> <span class="toc-text">Logger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传输协议"><span class="toc-number">5.6.</span> <span class="toc-text">传输协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端的实现——动态代理"><span class="toc-number">5.7.</span> <span class="toc-text">客户端的实现——动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Builder模式"><span class="toc-number">5.8.</span> <span class="toc-text">Builder模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端的实现——反射调用"><span class="toc-number">5.9.</span> <span class="toc-text">服务端的实现——反射调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试"><span class="toc-number">5.10.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注册多个服务"><span class="toc-number">6.</span> <span class="toc-text">注册多个服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#服务注册表"><span class="toc-number">6.1.</span> <span class="toc-text">服务注册表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他处理"><span class="toc-number">6.2.</span> <span class="toc-text">其他处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试-1"><span class="toc-number">6.3.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty传输和通用序列化接口"><span class="toc-number">7.</span> <span class="toc-text">Netty传输和通用序列化接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty-服务端与客户端"><span class="toc-number">7.1.</span> <span class="toc-text">Netty 服务端与客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义协议与编解码器"><span class="toc-number">7.2.</span> <span class="toc-text">自定义协议与编解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化接口"><span class="toc-number">7.3.</span> <span class="toc-text">序列化接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于Nacos-的服务器注册与发现"><span class="toc-number">8.</span> <span class="toc-text">基于Nacos 的服务器注册与发现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获得-Nacos"><span class="toc-number">8.1.</span> <span class="toc-text">获得 Nacos</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">RPC</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/04/15/RPC/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/04/15/RPC/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;588903?type&#x3D;post&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;2&amp;</span><br><span class="line">channel&#x3D;-1&amp;source_id&#x3D;search_post_nctrack</span><br></pre></td></tr></table></figure>

<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程<br>计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的<br>服务A、B 部署在两台不同的机器上，那么服务A 如果想要调用服务B 中的某<br>个方法该怎么办呢？使用 HTTP请求当然可以，但是可能会比较慢而且一些优<br>化做的并不好。RPC 的出现就是为了解决这个问题。<br>最终解决的问题：让分布式或者微服务系统中不同服务之间的调用像本地调用<br>一样简单</p>
<h3 id="RPC简要原理"><a href="#RPC简要原理" class="headerlink" title="RPC简要原理"></a>RPC简要原理</h3><ol>
<li>服务消费方（client）调用以本地调用方式调用服务</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的<br>消息体</li>
<li>client stub找到服务地址，并将消息发送到服务端</li>
<li>server stub收到消息后进行解码；</li>
<li>server stub根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给server stub</li>
<li>server stub将返回结果打包成消息并发送至消费方</li>
<li>client stub接收到消息，并进行解码</li>
<li>服务消费方得到最终结果</li>
</ol>
<h3 id="常见PRC框架"><a href="#常见PRC框架" class="headerlink" title="常见PRC框架"></a>常见PRC框架</h3><ol>
<li>Dubbo: Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得<br>应用可通过高性能的RPC 实现服务的输出和输入功能，可以和Spring框架无<br>缝集成。目前Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件</li>
<li>gRPC ：gRPC 是可以在任何环境中运行的高性能RPC框架。它可以通过可<br>插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡<br>，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，<br>以将设备，移动应用程序和浏览器连接到后端服务</li>
<li>Hessian： Hessian是一个轻量级的 remoting-on-http 工具，使用简<br>单的方法提供了RMI 的功能。 相比WebService，Hessian 更简单、快捷。采<br>用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进<br>制数据</li>
</ol>
<h3 id="为什么用RPC，不用HTTP"><a href="#为什么用RPC，不用HTTP" class="headerlink" title="为什么用RPC，不用HTTP"></a>为什么用RPC，不用HTTP</h3><ol>
<li>首先需要指正，这两个并不是并行概念。RPC 是一种设计，就是为了解决<br>不同服务之间的调用问题，完整的RPC 实现一般会包含有传输协议和序列化<br>协议这两个</li>
<li>而HTTP 是一种传输协议，RPC 框架完全可以使用HTTP 作为传输协议，<br>也可以直接使用TCP，使用不同的协议一般也是为了适应不同的场景</li>
</ol>
<h3 id="使用TCP和使用HTTP的区别"><a href="#使用TCP和使用HTTP的区别" class="headerlink" title="使用TCP和使用HTTP的区别"></a>使用TCP和使用HTTP的区别</h3><ol>
<li>传输效率</li>
</ol>
<ul>
<li>TCP 通常自定义上层协议，可以让请求报文体积更小</li>
<li>HTTP 如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容</li>
</ul>
<ol start="2">
<li>性能消耗，主要在于序列化和反序列化的耗时</li>
</ol>
<ul>
<li>TCP 可以基于各种序列化框架进行，效率比较高</li>
<li>HTTP 大部分是通过json 来实现的，字节大小和序列化耗时都要更消<br>耗性能</li>
</ul>
<ol start="3">
<li>跨平台</li>
</ol>
<ul>
<li>TCP 通常要求客户端和服务器为统一平台</li>
<li>HTTP 可以在各种异构系统上运行</li>
</ul>
<p>总结：RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效<br>率高。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三<br>方接口调用等</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="调用如何在客户端无感（动态代理）"><a href="#调用如何在客户端无感（动态代理）" class="headerlink" title="调用如何在客户端无感（动态代理）"></a>调用如何在客户端无感（动态代理）</h3><p>基于动态代理生成代理对象，当调用代理对象的方法时，由代理进行相关信息<br>（方法、参数等）的组装并发送到服务器进行远程调用，并由代理接收调用结<br>果并返回</p>
<h3 id="代理没有实现接口的对象"><a href="#代理没有实现接口的对象" class="headerlink" title="代理没有实现接口的对象"></a>代理没有实现接口的对象</h3><ol>
<li>CGLIB 框架实现了对无接口的对象进行代理的方式。JDK 动态代理是基于接<br>口实现的，而 CGLIB 是基于继承实现的。它会对目标类产生一个代理子类，通<br>过方法拦截技术对过滤父类的方法调用。代理子类需要实 MethodInterceptor<br>接口</li>
<li>CGLIB 底层是通过 asm 字节码框架实时生成类的字节码，达到动态创建<br>类的目的，效率较 JDK 动态代理低。Spring 中的AOP 就是基于动态代理的<br>，如果被代理类实现了某个接口，Spring 会采用 JDK 动态代理，否则会采<br>用CGLIB</li>
</ol>
<h3 id="对象是怎么在网络中传输的（序列化）"><a href="#对象是怎么在网络中传输的（序列化）" class="headerlink" title="对象是怎么在网络中传输的（序列化）"></a>对象是怎么在网络中传输的（序列化）</h3><p>通过将对象序列化成字节数组，即可将对象发送到网络中。<br>序列化在计算机科学的资料处理中，是指将数据结构或对象状态转换成可取用<br>格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或<br>另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节<br>的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像<br>是使用大量引用的复杂对象，这种序列化重建的过程并不容易。这种过程也称<br>为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反<br>序列化（也称为解编组）。<br>在Java中想要序列化一个对象，这个对象所属的类必须实现了Serializable<br>接口，并且其内部属性必须都是可序列化的。如果有一个属性不是可序列化的<br>，则该属性必须被声明为transient。<br>JDK 中提供了ObjectOutStream 类来对对象进行序列化。</p>
<h3 id="你的框架实现了哪几种序列化方式"><a href="#你的框架实现了哪几种序列化方式" class="headerlink" title="你的框架实现了哪几种序列化方式"></a>你的框架实现了哪几种序列化方式</h3><p>实现了JSON、Kryo、Hessian 和 Protobuf 的序列化。除了JSON剩下的都是基<br>于字节的序列化。</p>
<ol>
<li>JSON 是一种轻量级的数据交换语言，该语言以易于让人阅读的文字为基础<br>，用来传输由属性值或者序列性的值组成的数据对象，类似xml，Json 比xml<br>更小、更快更容易解析。JSON 由于采用字符方式存储，占用相对于字节方式较<br>大，并且序列化后类的信息会丢失，可能导致反序列化失败</li>
<li>Kryo 是一个快速高效的Java 序列化框架，旨在提供快速、高效和易用的<br>API。无论文件、数据库或网络数据Kryo 都可以随时完成序列化。Kryo 还可以<br>执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;<br>对象的拷贝。kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂</li>
<li>Hessian 是一个基于二进制的协议，Hessian 支持很多种语言，例如 Java<br>、python、c++,、net/c#、D、Erlang、PHP、Ruby、object-c等，它的序列化和反<br>序列化也是非常高效。速度较慢，序列化后的体积较大</li>
<li>protobuf 是由 Google 发布的数据交换格式，提供跨语言、跨平台的序列<br>化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 protocol<br>compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预<br>编译上。序列化反序列化性能较高，平台无关</li>
</ol>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能<br>协议服务器和客户端。Netty 基于NIO 的，封装了JDK 的NIO，让我们使用起来<br>更加方法灵活。特点和优势：</p>
<ol>
<li>使用简单：封装了 NIO 的很多细节，使用更简单</li>
<li>功能强大：预置了多种编解码功能，支持多种主流协议</li>
<li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展</li>
<li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优</li>
</ol>
<h3 id="为什么-Netty-性能高"><a href="#为什么-Netty-性能高" class="headerlink" title="为什么 Netty 性能高"></a>为什么 Netty 性能高</h3><ol>
<li>IO 线程模型：同步非阻塞，用最少的资源做更多的事</li>
<li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。</li>
<li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二<br>叉查找树管理内存分配情况</li>
<li>串行化处理读写：避免使用锁带来的性能开销</li>
<li>高性能序列化协议：支持 protobuf 等高性能序列化协议</li>
</ol>
<h3 id="BIO、NIO-和-AIO"><a href="#BIO、NIO-和-AIO" class="headerlink" title="BIO、NIO 和 AIO"></a>BIO、NIO 和 AIO</h3><ol>
<li>BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个<br>线程进行处理。线程开销大</li>
<li>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源</li>
<li>NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器<br>上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理</li>
<li>AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知<br>服务器应用去启动线程进行处理</li>
</ol>
<h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><h2 id="RPC简单实现"><a href="#RPC简单实现" class="headerlink" title="RPC简单实现"></a>RPC简单实现</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ol>
<li>docs文件夹：这个文档的源文件</li>
<li>images文件夹：Readme所用到的图片（其实只有一张）</li>
<li>rpc-api文件夹：服务端与客户端的公共调用接口</li>
<li>rpc-common文件夹：项目中的一些通用的枚举类和工具类</li>
<li>rpc-core文件夹：框架的核心实现</li>
<li>test-client文件夹：测试用的客户端项目</li>
<li>test-server文件夹：测试用的服务端项目</li>
<li>.gitignore：就是.gitignore</li>
<li>.travis.yml：持续集成的脚本（其实什么也没干）</li>
<li>LICENSE：基于MIT开源协议哦</li>
<li>README.md：就是Readme</li>
<li>pom.xml：项目的总的pom</li>
</ol>
<h3 id="modules的作用"><a href="#modules的作用" class="headerlink" title="modules的作用"></a>modules的作用</h3><p>在pom.xml文件中构建modules模块</p>
<ol>
<li>用来管理同个项目中的各个模块，每个模块的配置都在各自的pom.xml里</li>
<li>在构建这个项目的时候，不需要深入每个module去单独构建，而只是在项<br>目A下的pom.xml构建，就会完成对两个module的构建</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现<br>类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个<br>接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回<br>给客户端，作为客户端调用接口方法的返回值。<br>目前的问题如下：例如客户端怎么知道服务端的地址？客户端怎么告诉服务端<br>我要调用的接口？客户端怎么传递参数？只有接口客户端怎么生成实现类？</p>
<h3 id="通用接口"><a href="#通用接口" class="headerlink" title="通用接口"></a>通用接口</h3><p>创建HelloService接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gaoming.rpc.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(HelloObject object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hello方法需要传递一个对象，HelloObject对象，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个对象需要实现Serializable接口，因为它需要在调用过程中从客<br>户端传递给服务端。接着我们在服务端对这个接口进行实现，实现的方式也<br>很简单，返回一个字符串就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">	<span class="comment">//声明一个Logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(</span><br><span class="line">    	HelloServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HelloObject object)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//输出的log信息</span></span><br><span class="line">        logger.info(<span class="string">"接收到消息：&#123;&#125;"</span>, object.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是掉用的返回值，id="</span> + object.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>打印日志</p>
<h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>首先需要考虑服务端需要哪些信息，才能唯一确定服务端需要调用的接口的方<br>法。首先就是接口的名字和方法的名字，但是由于方法重载的缘故，我们还需<br>要这个方法的所有参数的类型，最后客户端调用时还需要传递参数的实际值<br>，那么服务端知道以上四个条件，就可以找到这个方法并且调用了。我们把<br>这四个条件写到一个对象里，到时候传输时传输这个对象就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用接口名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数类型，也可以用字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器调用完这个方法后，需要给客户端返回哪些信息呢？如果调用成功的<br>话，显然需要返回值，如果调用失败了，就需要失败的信息，这里封装成一<br>个RpcResponse对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态补充信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setData(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">fail</span><span class="params">(ResponseCode code)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(code.getCode());</span><br><span class="line">        response.setMessage(code.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还多写了两个静态方法，用于快速生成成功与失败的响应对象。其中<br>statusCode属性可以自行定义，客户端服务端一致即可</p>
<h3 id="客户端的实现——动态代理"><a href="#客户端的实现——动态代理" class="headerlink" title="客户端的实现——动态代理"></a>客户端的实现——动态代理</h3><p>客户端方面，由于在客户端这一侧我们并没有接口的具体实现类，就没有办<br>法直接生成实例对象。这时，我们可以通过动态代理的方式生成实例，并且<br>调用方法时生成需要的RpcRequest对象并且发送给服务端。这里我们采用<br>JDK动态代理，代理类是需要实现InvocationHandler接口的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), </span><br><span class="line">        	<span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要传递host和port来指明服务端的位置。并且使用getProxy()方法来<br>生成代理对象。InvocationHandler接口需要实现invoke()方法，来指明代<br>理对象的方法被调用时的动作。在这里我们显然就需要生成一个RpcRequest<br>对象，发送出去，然后返回从服务端接收到的结果即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    RpcRequest rpcRequest = RpcRequest.builder()</span><br><span class="line">            .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">            .methodName(method.getName())</span><br><span class="line">            .parameters(args)</span><br><span class="line">            .paramTypes(method.getParameterTypes())</span><br><span class="line">            .build();</span><br><span class="line">    RpcClient rpcClient = <span class="keyword">new</span> RpcClient();</span><br><span class="line">    <span class="keyword">return</span> ((RpcResponse) rpcClient.sendRequest(rpcRequest, host, </span><br><span class="line">    	port)).getData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成RpcRequest很简单，我使用Builder模式来生成这个对象。发送的逻辑我<br>使用了一个RpcClient对象来实现，这个对象的作用，就是将一个对象发过去<br>，并且接受返回的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(</span><br><span class="line">    	RpcClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest, String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(host, port)) &#123;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">            	socket.getOutputStream());</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">            	socket.getInputStream());</span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"调用时有错误发生："</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的实现很简单，直接使用Java的序列化方式，通过Socket传输。创建一个<br>Socket，获取ObjectOutputStream对象，然后把需要发送的对象传进去即<br>可，接收时获取ObjectInputStream对象，readObject()方法就可以获得<br>一个返回的对象</p>
<h3 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h3><p>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示</p>
<h3 id="服务端的实现——反射调用"><a href="#服务端的实现——反射调用" class="headerlink" title="服务端的实现——反射调用"></a>服务端的实现——反射调用</h3><p>服务端的实现就简单多了，使用一个ServerSocket监听某个端口，循环接收<br>连接请求，如果发来了请求就创建一个线程，在新线程中处理调用。这里创建<br>线程采用线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(</span><br><span class="line">    	RpcServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">60</span>;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, </span><br><span class="line">        	keepAliveTime, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里简化了一下，RpcServer暂时只能注册一个接口，即对外提供一个接口的<br>调用服务，添加register方法，在注册完一个服务后立刻开始监听：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">        logger.info(<span class="string">"服务器正在启动..."</span>);</span><br><span class="line">        Socket socket;</span><br><span class="line">        <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"客户端连接！Ip为："</span> + socket.getInetAddress());</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> WorkerThread(socket, service));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"连接时有错误发生："</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里向工作线程WorkerThread传入了socket和用于服务端实例service。<br>WorkerThread实现了Runnable接口，用于接收RpcRequest对象，解析并且调<br>用，生成RpcResponse对象并传输回去。run方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">    	socket.getInputStream());</span><br><span class="line">         ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">         	socket.getOutputStream())) &#123;</span><br><span class="line">        RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();</span><br><span class="line">        Method method = service.getClass().getMethod(rpcRequest.</span><br><span class="line">        	getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">        Object returnObject = method.invoke(service, rpcRequest.</span><br><span class="line">        	getParameters());</span><br><span class="line">        objectOutputStream.writeObject(RpcResponse.success(returnObject));</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | </span><br><span class="line">    	NoSuchMethodException | IllegalAccessException | </span><br><span class="line">    	InvocationTargetException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"调用或发送时有错误发生："</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中通过class.getMethod方法，传入方法名和方法参数类型即可获得Method<br>对象。如果你上面RpcRequest中使用String数组来存储方法参数类型的话，这<br>里你就需要通过反射生成对应的Class数组了。通过method.invoke方法，传入<br>对象实例和参数，即可调用并且获得返回值</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>服务端侧，我们已经在上面实现了一个HelloService的实现类HelloServiceImpl<br>的实现类了，我们只需要创建一个RpcServer并且把这个实现类注册进去就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer();</span><br><span class="line">        rpcServer.register(helloService, <span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端开放在9000端口。客户端方面，我们需要通过动态代理，生成代理对象<br>，并且调用，动态代理会自动帮我们向服务端发送请求的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">"This is a message"</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="注册多个服务"><a href="#注册多个服务" class="headerlink" title="注册多个服务"></a>注册多个服务</h2><p>之前一个服务器只能注册一个服务，将服务的注册和服务器启动分离，使得服务<br>端可以提供多个服务</p>
<h3 id="服务注册表"><a href="#服务注册表" class="headerlink" title="服务注册表"></a>服务注册表</h3><p>我们需要一个容器，这个容器很简单，就是保存一些本地服务的信息，并且在获<br>得一个服务名字的时候能够返回这个服务的信息。创建一个ServiceRegistry接<br>口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T service)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个register注册服务信息，一个getService获取服务信息。<br>我们新建一个默认的注册表类DefaultServiceRegistry 来实现这个接口，提供<br>服务注册服务，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.</span><br><span class="line">    	getLogger(DefaultServiceRegistry<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T service)</span> </span>&#123;</span><br><span class="line">        String serviceName = service.getClass().getCanonicalName();</span><br><span class="line">        <span class="keyword">if</span>(registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_IMPLEMENT_ANY_INTERFACE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; i : interfaces) &#123;</span><br><span class="line">            serviceMap.put(i.getCanonicalName(), service);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"向接口: &#123;&#125; 注册服务: &#123;&#125;"</span>, interfaces, serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">getService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span>(service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将服务名与提供服务的对象的对应关系保存在一个ConcurrentHashMap 中<br>，并且使用一个 Set 来保存当前有哪些对象已经被注册。在注册服务时，默认<br>采用这个对象实现的接口的完整类名作为服务名，例如某个对象A 实现了接口<br>X 和Y，那么将A 注册进去后，会有两个服务名X 和Y 对应于A 对象。这种处<br>理方式也就说明了某个接口只能有一个对象提供服务。</p>
<h3 id="其他处理"><a href="#其他处理" class="headerlink" title="其他处理"></a>其他处理</h3><p>为了降低耦合度，我们不会把ServiceRegistry 和某一个 RpcServer 绑定<br>在一起，而是在创建RpcServer 对象时，传入一个ServiceRegistry作为这<br>个服务的注册表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(</span><br><span class="line">    	RpcServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">(ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> </span><br><span class="line">        	ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, </span><br><span class="line">        	MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, </span><br><span class="line">        	workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">"服务器启动……"</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">"消费者连接: &#123;&#125;:&#123;&#125;"</span>, socket.getInetAddress(), </span><br><span class="line">                	socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> RequestHandlerThread(</span><br><span class="line">                	socket, requestHandler, serviceRegistry));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"服务器启动时有错误发生:"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建 RpcServer 时需要传入一个已经注册好服务的ServiceRegistry，<br>而原来的register 方法也被改成了start 方法，因为服务的注册已经不由<br>RpcServer 处理了，它只需要启动就行了。<br>而在每一个请求处理线程中也就需要传入ServiceRegistry 了，这里把处理<br>线程和处理逻辑分成了两个类：RequestHandlerThread 只是一个线程，从<br>ServiceRegistry 获取到提供服务的对象后，就会把 RpcRequest 和服务<br>对象直接交给RequestHandler去处理，反射等过程被放到RequestHandler<br>里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandlerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.</span><br><span class="line">    getLogger(RequestHandlerThread<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestHandlerThread</span><span class="params">(Socket socket, RequestHandler </span></span></span><br><span class="line"><span class="function"><span class="params">    	requestHandler, ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = requestHandler;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">        	socket.getInputStream());</span><br><span class="line">             ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">             	socket.getOutputStream())) &#123;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();</span><br><span class="line">            String interfaceName = rpcRequest.getInterfaceName();</span><br><span class="line">            Object service = serviceRegistry.getService(interfaceName);</span><br><span class="line">            Object result = requestHandler.handle(rpcRequest, service);</span><br><span class="line">            objectOutputStream.writeObject(RpcResponse.success(result));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"调用或发送时有错误发生："</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestHandler.java：通过反射进行方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(</span><br><span class="line">    	RequestHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = invokeTargetMethod(rpcRequest, service);</span><br><span class="line">            logger.info(<span class="string">"服务:&#123;&#125; 成功调用方法:&#123;&#125;"</span>, rpcRequest.</span><br><span class="line">            	getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"调用或发送时有错误发生："</span>, e);</span><br><span class="line">        &#125; <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object </span></span></span><br><span class="line"><span class="function"><span class="params">    	service)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        Method method;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = service.getClass().getMethod(rpcRequest.</span><br><span class="line">            	getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        serviceRegistry.register(helloService);</span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer(serviceRegistry);</span><br><span class="line">        rpcServer.start(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty传输和通用序列化接口"><a href="#Netty传输和通用序列化接口" class="headerlink" title="Netty传输和通用序列化接口"></a>Netty传输和通用序列化接口</h2><h3 id="Netty-服务端与客户端"><a href="#Netty-服务端与客户端" class="headerlink" title="Netty 服务端与客户端"></a>Netty 服务端与客户端</h3><p>NettyServer的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(</span><br><span class="line">    	NettyServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 256)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> </span><br><span class="line">                            	JsonSerializer()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"启动服务器时有错误发生: "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Netty 中有一个很重要的设计模式——责任链模式，责任链上有多个处理器，每<br>个处理器都会对数据进行加工，并将处理后的数据传给下一个处理器。代码中的 CommonEncoder、CommonDecoder和NettyServerHandler 分别就是编码器，<br>解码器和数据处理器。因为数据从外部传入时需要解码，而传出时需要编码，<br>类似计算机网络的分层模型，每一层向下层传递数据时都要加上该层的信息<br>，而向上层传递时则需要对本层信息进行解码。</p>
<h3 id="自定义协议与编解码器"><a href="#自定义协议与编解码器" class="headerlink" title="自定义协议与编解码器"></a>自定义协议与编解码器</h3><p>在传输过程中，我们可以在发送的数据上加上各种必要的数据，形成自定义的协<br>议，而自动加上这个数据就是编码器的工作，解析数据获得原始数据就是解码器<br>的工作。</p>
<h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><h2 id="基于Nacos-的服务器注册与发现"><a href="#基于Nacos-的服务器注册与发现" class="headerlink" title="基于Nacos 的服务器注册与发现"></a>基于Nacos 的服务器注册与发现</h2><p>我们目前实现的框架看起来工作的还不错，但是有一个问题：我们的服务端地址<br>是固化在代码中的，也就是说，对于一个客户端，它只会去寻找那么一个服务提<br>供者，如果这个提供者挂了或者换了地址，那就没有办法了。<br>在分布式架构中，有一个重要的组件，就是服务注册中心，它用于保存多个服务<br>提供者的信息，每个服务提供者在启动时都需要向注册中心注册自己所拥有的服<br>务。这样客户端在发起RPC 时，就可以直接去向注册中心请求服务提供者的信息<br>，如果拿来的这个挂了，还可以重新请求，并且在这种情况下可以很方便地实现<br>负载均衡。常见的注册中心有 Eureka、Zookeeper 和 Nacos。</p>
<h3 id="获得-Nacos"><a href="#获得-Nacos" class="headerlink" title="获得 Nacos"></a>获得 Nacos</h3><p>Nacos 是阿里开发的一款服务注册中心，在SpringCloud Alibaba 逐步替代原<br>始的SpringCloud 的过程中，Nacos 逐步走红，所以我们就是用 Nacos 作为<br>我们的注册中心</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/04/15/RPC/">https://skysea-gaoming.github.io/2021/04/15/RPC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/17/Spring2/"><i class="fa fa-chevron-left">  </i><span>Spring2</span></a></div><div class="next-post pull-right"><a href="/2021/04/15/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"><span>高并发项目学习</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/04/15/RPC/';
  this.page.identifier = '2021/04/15/RPC/';
  this.page.title = 'RPC';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>