<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JAVA基础总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>JAVA基础总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题"><span class="toc-number">2.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA的三大版本是什么？"><span class="toc-number">2.1.</span> <span class="toc-text">JAVA的三大版本是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM、JRE和JDK的关系是什么？"><span class="toc-number">2.2.</span> <span class="toc-text">JVM、JRE和JDK的关系是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是跨平台性？原理是什么？"><span class="toc-number">2.3.</span> <span class="toc-text">什么是跨平台性？原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java语言有哪些特点？"><span class="toc-number">2.4.</span> <span class="toc-text">Java语言有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译型语言和解释型语言的区别？"><span class="toc-number">2.5.</span> <span class="toc-text">编译型语言和解释型语言的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的三大特征分别是什么？"><span class="toc-number">2.6.</span> <span class="toc-text">面向对象的三大特征分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java和C-的区别有哪些？"><span class="toc-number">2.7.</span> <span class="toc-text">Java和C++的区别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类和对象的区别？"><span class="toc-number">2.8.</span> <span class="toc-text">类和对象的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA有哪些数据类型？"><span class="toc-number">2.9.</span> <span class="toc-text">JAVA有哪些数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型的转换情况有哪些？"><span class="toc-number">2.10.</span> <span class="toc-text">基本数据类型的转换情况有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动类型转换和强制类型转换的区别？"><span class="toc-number">2.11.</span> <span class="toc-text">自动类型转换和强制类型转换的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA采用何种编码？"><span class="toc-number">2.12.</span> <span class="toc-text">JAVA采用何种编码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机字符串是如何生成的？"><span class="toc-number">2.13.</span> <span class="toc-text">随机字符串是如何生成的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch的格式是什么样的？"><span class="toc-number">2.14.</span> <span class="toc-text">switch的格式是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组初始化的几种形式有哪些？"><span class="toc-number">2.15.</span> <span class="toc-text">数组初始化的几种形式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach是什么？"><span class="toc-number">2.16.</span> <span class="toc-text">foreach是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个类中有哪些常见的成员？"><span class="toc-number">2.17.</span> <span class="toc-text">一个类中有哪些常见的成员？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this的作用"><span class="toc-number">2.18.</span> <span class="toc-text">this的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问修饰符有哪些？区别是什么？"><span class="toc-number">2.19.</span> <span class="toc-text">访问修饰符有哪些？区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-和-amp-amp-的区别是什么？"><span class="toc-number">2.20.</span> <span class="toc-text">&amp;和&amp;&amp;的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的继承关系是什么样的？"><span class="toc-number">2.21.</span> <span class="toc-text">类的继承关系是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写父类方法时注意什么？"><span class="toc-number">2.22.</span> <span class="toc-text">重写父类方法时注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final有什么用？"><span class="toc-number">2.23.</span> <span class="toc-text">final有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-finally-finalize的区别是什么？"><span class="toc-number">2.24.</span> <span class="toc-text">final finally finalize的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super的用法是什么？"><span class="toc-number">2.25.</span> <span class="toc-text">super的用法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super和this的区别是什么？"><span class="toc-number">2.26.</span> <span class="toc-text">super和this的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static的作用是什么？"><span class="toc-number">2.27.</span> <span class="toc-text">static的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态是什么意思？"><span class="toc-number">2.28.</span> <span class="toc-text">多态是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态的实现原则是什么？"><span class="toc-number">2.29.</span> <span class="toc-text">多态的实现原则是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof运算符的用法？"><span class="toc-number">2.30.</span> <span class="toc-text">instanceof运算符的用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装箱和拆箱是什么意思？"><span class="toc-number">2.31.</span> <span class="toc-text">自动装箱和拆箱是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装箱和拆箱的本质是什么？"><span class="toc-number">2.32.</span> <span class="toc-text">自动装箱和拆箱的本质是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类是什么？"><span class="toc-number">2.33.</span> <span class="toc-text">抽象类是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类的特点有哪些？"><span class="toc-number">2.34.</span> <span class="toc-text">抽象类的特点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类能使用final修饰吗？"><span class="toc-number">2.35.</span> <span class="toc-text">抽象类能使用final修饰吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口是什么？有哪些特点？"><span class="toc-number">2.36.</span> <span class="toc-text">接口是什么？有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用接口？"><span class="toc-number">2.37.</span> <span class="toc-text">如何使用接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是内部类？"><span class="toc-number">2.38.</span> <span class="toc-text">什么是内部类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类的优点有哪些？"><span class="toc-number">2.39.</span> <span class="toc-text">内部类的优点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类有哪些应用场景？"><span class="toc-number">2.40.</span> <span class="toc-text">内部类有哪些应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda表达式的作用？"><span class="toc-number">2.41.</span> <span class="toc-text">Lambda表达式的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类访问局部变量的时候，为什么变量必须要加上final？"><span class="toc-number">2.42.</span> <span class="toc-text">内部类访问局部变量的时候，为什么变量必须要加上final？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写与重载的区别是什么？"><span class="toc-number">2.43.</span> <span class="toc-text">重写与重载的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和equals的区别是什么？"><span class="toc-number">2.44.</span> <span class="toc-text">&#x3D;&#x3D;和equals的区别是什么？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JAVA基础总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/30/JAVA基础总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://thinkwon.blog.csdn.net/article/details/104390612" target="_blank" rel="noopener">https://thinkwon.blog.csdn.net/article/details/104390612</a></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="JAVA的三大版本是什么？"><a href="#JAVA的三大版本是什么？" class="headerlink" title="JAVA的三大版本是什么？"></a>JAVA的三大版本是什么？</h3><p>Java分为三个版本</p>
<ul>
<li>Java SE Standard Edition(标准版) 包含那些构成Java语言核心的类，数据<br>库连接、接口定义、输入/输出、网络编程</li>
<li>Java EE Enterprise Edition(企业版) 包含Java SE 中的类，并且还包含用<br>于开发企业级应用的类，例如EJB、servlet、JSP、XML、事务控制</li>
<li>Java ME Micro Edition(微缩版) 包含Java SE中一部分类，用于消费类电子<br>产品的软件开发，例如呼机、智能卡、手机、PDA、机顶盒</li>
</ul>
<h3 id="JVM、JRE和JDK的关系是什么？"><a href="#JVM、JRE和JDK的关系是什么？" class="headerlink" title="JVM、JRE和JDK的关系是什么？"></a>JVM、JRE和JDK的关系是什么？</h3><p>JDK包含JRE，JRE包含JVM</p>
<ol>
<li>JVMJava Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不<br>同的平台有自己的虚拟机，因此Java语言可以实现跨平台</li>
<li>JRE Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库<br>等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基<br>本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个<br>包，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可</li>
<li>JDK Java Development Kit是提供给Java开发人员使用的，其中包含了Java<br>的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发<br>工具：编译工具(javac.exe)，打包工具(jar.exe)等</li>
</ol>
<h3 id="什么是跨平台性？原理是什么？"><a href="#什么是跨平台性？原理是什么？" class="headerlink" title="什么是跨平台性？原理是什么？"></a>什么是跨平台性？原理是什么？</h3><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运<br>行。实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以<br>安装相应的java虚拟机，该系统就可以运行java程序</p>
<h3 id="Java语言有哪些特点？"><a href="#Java语言有哪些特点？" class="headerlink" title="Java语言有哪些特点？"></a>Java语言有哪些特点？</h3><ol>
<li>Java是半编译半解释型语言 因为Java虚拟机既有解释器也有JIT即时编译器，<br>JIT即时编译器能够捕获程序中的热点代码，编译成机器码缓存起来存入方法区<br>中，当遇到相同的代码时，不必再去使用解释器翻译，直接去找对应的机器码执<br>行</li>
<li>Java 完全支持面向对象的三种基本特征:继承、封装和多态。Java语言完全以<br>对象为中心，Java程序的最小程序单位是类，整个Java程序是由一个个类组成</li>
<li>Java是一门强类型语言，强类型包括两个方面</li>
</ol>
<ul>
<li>所有的变量必须先声明、后使用</li>
<li>指定类型的变量只能接受类型与之匹配的值，强类型语言可以在编译过程中<br>发现源代码的错误 ，从而保证程序更加健壮</li>
</ul>
<h3 id="编译型语言和解释型语言的区别？"><a href="#编译型语言和解释型语言的区别？" class="headerlink" title="编译型语言和解释型语言的区别？"></a>编译型语言和解释型语言的区别？</h3><ol>
<li>编译型语言 指使用专门的编译器，针对特定平台（操作系统）将某种高级<br>语言源代码一次性”翻译”成可被该平台硬件执行的机器码（包括机器指令和<br>操作数），并包装成该平台所能识别的可执行性程序的格式，这个转换过程<br>称为编译（Compile）编译生成的可执行性程序可以脱离开发环境，在特定<br>的平台上独运行 C C++ Objective-C Swift kotlin</li>
<li>解释型语言 先编译成一种与平台无关的字节码文件，然后由解释器翻译<br>成特定机器码执行</li>
</ol>
<h3 id="面向对象的三大特征分别是什么？"><a href="#面向对象的三大特征分别是什么？" class="headerlink" title="面向对象的三大特征分别是什么？"></a>面向对象的三大特征分别是什么？</h3><ul>
<li>封装 将对象的实现细节隐藏起来，通过一些公用方法暴露对象的功能</li>
<li>继承 子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和<br>方法</li>
<li>多态 子类对象可以直接赋给父类对象，但运行时表现为子类的行为特征，<br>也是说同一个类型的对象执行同一个方法，表现不同行为特征</li>
</ul>
<h3 id="Java和C-的区别有哪些？"><a href="#Java和C-的区别有哪些？" class="headerlink" title="Java和C++的区别有哪些？"></a>Java和C++的区别有哪些？</h3><ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，C++支持多重继承，虽然Java的类不可以多继承，但<br>是接口可以多继承</li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<h3 id="类和对象的区别？"><a href="#类和对象的区别？" class="headerlink" title="类和对象的区别？"></a>类和对象的区别？</h3><p>具有相同或相似性质的一组对象的抽象就是类，类是对一类事物的描述，对象是<br>实际存在的该类事物的个体，也叫实例。用class定义类，用new创建类的对象</p>
<h3 id="JAVA有哪些数据类型？"><a href="#JAVA有哪些数据类型？" class="headerlink" title="JAVA有哪些数据类型？"></a>JAVA有哪些数据类型？</h3><p>Java语言支持的类型分为两类:基本类型和引用类型</p>
<ol>
<li>基本类型包括 boolean类型和数值类型。数值类型有整数类型和浮点类型。<br>整数类型包括byte short int long char，浮点类型包括float double <img src="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/1.jpg" alt></li>
<li>引用类型 包括类、接口和数组类型，还有一种特殊的 null 类型所谓引用<br>数据类型就是对一个对象的引用，对象包括实例和数组两种。实际上引用类型<br>变量就是一个指针，只是Java语言里不再使用指针这个说法空引用（null）<br>只能被转换成引用类型 不能转换成基本类型，因此不要把一个null值赋给<br>基本数据类型的变量</li>
</ol>
<h3 id="基本数据类型的转换情况有哪些？"><a href="#基本数据类型的转换情况有哪些？" class="headerlink" title="基本数据类型的转换情况有哪些？"></a>基本数据类型的转换情况有哪些？</h3><ol>
<li>如果直接将一个较小的整数值(在 byte short类型的表数范围内〉赋给byte<br>short变量系统会自动把这个整数值当成byte或者short类型来处理</li>
<li>如果使用一个巨大的整数值(超出了int类型的表数范围)时Java不会自动把<br>这个整数值当成long 类型来处理。如果希望系统把一个整数值当成long类型<br>来处理，应在这个整数值后增加或者l作为后缀。通常推荐使用L</li>
<li>Java语言的默认浮点类型是double类型，double占8个字节，float占4个<br>字节如果希望将一个浮点数当成float，在浮点数值后加f或F，浮点数必须要<br>有小数点</li>
</ol>
<h3 id="自动类型转换和强制类型转换的区别？"><a href="#自动类型转换和强制类型转换的区别？" class="headerlink" title="自动类型转换和强制类型转换的区别？"></a>自动类型转换和强制类型转换的区别？</h3><ol>
<li>自动类型转换 表数范围小的可以向表数范围大的自动转换 <img src="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/2.jpg" alt><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="comment">// int 类型可以自动转换为 float 类型</span></span><br><span class="line"><span class="keyword">float</span> f = a ; </span><br><span class="line"><span class="comment">// 下面将输出 6.0</span></span><br><span class="line">System.out.println(f); </span><br><span class="line"><span class="comment">// 定义 byte 类型的整数变量</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">9</span> ; </span><br><span class="line"><span class="comment">// 下面代码将出错，byte 类型不能自动类型转换为 char 类型</span></span><br><span class="line"><span class="comment">// char c = b; </span></span><br><span class="line"><span class="comment">// byte 类型变量可以自动类型转换为 double 类型</span></span><br><span class="line"><span class="keyword">double</span> d = b ; </span><br><span class="line"><span class="comment">// 下面将输出 9.0</span></span><br><span class="line"><span class="function">System out <span class="title">printl</span> <span class="params">(d)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于1是int类型，因此s1+1运算结果也是int型，需要强制转换类型才能赋值给short型</span></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>; </span><br><span class="line">s1 = s1 + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//可以正确编译，因为 s1+=1;相当于s1 = (short(s1 + 1);其中有隐含的强制类型转换。</span></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>浮点数强制转换为整数时会截断浮点数的小数部分<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iValue = <span class="number">233</span>; </span><br><span class="line"><span class="comment">// 强制把一个 int 类型的值转换为 byte 类型 的值</span></span><br><span class="line"><span class="keyword">byte</span> bValue = (<span class="keyword">byte</span>)iValue; </span><br><span class="line"><span class="comment">// 将输出 -23</span></span><br><span class="line">System.out.println(bValue) ; </span><br><span class="line"><span class="keyword">double</span> dValue = <span class="number">3.98</span> ; </span><br><span class="line"><span class="comment">// 强制把 double 类型的值转换为 int 类型的值</span></span><br><span class="line"><span class="keyword">int</span> tol = (<span class="keyword">int</span>)dValue</span><br><span class="line"><span class="comment">// 将输出3</span></span><br><span class="line">System.out.println(tol);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="JAVA采用何种编码？"><a href="#JAVA采用何种编码？" class="headerlink" title="JAVA采用何种编码？"></a>JAVA采用何种编码？</h3><p>这里Java文件的编码可能有多种多样，但Java编译器会自动将这些编码按照<br>Java文件的编码格式正确读取后产生class文件，这里的class文件编码是<br>Unicode编码（具体说是UTF-16编码）</p>
<h3 id="随机字符串是如何生成的？"><a href="#随机字符串是如何生成的？" class="headerlink" title="随机字符串是如何生成的？"></a>随机字符串是如何生成的？</h3><p>首先可以随机生成一个指定范围的int数字，例如生成一个小写字母就是在97<br>~122之间，然后强制转换为char类型，将这些字符拼接起来就是一个验证<br>字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个空字符串</span></span><br><span class="line">String resu1t = <span class="string">""</span>; </span><br><span class="line"><span class="comment">//进行6次循</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i ++) </span><br><span class="line"><span class="comment">//生成一个 97-122 间的 int 类型整数</span></span><br><span class="line"><span class="keyword">int</span> intVa1 = (<span class="keyword">int</span>) (Math.random() * <span class="number">26</span> + <span class="number">97</span>); </span><br><span class="line"><span class="comment">//将 intVa  强制转换为 char 类型后连接到 resu1t 后面</span></span><br><span class="line">result = result + (<span class="keyword">char</span>)intVal; </span><br><span class="line"><span class="comment">//输出随机字符串</span></span><br><span class="line">System.out.print1n(resu1t);</span><br></pre></td></tr></table></figure>

<h3 id="switch的格式是什么样的？"><a href="#switch的格式是什么样的？" class="headerlink" title="switch的格式是什么样的？"></a>switch的格式是什么样的？</h3><p>控制表达式的数据类型可以是short byte char int enum string</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expresson)</span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">case</span> conditionl: </span><br><span class="line">		statement(s) </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> condition2 : </span><br><span class="line">		statement(s) </span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">	<span class="keyword">default</span> : </span><br><span class="line">		statement(s)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组初始化的几种形式有哪些？"><a href="#数组初始化的几种形式有哪些？" class="headerlink" title="数组初始化的几种形式有哪些？"></a>数组初始化的几种形式有哪些？</h3><ol>
<li>静态初始化 初始化时由程序员显式指定每个数组元素的初始值，由系统<br>决定数组长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line">array=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//或者简写如下</span></span><br><span class="line">array=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li>动态初始化 初始化时程序员只指定数组长度，由系统为数组元素分配初始值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="foreach是什么？"><a href="#foreach是什么？" class="headerlink" title="foreach是什么？"></a>foreach是什么？</h3><p>Java5之后提供了一种比for更简洁的循环，这种循环遍历数组和集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type variablename:array|collection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自动迭代访问每个元素，实际访问的是临时变量而不是数组变量本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个类中有哪些常见的成员？"><a href="#一个类中有哪些常见的成员？" class="headerlink" title="一个类中有哪些常见的成员？"></a>一个类中有哪些常见的成员？</h3><p>类中有三个最常见的成员：构造器、成员变量和方法，static修饰的成员不能<br>访问没有static修饰的成员</p>
<ol>
<li>构造器 构造器是一种特殊的方法，如果一个类没有构造器就无法创建实例<br>，如果不显示创建构造器系统会默认提供一个构造器，否则不提供，通过new<br>来创建构造器返回返回该类的实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修饰符 可以省略或者是public protected private其中之一</span><br><span class="line">&#x2F;&#x2F;构造器名 必须与类名相同</span><br><span class="line">[修饰符] 构造器名(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;可执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>成员变量 包括基本类型和引用类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修饰符 可以省略，也可以是 public protected private static final</span><br><span class="line">&#x2F;&#x2F;其中public protected private只能出现一个，可以与 static final组合</span><br><span class="line">[修饰符] 类型 成员变量名 [&#x3D;默认值];</span><br></pre></td></tr></table></figure></li>
<li>方法 返回值类型可以是任意类型，包括基本类型和引用类型，也可以是void<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修饰符可以省略，也可以是public&#x2F;protected&#x2F;private static final&#x2F;abstract</span><br><span class="line">&#x2F;&#x2F;public protected private只能出现一个，final和abstract只能出现一个，可与static组合</span><br><span class="line">[修饰符] 方法返回值类型 方法名(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;可执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="this的作用"><a href="#this的作用" class="headerlink" title="this的作用"></a>this的作用</h3><p>实例变量和非静态方法必须通过对象来引用。Java提供了一个this关键字，this关<br>键字总是指向调用该方法的对象，在大部分时候，一个方法访问该类中定义的其他<br>方法、成员变量时加不加this前缀的效果是完全一样的。static定义的方法中不能<br>使用this引用，因此Java语法规定静态成员不能访问非静态成员</p>
<h3 id="访问修饰符有哪些？区别是什么？"><a href="#访问修饰符有哪些？区别是什么？" class="headerlink" title="访问修饰符有哪些？区别是什么？"></a>访问修饰符有哪些？区别是什么？</h3><p>private default protected public</p>
<ol>
<li>private 在同一类内可见。使用对象：变量、方法和构造器。 注意：不能修饰<br>类（外部类），用于修饰成员变量最合适，使用它来修饰成员变量就可以把成员<br>变量隐藏在该类的内部</li>
<li>default 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方<br>法和构造器。default访问控制的成员或外部类可以被相同包下的其他类访问</li>
<li>protected 对同一包内的类和所有子类可见。使用对象：变量、方法和构造器。<br>注意：不能修饰类（外部类）。这个成员既可以被同一个包中的其他类访问，也可<br>以被不同包中的子类访问，如果使用protected来修饰一个方法，通常是希望其<br>子类来重写这个方法</li>
<li>public 对所有类可见。使用对象：类、接口、变量、方法</li>
</ol>
<h3 id="amp-和-amp-amp-的区别是什么？"><a href="#amp-和-amp-amp-的区别是什么？" class="headerlink" title="&amp;和&amp;&amp;的区别是什么？"></a>&amp;和&amp;&amp;的区别是什么？</h3><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运<br>算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路<br>运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路<br>掉，不会进行运算</p>
<h3 id="类的继承关系是什么样的？"><a href="#类的继承关系是什么样的？" class="headerlink" title="类的继承关系是什么样的？"></a>类的继承关系是什么样的？</h3><p>每个子类只有一个直接父类，子类可以获得父类的全部成员变量和方法，但是不能<br>获得父类的构造器。如果定义一个类的时候没有指定这个类的直接父类，这个类默<br>认扩展java.lang.Object类</p>
<h3 id="重写父类方法时注意什么？"><a href="#重写父类方法时注意什么？" class="headerlink" title="重写父类方法时注意什么？"></a>重写父类方法时注意什么？</h3><p>方法的重写遵循“两同两小一大”规则。两同指方法名相同、形参列表相同。两小指子<br>类方法的返回值类型比父类返回值类型更小或相同、子类方法抛出的异常比父类抛<br>出的异常更小或相同。一大指子类方法的访问权限比父类更大或相同并且覆盖方法<br>和被覆盖方法必须都是类方法或者实例方法。子类的对象无法调用父类被重写的方<br>法，只能在子类方法中通过super或类来调用父类方法，如果父类中有一个方法是<br>private访问权限，那么子类就不算是重写没有限制</p>
<h3 id="final有什么用？"><a href="#final有什么用？" class="headerlink" title="final有什么用？"></a>final有什么用？</h3><p>用于修饰类、属性和方法</p>
<ul>
<li>被final修饰的类不可以被继承</li>
<li>被final修饰的方法不可以被重写，如果再加上一个private 就说明不是方法重<br>写而相当于重新定义一个方法，因为private修饰的方法只能在当前类可见，所以<br>不存在重写pirvate方法</li>
<li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是<br>引用指向的内容，引用指向的内容是可以改变的</li>
</ul>
<h3 id="final-finally-finalize的区别是什么？"><a href="#final-finally-finalize的区别是什么？" class="headerlink" title="final finally finalize的区别是什么？"></a>final finally finalize的区别是什么？</h3><ol>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该<br>方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值</li>
<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一<br>定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会<br>执行，一般用来存放一些关闭资源的代码</li>
<li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父<br>类，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法的时候，由<br>垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断</li>
</ol>
<h3 id="super的用法是什么？"><a href="#super的用法是什么？" class="headerlink" title="super的用法是什么？"></a>super的用法是什么？</h3><p>super用于限定该对象调用它从父类继承到的实例变量和方法，创建子类的时候也<br>会为父类的变量分配空间，可以通过super.调用。不管是否使用super调用来执行<br>父类构造器的初始化代码，子类总是会调用父类构造器一次</p>
<h3 id="super和this的区别是什么？"><a href="#super和this的区别是什么？" class="headerlink" title="super和this的区别是什么？"></a>super和this的区别是什么？</h3><ol>
<li>super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构<br>造方法</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字</li>
</ol>
<h3 id="static的作用是什么？"><a href="#static的作用是什么？" class="headerlink" title="static的作用是什么？"></a>static的作用是什么？</h3><ol>
<li>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即<br>使没有创建对象，也能使用属性和调用方法</li>
<li>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程<br>序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类<br>初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会<br>执行一次，创建对象时先执行初始化块后执行构造器</li>
<li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载<br>的时候执行一次。因此很多时候会将一些只需要进行一次的初始化操作都放在<br>static代码块中进行</li>
</ol>
<h3 id="多态是什么意思？"><a href="#多态是什么意思？" class="headerlink" title="多态是什么意思？"></a>多态是什么意思？</h3><p>Java引用变量有两个类型，一个是编译时类型，另一个是运行时类型，编译时类型<br>由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定，如果<br>编译类型和运行类型不一致就可能出现多态。Java允许把一个子类对象直接赋给一<br>个父类引用变量，当调用引用变量的方法时总是表现子类方法的特征，但是不能调<br>用子类独有的方法。与方法相反，对象的实例变量不具备多态性，只能访问编译时<br>定义的成员变量</p>
<h3 id="多态的实现原则是什么？"><a href="#多态的实现原则是什么？" class="headerlink" title="多态的实现原则是什么？"></a>多态的实现原则是什么？</h3><p>Java实现多态有三个必要条件：继承、重写、向上转型</p>
<ol>
<li>继承：在多态中必须存在有继承关系的子类和父类</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类<br>的方法</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够<br>具备技能调用父类的方法和子类的方法</li>
</ol>
<p>引用变量只能使用编译时类型的方法，如果要使用运行时类型的方法，需要进行强<br>制类型转换，引用类型之间的转换只能在具有继承关系的两个类之间</p>
<h3 id="instanceof运算符的用法？"><a href="#instanceof运算符的用法？" class="headerlink" title="instanceof运算符的用法？"></a>instanceof运算符的用法？</h3><p>instance运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一<br>个类或者接口，用于判断前面的对象是否是后面的类或者其子类需要注意前一个操<br>作数的编译类型要么相同要么与后面的类具有父子继承关系否则编译错误</p>
<h3 id="自动装箱和拆箱是什么意思？"><a href="#自动装箱和拆箱是什么意思？" class="headerlink" title="自动装箱和拆箱是什么意思？"></a>自动装箱和拆箱是什么意思？</h3><p>Java为8种基本数据类型分别定义了相应的引用类型，并称之为基本数据类<br>型的包装类，JDK提供了自动装箱和自动拆箱功能</p>
<ul>
<li>自动装箱 把一个基本数据类型直接赋给相应的包装类变量</li>
<li>自动拆箱 把一个包装类变量直接赋给一个对于的基本数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始类型: boolean，char，byte，short，int，long，float，double</span><br><span class="line">包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</span><br></pre></td></tr></table></figure>
<p>包装类还可以实现基本类型变量和字符串之间的转换，把字符串类型转换为<br>基本类型有两种方式</p>
<ul>
<li>parseXxx(String s) 静态方法</li>
<li>valueOf(String s) 静态方法</li>
</ul>
<h3 id="自动装箱和拆箱的本质是什么？"><a href="#自动装箱和拆箱的本质是什么？" class="headerlink" title="自动装箱和拆箱的本质是什么？"></a>自动装箱和拆箱的本质是什么？</h3><p>在装箱的时候自动调用的是Integer的valueOf()方法，在拆箱的时候自动调<br>用的是Integer的intValue()方法，注意valueOf方法本质是new Integer<br>，在-128到127时会直接引用已经创建好的Integer对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= Integer.IntegerCache.high ? </span><br><span class="line">        Integer.IntegerCache.cache[i + <span class="number">128</span>] : <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//先判断类型是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value == (Integer)obj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于Integer==int类似的比较，即两个操作数中有一个是int的情况, 比较的<br>是数值是否相等（即Integer类型的那个对象会触发自动拆箱的过程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Integer a = <span class="number">1</span>;</span><br><span class="line">       Integer b = <span class="number">2</span>;</span><br><span class="line">       Integer c = <span class="number">3</span>;</span><br><span class="line">       Integer d = <span class="number">3</span>;</span><br><span class="line">       Integer e = <span class="number">321</span>;</span><br><span class="line">       Integer f = <span class="number">321</span>;</span><br><span class="line">       Long g = <span class="number">3L</span>;</span><br><span class="line">       Long h = <span class="number">2L</span>;</span><br><span class="line">       System.out.println(c==d); <span class="comment">//true</span></span><br><span class="line">       System.out.println(e==f); <span class="comment">//false</span></span><br><span class="line">       System.out.println(c==(a+b)); <span class="comment">//true</span></span><br><span class="line">       System.out.println(c.equals(a+b)); <span class="comment">//true</span></span><br><span class="line">       System.out.println(g==(a+b)); <span class="comment">//true</span></span><br><span class="line">       System.out.println(g.equals(a+b)); <span class="comment">//false，类型都不一样</span></span><br><span class="line">       System.out.println(g.equals(a+h)); <span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类是什么？"><a href="#抽象类是什么？" class="headerlink" title="抽象类是什么？"></a>抽象类是什么？</h3><p>抽象方法和抽象类必须用abstract修饰，有抽象方法的类只能被定义为抽象<br>类，抽象类里可以没有抽象方法，提供方法但是不提供具体实现，这就是抽<br>象方法。抽象类是从多个具体类中抽象出来的父类，具有更高的抽象层次，<br>抽象类就相当于子类的模板，体现一种模板模式的设计</p>
<h3 id="抽象类的特点有哪些？"><a href="#抽象类的特点有哪些？" class="headerlink" title="抽象类的特点有哪些？"></a>抽象类的特点有哪些？</h3><ol>
<li>抽象类不能实例化，无法使用new关键字来调用抽象类的构造器，但是可<br>以被子类继承</li>
<li>抽象类可以包含成员变量、方法（普通方法和抽象方法）、构造器、初始化<br>块，内部类等。构造器是由子类调用而不是创建实例</li>
<li>包含抽象方法的类（直接定义一个抽象方法、继承一个抽象类但没有完全<br>实现父类包含的抽象方法、实现一个接口但没有完全实现接口中的方法）只<br>能被定义为抽象类</li>
<li>static和abstract不能修饰一个方法，但是可以修饰一个内部类</li>
<li>final和abstract不能同时使用，private和abstract也不能同时使用</li>
</ol>
<h3 id="抽象类能使用final修饰吗？"><a href="#抽象类能使用final修饰吗？" class="headerlink" title="抽象类能使用final修饰吗？"></a>抽象类能使用final修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继<br>承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<h3 id="接口是什么？有哪些特点？"><a href="#接口是什么？有哪些特点？" class="headerlink" title="接口是什么？有哪些特点？"></a>接口是什么？有哪些特点？</h3><p>接口实际上是一种更为特殊的抽象类，只提供实现类需要实现的方法。Java9对接口<br>进行了改进，允许接口定义默认方法和类方法，并且都可以提供具体实现，还增加<br>了私有方法，也可以提供具体实现</p>
<ol>
<li>接口的修饰符可以是public或者省略，如果省略就是默认包访问权限</li>
<li>一个接口可以有多个父接口，只能继承接口不能继承类</li>
<li>接口中不能有构造器和初始化块</li>
<li>接口里的成员变量只能是静态变量</li>
<li>接口定义的是多个类共同的行为规范，所以接口里的常量、方法、内部类<br>和内部枚举都是public访问权限，定义接口成员时可以省略访问修饰符，<br>如果显示指定只能是public</li>
<li>接口里的方法只能是抽象方法、默认方法、类方法或私有方法，如果不是默<br>认类或私有方法，系统会自动为普通方法增加abstract修饰符，所以普通方<br>法总是使用 public abstract 修饰，其他方法必须有方法体</li>
<li>接口里的内部类、内部接口和内部枚举默认使用 public static 修饰</li>
</ol>
<h3 id="如何使用接口？"><a href="#如何使用接口？" class="headerlink" title="如何使用接口？"></a>如何使用接口？</h3><p>接口不能创建实例，但是接口可以声明为引用类型变量，这个引用类型变量必须<br>引用到其实现类的对象，一个类可以实现多个接口，必须实现接口中的所以抽象<br>方法，否则就会定义为抽象类，一个类可以继承父类并实现多个接口，extends<br>必须放在implements之前</p>
<h3 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h3><p>在某些情况下把一个类放在另一个类的内部定义，这个定义在其他类的内部的类就<br>是内部类，包含内部类的类也称为外部类。内部类可以分为四种：成员内部类、局<br>部内部类、匿名内部类和静态内部类</p>
<ol>
<li>静态内部类 定义在类内部的静态类，就是静态内部类，可以包括静态和非静<br>态成员，静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静<br>态变量</li>
<li>成员内部类 定义在类内部，成员位置上的非静态类，就是成员内部类，成员<br>内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成<br>员内部类依赖于外部类的实例</li>
<li>局部内部类 定义在方法中的内部类，就是局部内部类，定义在实例方法中的<br>局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问<br>外部类的静态变量和方法</li>
<li>匿名内部类 匿名内部类就是没有名字的内部类，适合创建那种只需要使用一<br>次的类</li>
</ol>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口</li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为final</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象<br>方法</li>
</ul>
<h3 id="内部类的优点有哪些？"><a href="#内部类的优点有哪些？" class="headerlink" title="内部类的优点有哪些？"></a>内部类的优点有哪些？</h3><ol>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷</li>
<li>匿名内部类可以很方便的定义回调</li>
</ol>
<h3 id="内部类有哪些应用场景？"><a href="#内部类有哪些应用场景？" class="headerlink" title="内部类有哪些应用场景？"></a>内部类有哪些应用场景？</h3><ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展</li>
<li>当某个类除了它的外部类，不再被其他的类使用时</li>
</ol>
<h3 id="Lambda表达式的作用？"><a href="#Lambda表达式的作用？" class="headerlink" title="Lambda表达式的作用？"></a>Lambda表达式的作用？</h3><p>Lambda表达式支持将代码块作为方法参数，Lambda允许使用更简洁的代码来<br>创建只有一个抽象方法的接口（这种接口被称为函数式接口）实例</p>
<ul>
<li>形参列表允许省略形参类型，如果形参只有一个参数那么圆括号也可以省略</li>
<li>箭头 -&gt;</li>
<li>如果方法体中只有一条返回语句则可以省略花括号，return也可以省略，会<br>自动返回这条语句的值</li>
</ul>
<p>Lambda表达式的目标类型必须是函数式接口，一个函数式接口代表只含一个抽<br>象方法的接口，可以包含多个默认方法和类方法，但是只能有一个抽象方法</p>
<h3 id="内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="内部类访问局部变量的时候，为什么变量必须要加上final？"></a>内部类访问局部变量的时候，为什么变量必须要加上final？</h3><p>是因为生命周期不一致，局部变量直接存储在栈中，当方法执行结束后，非<br>final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如<br>果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内<br>部类使用的变量与外层的局部变量区分开，解决了这个问题</p>
<h3 id="重写与重载的区别是什么？"><a href="#重写与重载的区别是什么？" class="headerlink" title="重写与重载的区别是什么？"></a>重写与重载的区别是什么？</h3><ol>
<li>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个<br>数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能<br>根据返回类型进行区分</li>
<li>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父<br>类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）<br>，如果父类方法访问修饰符为private则子类中就不是重写</li>
</ol>
<h3 id="和equals的区别是什么？"><a href="#和equals的区别是什么？" class="headerlink" title="==和equals的区别是什么？"></a>==和equals的区别是什么？</h3><ol>
<li>== 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是<br>不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型==比较<br>的是内存地址)</li>
<li>equals() 它的作用也是判断两个对象是否相等。但它一般有两种使用<br>情况</li>
</ol>
<ul>
<li>没有覆盖equals()方法。比较该类的两个对象时，等价于通过==比较这<br>两个对象</li>
<li>类覆盖了equals()方法。一般我们都覆盖equals()方法来两个对象的内<br>容相等，若它们的内容相等，则返回true</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>JAVA集合总结</span></a></div><div class="next-post pull-right"><a href="/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><span>刷题总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/01/30/JAVA基础总结/';
  this.page.title = 'JAVA基础总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>