<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JAVA基础总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>JAVA基础总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题"><span class="toc-number">2.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA的三大版本是什么？"><span class="toc-number">2.1.</span> <span class="toc-text">JAVA的三大版本是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM、JRE和JDK的关系是什么？"><span class="toc-number">2.2.</span> <span class="toc-text">JVM、JRE和JDK的关系是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle-JDK-和OpenJDK-的区别是什么？"><span class="toc-number">2.3.</span> <span class="toc-text">Oracle JDK 和OpenJDK 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是跨平台性？原理是什么？"><span class="toc-number">2.4.</span> <span class="toc-text">什么是跨平台性？原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译型语言和解释型语言的区别？"><span class="toc-number">2.5.</span> <span class="toc-text">编译型语言和解释型语言的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java语言有哪些特点？"><span class="toc-number">2.6.</span> <span class="toc-text">Java语言有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java与C-的相同和不同？"><span class="toc-number">2.7.</span> <span class="toc-text">Java与C++的相同和不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是字节码？采用字节码的好处是什么？"><span class="toc-number">2.8.</span> <span class="toc-text">什么是字节码？采用字节码的好处是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的三大特征分别是什么？"><span class="toc-number">2.9.</span> <span class="toc-text">面向对象的三大特征分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象和面向过程的区别？"><span class="toc-number">2.10.</span> <span class="toc-text">面向对象和面向过程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类和对象的区别？"><span class="toc-number">2.11.</span> <span class="toc-text">类和对象的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-有哪些数据类型？"><span class="toc-number">2.12.</span> <span class="toc-text">Java 有哪些数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型的转换情况有哪些？"><span class="toc-number">2.13.</span> <span class="toc-text">基本数据类型的转换情况有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动类型转换和强制类型转换的区别？"><span class="toc-number">2.14.</span> <span class="toc-text">自动类型转换和强制类型转换的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA采用何种编码？"><span class="toc-number">2.15.</span> <span class="toc-text">JAVA采用何种编码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char可以存储汉字吗"><span class="toc-number">2.16.</span> <span class="toc-text">char可以存储汉字吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机字符串是如何生成的？"><span class="toc-number">2.17.</span> <span class="toc-text">随机字符串是如何生成的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符型常量和字符串常量的区别？"><span class="toc-number">2.18.</span> <span class="toc-text">字符型常量和字符串常量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是字符串常量池？"><span class="toc-number">2.19.</span> <span class="toc-text">什么是字符串常量池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch的格式是什么样的？"><span class="toc-number">2.20.</span> <span class="toc-text">switch的格式是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break-continue-return-的区别及作用？"><span class="toc-number">2.21.</span> <span class="toc-text">break continue return 的区别及作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组初始化的几种形式有哪些？"><span class="toc-number">2.22.</span> <span class="toc-text">数组初始化的几种形式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach是什么？"><span class="toc-number">2.23.</span> <span class="toc-text">foreach是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个类中有哪些常见的成员？"><span class="toc-number">2.24.</span> <span class="toc-text">一个类中有哪些常见的成员？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法签名是什么？"><span class="toc-number">2.25.</span> <span class="toc-text">方法签名是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-注解是什么？"><span class="toc-number">2.26.</span> <span class="toc-text">Java 注解是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-注解有什么作用？"><span class="toc-number">2.27.</span> <span class="toc-text">Java 注解有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元注解是什么？"><span class="toc-number">2.28.</span> <span class="toc-text">元注解是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注解的本质是什么？"><span class="toc-number">2.29.</span> <span class="toc-text">注解的本质是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this的作用"><span class="toc-number">2.30.</span> <span class="toc-text">this的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问修饰符有哪些？区别是什么？"><span class="toc-number">2.31.</span> <span class="toc-text">访问修饰符有哪些？区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-和-amp-amp-的区别是什么？"><span class="toc-number">2.32.</span> <span class="toc-text">&amp;和&amp;&amp;的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的继承关系是什么样的？"><span class="toc-number">2.33.</span> <span class="toc-text">类的继承关系是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写父类方法时注意什么？"><span class="toc-number">2.34.</span> <span class="toc-text">重写父类方法时注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final有什么用？"><span class="toc-number">2.35.</span> <span class="toc-text">final有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system-exit-1-和-system-exit-0-？"><span class="toc-number">2.36.</span> <span class="toc-text">system.exit(1) 和 system.exit(0)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-finally-finalize的区别是什么？"><span class="toc-number">2.37.</span> <span class="toc-text">final finally finalize的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super的用法是什么？"><span class="toc-number">2.38.</span> <span class="toc-text">super的用法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super和this的区别是什么？"><span class="toc-number">2.39.</span> <span class="toc-text">super和this的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-的作用是什么？"><span class="toc-number">2.40.</span> <span class="toc-text">static 的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java静态变量、代码块、和静态方法的执行顺序是什么？"><span class="toc-number">2.41.</span> <span class="toc-text">Java静态变量、代码块、和静态方法的执行顺序是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态是什么意思？"><span class="toc-number">2.42.</span> <span class="toc-text">多态是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态的实现原则是什么？"><span class="toc-number">2.43.</span> <span class="toc-text">多态的实现原则是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof运算符的用法？"><span class="toc-number">2.44.</span> <span class="toc-text">instanceof运算符的用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装箱和拆箱是什么意思？"><span class="toc-number">2.45.</span> <span class="toc-text">自动装箱和拆箱是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型和包装类型的区别？"><span class="toc-number">2.46.</span> <span class="toc-text">基本类型和包装类型的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装箱和拆箱的本质是什么？"><span class="toc-number">2.47.</span> <span class="toc-text">自动装箱和拆箱的本质是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类是什么？"><span class="toc-number">2.48.</span> <span class="toc-text">抽象类是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类的特点有哪些？"><span class="toc-number">2.49.</span> <span class="toc-text">抽象类的特点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类能使用final修饰吗？"><span class="toc-number">2.50.</span> <span class="toc-text">抽象类能使用final修饰吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口是什么？有哪些特点？"><span class="toc-number">2.51.</span> <span class="toc-text">接口是什么？有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用接口？"><span class="toc-number">2.52.</span> <span class="toc-text">如何使用接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类和接口的区别？"><span class="toc-number">2.53.</span> <span class="toc-text">抽象类和接口的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是内部类？"><span class="toc-number">2.54.</span> <span class="toc-text">什么是内部类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类的优点有哪些？"><span class="toc-number">2.55.</span> <span class="toc-text">内部类的优点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类有哪些应用场景？"><span class="toc-number">2.56.</span> <span class="toc-text">内部类有哪些应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda表达式的作用？"><span class="toc-number">2.57.</span> <span class="toc-text">Lambda表达式的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类访问局部变量的时候，为什么变量必须要加上final？"><span class="toc-number">2.58.</span> <span class="toc-text">内部类访问局部变量的时候，为什么变量必须要加上final？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写与重载的区别是什么？"><span class="toc-number">2.59.</span> <span class="toc-text">重写与重载的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和equals的区别是什么？"><span class="toc-number">2.60.</span> <span class="toc-text">&#x3D;&#x3D;和equals的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals-的特性？"><span class="toc-number">2.61.</span> <span class="toc-text">equals 的特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍下hashCode-？"><span class="toc-number">2.62.</span> <span class="toc-text">介绍下hashCode()？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深拷贝和浅拷贝的区别？"><span class="toc-number">2.63.</span> <span class="toc-text">深拷贝和浅拷贝的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化和反序列化的区别？"><span class="toc-number">2.64.</span> <span class="toc-text">序列化和反序列化的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是serialVersionUID？"><span class="toc-number">2.65.</span> <span class="toc-text">什么是serialVersionUID？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么还要显示指定serialVersionUID的值？"><span class="toc-number">2.66.</span> <span class="toc-text">为什么还要显示指定serialVersionUID的值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serialVersionUID的作用？"><span class="toc-number">2.67.</span> <span class="toc-text">serialVersionUID的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serialVersionUID什么时候修改？"><span class="toc-number">2.68.</span> <span class="toc-text">serialVersionUID什么时候修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-序列化中如果有些字段不想进行序列化，怎么办？"><span class="toc-number">2.69.</span> <span class="toc-text">Java 序列化中如果有些字段不想进行序列化，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化的作用是什么？"><span class="toc-number">2.70.</span> <span class="toc-text">序列化的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO流有哪几种？"><span class="toc-number">2.71.</span> <span class="toc-text">IO流有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节流如何转为字符流？"><span class="toc-number">2.72.</span> <span class="toc-text">字节流如何转为字符流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符流与字节流的区别？"><span class="toc-number">2.73.</span> <span class="toc-text">字符流与字节流的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是阻塞IO？什么是非阻塞IO？"><span class="toc-number">2.74.</span> <span class="toc-text">什么是阻塞IO？什么是非阻塞IO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步IO和异步IO的区别？"><span class="toc-number">2.75.</span> <span class="toc-text">同步IO和异步IO的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-NIO-AIO-有什么区别？"><span class="toc-number">2.76.</span> <span class="toc-text">BIO,NIO,AIO 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO都有哪些设计模式？"><span class="toc-number">2.77.</span> <span class="toc-text">Java IO都有哪些设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化的过程？"><span class="toc-number">2.78.</span> <span class="toc-text">序列化的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反序列化的过程？"><span class="toc-number">2.79.</span> <span class="toc-text">反序列化的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的泛型是什么？"><span class="toc-number">2.80.</span> <span class="toc-text">Java中的泛型是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的好处？"><span class="toc-number">2.81.</span> <span class="toc-text">泛型的好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java泛型的原理是什么？"><span class="toc-number">2.82.</span> <span class="toc-text">Java泛型的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型翻译是什么？"><span class="toc-number">2.83.</span> <span class="toc-text">泛型翻译是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是类型擦除？"><span class="toc-number">2.84.</span> <span class="toc-text">什么是类型擦除？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是泛型中的限定通配符和非限定通配符？"><span class="toc-number">2.85.</span> <span class="toc-text">什么是泛型中的限定通配符和非限定通配符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别？"><span class="toc-number">2.86.</span> <span class="toc-text">List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可以把List-lt-String-gt-传递给一个接受List-lt-Object-gt-参数的方法吗？"><span class="toc-number">2.87.</span> <span class="toc-text">可以把List&lt;String&gt;传递给一个接受List&lt;Object&gt;参数的方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断ArrayList-lt-String-gt-与ArrayList-lt-Integer-gt-是否相等？"><span class="toc-number">2.88.</span> <span class="toc-text">判断ArrayList&lt;String&gt;与ArrayList&lt;Integer&gt;是否相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-创建对象有哪几种方式？"><span class="toc-number">2.89.</span> <span class="toc-text">Java 创建对象有哪几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是不可变对象？"><span class="toc-number">2.90.</span> <span class="toc-text">什么是不可变对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#能否创建一个包含可变对象的不可变对象？"><span class="toc-number">2.91.</span> <span class="toc-text">能否创建一个包含可变对象的不可变对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是反射机制？"><span class="toc-number">2.92.</span> <span class="toc-text">什么是反射机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射机制的优缺点有哪些？"><span class="toc-number">2.93.</span> <span class="toc-text">反射机制的优缺点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射机制的应用场景有哪些？"><span class="toc-number">2.94.</span> <span class="toc-text">反射机制的应用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的加载过程是什么样的？"><span class="toc-number">2.95.</span> <span class="toc-text">类的加载过程是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的初始化过程？"><span class="toc-number">2.96.</span> <span class="toc-text">类的初始化过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类初始化的时机有哪几种？"><span class="toc-number">2.97.</span> <span class="toc-text">类初始化的时机有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java获取Class对象的三种方法？"><span class="toc-number">2.98.</span> <span class="toc-text">Java获取Class对象的三种方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java反射API有几类？"><span class="toc-number">2.99.</span> <span class="toc-text">Java反射API有几类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射的步骤？"><span class="toc-number">2.100.</span> <span class="toc-text">反射的步骤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何从Class中获取构造器有几种方式？"><span class="toc-number">2.101.</span> <span class="toc-text">如何从Class中获取构造器有几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何通过反射操作对象？"><span class="toc-number">2.102.</span> <span class="toc-text">如何通过反射操作对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射机制的原理是什么？"><span class="toc-number">2.103.</span> <span class="toc-text">反射机制的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是异常？"><span class="toc-number">2.104.</span> <span class="toc-text">什么是异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常分为几类？"><span class="toc-number">2.105.</span> <span class="toc-text">异常分为几类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-和-Exception-区别是什么？"><span class="toc-number">2.106.</span> <span class="toc-text">Error 和 Exception 区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时异常和受检查异常区别是什么？"><span class="toc-number">2.107.</span> <span class="toc-text">运行时异常和受检查异常区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何处理异常？"><span class="toc-number">2.108.</span> <span class="toc-text">如何处理异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally是什么？"><span class="toc-number">2.109.</span> <span class="toc-text">finally是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw-和throws-的区别是什么？"><span class="toc-number">2.110.</span> <span class="toc-text">throw 和throws 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoClassDefFoundError-和ClassNotFoundException-区别？"><span class="toc-number">2.111.</span> <span class="toc-text">NoClassDefFoundError 和ClassNotFoundException 区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-finally-中哪个部分可以省略？"><span class="toc-number">2.112.</span> <span class="toc-text">try-catch-finally 中哪个部分可以省略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-finally，如果catch中return了，finally还会执行吗？"><span class="toc-number">2.113.</span> <span class="toc-text">try-catch-finally，如果catch中return了，finally还会执行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-是如何处理异常的？"><span class="toc-number">2.114.</span> <span class="toc-text">JVM 是如何处理异常的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-StringBuffer-StringBuilder的区别是什么？"><span class="toc-number">2.115.</span> <span class="toc-text">String StringBuffer StringBuilder的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String为什么要设计成不可变的？"><span class="toc-number">2.116.</span> <span class="toc-text">String为什么要设计成不可变的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接赋予一个字符串和new-String一样吗？"><span class="toc-number">2.117.</span> <span class="toc-text">直接赋予一个字符串和new String一样吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intern-函数的作用？"><span class="toc-number">2.118.</span> <span class="toc-text">intern()函数的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有了解过Java中的NIO吗？原理是什么？"><span class="toc-number">2.119.</span> <span class="toc-text">有了解过Java中的NIO吗？原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC具体过程"><span class="toc-number">2.120.</span> <span class="toc-text">RPC具体过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC用到的技术？"><span class="toc-number">2.121.</span> <span class="toc-text">RPC用到的技术？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从用户输入密码到密码存储到登录密码校验的整个流程？"><span class="toc-number">2.122.</span> <span class="toc-text">从用户输入密码到密码存储到登录密码校验的整个流程？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">75</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JAVA基础总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/30/JAVA基础总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://thinkwon.blog.csdn.net/article/details/104390612" target="_blank" rel="noopener">https://thinkwon.blog.csdn.net/article/details/104390612</a></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="JAVA的三大版本是什么？"><a href="#JAVA的三大版本是什么？" class="headerlink" title="JAVA的三大版本是什么？"></a>JAVA的三大版本是什么？</h3><p>Java分为三个版本</p>
<ul>
<li>Java SE Standard Edition(标准版) 包含那些构成Java语言核心的类，数据<br>库连接、接口定义、输入/输出、网络编程</li>
<li>Java EE Enterprise Edition(企业版) 包含Java SE 中的类，并且还包含用<br>于开发企业级应用的类，例如EJB、servlet、JSP、XML、事务控制</li>
<li>Java ME Micro Edition(微缩版) 包含Java SE中一部分类，用于消费类电子<br>产品的软件开发，例如呼机、智能卡、手机、PDA、机顶盒</li>
</ul>
<h3 id="JVM、JRE和JDK的关系是什么？"><a href="#JVM、JRE和JDK的关系是什么？" class="headerlink" title="JVM、JRE和JDK的关系是什么？"></a>JVM、JRE和JDK的关系是什么？</h3><p>JDK包含JRE，JRE包含JVM</p>
<ol>
<li>JVM Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，<br>不同的平台有自己的虚拟机，因此Java语言可以实现跨平台</li>
<li>JRE Java Runtime Environment包括Java 虚拟机和Java 程序所需的<br>核心类库等。核心类库主要是java.lang包：包含了运行Java 程序必不可少<br>的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理<br>类等，系统缺省加载这个包，如果想要运行一个已编译的Java程序，计<br>算机中只需要安装JRE即可</li>
<li>JDK Java Development Kit是提供给Java开发人员使用的，其中包含了<br>Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。<br>其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</li>
</ol>
<h3 id="Oracle-JDK-和OpenJDK-的区别是什么？"><a href="#Oracle-JDK-和OpenJDK-的区别是什么？" class="headerlink" title="Oracle JDK 和OpenJDK 的区别是什么？"></a>Oracle JDK 和OpenJDK 的区别是什么？</h3><ol>
<li>Oracle JDK 版本将每三年发布一次，而OpenJDK 版本每三个月发布一次</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是OpenJDK<br>的一个实现，并不是完全开源的</li>
<li>在响应性和JVM 性能方面，Oracle JDK 与OpenJDK 相比提供了更好的性能</li>
</ol>
<h3 id="什么是跨平台性？原理是什么？"><a href="#什么是跨平台性？原理是什么？" class="headerlink" title="什么是跨平台性？原理是什么？"></a>什么是跨平台性？原理是什么？</h3><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运<br>行。实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以<br>安装相应的java虚拟机，该系统就可以运行java程序</p>
<h3 id="编译型语言和解释型语言的区别？"><a href="#编译型语言和解释型语言的区别？" class="headerlink" title="编译型语言和解释型语言的区别？"></a>编译型语言和解释型语言的区别？</h3><ol>
<li>编译型语言 指使用专门的编译器，针对特定平台（操作系统）将某种高级<br>语言源代码一次性”翻译”成可被该平台硬件执行的机器码（包括机器指令和<br>操作数），并包装成该平台所能识别的可执行性程序的格式，这个转换过程<br>称为编译（Compile）编译生成的可执行性程序可以脱离开发环境，在特定<br>的平台上独运行。运行时不需要重新翻译，直接使用编译的结果就行了。C<br>C++ Objective-C Swift kotlin</li>
<li>解释型语言 先编译成一种与平台无关的字节码文件，然后在运行时由解<br>释器翻译成特定机器码执行</li>
</ol>
<h3 id="Java语言有哪些特点？"><a href="#Java语言有哪些特点？" class="headerlink" title="Java语言有哪些特点？"></a>Java语言有哪些特点？</h3><ol>
<li>Java是半编译半解释型语言 因为Java虚拟机既有解释器也有JIT即时编译<br>器，JIT即时编译器能够捕获程序中的热点代码，编译成机器码缓存起来存入<br>方法区中，当遇到相同的代码时，不必再去使用解释器翻译，直接去找对应<br>的机器码执行</li>
<li>Java 完全支持面向对象的三种基本特征:继承、封装和多态。Java语言完全以<br>对象为中心，Java程序的最小程序单位是类，整个Java程序是由一个个类组成</li>
<li>Java是一门强类型语言，强类型包括两个方面</li>
</ol>
<ul>
<li>所有的变量必须先声明、后使用</li>
<li>指定类型的变量只能接受类型与之匹配的值，强类型语言可以在编译过程中<br>发现源代码的错误 ，从而保证程序更加健壮</li>
</ul>
<ol start="4">
<li>一次编写，到处运行，具有很好的可移植性</li>
<li>支持多线程。C++ 语言没有内置的多线程机制，因此必须调用操作系统的多<br>线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持</li>
<li>支持网络编程并且很方便。Java 语言诞生本身就是为简化网络编程设计的，<br>因此Java 语言不仅支持网络编程而且很方便</li>
</ol>
<h3 id="Java与C-的相同和不同？"><a href="#Java与C-的相同和不同？" class="headerlink" title="Java与C++的相同和不同？"></a>Java与C++的相同和不同？</h3><ol>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>C++ 支持指针，而 Java 没有指针的概念</li>
<li>C++ 支持多继承，而Java 不支持多重继承，但允许一个类实现多个接口</li>
<li>Java 自动进行无用内存回收操作，不再需要程序员进行手动删除，而C++<br>中必须由程序释放内存资源，这就增加了程序员的负担</li>
<li>Java 不支持操作符重载，操作符重载则被认为是C++ 的突出特征</li>
<li>Java 取消了C/C++ 中的结构和联合，使编译程序更加简洁</li>
<li>C 和C++ 不支持字符串变量，在C 和C++ 程序中使用“Null”终止符代表字<br>符串的结束。在Java 中字符串是用类对象（String和StringBuffer）来实现</li>
</ol>
<h3 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h3><p>字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单<br>位进行读取。在Java 中一般是用javac 命令编译源代码为字节码文件</p>
<h3 id="面向对象的三大特征分别是什么？"><a href="#面向对象的三大特征分别是什么？" class="headerlink" title="面向对象的三大特征分别是什么？"></a>面向对象的三大特征分别是什么？</h3><ul>
<li>封装 将对象的实现细节隐藏起来，通过一些公用方法暴露对象的功能</li>
<li>继承 子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和<br>方法</li>
<li>多态 子类对象可以直接赋给父类对象，但运行时表现为子类的行为特征，<br>也是说同一个类型的对象执行同一个方法，表现不同行为特征</li>
</ul>
<h3 id="面向对象和面向过程的区别？"><a href="#面向对象和面向过程的区别？" class="headerlink" title="面向对象和面向过程的区别？"></a>面向对象和面向过程的区别？</h3><ol>
<li>面向过程 性能比面向对象高，因为类调用时需要实例化，开销比较大，<br>比较消耗资源。比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程<br>开发，性能是最重要的因素</li>
<li>面向对象 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的<br>特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li>
</ol>
<h3 id="类和对象的区别？"><a href="#类和对象的区别？" class="headerlink" title="类和对象的区别？"></a>类和对象的区别？</h3><p>具有相同或相似性质的一组对象的抽象就是类，类是对一类事物的描述，对象是<br>实际存在的该类事物的个体，也叫实例。用class定义类，用new创建类的对象</p>
<h3 id="Java-有哪些数据类型？"><a href="#Java-有哪些数据类型？" class="headerlink" title="Java 有哪些数据类型？"></a>Java 有哪些数据类型？</h3><p>Java语言支持的类型分为两类:基本类型和引用类型</p>
<ol>
<li>基本类型包括 boolean类型和数值类型。数值类型有整数类型和浮点类型。<br>整数类型包括byte short int long char，浮点类型包括float double <img src="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/1.jpg" alt></li>
<li>引用类型 包括类、接口和数组类型，还有一种特殊的 null 类型所谓引<br>用数据类型就是对一个对象的引用，对象包括实例和数组两种。实际上引用<br>类型变量就是一个指针，只是Java语言里不再使用指针这个说法，空引用<br>（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个<br>null值赋给基本数据类型的变量</li>
</ol>
<h3 id="基本数据类型的转换情况有哪些？"><a href="#基本数据类型的转换情况有哪些？" class="headerlink" title="基本数据类型的转换情况有哪些？"></a>基本数据类型的转换情况有哪些？</h3><ol>
<li>如果直接将一个较小的整数值(在 byte short类型的表数范围内〉赋给byte<br>short变量系统会自动把这个整数值当成byte或者short类型来处理</li>
<li>如果使用一个巨大的整数值(超出了int类型的表数范围)时Java不会自动把<br>这个整数值当成long 类型来处理。如果希望系统把一个整数值当成long类型<br>来处理，应在这个整数值后增加L或者l作为后缀。通常推荐使用L</li>
<li>Java语言的默认浮点类型是double类型，double占8个字节，float占4个<br>字节如果希望将一个浮点数当成float，在浮点数值后加f或F，浮点数必须要<br>有小数点</li>
</ol>
<h3 id="自动类型转换和强制类型转换的区别？"><a href="#自动类型转换和强制类型转换的区别？" class="headerlink" title="自动类型转换和强制类型转换的区别？"></a>自动类型转换和强制类型转换的区别？</h3><ol>
<li>自动类型转换 表数范围小的可以向表数范围大的自动转换 <img src="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/2.jpg" alt><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="comment">// int 类型可以自动转换为 float 类型</span></span><br><span class="line"><span class="keyword">float</span> f = a ; </span><br><span class="line"><span class="comment">// 下面将输出 6.0</span></span><br><span class="line">System.out.println(f); </span><br><span class="line"><span class="comment">// 定义 byte 类型的整数变量</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">9</span> ; </span><br><span class="line"><span class="comment">// 下面代码将出错，byte 类型不能自动类型转换为 char 类型</span></span><br><span class="line"><span class="comment">// char c = b; </span></span><br><span class="line"><span class="comment">// byte 类型变量可以自动类型转换为 double 类型</span></span><br><span class="line"><span class="keyword">double</span> d = b ; </span><br><span class="line"><span class="comment">// 下面将输出 9.0</span></span><br><span class="line"><span class="function">System out <span class="title">printl</span> <span class="params">(d)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于1是int类型，因此s1+1运算结果也是int型，需要强制转换类型才能赋值给short型</span></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>; </span><br><span class="line">s1 = s1 + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//可以正确编译，因为 s1+=1;相当于s1 = (short(s1 + 1);其中有隐含的强制类型转换。</span></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>浮点数强制转换为整数时会截断浮点数的小数部分<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iValue = <span class="number">233</span>; </span><br><span class="line"><span class="comment">// 强制把一个 int 类型的值转换为 byte 类型 的值</span></span><br><span class="line"><span class="keyword">byte</span> bValue = (<span class="keyword">byte</span>)iValue; </span><br><span class="line"><span class="comment">// 将输出 -23</span></span><br><span class="line">System.out.println(bValue) ; </span><br><span class="line"><span class="keyword">double</span> dValue = <span class="number">3.98</span> ; </span><br><span class="line"><span class="comment">// 强制把 double 类型的值转换为 int 类型的值</span></span><br><span class="line"><span class="keyword">int</span> tol = (<span class="keyword">int</span>)dValue</span><br><span class="line"><span class="comment">// 将输出3</span></span><br><span class="line">System.out.println(tol);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="JAVA采用何种编码？"><a href="#JAVA采用何种编码？" class="headerlink" title="JAVA采用何种编码？"></a>JAVA采用何种编码？</h3><p>这里Java文件的编码可能有多种多样，但Java编译器会自动将这些编码按照<br>Java文件的编码格式正确读取后产生class文件，这里的class文件编码是<br>Unicode编码（具体说是UTF-16编码）</p>
<h3 id="char可以存储汉字吗"><a href="#char可以存储汉字吗" class="headerlink" title="char可以存储汉字吗"></a>char可以存储汉字吗</h3><p>char是按照字符存储的，不管英文还是中文，固定占用占用2个字节，用来储<br>存Unicode字符</p>
<h3 id="随机字符串是如何生成的？"><a href="#随机字符串是如何生成的？" class="headerlink" title="随机字符串是如何生成的？"></a>随机字符串是如何生成的？</h3><p>首先可以随机生成一个指定范围的int数字，例如生成一个小写字母就是在97<br>~122之间，然后强制转换为char类型，将这些字符拼接起来就是一个验证<br>字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个空字符串</span></span><br><span class="line">String resu1t = <span class="string">""</span>; </span><br><span class="line"><span class="comment">//进行6次循</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i ++) </span><br><span class="line"><span class="comment">//生成一个 97-122 间的 int 类型整数</span></span><br><span class="line"><span class="keyword">int</span> intVa1 = (<span class="keyword">int</span>) (Math.random() * <span class="number">26</span> + <span class="number">97</span>); </span><br><span class="line"><span class="comment">//将 intVa  强制转换为 char 类型后连接到 resu1t 后面</span></span><br><span class="line">result = result + (<span class="keyword">char</span>)intVal; </span><br><span class="line"><span class="comment">//输出随机字符串</span></span><br><span class="line">System.out.print1n(resu1t);</span><br></pre></td></tr></table></figure>

<h3 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h3><ol>
<li>形式上: 字符常量是单引号引起的一个字符，字符串常量是双引号引起<br>的若干个字符</li>
<li>含义上: 字符常量相当于一个整型值(ASCII值)，可以参加表达式运算，<br>字符串常量代表一个地址值(该字符串在内存中存放位置，相当于对象占</li>
<li>内存大小：字符常量只占2个字节；字符串常量占若干个字节(至少一个<br>字符结束标志) (注意: char 在Java中占两个字节)</li>
</ol>
<h3 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h3><p>Java中常量池的概念主要有三个：全局字符串常量池，class文件常量池，<br>运行时常量池</p>
<ol>
<li>全局字符串常量池 jvm 为了提升性能和减少内存开销，避免字符的重复<br>创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，<br>先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，<br>如果不存在，初始化，并将该字符串放入字符串常量池中</li>
<li>class文件常量池 用于存放编译器生成的各种字面量(Literal)和符号<br>引用(Symbolic References )。字面量就是我们所说的常量概念，如文本<br>字符串、被声明为final 的常量值等。符号引用是一组符号来描述所引用的<br>目标，符号可以是任何形式的字面量</li>
<li>运行时常量池 当类加载到内存中后，jvm 就会将class常量池中的内容<br>存放到运行时常量池。将每个class常量池中的符号引用值替换成直接引用</li>
</ol>
<h3 id="switch的格式是什么样的？"><a href="#switch的格式是什么样的？" class="headerlink" title="switch的格式是什么样的？"></a>switch的格式是什么样的？</h3><p>控制表达式的数据类型可以是short byte char int enum string，目前<br>不支持long</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expresson)</span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">case</span> conditionl: </span><br><span class="line">		statement(s) </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> condition2 : </span><br><span class="line">		statement(s) </span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">	<span class="keyword">default</span> : </span><br><span class="line">		statement(s)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="break-continue-return-的区别及作用？"><a href="#break-continue-return-的区别及作用？" class="headerlink" title="break continue return 的区别及作用？"></a>break continue return 的区别及作用？</h3><ol>
<li>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</li>
<li>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环，<br>进入下一个循环条件)</li>
<li>return 程序返回，不再执行下面的代码(结束当前的方法直接返回)</li>
</ol>
<h3 id="数组初始化的几种形式有哪些？"><a href="#数组初始化的几种形式有哪些？" class="headerlink" title="数组初始化的几种形式有哪些？"></a>数组初始化的几种形式有哪些？</h3><ol>
<li>静态初始化 初始化时由程序员显式指定每个数组元素的初始值，由系统<br>决定数组长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line">array=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//或者简写如下</span></span><br><span class="line">array=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li>动态初始化 初始化时程序员只指定数组长度，由系统为数组元素分配初始值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="foreach是什么？"><a href="#foreach是什么？" class="headerlink" title="foreach是什么？"></a>foreach是什么？</h3><p>Java5之后提供了一种比for更简洁的循环，这种循环遍历数组和集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type variablename:array|collection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自动迭代访问每个元素，实际访问的是临时变量而不是数组变量本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个类中有哪些常见的成员？"><a href="#一个类中有哪些常见的成员？" class="headerlink" title="一个类中有哪些常见的成员？"></a>一个类中有哪些常见的成员？</h3><p>类中有三个最常见的成员：构造器、成员变量和方法，static修饰的成员不能<br>访问没有static修饰的成员</p>
<ol>
<li>构造器 构造器是一种特殊的方法，如果一个类没有构造器就无法创建实例<br>，如果不显示创建构造器系统会默认提供一个构造器，否则不提供，通过new<br>来创建构造器返回该类的实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修饰符 可以省略或者是public protected private其中之一</span><br><span class="line">&#x2F;&#x2F;构造器名 必须与类名相同</span><br><span class="line">[修饰符] 构造器名(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;可执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>成员变量 包括基本类型和引用类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修饰符 可以省略，也可以是 public protected private static final</span><br><span class="line">&#x2F;&#x2F;其中public protected private只能出现一个，可以与 static final组合</span><br><span class="line">[修饰符] 类型 成员变量名 [&#x3D;默认值];</span><br></pre></td></tr></table></figure></li>
<li>方法 返回值类型可以是任意类型，包括基本类型和引用类型，也可以是void<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;修饰符可以省略，也可以是public&#x2F;protected&#x2F;private static final&#x2F;abstract</span><br><span class="line">&#x2F;&#x2F;public protected private只能出现一个，final和abstract只能出现一个，可与static组合</span><br><span class="line">[修饰符] 方法返回值类型 方法名(形参列表)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;可执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="方法签名是什么？"><a href="#方法签名是什么？" class="headerlink" title="方法签名是什么？"></a>方法签名是什么？</h3><p>方法声明的两个组件构成了方法签名，方法的名称和参数类型</p>
<h3 id="Java-注解是什么？"><a href="#Java-注解是什么？" class="headerlink" title="Java 注解是什么？"></a>Java 注解是什么？</h3><p>Java 注解用于为Java 代码提供元数据。作为元数据，注解不直接影响你的<br>代码执行，但也有一些类型的注解实际上可以用于这一目的，注解可以放在<br>类或者方法上,在类、方法、成员变量、形参位置</p>
<ol>
<li>自定义注解 自定义注解就是我们自己写的注解</li>
<li>JDK内置注解 @Override @Deprecated</li>
<li>还有第三方框架提供的注解 SpringMVC的 @Controller</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@Override，表示当前的方法定义将覆盖超类中的方法</li>
<li>@Deprecated，如果程序员使用了注解为它的元素，那么编译器会发出警告信息</li>
<li>@SuppressWarnings，关闭不当的编译器警告信息。在java SE5之前的<br>版本中，也可以使用该注解，不过会被忽略不起作用。</li>
</ul>
<h3 id="Java-注解有什么作用？"><a href="#Java-注解有什么作用？" class="headerlink" title="Java 注解有什么作用？"></a>Java 注解有什么作用？</h3><ol>
<li>生成帮助文档</li>
<li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并<br>不是覆盖了超类方法，则编译时就能检查出，@Deprecated标识方法过期</li>
<li>提供信息给编译器 编译器可以利用注解来检测出错误或者警告信息，<br>打印出日志</li>
</ol>
<h3 id="元注解是什么？"><a href="#元注解是什么？" class="headerlink" title="元注解是什么？"></a>元注解是什么？</h3><p>注解的注解，它是作用在注解中，方便我们使用注解实现想要的功能</p>
<ol>
<li>@Retention 表示注解存在阶段是保留在源码（编译期），字节码（类<br>加载）或者运行期（JVM中运行），使用枚举来表示注解保留时期</li>
<li>@Target 表示注解作用的范围可以是类，方法，方法参数变量</li>
<li>@Documented 将注解中的元素包含到 Javadoc 中去</li>
<li>@Inherited 该注解了的注解修饰了一个父类，如果他的子类没有被其<br>他注解修饰，则它的子类也继承了父类的注解</li>
<li>@Repeatable 被这个元注解修饰的注解可以同时作用一个对象多次，但<br>是每次作用注解又可以代表不同的含义</li>
</ol>
<h3 id="注解的本质是什么？"><a href="#注解的本质是什么？" class="headerlink" title="注解的本质是什么？"></a>注解的本质是什么？</h3><p>注解的本质就是一个Annotation接口，可以有属性和方法</p>
<h3 id="this的作用"><a href="#this的作用" class="headerlink" title="this的作用"></a>this的作用</h3><p>实例变量和非静态方法必须通过对象来引用。Java提供了一个this关键字，this关<br>键字总是指向调用该方法的对象，在大部分时候，一个方法访问该类中定义的其他<br>方法、成员变量时加不加this前缀的效果是完全一样的。static定义的方法中不能<br>使用this引用，因此Java语法规定静态成员不能访问非静态成员</p>
<h3 id="访问修饰符有哪些？区别是什么？"><a href="#访问修饰符有哪些？区别是什么？" class="headerlink" title="访问修饰符有哪些？区别是什么？"></a>访问修饰符有哪些？区别是什么？</h3><p>private default protected public</p>
<ol>
<li>private 在同一类内可见。使用对象：变量、方法和构造器。 注意：不能修<br>饰类（外部类），用于修饰成员变量最合适，使用它来修饰成员变量就可以<br>把成员变量隐藏在该类的内部</li>
<li>default 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、<br>方法和构造器。default访问控制的成员或外部类可以被相同包下的其他类访问</li>
<li>protected 对同一包内的类和所有子类可见。使用对象：变量、方法和构造<br>器。注意：不能修饰类（外部类）。 这个成员既可以被同一个包中的其他类<br>访问，也可以被不同包中的子类访问，如果使用protected 来修饰一个方<br>法，通常是希望其子类来重写这个方法。注意不同包下对孙类不可见</li>
<li>public 对所有类可见。使用对象：类、接口、变量、方法</li>
</ol>
<h3 id="amp-和-amp-amp-的区别是什么？"><a href="#amp-和-amp-amp-的区别是什么？" class="headerlink" title="&amp;和&amp;&amp;的区别是什么？"></a>&amp;和&amp;&amp;的区别是什么？</h3><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运<br>算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路<br>运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路<br>掉，不会进行运算</p>
<h3 id="类的继承关系是什么样的？"><a href="#类的继承关系是什么样的？" class="headerlink" title="类的继承关系是什么样的？"></a>类的继承关系是什么样的？</h3><p>每个子类只有一个直接父类，子类可以获得父类的全部成员变量和方法，但是不能<br>获得父类的构造器。如果定义一个类的时候没有指定这个类的直接父类，这个类默<br>认扩展java.lang.Object类</p>
<h3 id="重写父类方法时注意什么？"><a href="#重写父类方法时注意什么？" class="headerlink" title="重写父类方法时注意什么？"></a>重写父类方法时注意什么？</h3><p>方法的重写遵循“两同两小一大”规则。两同指方法名相同、形参列表相同。两小指子<br>类方法的返回值类型比父类返回值类型更小或相同、子类方法抛出的异常比父类抛<br>出的异常更小或相同。一大指子类方法的访问权限比父类更大或相同并且覆盖方法<br>和被覆盖方法必须都是类方法或者实例方法。子类的对象无法调用父类被重写的方<br>法，只能在子类方法中通过super或类来调用父类方法，如果父类中有一个方法是<br>private访问权限，那么子类就不算是重写没有限制</p>
<h3 id="final有什么用？"><a href="#final有什么用？" class="headerlink" title="final有什么用？"></a>final有什么用？</h3><p>用于修饰类、属性和方法</p>
<ul>
<li>被final修饰的类不可以被继承</li>
<li>被final修饰的方法不可以被重写，如果再加上一个private就说明不是方法<br>重写而相当于重新定义一个方法，因为private 修饰的方法只能在当前类可见<br>，所以不存在重写pirvate方法</li>
<li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是<br>引用指向的内容，引用指向的内容是可以改变的</li>
</ul>
<h3 id="system-exit-1-和-system-exit-0-？"><a href="#system-exit-1-和-system-exit-0-？" class="headerlink" title="system.exit(1) 和 system.exit(0)？"></a>system.exit(1) 和 system.exit(0)？</h3><ol>
<li>为0时为正常退出程序，也就是结束当前正在运行中的java虚拟机</li>
<li>为非0的其他整数，表示非正常退出当前程序</li>
</ol>
<h3 id="final-finally-finalize的区别是什么？"><a href="#final-finally-finalize的区别是什么？" class="headerlink" title="final finally finalize的区别是什么？"></a>final finally finalize的区别是什么？</h3><ol>
<li>final 可以修饰类、变量、方法，修饰类表示类不能被继承、修饰方法表示<br>该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值，修饰<br>的变量必须初始化</li>
<li>finally 作为异常处理的一部分，它只能在 try/catch 语句中，通常我们<br>将一定要执行的代码方法finally 代码块中，表示不管是否出现异常，该代码<br>块都会执行，一般用来存放一些关闭资源的代码。System.exit(0) 可以阻断<br>finally 执行</li>
<li>finalize 是一个方法，属于Object类的一个方法，而Object类是所有类<br>的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法的时<br>候，由垃圾回收器调用finalize()回收垃圾，是一个对象是否可回收的最后<br>判断</li>
</ol>
<h3 id="super的用法是什么？"><a href="#super的用法是什么？" class="headerlink" title="super的用法是什么？"></a>super的用法是什么？</h3><p>super用于限定该对象调用它从父类继承到的实例变量和方法，创建子类的时候也<br>会为父类的变量分配空间，可以通过super.调用。不管是否使用super调用来执行<br>父类构造器的初始化代码，子类总是会调用父类构造器一次</p>
<h3 id="super和this的区别是什么？"><a href="#super和this的区别是什么？" class="headerlink" title="super和this的区别是什么？"></a>super和this的区别是什么？</h3><ol>
<li>super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构<br>造方法</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字</li>
</ol>
<h3 id="static-的作用是什么？"><a href="#static-的作用是什么？" class="headerlink" title="static 的作用是什么？"></a>static 的作用是什么？</h3><ol>
<li>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即<br>使没有创建对象，也能使用属性和调用方法</li>
<li>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程<br>序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类<br>初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会<br>执行一次，创建对象时先执行初始化块后执行构造器</li>
<li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加<br>载的时候执行一次。因此很多时候会将一些只需要进行一次的初始化操作都<br>放在static代码块中进行</li>
<li>static 变量在Java中是属于类的，它在所有的实例中的值是一样的。当类<br>被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不<br>用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出<br>来，还没有跟任何实例关联上</li>
</ol>
<h3 id="Java静态变量、代码块、和静态方法的执行顺序是什么？"><a href="#Java静态变量、代码块、和静态方法的执行顺序是什么？" class="headerlink" title="Java静态变量、代码块、和静态方法的执行顺序是什么？"></a>Java静态变量、代码块、和静态方法的执行顺序是什么？</h3><ol>
<li>代码块执行顺序 静态代码块——&gt; 构造代码块 ——&gt; 构造函数</li>
<li>继承中代码块执行顺序：父类静态块——&gt;子类静态块——&gt;父类代码块<br>——&gt;父类构造器——&gt;子类代码块——&gt;子类构造器</li>
</ol>
<h3 id="多态是什么意思？"><a href="#多态是什么意思？" class="headerlink" title="多态是什么意思？"></a>多态是什么意思？</h3><p>多态分为两种</p>
<ol>
<li>编译时多态（又称静态多态）重载（overload）就是编译时多态的一个例子<br>，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法</li>
<li>运行时多态（又称动态多态）Java引用变量有两个类型，一个是编译时类<br>型，另一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运<br>行时类型由实际赋给该变量的对象决定，如果编译类型和运行类型不一致就<br>可能出现多态。Java 允许把一个子类对象直接赋给一个父类引用变量，当<br>调用引用变量的方法时总是表现子类方法的特征，但是不能调用子类独有<br>的方法。与方法相反，对象的实例变量不具备多态性，只能访问编译时定<br>义的成员变量</li>
</ol>
<h3 id="多态的实现原则是什么？"><a href="#多态的实现原则是什么？" class="headerlink" title="多态的实现原则是什么？"></a>多态的实现原则是什么？</h3><p>Java实现多态有三个必要条件：继承、重写、向上转型</p>
<ol>
<li>继承：在多态中必须存在有继承关系的子类和父类</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用<br>子类的方法</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才<br>能够具备技能调用父类的方法和子类的方法</li>
</ol>
<p>引用变量只能使用编译时类型的方法，如果要使用运行时类型的方法，需要进行强<br>制类型转换，引用类型之间的转换只能在具有继承关系的两个类之间</p>
<h3 id="instanceof运算符的用法？"><a href="#instanceof运算符的用法？" class="headerlink" title="instanceof运算符的用法？"></a>instanceof运算符的用法？</h3><p>instance运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一<br>个类或者接口，用于判断前面的对象是否是后面的类或者其子类需要注意前一个操<br>作数的编译类型要么相同要么与后面的类具有父子继承关系否则编译错误</p>
<h3 id="自动装箱和拆箱是什么意思？"><a href="#自动装箱和拆箱是什么意思？" class="headerlink" title="自动装箱和拆箱是什么意思？"></a>自动装箱和拆箱是什么意思？</h3><p>Java为8种基本数据类型分别定义了相应的引用类型，并称之为基本数据类<br>型的包装类，JDK提供了自动装箱和自动拆箱功能</p>
<ul>
<li>自动装箱 把一个基本数据类型直接赋给相应的包装类变量</li>
<li>自动拆箱 把一个包装类变量直接赋给一个对于的基本数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始类型: boolean，char，byte，short，int，long，float，double</span><br><span class="line">包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</span><br></pre></td></tr></table></figure>
<p>包装类还可以实现基本类型变量和字符串之间的转换，把字符串类型转换为<br>基本类型有两种方式</p>
<ul>
<li>parseXxx(String s) 静态方法</li>
<li>valueOf(String s) 静态方法</li>
</ul>
<h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ol>
<li>包装类型可以为null，而基本类型不可以</li>
<li>包装类型可用于泛型，而基本类型不可以。因为泛型在编译时会进行类型擦<br>除，最后只保留原始类型，而原始类型只能是 Object 类及其子类</li>
<li>基本类型比包装类型更高效，占用空间更少</li>
</ol>
<h3 id="自动装箱和拆箱的本质是什么？"><a href="#自动装箱和拆箱的本质是什么？" class="headerlink" title="自动装箱和拆箱的本质是什么？"></a>自动装箱和拆箱的本质是什么？</h3><p>在装箱的时候自动调用的是Integer的valueOf()方法，在拆箱的时候自动调<br>用的是Integer的intValue()方法，注意valueOf方法本质是new Integer<br>，在-128到127时会直接引用已经创建好的缓存Integer对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= Integer.IntegerCache.high ? </span><br><span class="line">        Integer.IntegerCache.cache[i + <span class="number">128</span>] : <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//先判断类型是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value == (Integer)obj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于Integer==int类似的比较，即两个操作数中有一个是int的情况, 比较的<br>是数值是否相等（即Integer类型的那个对象会触发自动拆箱的过程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Integer a = <span class="number">1</span>;</span><br><span class="line">       Integer b = <span class="number">2</span>;</span><br><span class="line">       Integer c = <span class="number">3</span>;</span><br><span class="line">       Integer d = <span class="number">3</span>;</span><br><span class="line">       Integer e = <span class="number">321</span>;</span><br><span class="line">       Integer f = <span class="number">321</span>;</span><br><span class="line">       Long g = <span class="number">3L</span>;</span><br><span class="line">       Long h = <span class="number">2L</span>;</span><br><span class="line">       System.out.println(c==d); <span class="comment">//true</span></span><br><span class="line">       System.out.println(e==f); <span class="comment">//false</span></span><br><span class="line">       System.out.println(c==(a+b)); <span class="comment">//true</span></span><br><span class="line">       System.out.println(c.equals(a+b)); <span class="comment">//true</span></span><br><span class="line">       System.out.println(g==(a+b)); <span class="comment">//true</span></span><br><span class="line">       System.out.println(g.equals(a+b)); <span class="comment">//false，类型都不一样</span></span><br><span class="line">       System.out.println(g.equals(a+h)); <span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类是什么？"><a href="#抽象类是什么？" class="headerlink" title="抽象类是什么？"></a>抽象类是什么？</h3><p>抽象方法和抽象类必须用abstract修饰，有抽象方法的类只能被定义为抽象<br>类，抽象类里可以没有抽象方法，提供方法但是不提供具体实现，这就是抽<br>象方法。抽象类是从多个具体类中抽象出来的父类，具有更高的抽象层次，<br>抽象类就相当于子类的模板，体现一种模板模式的设计</p>
<h3 id="抽象类的特点有哪些？"><a href="#抽象类的特点有哪些？" class="headerlink" title="抽象类的特点有哪些？"></a>抽象类的特点有哪些？</h3><ol>
<li>抽象类不能实例化，无法使用new关键字来调用抽象类的构造器，但是可<br>以被子类继承</li>
<li>抽象类可以包含成员变量、方法（普通方法和抽象方法）、构造器、初始化<br>块，内部类等。构造器是由子类调用而不是创建实例</li>
<li>包含抽象方法的类（直接定义一个抽象方法、继承一个抽象类但没有完全<br>实现父类包含的抽象方法、实现一个接口但没有完全实现接口中的方法）只<br>能被定义为抽象类</li>
<li>static和abstract不能修饰一个方法，但是可以修饰一个内部类</li>
<li>final和abstract不能同时使用，private和abstract也不能同时使用</li>
</ol>
<h3 id="抽象类能使用final修饰吗？"><a href="#抽象类能使用final修饰吗？" class="headerlink" title="抽象类能使用final修饰吗？"></a>抽象类能使用final修饰吗？</h3><p>不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继<br>承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<h3 id="接口是什么？有哪些特点？"><a href="#接口是什么？有哪些特点？" class="headerlink" title="接口是什么？有哪些特点？"></a>接口是什么？有哪些特点？</h3><p>接口实际上是一种更为特殊的抽象类，只提供实现类需要实现的方法。Java9对接口<br>进行了改进，允许接口定义默认方法和类方法，并且都可以提供具体实现，还增加<br>了私有方法，也可以提供具体实现</p>
<ol>
<li>接口的修饰符可以是public或者省略，如果省略就是默认包访问权限</li>
<li>一个接口可以有多个父接口，只能继承接口不能继承类</li>
<li>接口中不能有构造器和初始化块</li>
<li>接口里的成员变量只能是静态变量</li>
<li>接口定义的是多个类共同的行为规范，所以接口里的常量、方法、内部类<br>和内部枚举都是public访问权限，定义接口成员时可以省略访问修饰符，<br>如果显示指定只能是public</li>
<li>接口里的方法只能是抽象方法、默认方法、类方法或私有方法，如果不是默<br>认类或私有方法，系统会自动为普通方法增加abstract修饰符，所以普通方<br>法总是使用 public abstract 修饰，其他方法必须有方法体</li>
<li>接口里的内部类、内部接口和内部枚举默认使用 public static 修饰</li>
</ol>
<h3 id="如何使用接口？"><a href="#如何使用接口？" class="headerlink" title="如何使用接口？"></a>如何使用接口？</h3><p>接口不能创建实例，但是接口可以声明为引用类型变量，这个引用类型变量必须<br>引用到其实现类的对象，一个类可以实现多个接口，必须实现接口中的所以抽象<br>方法，否则就会定义为抽象类，一个类可以继承父类并实现多个接口，extends<br>必须放在implements之前</p>
<h3 id="抽象类和接口的区别？"><a href="#抽象类和接口的区别？" class="headerlink" title="抽象类和接口的区别？"></a>抽象类和接口的区别？</h3><ol>
<li>语法层面上的区别</li>
</ol>
<ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract<br>方法</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public<br>static final类型的</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静<br>态方法</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li>
</ul>
<ol start="2">
<li>设计层面上的区别</li>
</ol>
<ul>
<li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类<br>是对整个类整体进行抽象，包括属性行为，但是接口却是对类局部（行为）<br>进行抽象</li>
<li>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口<br>是一种行为规范，它是一种辐射式设计</li>
</ul>
<h3 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h3><p>在某些情况下把一个类放在另一个类的内部定义，这个定义在其他类的内部的类就<br>是内部类，包含内部类的类也称为外部类。内部类可以分为四种：成员内部类、局<br>部内部类、匿名内部类和静态内部类</p>
<ol>
<li>静态内部类 定义在类内部的静态类，就是静态内部类，可以包括静态和非<br>静态成员，静态内部类可以访问外部类所有的静态变量，而不可访问外部类<br>的非静态变量</li>
<li>成员内部类 定义在类内部，成员位置上的非静态类，就是成员内部类，成<br>员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公<br>有。成员内部类依赖于外部类的实例</li>
<li>局部内部类 定义在方法中的内部类，就是局部内部类，定义在实例方法中<br>的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能<br>访问外部类的静态变量和方法</li>
<li>匿名内部类 匿名内部类就是没有名字的内部类，适合创建那种只需要使用一<br>次的类</li>
</ol>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口</li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为final</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽<br>象方法</li>
</ul>
<h3 id="内部类的优点有哪些？"><a href="#内部类的优点有哪些？" class="headerlink" title="内部类的优点有哪些？"></a>内部类的优点有哪些？</h3><ol>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷</li>
<li>匿名内部类可以很方便的定义回调</li>
</ol>
<h3 id="内部类有哪些应用场景？"><a href="#内部类有哪些应用场景？" class="headerlink" title="内部类有哪些应用场景？"></a>内部类有哪些应用场景？</h3><ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展</li>
<li>当某个类除了它的外部类，不再被其他的类使用时</li>
</ol>
<h3 id="Lambda表达式的作用？"><a href="#Lambda表达式的作用？" class="headerlink" title="Lambda表达式的作用？"></a>Lambda表达式的作用？</h3><p>Lambda表达式支持将代码块作为方法参数，Lambda允许使用更简洁的代码来<br>创建只有一个抽象方法的接口（这种接口被称为函数式接口）实例</p>
<ul>
<li>形参列表允许省略形参类型，如果形参只有一个参数那么圆括号也可以省略</li>
<li>箭头 -&gt;</li>
<li>如果方法体中只有一条返回语句则可以省略花括号，return也可以省略，会<br>自动返回这条语句的值</li>
</ul>
<p>Lambda表达式的目标类型必须是函数式接口，一个函数式接口代表只含一个抽<br>象方法的接口，可以包含多个默认方法和类方法，但是只能有一个抽象方法</p>
<h3 id="内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="内部类访问局部变量的时候，为什么变量必须要加上final？"></a>内部类访问局部变量的时候，为什么变量必须要加上final？</h3><p>是因为生命周期不一致，局部变量直接存储在栈中，当方法执行结束后，非<br>final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如<br>果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内<br>部类使用的变量与外层的局部变量区分开，解决了这个问题</p>
<h3 id="重写与重载的区别是什么？"><a href="#重写与重载的区别是什么？" class="headerlink" title="重写与重载的区别是什么？"></a>重写与重载的区别是什么？</h3><ol>
<li>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个<br>数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能<br>根据返回类型进行区分</li>
<li>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父<br>类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）<br>，如果父类方法访问修饰符为private则子类中就不是重写</li>
</ol>
<h3 id="和equals的区别是什么？"><a href="#和equals的区别是什么？" class="headerlink" title="==和equals的区别是什么？"></a>==和equals的区别是什么？</h3><ol>
<li>== 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是<br>不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型==比较<br>的是内存地址)</li>
<li>equals() 它的作用也是判断两个对象是否相等。但它一般有两种使用<br>情况</li>
</ol>
<ul>
<li>没有覆盖equals()方法。比较该类的两个对象时，等价于通过==比较这<br>两个对象</li>
<li>类覆盖了equals()方法。一般我们都覆盖equals()方法来两个对象的内<br>容相等，若它们的内容相等，则返回true</li>
</ul>
<h3 id="equals-的特性？"><a href="#equals-的特性？" class="headerlink" title="equals 的特性？"></a>equals 的特性？</h3><ol>
<li>自反性。对于任意不为null的引用值x，x.equals(x)一定是true</li>
<li>对称性。对于任意不为null的引用值x和y，当且仅当x.equals(y) 是<br>true时，y.equals(x)也是true</li>
<li>传递性。对于任意不为null的引用值x、y和z，如果x.equals(y)是true<br>，同时y.equals(z)是true，那么x.equals(z)一定是true</li>
<li>一致性。对于任意不为null的引用值x和y，如果用于equals比较的对象<br>信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true 要么<br>一致地返回false</li>
<li>对于任意不为null的引用值x，x.equals(null)返回false</li>
</ol>
<h3 id="介绍下hashCode-？"><a href="#介绍下hashCode-？" class="headerlink" title="介绍下hashCode()？"></a>介绍下hashCode()？</h3><p>hashCode() 的作用是获取哈希码，也称为散列码，它实际上是返回一个int<br>整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定<br>义在JDK的Object中，这就意味着Java中的任何类都包含有hashCode()函数<br>。散列表存储的是键值对(key-value )，它的特点是能根据“键”快速的检索<br>出对应的“值”。这其中就利用到了散列码（可以快速找到所需要的对象）</p>
<h3 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h3><p>如果想要深拷贝一个对象，这个对象必须要实现Cloneable 接口，实现clone<br>方法，并且在clone方法内部，把该对象引用的其他对象也要clone一份，这就<br>要求这个被引用的对象必须也要实现Cloneable接口并且实现clone方法。<br>如果在拷贝一个对象时，要想让这个拷贝的对象和源对象完全彼此独立，那么<br>在引用链上的每一级对象都要被显式的拷贝。所以 创建彻底的深拷贝是非常<br>麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引<br>用了一个第三方的对象， 而这个对象没有实现clone方法， 那么在它之后<br>的所有引用的对象都是被共享的。String是不可变对象，保存在常量池中，<br>也算是深拷贝。</p>
<h3 id="序列化和反序列化的区别？"><a href="#序列化和反序列化的区别？" class="headerlink" title="序列化和反序列化的区别？"></a>序列化和反序列化的区别？</h3><ol>
<li>把对象转换为字节序列的过程称为对象的序列化，以便在网络上传输或者<br>保存在本地文件中。核心作用是对象状态的保存与重建</li>
<li>把字节序列恢复为对象的过程称为对象的反序列化，客户端从文件中或网<br>络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信<br>息，通过反序列化重建对象</li>
</ol>
<p>只有实现了Serializable和Externalizable接口的类的对象才能被序列化。<br>Externalizable接口继承自 Serializable接口，实现Externalizable接<br>口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可<br>以采用默认的序列化方式</p>
<h3 id="什么是serialVersionUID？"><a href="#什么是serialVersionUID？" class="headerlink" title="什么是serialVersionUID？"></a>什么是serialVersionUID？</h3><p>serialVersionUID 用来表明类的不同版本间的兼容性。<br>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一<br>致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与<br>本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致<br>的，可以进行反序列化，否则就会出现序列化版本不一致的异常</p>
<h3 id="为什么还要显示指定serialVersionUID的值？"><a href="#为什么还要显示指定serialVersionUID的值？" class="headerlink" title="为什么还要显示指定serialVersionUID的值？"></a>为什么还要显示指定serialVersionUID的值？</h3><ol>
<li>如果不显示指定serialVersionUID，JVM 在序列化时会根据属性自动生成<br>一个serialVersionUID，然后与属性一起序列化，再进行持久化或网络传输。<br>在反序列化时, JVM会再根据属性自动生成一个新版serialVersionUID ，然<br>后将这个新版serialVersionUID与序列化时生成的旧版serialVersionUID<br>进行比较, 如果相同则反序列化成功，否则报错</li>
<li>如果显示指定，在序列化和反序列化时仍然都会生成serialVersionUID<br>，但值为显示指定的值，这样在反序列化时新旧版本的serialVersionUID<br>就一致了</li>
</ol>
<h3 id="serialVersionUID的作用？"><a href="#serialVersionUID的作用？" class="headerlink" title="serialVersionUID的作用？"></a>serialVersionUID的作用？</h3><p>在实际开发中是不可能的，我们的类会不断迭代，一旦类被修改了，那旧对象<br>反序列化就会报错。所以在实际开发中，我们都会显示指定，值是多少无所谓<br>，只要不变就行。如果要在序列化后添加或减少一个字段或者方法，不会影响<br>还原。序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是<br>对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量</p>
<h3 id="serialVersionUID什么时候修改？"><a href="#serialVersionUID什么时候修改？" class="headerlink" title="serialVersionUID什么时候修改？"></a>serialVersionUID什么时候修改？</h3><p>如果完全不兼容升级可以修改，但是会抛出序列化运行时异常</p>
<h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><ol>
<li>对于不想进行序列化的变量，使用transient关键字修饰。transient关<br>键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该<br>变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初<br>始值，如 int 型的是 0，对象型的是 null。transient 只能修饰变量<br>，不能修饰类和方法</li>
<li>静态变量不会被序列化 serialVersionUID也被static修饰，在序列<br>化对象时会自动生成一个 serialVersionUID ，然后将我们显示指定的<br>serialVersionUID属性值赋给自动生成的serialVersionUID</li>
</ol>
<h3 id="序列化的作用是什么？"><a href="#序列化的作用是什么？" class="headerlink" title="序列化的作用是什么？"></a>序列化的作用是什么？</h3><ol>
<li>对象序列化可以实现分布式对象。RMI(即远程调用)要利用对象序列化运<br>行远程主机上的服务，就像在本地机上运行对象时一样</li>
<li>java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个<br>对象的数据，可以进行对象的”深复制”，即复制对象本身及引用的对象本身</li>
<li>序列化可以将内存中的类写入文件或数据库中</li>
<li>对象、文件、数据，有许多不同的格式，很难统一传输和保存，序列化以后<br>就都是字节流了</li>
</ol>
<h3 id="IO流有哪几种？"><a href="#IO流有哪几种？" class="headerlink" title="IO流有哪几种？"></a>IO流有哪几种？</h3><ol>
<li>按照流的流向分 输入流(inputStream)和输出流(outputStream)</li>
<li>按照实现功能分 节点流（可以从或者向一个特定的地方读写数据，如<br>FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封<br>装的流的功能调用实现数据读写， BufferedReader）</li>
<li>按照处理数据的单位 字节流和字符流。分别由四个抽象类来表示（每种<br>流包括输入和输出两种所以一共四个）:InputStream，OutputStream，<br>Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的</li>
</ol>
<h3 id="字节流如何转为字符流？"><a href="#字节流如何转为字符流？" class="headerlink" title="字节流如何转为字符流？"></a>字节流如何转为字符流？</h3><ol>
<li>字节输入流转字符输入流通过InputStreamReader 实现，该类的构造<br>函数可以传入InputStream 对象</li>
<li>字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构<br>造函数可以传入OutputStream 对象</li>
</ol>
<h3 id="字符流与字节流的区别？"><a href="#字符流与字节流的区别？" class="headerlink" title="字符流与字节流的区别？"></a>字符流与字节流的区别？</h3><ol>
<li>读写的时候字节流是按字节读写，字符流按字符读写</li>
<li>字节流适合所有类型文件的数据传输，因为计算机字节（Byte）是电脑<br>中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据<br>不行，但是字符流处理文本要比字节流处理文本要方便</li>
<li>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据<br>的时候一般会选择字符流</li>
<li>只是读写文件，和文件内容无关时，一般选择字节流</li>
</ol>
<h3 id="什么是阻塞IO？什么是非阻塞IO？"><a href="#什么是阻塞IO？什么是非阻塞IO？" class="headerlink" title="什么是阻塞IO？什么是非阻塞IO？"></a>什么是阻塞IO？什么是非阻塞IO？</h3><p>IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。<br>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读<br>取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，<br>直到数据就绪，对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息<br>告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户<br>线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求<br>操作包括两个阶段：</p>
<ul>
<li>查看数据是否就绪</li>
<li>进行数据拷贝（内核将数据拷贝到用户线程）</li>
</ul>
<p>那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一<br>个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是<br>直接返回一个标志信息。Java中传统的IO都是阻塞IO，比如通过socket 来读<br>数据，调用read() 方法之后，如果数据没有就绪，当前线程就会一直阻塞在<br>read 方法调用那里，直到有数据才返回，而如果是非阻塞IO的话，当数据没<br>有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，<br>而不是一直在那里等待</p>
<h3 id="同步IO和异步IO的区别？"><a href="#同步IO和异步IO的区别？" class="headerlink" title="同步IO和异步IO的区别？"></a>同步IO和异步IO的区别？</h3><ol>
<li>同步IO：当用户发出IO请求操作后，内核会去查看要读取的数据是否就<br>绪，如果没有，就一直等待。期间用户线程或内存会不断地轮询数据是否就<br>绪。当数据就绪时，再把数据从内核拷贝到用户空间</li>
<li>异步IO：用户线程只需发出IO请求和接收IO操作完成通知，期间的IO操<br>作由内核自动完成，并发送通知告知用户线程IO操作已经完成。也就是说，<br>在异步IO中，并不会对用户线程产生任何阻塞</li>
</ol>
<h3 id="BIO-NIO-AIO-有什么区别？"><a href="#BIO-NIO-AIO-有什么区别？" class="headerlink" title="BIO,NIO,AIO 有什么区别？"></a>BIO,NIO,AIO 有什么区别？</h3><ol>
<li>BIO：Block IO 同步阻塞式IO，就是我们平常使用的传统IO，它的特点<br>是模式简单使用方便，并发处理能力低。在服务器中实现的模式为一个连接<br>一个线程。也就是说客户端有连接请求的时候，服务器就需要启动一个线程<br>进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这<br>也可以通过线程池机制改善。BIO 一般适用于连接数目小且固定的架构，<br>这种方式对于服务器资源要求比较高，而且并发局限于应用中，是<br>JDK1.4之前的唯一选择，但好在程序直观简单，易理解</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端<br>通过Channel（通道）通讯，实现了多路复用。同步并非阻塞，在服务器中<br>实现的模式为一个请求一个线程，也就是说客户端发送的连接请求都会注<br>册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程<br>进行处理。NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并<br>发局限于应用中，编程比较复杂，从JDK1.4开始支持</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非<br>堵塞IO ，异步 IO 的操作基于事件和回调机制。异步并非阻塞，在服务器<br>中实现的模式为一个有效请求一个线程，也就是说，客户端的IO请求都是<br>通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO<br>一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作<br>系统参与并发操作，编程比较复杂，从JDK1.7开始支持</li>
</ol>
<h3 id="Java-IO都有哪些设计模式？"><a href="#Java-IO都有哪些设计模式？" class="headerlink" title="Java IO都有哪些设计模式？"></a>Java IO都有哪些设计模式？</h3><p>使用了适配器模式和装饰器模式</p>
<ol>
<li>适配器模式 把一个类的接口变换成客户端所期待的另一种接口，从而<br>使原本因接口不匹配而无法在一起工作的两个类能够在一起工作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> INputStreamReader(inputStream);</span><br></pre></td></tr></table></figure></li>
<li>装饰器模式 一种动态地往一个类中添加新的行为的设计模式。就功能而<br>言，装饰器模式相比生成子类更为灵活，这样可以给某个对象而不是整个<br>类添加一些功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(inputStream));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="序列化的过程？"><a href="#序列化的过程？" class="headerlink" title="序列化的过程？"></a>序列化的过程？</h3><ol>
<li>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流</li>
<li>通过对象输出流的writeObject()方法写对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">	<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"E:/Person.txt"</span>)));</span><br><span class="line">	oo.writeObject(person);</span><br></pre></td></tr></table></figure>

<h3 id="反序列化的过程？"><a href="#反序列化的过程？" class="headerlink" title="反序列化的过程？"></a>反序列化的过程？</h3><ol>
<li>创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流</li>
<li>通过对象输入流的readObject()方法读取对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                 <span class="keyword">new</span> File(<span class="string">"E:/Person.txt"</span>)));</span><br><span class="line">         Person person = (Person) ois.readObject();</span><br></pre></td></tr></table></figure>


<h3 id="Java中的泛型是什么？"><a href="#Java中的泛型是什么？" class="headerlink" title="Java中的泛型是什么？"></a>Java中的泛型是什么？</h3><p>泛型是 JDK1.5 的一个新特性，泛型就是将类型参数化，其在编译时才确定具体<br>的参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型<br>接口、泛型方法</p>
<h3 id="泛型的好处？"><a href="#泛型的好处？" class="headerlink" title="泛型的好处？"></a>泛型的好处？</h3><ol>
<li>如果使用 Object 来实现通用、不同类型的处理，有这么两个缺点：</li>
</ol>
<ul>
<li>每次使用时都需要强制转换成想要的类型</li>
<li>在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全</li>
</ul>
<ol start="2">
<li>类型安全 编译时期就可以检查出因 Java 类型不正确导致的<br>ClassCastException 异常</li>
<li>消除强制类型转换</li>
<li>潜在的性能收益 由于泛型的实现方式，支持泛型（几乎）不需要JVM 或<br>类文件更改，所有工作都在编译器中完成，编译器生成的代码跟不使用泛型<br>（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已</li>
</ol>
<h3 id="Java泛型的原理是什么？"><a href="#Java泛型的原理是什么？" class="headerlink" title="Java泛型的原理是什么？"></a>Java泛型的原理是什么？</h3><p>泛型是一种语法糖，泛型这种语法糖的基本原理是类型擦除。Java中的泛型基本<br>上都是在编译器这个层次来实现的，也就是说泛型只存在于编译阶段，而不存<br>在于运行阶段。在编译后的 class 文件中，是没有泛型这个概念的。<br>实际上编译器会正常的将使用泛型的地方编译并进行类型擦除，然后返回实例。<br>但是除此之外的是，如果构建泛型实例时使用了泛型语法，那么编译器将标记<br>该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指<br>定类型的方法都不能调用成功</p>
<h3 id="泛型翻译是什么？"><a href="#泛型翻译是什么？" class="headerlink" title="泛型翻译是什么？"></a>泛型翻译是什么？</h3><p>编译器不仅关注一个泛型方法的调用，它还会为某些返回值为限定的泛型类型<br>的方法进行强制类型转换，由于类型擦除，返回值为泛型类型的方法都会擦除<br>成 Object 类型，当这些方法被调用后，编译器会额外插入一行 checkcast<br>指令用于强制类型转换。这一个过程就叫做 泛型翻译</p>
<h3 id="什么是类型擦除？"><a href="#什么是类型擦除？" class="headerlink" title="什么是类型擦除？"></a>什么是类型擦除？</h3><p>类型擦除：使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数</p>
<ol>
<li>大部分情况下，泛型类型都会以 Object 进行替换</li>
<li>使用到了extends和super语法的有界类型 这种情况的泛型类型，num会被<br>替换为String而不再是Object。这是一个类型限定的语法，它限定T是String<br>或者 String 的子类，也就是你构建 Caculate 实例的时候只能限定 T 为<br>String 或者String 的子类，所以无论你限定T 为什么类型，String都是<br>父类，不会出现类型不匹配的问题，于是可以使用 String 进行类型擦除</li>
</ol>
<h3 id="什么是泛型中的限定通配符和非限定通配符？"><a href="#什么是泛型中的限定通配符和非限定通配符？" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符？"></a>什么是泛型中的限定通配符和非限定通配符？</h3><ol>
<li>限定通配符对类型进行限制。有两种限定通配符，一种是&lt;? extends T&gt;<br>它通过确保类型必须是T 的子类来设定类型的上界，另一种是&lt;? super T&gt;<br>它通过确保类型必须是T 的父类来设定类型的下界。泛型类型必须用限定内<br>的类型来进行初始化，否则会导致编译错误</li>
<li>非限定通配符 ?,可以用任意类型来替代。如List&lt;?&gt; 的意思是这个集合<br>是一个可以持有任意类型的集合，它可以是List&lt;A&gt;，也可以是List&lt;B&gt;<br>，或者List&lt;C&gt; 等等</li>
</ol>
<h3 id="List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别？"><a href="#List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别？" class="headerlink" title="List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别？"></a>List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别？</h3><p>这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受<br>任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构<br>成的List。例如List&lt;? extends Number&gt;可以接受List&lt;Integer&gt;或<br>List&lt;Float&gt;</p>
<h3 id="可以把List-lt-String-gt-传递给一个接受List-lt-Object-gt-参数的方法吗？"><a href="#可以把List-lt-String-gt-传递给一个接受List-lt-Object-gt-参数的方法吗？" class="headerlink" title="可以把List&lt;String&gt;传递给一个接受List&lt;Object&gt;参数的方法吗？"></a>可以把List&lt;String&gt;传递给一个接受List&lt;Object&gt;参数的方法吗？</h3><p>不可以。真这样做的话会导致编译错误。因为List&lt;Object&gt;可以存储任何<br>类型的对象包括String Integer等等，而List&lt;String&gt;却只能用来存<br>储String</p>
<h3 id="判断ArrayList-lt-String-gt-与ArrayList-lt-Integer-gt-是否相等？"><a href="#判断ArrayList-lt-String-gt-与ArrayList-lt-Integer-gt-是否相等？" class="headerlink" title="判断ArrayList&lt;String&gt;与ArrayList&lt;Integer&gt;是否相等？"></a>判断ArrayList&lt;String&gt;与ArrayList&lt;Integer&gt;是否相等？</h3><p>Class类型都是一致的，都是ArrayList.class。差别体现在类编译的时候。<br>当 JVM 进行类编译时，会进行泛型检查，如果一个集合被声明为 String<br>类型，那么它往该集合存取数据的时候就会对数据进行判断，从而避免存<br>入或取出错误的数据。Array不可以使用泛型</p>
<h3 id="Java-创建对象有哪几种方式？"><a href="#Java-创建对象有哪几种方式？" class="headerlink" title="Java 创建对象有哪几种方式？"></a>Java 创建对象有哪几种方式？</h3><p>java中提供了以下四种创建对象的方式:</p>
<ol>
<li>new创建新对象</li>
<li>通过反射机制</li>
<li>采用clone机制</li>
<li>通过序列化机制</li>
</ol>
<p>前两者都需要显式地调用构造方法。对于clone机制,需要注意浅拷贝和深拷贝的区<br>别，对于序列化机制需要通过实现Externalizable或者Serializable来实现</p>
<h3 id="什么是不可变对象？"><a href="#什么是不可变对象？" class="headerlink" title="什么是不可变对象？"></a>什么是不可变对象？</h3><p>不可变对象指对象一旦被创建，状态就不能再改变，任何修改都会创建一个新的<br>对象，如String、Integer 及其它包装类.不可变对象最大的好处是线程安全</p>
<h3 id="能否创建一个包含可变对象的不可变对象？"><a href="#能否创建一个包含可变对象的不可变对象？" class="headerlink" title="能否创建一个包含可变对象的不可变对象？"></a>能否创建一个包含可变对象的不可变对象？</h3><p>可以，比如final Person[] persons = new Persion[]{}。persons是不可变<br>对象的引用，但其数组中的Person实例却是可变的</p>
<h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性<br>和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获<br>取的信息以及动态调用对象的方法的功能称为java语言的反射机制</p>
<h3 id="反射机制的优缺点有哪些？"><a href="#反射机制的优缺点有哪些？" class="headerlink" title="反射机制的优缺点有哪些？"></a>反射机制的优缺点有哪些？</h3><ol>
<li>优点 能够运行时动态获取类的实例，提高灵活性，可与动态编译结合，<br>加载MySQL的驱动类</li>
<li>缺点 使用反射性能较低，需要解析字节码，将内存中的对象进行解析。<br>其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反<br>射速度，多次创建一个类的实例时，有缓存会快很多，ReflflectASM工<br>具类，通过字节码生成的方式加快反射速度</li>
</ol>
<h3 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h3><ol>
<li>我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的<br>驱动程序，通过 DriverManager 类进行数据库的连接，通过Connection 接<br>口接收连接</li>
<li>Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring通<br>过XML配置模式装载 Bean 的过程：</li>
</ol>
<ul>
<li>将程序内所有 XML 或 Properties 配置文件加载入内存中</li>
<li>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符<br>串以及相关的属性信息</li>
<li>使用反射机制，根据这个字符串获得某个类的Class实例</li>
<li>动态配置实例的属性</li>
</ul>
<p>Spring这样做的好处是</p>
<ul>
<li>不用每一次都要在代码里面去new或者做其他的事情</li>
<li>以后要改的话直接改配置文件，代码维护起来就很方便了</li>
<li>有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以<br>通过反射机制来实现</li>
</ul>
<h3 id="类的加载过程是什么样的？"><a href="#类的加载过程是什么样的？" class="headerlink" title="类的加载过程是什么样的？"></a>类的加载过程是什么样的？</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加<br>载、连接和初始化三个步骤对该类进行初始化。类的class文件读入内存后，<br>会在内存中创建一个java.lang.Class对象，类实际上也是一种对象，都是<br>java.lang.Class的实例</p>
<h3 id="类的初始化过程？"><a href="#类的初始化过程？" class="headerlink" title="类的初始化过程？"></a>类的初始化过程？</h3><p>对类变量进行初始化，声明时指定和静态初始化块都会变为类初始化语句，会按照<br>顺序执行初始化语句。初始化一个类的步骤如下</p>
<ol>
<li>如果这个类还没有加载连接就先加载连接</li>
<li>如果该类的直接父类还没有初始化就先初始化直接父类</li>
<li>如果类中有初始化语句则依次执行</li>
</ol>
<h3 id="类初始化的时机有哪几种？"><a href="#类初始化的时机有哪几种？" class="headerlink" title="类初始化的时机有哪几种？"></a>类初始化的时机有哪几种？</h3><p>通过以下6种方式使用类或接口时就会进行初始化，注意使用final的时候不会导<br>致初始化，final修饰的在编译时就已经确定的变量不会初始化，类的loadClass<br>方法加载类时只是加载，也不会导致初始化</p>
<ol>
<li>创建类的实例 为某个类创建实例的方式包括：使用new操作符来创建实例，<br>通过反射来创建实例，通过反序列化的方式来创建实例</li>
<li>调用某个类的类方法（静态方法）</li>
<li>访问某个类或接口的类变量，或为该类变量赋值</li>
<li>使用反射方式来强制创建某个类或接口对应的java.lang.C1ass对象 例如代<br>码C1ass.forName(“Person”) ，如果系统还未初始化Person类，则这行代码<br>将会导致该Person类被初始化并返回Person类对应的java.lang.C1ass对象</li>
<li>初始化某个类的子类，当初始化某个类的子类时，该子类的所有父类都会被<br>初始化</li>
<li>直接使用java.exe命令来运行某个主类，当运行某个主类时，程序会先初始化<br>该主类</li>
</ol>
<h3 id="Java获取Class对象的三种方法？"><a href="#Java获取Class对象的三种方法？" class="headerlink" title="Java获取Class对象的三种方法？"></a>Java获取Class对象的三种方法？</h3><ol>
<li>对象名.getClass()</li>
<li>Class.forName(“类的路径”)，当你知道该类的全路径名时，你可以使<br>用该方法获取 Class 类对象</li>
<li>类名.class。这种方法只适合在编译前就知道操作的Class</li>
<li>如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装<br>类的Class对象</li>
</ol>
<h3 id="Java反射API有几类？"><a href="#Java反射API有几类？" class="headerlink" title="Java反射API有几类？"></a>Java反射API有几类？</h3><p>反射API 用来生成 JVM 中的类、接口或则对象的信息</p>
<ol>
<li>Class 类：反射的核心类，可以获取类的属性，方法等信息</li>
<li>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可<br>以用来获取和设置类之中的属性值</li>
<li>Method 类：Java.lang.reflect包中的类，表示类的方法，它可以用<br>来获取类中的方法信息或者执行方法</li>
<li>Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法</li>
</ol>
<h3 id="反射的步骤？"><a href="#反射的步骤？" class="headerlink" title="反射的步骤？"></a>反射的步骤？</h3><ol>
<li>获取想要操作的类的Class对象，这是反射的核心，通过Class对象我们可<br>以任意调用类的方法</li>
<li>调用 Class 类中的方法，既就是反射的使用阶段。</li>
<li>使用反射 API 来操作这些信息</li>
</ol>
<h3 id="如何从Class中获取构造器有几种方式？"><a href="#如何从Class中获取构造器有几种方式？" class="headerlink" title="如何从Class中获取构造器有几种方式？"></a>如何从Class中获取构造器有几种方式？</h3><ol>
<li>getConstructor() 返回此Class对象对应的带指定参数的public构造器</li>
<li>getConstructors() 返回所有public构造器</li>
<li>getDeclaredConstructor() 返回带指定参数的构造器，与访问权限无关</li>
<li>getDeclaredConstructors() 返回所有构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class[] p=&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>&#125;</span>;</span><br><span class="line">constructor=classinstance.getDeclaredConstructor(p);</span><br></pre></td></tr></table></figure>
<h3 id="如何通过反射操作对象？"><a href="#如何通过反射操作对象？" class="headerlink" title="如何通过反射操作对象？"></a>如何通过反射操作对象？</h3><ol>
<li>获取类的Class 对象实例</li>
<li>根据Class对象实例获取Constructor对象，传入构造参数是class类型</li>
<li>使用Constructor 对象的newInstance 方法获取反射类对象，传入构<br>造器参数，返回的是一个Object类型</li>
<li>通过class对象获取方法的Method 对象，传入参数是方法名和参数类型<br>，类型是class类型</li>
<li>通过Method对象调用invoke 方法调用方法传入Object实例和方法参数</li>
<li>通过Class对象的getFields() 或getField() 方法可以获得该类所有<br>成员，然后通过get和set来操作变量的值，参数传入对象实例和设置值</li>
</ol>
<ul>
<li>getXxx(obj) 获取成员变量的值，Xxx对应8种基本数据类型，如果是引用类型<br>则不需要Xxx</li>
<li>setXxx(Object obj,Xxx value) 设置成员变量值，Xxx对应8种基本数据类型<br>，如果是引用类型则不需要Xxx</li>
</ul>
<h3 id="反射机制的原理是什么？"><a href="#反射机制的原理是什么？" class="headerlink" title="反射机制的原理是什么？"></a>反射机制的原理是什么？</h3><ol>
<li>反射获取类实例Class.forName()，先获取 ClassLoader，然后调用native<br>方法，获取信息，加载类则是回调 java.lang.ClassLoader。最后，jvm又会回<br>调ClassLoader 进类加载</li>
<li>newInstance() 调用具体方法的无参构造方法，生成实例并返回</li>
<li>获取Method对象 JVM 为每个类管理一个独一无二的Class对象，这份Class<br>对象里维护着该类的所有Method，Field，Constructor 的cache ，这份<br>cache也可以被称作根对象。每次getMethod获取到的Method对象都持有对<br>根对象的引用，每一次创建都会调用根对象的copy方法复制一份</li>
<li>调用invoke()方法 调用Method.invoke之后，会直接去调MethodAccessor<br>.invoke。MethodAccessor就是上面提到的所有同名method共享的一个实例<br>，由ReflectionFactory创建</li>
</ol>
<h3 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h3><p>异常机制就是当程序出现错误的时候的处理机制。异常和错误的区别就是异常<br>是可以被处理的，错误一般是无法处理的</p>
<h3 id="异常分为几类？"><a href="#异常分为几类？" class="headerlink" title="异常分为几类？"></a>异常分为几类？</h3><p>异常可以分为运行时异常和编译异常</p>
<ul>
<li>运行时异常 可以通过编译不能通过运行，如NullPointerException、<br>IndexOutOfBoundsException</li>
<li>编译异常 从语法角度必须进行相应的强制处理异常否则不能通过编译，如<br>IOException、SQLException</li>
</ul>
<h3 id="Error-和-Exception-区别是什么？"><a href="#Error-和-Exception-区别是什么？" class="headerlink" title="Error 和 Exception 区别是什么？"></a>Error 和 Exception 区别是什么？</h3><p>Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable<br>类。Throwable 类有两个重要的子类Exception（异常）和Error（错误）</p>
<ol>
<li>Exception :程序本身可以处理的异常，可以通过catch来进行捕获，<br>通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<br>Exception又可以分为运行时异常(RuntimeException, 又叫非受检<br>查异常)和非运行时异常(又叫受检查异常) </li>
<li>Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来<br>进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错<br>误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本<br>身无法恢复。StackOverflowError OutOfMemoryError</li>
</ol>
<h3 id="运行时异常和受检查异常区别是什么？"><a href="#运行时异常和受检查异常区别是什么？" class="headerlink" title="运行时异常和受检查异常区别是什么？"></a>运行时异常和受检查异常区别是什么？</h3><ol>
<li>运行时异常：包括RuntimeException 类及其子类，表示JVM 在运行<br>期间可能出现的异常。Java 编译器不会检查运行时异常。例如：(空指针)<br>、（字符串转换为数字）、(数组越界)、(类转换异常)、(数据存储异常，<br>操作数组时类型不一致)等</li>
<li>受检查异常：是Exception 中除RuntimeException 及其子类之外的<br>异常。Java 编译器会检查受检查异常。常见的受检查异常有：IO 相关的<br>异常、ClassNotFoundException 、SQLException等</li>
</ol>
<p>非受检查异常和受检查异常之间的区别：是否强制要求调用者必须处理此异<br>常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选<br>择非受检查异常</p>
<h3 id="如何处理异常？"><a href="#如何处理异常？" class="headerlink" title="如何处理异常？"></a>如何处理异常？</h3><p>将业务逻辑代码放在try块中，将错误处理逻辑放在catch块中处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意异常可以出现在任何地方，并不是在try块中才会产生异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意只会有一个catch块会被执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line">	<span class="comment">//处理逻辑</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception2 ex)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在try块中出现异常系统会自动生成一个异常，这个异常对象会提交给Java<br>运行环境，这个过程就叫做throw，也就是抛出异常。Java环境接收到异常后会<br>寻找能够处理异常的catch块，如果找到合适的catch块就会交给catch块来处<br>理，这个过程就叫做catch，也就是捕获异常。如果Java环境找不到捕获异常<br>的catch块，那么运行环境就会终止</p>
<h3 id="finally是什么？"><a href="#finally是什么？" class="headerlink" title="finally是什么？"></a>finally是什么？</h3><p>有些情况下系统打开了一些物理资源，比如数据库连接、网络连接和磁盘文件，<br>这些物理资源都必须显示回收，注意垃圾回收机制回收的是JVM内存中的空间。<br>接下来分析一下在哪里回收资源，如果在try中回收资源，那么程序运行到一<br>半可能产生异常，那么之后的代码就不会执行。如果在catch中回收资源，可<br>能程序不会产生异常那么catch块也就不会执行。所以异常处理机制提供了<br>finally块来回收资源，finally块一定会被执行</p>
<h3 id="throw-和throws-的区别是什么？"><a href="#throw-和throws-的区别是什么？" class="headerlink" title="throw 和throws 的区别是什么？"></a>throw 和throws 的区别是什么？</h3><p>可以通过throws 关键字在方法上声明该方法要拋出的异常，或者在方法内<br>部通过throw 拋出异常对象</p>
<ol>
<li>throw 当程序出现错误时会自动抛出异常，此外程序也可以自行抛出异常<br>，自行抛出异常用throw完成，每次只能抛出一个异常实例，注意运行时异常<br>可以显示捕获也可以不理会，Checked异常必须显示捕获</li>
<li>throws 用在方法声明上，用来声明一个方法可能产生的所有异常，调用<br>该方法的方法必须包含可处理异常的代码，否则也要在方法签名中用throws<br>关键字声明相应的异常</li>
</ol>
<h3 id="NoClassDefFoundError-和ClassNotFoundException-区别？"><a href="#NoClassDefFoundError-和ClassNotFoundException-区别？" class="headerlink" title="NoClassDefFoundError 和ClassNotFoundException 区别？"></a>NoClassDefFoundError 和ClassNotFoundException 区别？</h3><ol>
<li>NoClassDefFoundError 是一个 Error 类型的异常，是由JVM 引起的<br>，不应该尝试捕获这个异常。引起该异常的原因是 JVM 或ClassLoader 尝<br>试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译<br>时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致</li>
<li>ClassNotFoundException 是一个受检查异常，需要显式地使用try-<br>catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明<br>。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader<br>.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没<br>有找到该类，就会抛出该异常，另一种抛出该异常的可能原因是某个类已<br>经由一个类加载器加载至内存中，另一个加载器又尝试去加载它</li>
</ol>
<h3 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h3><p>catch 可以省略。更为严格的说法其实是：try 只适合处理运行时异常，try<br>+catch 适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普<br>通异常却不加以catch 处理，编译是通不过的，因为编译器硬性规定，普通<br>异常如果选择捕获，则必须用catch 显示声明以便进一步处理。而运行时异<br>常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉<br>得无可厚非</p>
<h3 id="try-catch-finally，如果catch中return了，finally还会执行吗？"><a href="#try-catch-finally，如果catch中return了，finally还会执行吗？" class="headerlink" title="try-catch-finally，如果catch中return了，finally还会执行吗？"></a>try-catch-finally，如果catch中return了，finally还会执行吗？</h3><p>会执行，在return 前执行。<br>在finally 中改变返回值的做法是不好的，因为如果存在finally 代码块，<br>try中的return 语句不会立马返回调用者，而是记录下返回值待finally代<br>码块执行完毕之后再向调用者返回其值，然后如果在finally 中修改了返回<br>值，就会返回修改后的值。显然在finally 中返回或者修改返回值会对程序<br>造成很大的困扰，Java 中也可以通过提升编译器的语法检查级别来产生警<br>告或错误。如果finally中没有return语句那么catch返回的值有两种情况</p>
<ol>
<li>基本数据类型 返回的值与finally中的修改不会改变返回值</li>
<li>引用类型 finally代码会改变返回值。本质是在catch中return的时候<br>会创建一个副本，根据数据类型判断是否把副本设置为修改的值</li>
</ol>
<h3 id="JVM-是如何处理异常的？"><a href="#JVM-是如何处理异常的？" class="headerlink" title="JVM 是如何处理异常的？"></a>JVM 是如何处理异常的？</h3><ol>
<li>在一个方法中如果发生异常，这个方法创建一个异常对象，并转交给JVM<br>，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创<br>建异常对象并转交给JVM 的过程称为抛出异常。可能有一系列的方法调用，<br>最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈</li>
<li>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有则调用<br>异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递<br>给它。如果 JVM 没有找到可以处理该异常的代码块，JVM就会将该异常转<br>交给默认的异常处理器（默认处理器为JVM的一部分），默认异常处理器<br>打印出异常信息并终止应用程序</li>
</ol>
<h3 id="String-StringBuffer-StringBuilder的区别是什么？"><a href="#String-StringBuffer-StringBuilder的区别是什么？" class="headerlink" title="String StringBuffer StringBuilder的区别是什么？"></a>String StringBuffer StringBuilder的区别是什么？</h3><ol>
<li>可变与不可变 String类中使用字节数组保存字符串，因为有“final”修饰<br>符，所以string对象是不可变的。对于已经存在的String对象的修改都是重新<br>创建一个新的对象，然后把新的值保存进去。StringBuilder与StringBuffer<br>是可变的，没有使用final修饰字节数组</li>
<li>是否线程安全 String中的对象是不可变的，也就可以理解为常量，显然线<br>程安全。StringBuilder是非线程安全的。StringBuffer对方法加了同步锁或<br>者对调用的方法加了同步锁，所以是线程安全的</li>
</ol>
<h3 id="String为什么要设计成不可变的？"><a href="#String为什么要设计成不可变的？" class="headerlink" title="String为什么要设计成不可变的？"></a>String为什么要设计成不可变的？</h3><ol>
<li>便于实现字符串池（String pool）在Java中，由于会大量的使用String<br>常量，如果每一次声明一个String 都创建一个String 对象，那将会造成极<br>大的空间资源的浪费。Java 提出了String pool的概念，在堆中开辟一块存<br>储空间String pool ，当初始化一个String 变量时，如果该字符串已经存<br>在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串<br>的引用。如果字符串是可变的，某一个字符串变量改变了其值，那么其指向<br>的变量的值也会改变，String pool将不能够实现</li>
<li>使多线程安全 在并发场景下，多个线程同时读一个资源，是安全的，不<br>会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所<br>以保证了多线程的安全</li>
<li>避免安全问题 在网络连接和数据库连接中字符串常常作为参数，例如，<br>网络连接地址URL，文件路径path，反射机制所需要的String参数。其不可<br>变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符<br>串指向对象的值，那么会引起很严重的安全问题</li>
<li>加快字符串处理速度 由于String是不可变的，保证了hashcode 的唯一<br>性，于是在创建对象时其hashcode就可以放心的缓存了，不需要重新计算。<br>这也就是Map喜欢将String作为Key的原因，处理速度要快过其它的键对象<br>。所以HashMap中的键往往都使用String</li>
</ol>
<h3 id="直接赋予一个字符串和new-String一样吗？"><a href="#直接赋予一个字符串和new-String一样吗？" class="headerlink" title="直接赋予一个字符串和new String一样吗？"></a>直接赋予一个字符串和new String一样吗？</h3><ol>
<li>使用String a = “aaa” ，程序运行时会在常量池中查找”aaa”字符串，<br>若没有，会将”aaa”字符串放进常量池，再将其地址赋给a，若有，将找到的<br>”aaa”字符串的地址赋给a</li>
<li>使用String b = new String(“aaa”)，程序会在堆内存中开辟一片新空<br>间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，<br>无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放<br>新对象</li>
</ol>
<h3 id="intern-函数的作用？"><a href="#intern-函数的作用？" class="headerlink" title="intern()函数的作用？"></a>intern()函数的作用？</h3><p>intern函数的作用是将对应的符号常量进入特殊处理</p>
<ol>
<li>JDK1.6 在JDK1.6中，intern的处理是 先判断字符串常量是否在字符串<br>常量池中，如果存在直接返回该常量，如果没有找到，则将该字符串常量加<br>入到字符串常量区，也就是在字符串常量区建立该常量</li>
<li>JDK1.7 在JDK1.7中，intern的处理是 先判断字符串常量是否在字符串<br>常量池中，如果存在直接返回该常量，如果没有找到，说明该字符串常量在<br>堆中，则处理是把堆区该对象的引用加入到字符串常量池中，以后别人拿到<br>的是该字符串常量的引用，实际存在堆中</li>
</ol>
<h3 id="有了解过Java中的NIO吗？原理是什么？"><a href="#有了解过Java中的NIO吗？原理是什么？" class="headerlink" title="有了解过Java中的NIO吗？原理是什么？"></a>有了解过Java中的NIO吗？原理是什么？</h3><ol>
<li>基于直接内存实现</li>
<li>NIO底层原理，同步非阻塞的IO模型，它是面向缓冲区的</li>
</ol>
<h3 id="RPC具体过程"><a href="#RPC具体过程" class="headerlink" title="RPC具体过程"></a>RPC具体过程</h3><p>当远程过程调用，简称为RPC，是一个计算机通信协议，它允许运行于一台<br>计算机的程序调用另一台计算机的子程序，而无需额外地为这个交互作用<br>编程</p>
<ol>
<li>传输效率高(二进制传输)，发起调用的一方无需知道RPC的具体实现，如同<br>调用本地函数般调用</li>
<li>通用性不如HTTP好(HTTP是标准协议)</li>
<li>RPC适合内部服务间的通信调用；HTTP适合面向用户与服务间的通信调用</li>
</ol>
<h3 id="RPC用到的技术？"><a href="#RPC用到的技术？" class="headerlink" title="RPC用到的技术？"></a>RPC用到的技术？</h3><ol>
<li>动态代理</li>
<li>序列化</li>
<li>NIO</li>
<li>服务注册中心</li>
</ol>
<h3 id="从用户输入密码到密码存储到登录密码校验的整个流程？"><a href="#从用户输入密码到密码存储到登录密码校验的整个流程？" class="headerlink" title="从用户输入密码到密码存储到登录密码校验的整个流程？"></a>从用户输入密码到密码存储到登录密码校验的整个流程？</h3><ol>
<li>为什么不用https协议</li>
<li>如果用的https协议，就一定是安全的吗</li>
<li>写代码的人是知道明文密码后进行加密存储到数据库的，这个过程怎么保证安全性</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>JAVA集合总结</span></a></div><div class="next-post pull-right"><a href="/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><span>刷题总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/01/30/JAVA基础总结/';
  this.page.title = 'JAVA基础总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>