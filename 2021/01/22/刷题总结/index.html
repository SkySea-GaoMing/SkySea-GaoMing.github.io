<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="刷题总结"><meta name="keywords" content="DataStructure"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>刷题总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#刷题分类"><span class="toc-number">1.</span> <span class="toc-text">刷题分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二分查找"><span class="toc-number">1.1.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中找位置"><span class="toc-number">1.1.1.</span> <span class="toc-text">数组中找位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#平方根"><span class="toc-number">1.1.2.</span> <span class="toc-text">平方根</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动窗口"><span class="toc-number">1.2.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#滑动窗口最大值"><span class="toc-number">1.2.1.</span> <span class="toc-text">滑动窗口最大值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">1.3.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一个元素在数组中的次数大于n-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">一个元素在数组中的次数大于n&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大子序和"><span class="toc-number">1.3.2.</span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除排序数组中重复元素"><span class="toc-number">1.3.3.</span> <span class="toc-text">删除排序数组中重复元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回一个数组的所有子集"><span class="toc-number">1.3.4.</span> <span class="toc-text">返回一个数组的所有子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#除自身以外数组的乘积"><span class="toc-number">1.3.5.</span> <span class="toc-text">除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#盛水容器"><span class="toc-number">1.3.6.</span> <span class="toc-text">盛水容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中第k个最大元素"><span class="toc-number">1.3.7.</span> <span class="toc-text">数组中第k个最大元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个正序数组的中位数"><span class="toc-number">1.3.8.</span> <span class="toc-text">两个正序数组的中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乘积最大子数组"><span class="toc-number">1.3.9.</span> <span class="toc-text">乘积最大子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大子序和-1"><span class="toc-number">1.3.10.</span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#岛屿最大面积"><span class="toc-number">1.3.11.</span> <span class="toc-text">岛屿最大面积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接雨水问题"><span class="toc-number">1.3.12.</span> <span class="toc-text">接雨水问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">1.4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反转一个字符串中的单词"><span class="toc-number">1.4.1.</span> <span class="toc-text">反转一个字符串中的单词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最长回文子串"><span class="toc-number">1.4.2.</span> <span class="toc-text">最长回文子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">1.5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不给前置节点条件下删除链表中的节点"><span class="toc-number">1.5.1.</span> <span class="toc-text">不给前置节点条件下删除链表中的节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反转一个单链表"><span class="toc-number">1.5.2.</span> <span class="toc-text">反转一个单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#k个一组反转链表"><span class="toc-number">1.5.3.</span> <span class="toc-text">k个一组反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合并两个有序链表"><span class="toc-number">1.5.4.</span> <span class="toc-text">合并两个有序链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#找到相交链表的起始节点"><span class="toc-number">1.5.5.</span> <span class="toc-text">找到相交链表的起始节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#判断一个链表是否有环"><span class="toc-number">1.5.6.</span> <span class="toc-text">判断一个链表是否有环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除排序链表中的重复元素"><span class="toc-number">1.5.7.</span> <span class="toc-text">删除排序链表中的重复元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回文链表"><span class="toc-number">1.5.8.</span> <span class="toc-text">回文链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复制带随机指针的链表"><span class="toc-number">1.5.9.</span> <span class="toc-text">复制带随机指针的链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重排链表"><span class="toc-number">1.5.10.</span> <span class="toc-text">重排链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树"><span class="toc-number">1.6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#求二叉树的最大深度"><span class="toc-number">1.6.1.</span> <span class="toc-text">求二叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#找二叉树的最近公共祖先"><span class="toc-number">1.6.2.</span> <span class="toc-text">找二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第k小的元素"><span class="toc-number">1.6.3.</span> <span class="toc-text">第k小的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从前序与中序遍历序列构造二叉树"><span class="toc-number">1.6.4.</span> <span class="toc-text">从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从中序与后序遍历序列构造二叉树"><span class="toc-number">1.6.5.</span> <span class="toc-text">从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重上到下打印二叉树"><span class="toc-number">1.6.6.</span> <span class="toc-text">重上到下打印二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的右视图"><span class="toc-number">1.6.7.</span> <span class="toc-text">二叉树的右视图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TopK"><span class="toc-number">1.7.</span> <span class="toc-text">TopK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计题"><span class="toc-number">1.8.</span> <span class="toc-text">设计题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最小栈"><span class="toc-number">1.8.1.</span> <span class="toc-text">最小栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个栈实现队列"><span class="toc-number">1.8.2.</span> <span class="toc-text">两个栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU缓存机制"><span class="toc-number">1.8.3.</span> <span class="toc-text">LRU缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#验证栈序列"><span class="toc-number">1.8.4.</span> <span class="toc-text">验证栈序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-number">1.9.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二维网格找路径"><span class="toc-number">1.9.1.</span> <span class="toc-text">二维网格找路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二维网格找路径II"><span class="toc-number">1.9.2.</span> <span class="toc-text">二维网格找路径II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比特位计数"><span class="toc-number">1.9.3.</span> <span class="toc-text">比特位计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#做菜顺序"><span class="toc-number">1.9.4.</span> <span class="toc-text">做菜顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最长湍流子数组"><span class="toc-number">1.9.5.</span> <span class="toc-text">最长湍流子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小路径和"><span class="toc-number">1.9.6.</span> <span class="toc-text">最小路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用最小花费爬阶梯"><span class="toc-number">1.9.7.</span> <span class="toc-text">使用最小花费爬阶梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最长递增子序列"><span class="toc-number">1.9.8.</span> <span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最长公共子序列"><span class="toc-number">1.9.9.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编辑距离"><span class="toc-number">1.9.10.</span> <span class="toc-text">编辑距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#零钱兑换"><span class="toc-number">1.9.11.</span> <span class="toc-text">零钱兑换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#股票系列"><span class="toc-number">1.10.</span> <span class="toc-text">股票系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#买股票最佳时机I"><span class="toc-number">1.10.1.</span> <span class="toc-text">买股票最佳时机I</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#买股票的最佳时机II"><span class="toc-number">1.10.2.</span> <span class="toc-text">买股票的最佳时机II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#括号系列"><span class="toc-number">1.11.</span> <span class="toc-text">括号系列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节"><span class="toc-number">1.12.</span> <span class="toc-text">字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指Offer"><span class="toc-number">1.13.</span> <span class="toc-text">剑指Offer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数学"><span class="toc-number">1.14.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#只出现一次的数字，使用异或"><span class="toc-number">1.14.1.</span> <span class="toc-text">只出现一次的数字，使用异或</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#判断一个数是回文数"><span class="toc-number">1.14.2.</span> <span class="toc-text">判断一个数是回文数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反转一个数字"><span class="toc-number">1.14.3.</span> <span class="toc-text">反转一个数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#平方数之和"><span class="toc-number">1.14.4.</span> <span class="toc-text">平方数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完美数"><span class="toc-number">1.14.5.</span> <span class="toc-text">完美数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卡牌分组"><span class="toc-number">1.14.6.</span> <span class="toc-text">卡牌分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大交换"><span class="toc-number">1.14.7.</span> <span class="toc-text">最大交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二进制中1的个数"><span class="toc-number">1.14.8.</span> <span class="toc-text">二进制中1的个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#颠倒二进制位"><span class="toc-number">1.14.9.</span> <span class="toc-text">颠倒二进制位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三数之和"><span class="toc-number">1.14.10.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字典排序"><span class="toc-number">1.14.11.</span> <span class="toc-text">字典排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回溯"><span class="toc-number">1.15.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一组数的所有排列"><span class="toc-number">1.15.1.</span> <span class="toc-text">一组数的所有排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树中和为某一值的路径"><span class="toc-number">1.15.2.</span> <span class="toc-text">二叉树中和为某一值的路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心"><span class="toc-number">1.16.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#交换一次的先前排列"><span class="toc-number">1.16.1.</span> <span class="toc-text">交换一次的先前排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跳跃游戏"><span class="toc-number">1.16.2.</span> <span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对称数组的交换"><span class="toc-number">1.16.3.</span> <span class="toc-text">对称数组的交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治"><span class="toc-number">1.17.</span> <span class="toc-text">分治</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#求逆序对"><span class="toc-number">1.17.1.</span> <span class="toc-text">求逆序对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#脑筋急转弯"><span class="toc-number">1.18.</span> <span class="toc-text">脑筋急转弯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剪绳子I"><span class="toc-number">1.19.</span> <span class="toc-text">剪绳子I</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#剪绳子II"><span class="toc-number">1.19.1.</span> <span class="toc-text">剪绳子II</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#智力题"><span class="toc-number">2.</span> <span class="toc-text">智力题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#高楼扔鸡蛋问题"><span class="toc-number">2.1.</span> <span class="toc-text">高楼扔鸡蛋问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#找砝码问题"><span class="toc-number">2.2.</span> <span class="toc-text">找砝码问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#找玻璃球问题"><span class="toc-number">2.3.</span> <span class="toc-text">找玻璃球问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#毒药问题"><span class="toc-number">2.4.</span> <span class="toc-text">毒药问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成随机数问题"><span class="toc-number">2.5.</span> <span class="toc-text">生成随机数问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先手必胜策略"><span class="toc-number">2.6.</span> <span class="toc-text">先手必胜策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#瓶子换饮料问题"><span class="toc-number">2.7.</span> <span class="toc-text">瓶子换饮料问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#烧香确定时间问题"><span class="toc-number">2.8.</span> <span class="toc-text">烧香确定时间问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#掰巧克力问题"><span class="toc-number">2.9.</span> <span class="toc-text">掰巧克力问题</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">刷题总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/22/刷题总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="刷题分类"><a href="#刷题分类" class="headerlink" title="刷题分类"></a>刷题分类</h2><p>String.split</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="数组中找位置"><a href="#数组中找位置" class="headerlink" title="数组中找位置"></a>数组中找位置</h4><p>有重复数字的升序数组的二分查找。思路很简单就是一直从中间位置开始查找即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index1=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> index2=n-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> mid=(index1+index2)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(a[mid]&gt;v)</span><br><span class="line">             index2=mid-<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;v)</span><br><span class="line">             index1=mid+<span class="number">1</span>;</span><br><span class="line">         mid=(index1+index2)/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span>(index1&gt;=index2)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">if</span>(a[mid]==v)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(a[mid]&gt;=v)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">while</span>(a[mid]&gt;=v)</span><br><span class="line">              mid--;</span><br><span class="line">          <span class="keyword">return</span> mid+<span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">while</span>(a[mid]&lt;v)</span><br><span class="line">             mid++;</span><br><span class="line">         <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h4><p>思路依然是找中间位置，判断中间位置和数值的关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">long</span> left=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">long</span> right=x/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//这里要取右中位数</span></span><br><span class="line">          <span class="keyword">long</span> mid=(left+right+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">          <span class="keyword">long</span> value=mid*mid;</span><br><span class="line">          <span class="keyword">if</span>(value&gt;x)</span><br><span class="line">              right=mid-<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">              left=mid;</span><br><span class="line">         </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">int</span>)left;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><p>给定一个数组nums 和滑动窗口的大小k，请找出所有滑动窗口里的最大值。如<br>果使用暴力破解法，那么时间复杂度是 O(nk)。优化就是在滑动时能够保证在<br>O(1)的时间复杂度内获取最大值。单调队列是指队列中元素之间的关系具有单<br>调性，而且队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。遍<br>历数组时每轮保证单调队列deque</p>
<ol>
<li>deque仅包含窗口内的元素，每轮窗口滑动移除了元素nums[i-1]，需将<br>deque内的对应元素一起删除</li>
<li>deque非严格递减，每轮窗口滑动添加了元素nums[j+1]，需将deque内<br>所有小于nums[j+1]的元素删除</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//未形成窗口时</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">	<span class="comment">//删除 dequedeque 内所有 &lt; nums[j]的元素，以保持deque递减</span></span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty()&amp;&amp; deque.peekLast() &lt; nums[i])</span><br><span class="line">		deque.removeLast();</span><br><span class="line">	deque.addLast(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">res[<span class="number">0</span>]=queue.peekFirst();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">	<span class="comment">//若i&gt;0且队首元素deque[0]=被删除元素nums[i - 1] 则队首元素出队</span></span><br><span class="line">	<span class="keyword">if</span>(deque.peekFirst()==nums[i-k])</span><br><span class="line">		deque.removeFirst();</span><br><span class="line">	<span class="comment">//删除 dequedeque 内所有 &lt; nums[j]的元素，以保持deque递减</span></span><br><span class="line">	<span class="keyword">while</span>(!queue.isEmpty()&amp;&amp; deque.peekLast() &lt; nums[i])</span><br><span class="line">		deque.removeLast();</span><br><span class="line">	deque.addLast(nums[i]);</span><br><span class="line">	res[i - k + <span class="number">1</span>] = deque.peekFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="一个元素在数组中的次数大于n-2"><a href="#一个元素在数组中的次数大于n-2" class="headerlink" title="一个元素在数组中的次数大于n/2"></a>一个元素在数组中的次数大于n/2</h4><p>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个<br>数开始计数，总能找到最多的那个。也就是摩尔投票法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> n=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(n!=nums[i])</span><br><span class="line">          &#123;</span><br><span class="line">              num--;</span><br><span class="line">              <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                  num=<span class="number">0</span>;</span><br><span class="line">                  n=nums[i];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              num++;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>至少要有一个元素。最简单的是动态规划的思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">	dp[i] = Math.max(dp[i- <span class="number">1</span>] + nums[i], nums[i]);	</span><br><span class="line">	<span class="keyword">if</span> (max &lt; dp[i]) &#123;</span><br><span class="line">		max = dp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贪心的思路跟动态规划很像</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">              num=num+nums[i];</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              num=nums[i];</span><br><span class="line">          max=max&gt;num?max:num;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除排序数组中重复元素"><a href="#删除排序数组中重复元素" class="headerlink" title="删除排序数组中重复元素"></a>删除排序数组中重复元素</h4><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现<br>一次，返回移除后数组新长度。使用快慢指针，快慢指针的意思就是定义两个<br>索引指针，一个走的快一个走的慢，快的就是正常遍历数组，慢的是遍历不<br>重复的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> value=nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]==value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//慢指针</span></span><br><span class="line">        index++;</span><br><span class="line">        nums[index]=nums[i];</span><br><span class="line">        value=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回一个数组的所有子集"><a href="#返回一个数组的所有子集" class="headerlink" title="返回一个数组的所有子集"></a>返回一个数组的所有子集</h4><p>主要体现在遍历的设计上，先是添加空数组，然后将每一个元素加入，十分巧妙<br>，遍历时每遇到一个数就把该数加到所有子集中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> all = res.size();</span><br><span class="line">         <span class="comment">//一开始只有空集</span></span><br><span class="line">         <span class="comment">//1加到所有子集上 空集 [1]</span></span><br><span class="line">         <span class="comment">//2加到所有子集上 空集 [2] [1,2]</span></span><br><span class="line">         <span class="comment">//3加到所有子集上...</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; all; j++) &#123;</span><br><span class="line">              List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(res.get(j));</span><br><span class="line">              tmp.add(nums[i]);</span><br><span class="line">              res.add(tmp);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h4><p>返回输出数组，其中output[i]等于nums中除nums[i]之外其余各元素的乘积。对<br>与nums[i]来说，乘积 = 当前数左边的乘积 * 当前数右边的乘积</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">      <span class="keyword">int</span> help=<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//从左边开始获取nums[i]左边的乘积</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          array[i]=help;</span><br><span class="line">          help*=nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      help=<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//从右边开始获取获取nums[i]右边的乘积</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">          array[i]*=help;</span><br><span class="line">          help*=nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br></pre></td></tr></table></figure>
<h4 id="盛水容器"><a href="#盛水容器" class="headerlink" title="盛水容器"></a>盛水容器</h4><p>双指针，每次都移动较短的那个柱子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> right=height.length-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> min=height[right]&lt;height[left]?height[right]:height[left];</span><br><span class="line">      <span class="keyword">int</span> max=(right-left)*min;</span><br><span class="line">      <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">              left++;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              right--;</span><br><span class="line">          min=height[left]&lt;height[right]?height[left]:height[right];</span><br><span class="line">          <span class="keyword">if</span>(max&lt;min*(right-left))</span><br><span class="line">              max=min*(right-left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br></pre></td></tr></table></figure>
<h4 id="数组中第k个最大元素"><a href="#数组中第k个最大元素" class="headerlink" title="数组中第k个最大元素"></a>数组中第k个最大元素</h4><p>在未排序的数组中找到第k个最大的元素。构建一个大顶堆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造一个大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	  &#123;</span><br><span class="line">		sink(nums,i,nums.length);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="comment">//每次移除最大元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;nums.length-<span class="number">1</span>-k;i--)</span><br><span class="line">	  &#123;</span><br><span class="line">		<span class="keyword">int</span> temp=nums[i];</span><br><span class="line">		nums[i]=nums[<span class="number">0</span>];</span><br><span class="line">		nums[<span class="number">0</span>]=temp;</span><br><span class="line">		sink(nums,<span class="number">0</span>,i);</span><br><span class="line">	  &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*k+<span class="number">1</span>;j&lt;length;j=<span class="number">2</span>*j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j+<span class="number">1</span>&lt;length&amp;&amp;array[j]&lt;array[j+<span class="number">1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="keyword">if</span>(array[j]&gt;array[k])</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=array[k];</span><br><span class="line">		array[k]=array[j];</span><br><span class="line">		array[j]=temp;</span><br><span class="line">		k=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两个正序数组的中位数"><a href="#两个正序数组的中位数" class="headerlink" title="两个正序数组的中位数"></a>两个正序数组的中位数</h4><p>这个题如果要求时间复杂度为O(m+n)其实很简单，就是直接通过遍历比<br>较找到中间位置，但是时间复杂度要求为O(log(m+n))，应该联想到用<br>二分思想，首先要分奇偶来求出中位数，参考力扣一个大牛的话(m+n+1)<br>和(m+n+2)取平均值可以消除奇偶的影响，首先考虑如何找到数组中第k<br>个元素，一种思路是双指针进行比较求得第k个元素，但是时间复杂度为<br>O(m+n)，如果利用二分查找，先分别在两个数组中找到第k/2个元素，<br>比较这两个元素比如nums1[k/2] &lt; nums2[k/2]，那么nums1数组前k/2个<br>一定不存在第k个元素，此时删除nums1前k/2个元素，然后继续找，这个时<br>候实际找的是第k-k/2个元素，因为k/2个元素已经被除去了嘛，所以接下<br>来查找的范围就会越来越小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> m=nums1.length;</span><br><span class="line">      <span class="keyword">int</span> n=nums2.length;</span><br><span class="line">      <span class="keyword">int</span> left=(m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> right=(m+n+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> (findk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left)+findk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right))/<span class="number">2.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findk</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> i,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;=nums1.length)</span><br><span class="line">        <span class="keyword">return</span> nums2[j+k-<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=nums2.length)</span><br><span class="line">        <span class="keyword">return</span> nums1[i+k-<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Math.min(nums1[i],nums2[j]);</span><br><span class="line">      <span class="keyword">int</span> midindex1=(i+k/<span class="number">2</span>-<span class="number">1</span>&lt;nums1.length)?nums1[i+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">int</span> midindex2=(j+k/<span class="number">2</span>-<span class="number">1</span>&lt;nums2.length)?nums2[j+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">if</span>(midindex1&lt;midindex2)</span><br><span class="line">        <span class="keyword">return</span> findk(nums1,i+k/<span class="number">2</span>,nums2,j,k-k/<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> findk(nums1,i,nums2,j+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h4><p>核心思路就是以0为分界遍历数组更新最大值，对于负数的数量影响可以<br>想到从开头和结尾两个方向遍历解决奇数情况</p>
<ol>
<li>负数为偶数个，则整个数组的各个值相乘为最大值</li>
<li>负数为奇数个，则从左边开始，乘到最后一个负数停止有一个“最大值”，<br>从右边也有一个“最大值”，比较，得出最大值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          num*=nums[i];</span><br><span class="line">          max=Math.max(num,max);</span><br><span class="line">          <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">              num=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">          num*=nums[i];</span><br><span class="line">          max=Math.max(num,max);</span><br><span class="line">          <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">              num=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大子序和-1"><a href="#最大子序和-1" class="headerlink" title="最大子序和"></a>最大子序和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(num&gt;=<span class="number">0</span>)</span><br><span class="line">              num+=nums[i];</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              num=nums[i];</span><br><span class="line">          max=Math.max(max,num);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="岛屿最大面积"><a href="#岛屿最大面积" class="headerlink" title="岛屿最大面积"></a>岛屿最大面积</h4><p>找到给定的二维数组中最大的岛屿面积。这道题需要利用深度优先搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> num=dfs(i,j,grid);</span><br><span class="line">                    max=max&gt;num?max:num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=grid.length||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        grid[i][j]=<span class="number">0</span>;</span><br><span class="line">        num+=dfs(i-<span class="number">1</span>,j,grid);</span><br><span class="line">        num+=dfs(i+<span class="number">1</span>,j,grid);</span><br><span class="line">        num+=dfs(i,j+<span class="number">1</span>,grid);</span><br><span class="line">        num+=dfs(i,j-<span class="number">1</span>,grid);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="接雨水问题"><a href="#接雨水问题" class="headerlink" title="接雨水问题"></a>接雨水问题</h4><p>给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，<br>下雨之后能接多少雨水。使用单调栈，单调栈分为单调递增栈和单调递减栈。<br>这里，当后面的柱子高度比前面的低时，是无法接雨水的，当找到一根比前<br>面高的柱子，就可以计算接到的雨水，所以使用单调递减栈。</p>
<ol>
<li>对更低的柱子入栈，更低的柱子以为这后面如果能找到高柱子，这里就<br>能接到雨水，所以入栈把它保存起来</li>
<li>当出现高于栈顶的柱子时，说明可以对前面的柱子结算了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//特殊情况       </span></span><br><span class="line">   <span class="keyword">if</span>(height.length &lt;<span class="number">3</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">   	<span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()])&#123;          </span><br><span class="line">           <span class="comment">//栈顶元素</span></span><br><span class="line">           <span class="keyword">int</span> popnum = stack.pop(); </span><br><span class="line">           <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">int</span> l=stack.peek();</span><br><span class="line">           <span class="keyword">int</span> r=i;</span><br><span class="line">           <span class="keyword">int</span> h=Math.min(height[r],height[l])-height[popnum];</span><br><span class="line">           water+=(r-l-<span class="number">1</span>)*h;</span><br><span class="line">       &#125;</span><br><span class="line">       stack.push(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> water;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="反转一个字符串中的单词"><a href="#反转一个字符串中的单词" class="headerlink" title="反转一个字符串中的单词"></a>反转一个字符串中的单词</h4><p>你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。获取<br>字符串的字符数组，设置start和end两个位置，开始遍历，每次取得一个单词然后<br>反转字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] array=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;array.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((array[end]==<span class="string">' '</span>)||(end==array.length-<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cut=end;</span><br><span class="line">                <span class="keyword">if</span>(array[end]==<span class="string">' '</span>)</span><br><span class="line">                end--;</span><br><span class="line">            	<span class="comment">//这个操作就是反转一个字符串的核心</span></span><br><span class="line">                <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> tempt=array[end];</span><br><span class="line">                    array[end]=array[start];</span><br><span class="line">                    array[start]=tempt;</span><br><span class="line">                    start++;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">                start=cut+<span class="number">1</span>;</span><br><span class="line">                end=cut+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end++;</span><br><span class="line">        &#125;</span><br><span class="line">        s=<span class="keyword">new</span> String(array);</span><br></pre></td></tr></table></figure>
<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><p>易想到的是中心扩散法，从某个位置向两边进行扩散，但是要分两种情况<br>，例如aba abba</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> maxlength=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">    String ss=s.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()-<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        String s1=Stringcut(s,i,i+<span class="number">1</span>);</span><br><span class="line">        String s2=Stringcut(s,i,i);</span><br><span class="line">        String max=s1.length()&gt;s2.length()?s1:s2;</span><br><span class="line">        <span class="keyword">if</span>(max.length()&gt;maxlength)</span><br><span class="line">          &#123;</span><br><span class="line">              ss=max;</span><br><span class="line">              maxlength=max.length();</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Stringcut</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=s.length();</span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=right;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="不给前置节点条件下删除链表中的节点"><a href="#不给前置节点条件下删除链表中的节点" class="headerlink" title="不给前置节点条件下删除链表中的节点"></a>不给前置节点条件下删除链表中的节点</h4><p>这里只给了要删除的节点，没有给其前置节点，只需要把要删除节点的值设置<br>为下一个节点的值，然后next设置为下一个节点的next</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.val=node.next.val;</span><br><span class="line">   node.next=node.next.next;</span><br></pre></td></tr></table></figure>
<h4 id="反转一个单链表"><a href="#反转一个单链表" class="headerlink" title="反转一个单链表"></a>反转一个单链表</h4><ol>
<li>迭代方式 这个反转过程需要三个指针 pre cur next。每遍历到一个节点都要<br>改变节点的pre和next，比如遍历到第一个节点，此时获取next，然后把第一个节<br>点的next指向pre，然后pre更新为第一个节点，接下来遍历到下一个<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li>
<li>递归方式 既然使用递归首先要考虑递归的终止方式，有两个终止条件</li>
</ol>
<ul>
<li>终止条件是当前节点或者下一个节点==null</li>
<li>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函<br>数那句 head.next.next = head<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如1 2 3 4 5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> head;</span><br><span class="line">    	<span class="comment">//cur得到的值始终都是5</span></span><br><span class="line">    	ListNode cur=reverseList(head.next);</span><br><span class="line">    	<span class="comment">//得到head的顺序是4 3 2 1</span></span><br><span class="line">    	<span class="comment">//反转相邻节点4-5 3-4 2-3 1-2</span></span><br><span class="line">    	head.next.next=head;</span><br><span class="line">    	<span class="comment">//防止链表循环，需要将head.next设置为空，实际上就是1到2的引用必须除去</span></span><br><span class="line">    	head.next=<span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="k个一组反转链表"><a href="#k个一组反转链表" class="headerlink" title="k个一组反转链表"></a>k个一组反转链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">ListNode prev = dummy;</span><br><span class="line">ListNode curr = head,;</span><br><span class="line">ListNode next;</span><br><span class="line">      dummy.next = head;</span><br><span class="line">      <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">          length++;</span><br><span class="line">          head = head.next;</span><br><span class="line">      &#125;</span><br><span class="line">      head = dummy.next;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length / k; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123;</span><br><span class="line">              next = curr.next;</span><br><span class="line">              curr.next = next.next;</span><br><span class="line">              next.next = prev.next;</span><br><span class="line">              prev.next = next;</span><br><span class="line">          &#125;</span><br><span class="line">          prev = curr;</span><br><span class="line">          curr = prev.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dummy.next;</span><br></pre></td></tr></table></figure>

<h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的<br>两个链表的所有节点组成的。注意不能创建新节点。可以使用dummyHead，也<br>就是临时创建一个头节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  	ListNode prehead=pre;</span><br><span class="line">  	<span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> l2;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> l1;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">      	<span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">      		pre.next=l1;</span><br><span class="line">      		l1=l1.next;</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">else</span>&#123;</span><br><span class="line">      		pre.next=l2;</span><br><span class="line">      		l2=l2.next;</span><br><span class="line">      	&#125;</span><br><span class="line">      	pre=pre.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">      	pre.next=l2;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      	pre.next=l1;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> prehead.next;</span><br></pre></td></tr></table></figure>
<p>也可以使用递归解决，终止条件就是l1或l2为null，返回的是排序好的<br>链表头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="找到相交链表的起始节点"><a href="#找到相交链表的起始节点" class="headerlink" title="找到相交链表的起始节点"></a>找到相交链表的起始节点</h4><p>如果两个链表存在相交部分，那么从相交位置开始到末尾的长度都是相同的。<br>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这<br>个位置只能是较短链表的头结点位置。为此我们必须消除两个链表的长度差，<br>两个指针从相同位置开始遍历过程如果能相遇那么就有相交</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode node1=headA;</span><br><span class="line">      ListNode node2=headB;</span><br><span class="line">      <span class="keyword">while</span>(node1!=node2)</span><br><span class="line">      &#123;</span><br><span class="line">      	<span class="comment">//消除长度差的本质就是各自从另一条路走</span></span><br><span class="line">          node1=node1==<span class="keyword">null</span>?headB:node1.next;</span><br><span class="line">          node2=node2==<span class="keyword">null</span>?headA:node2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node1;</span><br></pre></td></tr></table></figure>
<h4 id="判断一个链表是否有环"><a href="#判断一个链表是否有环" class="headerlink" title="判断一个链表是否有环"></a>判断一个链表是否有环</h4><p>依然是使用快慢指针的思想，一个每次跳转到下一个节点，慢指针每次跳转两个<br>节点，最终如果有环一定可以相遇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ListNode node=head;</span><br><span class="line">      ListNode first=head;</span><br><span class="line">      ListNode second=head;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(first.next!=<span class="keyword">null</span>)</span><br><span class="line">              first=first.next;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(second.next!=<span class="keyword">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(second.next.next!=<span class="keyword">null</span>)</span><br><span class="line">                  second=second.next.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(first==second)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>接下来不仅判断有环，还要判断环的起始位置。</p>
<ol>
<li>fast 走的步数是slow步数的2倍，即 f= 2s</li>
<li>fast 比 slow多走了 n个环的长度，即 f = s + nb</li>
</ol>
<p>如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时<br>的步数是：k=a+nb（先走a步到入口节点，之后每绕1圈环都会再次到入口节点）<br>所以第一次重合之后让快指针从head开始走a步那么就与慢指针重合，这时就是<br>在环的入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode fast = head, slow = head;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          fast = fast.next.next;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fast = head;</span><br><span class="line">      <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          fast = fast.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fast;</span><br></pre></td></tr></table></figure>
<h4 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h4><p>注意链表是已经排序的。可以采用递归</p>
<ol>
<li>找终止条件：当head指向链表只剩一个元素的时候，自然是不可能重复<br>的，因此return</li>
<li>想想应该返回什么值：应该返回的自然是已经去重的链表的头节点</li>
<li>每一步要做什么：宏观上考虑，此时head.next已经指向一个去重的链表<br>了，而根据第二步，我应该返回一个去重的链表的头节点。因此这一步应该做<br>的是判断当前的head和head.next是否相等，如果相等则说明重了，返回<br>head.next，否则返回head<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">if</span>(head.val == head.next.val) head = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h4><p>请判断一个链表是否为回文链表。可以使用快慢指针，流程分为5步</p>
<ol>
<li>找到前半部分链表的尾节点 有两种办法，第一种直接遍历整个链表得<br>到链表长度，然后再遍历找到中间位置。第二种方式是通过快慢指针获取<br>链表的中间位置，慢指针每次走一步快指针一次走两步，当快指针到达<br>末尾时慢指针刚好到终点</li>
<li>反转后半部分链表 之前有一个反转链表的题</li>
<li>判断是否回文</li>
<li>恢复链表</li>
<li>返回结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode firstHalfEnd = endOfFirstHalf(head);</span><br><span class="line">        ListNode secondHalfStart = reverseList(firstHalfEnd.next);</span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = secondHalfStart;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd.next = reverseList(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">endOfFirstHalf</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h4><p>浅拷贝：返回地址一样的链表。 深拷贝：返回地址不一样，但关系一致的链<br>表。 所以不能直接简单粗暴的遍历复制，这样出来的复制是一样的地址。</p>
<ol>
<li>根据遍历到的原节点创建对应的新节点，每个新创建的节点是在原节点后面</li>
<li>第二步是最关键的一步，用来设置新链表的随机指针，原节点i的随机指针<br>(如果有的话)，指向的是原节点j，那么新节点i的随机指针，指向的是原节点<br>j的next</li>
<li>第三步就简单了，只要将两个链表分离开，再返回新链表就可以了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="comment">//第一步，在每个原节点后面创建一个新节点</span></span><br><span class="line">        <span class="comment">//1-&gt;1'-&gt;2-&gt;2'-&gt;3-&gt;3'</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(p.val);</span><br><span class="line">            newNode.next = p.next;</span><br><span class="line">            p.next = newNode;</span><br><span class="line">            p = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="comment">//第二步，设置新节点的随机节点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.random!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                p.next.random = p.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">        p = head;</span><br><span class="line">        Node cur = dummy;</span><br><span class="line">        <span class="comment">//第三步，将两个链表分离</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            cur.next = p.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            p.next = cur.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更简单的是通过哈希表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个哈希表，key是原节点，value是新节点</span></span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="comment">//将原节点和新节点放入哈希表中</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(p.val);</span><br><span class="line">            map.put(p,newNode);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="comment">//遍历原链表，设置新节点的next和random</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            Node newNode = map.get(p);</span><br><span class="line">            <span class="comment">//p是原节点，map.get(p)是对应的新节点，p.next是原节点的下一个</span></span><br><span class="line">            <span class="comment">//map.get(p.next)是原节点下一个对应的新节点</span></span><br><span class="line">            <span class="keyword">if</span>(p.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                newNode.next = map.get(p.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p.random是原节点随机指向</span></span><br><span class="line">            <span class="comment">//map.get(p.random)是原节点随机指向  对应的新节点 </span></span><br><span class="line">            <span class="keyword">if</span>(p.random!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                newNode.random = map.get(p.random);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回头结点，即原节点对应的value(新节点)</span></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><ol>
<li>快慢指针找到中间节点</li>
<li>反转后半段链表</li>
<li>合并前半段链表和后半段链表</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到链表的中间节点</span></span><br><span class="line">        ListNode mid = findMidNode(head);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将整个链表分成两个链表</span></span><br><span class="line">        ListNode head1 = head;</span><br><span class="line">        ListNode head2 = mid.next;</span><br><span class="line">        mid.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将第二个链表进行反转</span></span><br><span class="line">        head2 = revereList(head2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两个链表</span></span><br><span class="line">        mergeList(head1, head2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的中间节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">findMidNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="keyword">null</span>) <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表，并返回新的头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">revereList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nxt = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        ListNode t1 = <span class="keyword">null</span>, t2 = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 防止链表断开</span></span><br><span class="line">            t1 = head1.next;</span><br><span class="line">            t2 = head2.next;</span><br><span class="line"></span><br><span class="line">            head1.next = head2;</span><br><span class="line">            head2.next = t1;</span><br><span class="line"></span><br><span class="line">            head1 = t1;</span><br><span class="line">            head2 = t2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="求二叉树的最大深度"><a href="#求二叉树的最大深度" class="headerlink" title="求二叉树的最大深度"></a>求二叉树的最大深度</h4><p>使用递归的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=deep(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=deep(root.right);</span><br><span class="line">        <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left=deep(node.left);</span><br><span class="line">            <span class="keyword">int</span> right=deep(node.right);</span><br><span class="line">            <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="找二叉树的最近公共祖先"><a href="#找二叉树的最近公共祖先" class="headerlink" title="找二叉树的最近公共祖先"></a>找二叉树的最近公共祖先</h4><p>这里是二叉树而不是二叉搜索树，不能直接根据节点的值判断。但是依然根据<br>节点的位置来判断公共祖先，遍历到某个节点时，判断左右子树中p和q的情<br>况，如果左右都有那么就是root，如果只有左或右那么p和q中一定有一个<br>是公共祖先</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//当遍历到叶结点后就会返回null</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当找到p或者q的是时候就会返回pq</span></span><br><span class="line">        <span class="comment">/*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外</span></span><br><span class="line"><span class="comment">       一个，我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的结点进行保存，可能是null</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">//也可能是pq，还可能是公共祖先</span></span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果左右都存在，就说明pq都出现了，这就是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//否则我们返回已经找到的那个值（存储在left，与right中），p或者q</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//还有一种可能就是，由下面返回的公共祖先，并将这个值一路返回到最表层</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="第k小的元素"><a href="#第k小的元素" class="headerlink" title="第k小的元素"></a>第k小的元素</h4><p>中序遍历得到的就是一个有序序列，最简单的思路是得到树中元素个数，<br>然后中序遍历存放到数组中，当遍历到第k个就停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       count=k;</span><br><span class="line">       search(root);</span><br><span class="line">       <span class="keyword">return</span> val;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode node)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       </span><br><span class="line">       search(node.left);</span><br><span class="line">       index++;</span><br><span class="line">       <span class="keyword">if</span>(index==count)</span><br><span class="line">           &#123;</span><br><span class="line">               val=node.val;</span><br><span class="line">               <span class="keyword">return</span> ;</span><br><span class="line">           &#125;</span><br><span class="line">       search(node.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h4><p>要利用好中序和前序的性质，注意边界关系 <img src="/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<ol>
<li>从左到右遍历preorder、inorder</li>
<li>preorder的第一个元素一定是根元素</li>
</ol>
<ul>
<li>2.1. 找到根元素后，可以在inorder中区分左、右子树</li>
<li>2.2. 当前根的左子树范围：inorder[inorder未查找的最左边（从0开始），<br>和根元素相等的索引位置</li>
<li>2.3. 当前根的左子树范围：preorder(当前根索引位置（从0开始）, 当前<br>根的索引位置 + inorder已知左子树长度，原因：因为preorder、inorder中<br>左、右子树的长度相等（只是观察得出，为什么这么巧，还没想透彻）</li>
</ul>
<ol start="3">
<li>当preorder的指针向右移动到”左子树长度”，说明当前根节点的左子树已经处理完毕</li>
<li>递归开始查找，如果没有超出左子树范围，preorder指针向右移动一位继续搜索</li>
</ol>
<ul>
<li>4.1. 此时的节点最多只可能有2种身份：A + B<br>A. 根节点<br>B. 左节点或右节点</li>
<li>4.2. inorder的起始节点是”最左的节点”，当preorder中的值与他相等时，可<br>以判断无后续数据，结束搜索</li>
<li>4.3  inorder指针向右移动一位（排除已使用节点），缩小搜索范围</li>
</ul>
<ol start="5">
<li>右节点确定规则：因为上一步确定的是一个左节点，preorder顺序为根左右，<br>所以preorder的下一个节点就是右节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">           &#123; <span class="keyword">if</span>(preorder[<span class="number">0</span>]==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        root.left=sear(<span class="number">1</span>,index,<span class="number">0</span>,index-<span class="number">1</span>,preorder,inorder);</span><br><span class="line">        root.right=sear(index+<span class="number">1</span>,preorder.length-<span class="number">1</span>,index+<span class="number">1</span>,</span><br><span class="line">        	inorder.length-<span class="number">1</span>,preorder,inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sear</span><span class="params">(<span class="keyword">int</span> left1,<span class="keyword">int</span> right1,<span class="keyword">int</span> left2,<span class="keyword">int</span> right2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] preorder,<span class="keyword">int</span>[] inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left1&gt;right1||left2&gt;right2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> TreeNode(preorder[left1]);</span><br><span class="line">        <span class="keyword">int</span> index=left1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left2;i&lt;=right2;i++)</span><br><span class="line">            &#123;<span class="keyword">if</span>(preorder[left1]==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        node.left=sear(left1+<span class="number">1</span>,left1+index-left2,left2,index-<span class="number">1</span>,preorder</span><br><span class="line">        ,inorder);</span><br><span class="line">        node.right=sear(left1+<span class="number">1</span>+index-left2,right1,index+<span class="number">1</span>,right2</span><br><span class="line">        ,preorder,inorder);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[postorder.length-<span class="number">1</span>]==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left=sear(<span class="number">0</span>,index-<span class="number">1</span>,<span class="number">0</span>,index-<span class="number">1</span>,inorder,postorder);</span><br><span class="line">        root.right=sear(index+<span class="number">1</span>,inorder.length-<span class="number">1</span>,index,inorder.length-<span class="number">2</span>,</span><br><span class="line">        inorder,postorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sear</span><span class="params">(<span class="keyword">int</span> left1,<span class="keyword">int</span> right1,<span class="keyword">int</span> left2,<span class="keyword">int</span> right2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] inorder,<span class="keyword">int</span>[] postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left1&gt;right1||left2&gt;right2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> TreeNode(postorder[right2]);</span><br><span class="line">        <span class="keyword">int</span> index=left1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left1;i&lt;=right1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==postorder[right2])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left=sear(left1,index-<span class="number">1</span>,left2,left2+index-<span class="number">1</span>-left1,inorder,</span><br><span class="line">        postorder);</span><br><span class="line">        node.right=sear(index+<span class="number">1</span>,right1,left2+index-left1,right2-<span class="number">1</span>,</span><br><span class="line">        inorder,postorder);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="重上到下打印二叉树"><a href="#重上到下打印二叉树" class="headerlink" title="重上到下打印二叉树"></a>重上到下打印二叉树</h4><p>可以用一个flag判断当前行是从左到右还是从右到左</p>
<h4 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h4><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从<br>右侧所能看到的节点值。容易想到层次遍历，但注意只保留每层最后一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode node=root;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        list.add(root);</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num=list.size();</span><br><span class="line">            <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                node=list.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">			        list.add(node.left);</span><br><span class="line">		        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">			        list.add(node.right);</span><br><span class="line">                num--;</span><br><span class="line">                temp=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            list2.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h3><h3 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h3><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>前三种操作都可以完成，如何获取最小元素，每次入栈的时候都要判断这个元素是<br>不是最小的，如果不是最小的那么直接入栈，如果是最小的，那么首先把之前最小<br>的入栈，然后该元素入栈。这样做的目的是如果该元素要出栈，那么出栈时判断这<br>个元素是最小的，那么继续出栈就获取之前最小的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(min&gt;=x)</span><br><span class="line">      &#123;</span><br><span class="line">          stack.push(min);</span><br><span class="line">          min=x;</span><br><span class="line">      &#125;</span><br><span class="line">       stack.push(x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(stack.pop()==min)</span><br><span class="line">           min=stack.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h4><p>直接使用两个Stack，但是栈底的元素无法删除，所以一个添加栈用来添加<br>元素，当需要删除元素的时候，就把添加栈的元素转移到删除栈中，此时<br>元素就已经反转顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1,stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.empty() &amp;&amp; stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h4><p>LinkedHashMap可以实现LRU，在构造参数中设置accessOrder为true，<br>重写removeEldestEntry表示达到限定容量时进行删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        cache = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cache.size() &gt; capacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Integer a=cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(a!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="验证栈序列"><a href="#验证栈序列" class="headerlink" title="验证栈序列"></a>验证栈序列</h4><p>给定 pushed 和 popped 两个序列，每个序列中的值都不重复，只有当<br>它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结<br>果时，返回 true，否则返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//索引popped</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">          stack.push(pushed[i]);</span><br><span class="line">          <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[j]) &#123;</span><br><span class="line">              j++;</span><br><span class="line">              stack.pop();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack.isEmpty();</span><br></pre></td></tr></table></figure>



<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol>
<li>斐波那契数列 dp[n]=dp[n−1]+dp[n−2]</li>
</ol>
<h4 id="二维网格找路径"><a href="#二维网格找路径" class="headerlink" title="二维网格找路径"></a>二维网格找路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        array[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        array[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">             array[i][j]=array[i-<span class="number">1</span>][j]+array[i][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="二维网格找路径II"><a href="#二维网格找路径II" class="headerlink" title="二维网格找路径II"></a>二维网格找路径II</h4><p>网格中有障碍物</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">          dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;obstacleGrid.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line">              num=<span class="number">0</span>;</span><br><span class="line">          dp[i][<span class="number">0</span>]=num;</span><br><span class="line">      &#125;</span><br><span class="line">      num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;obstacleGrid[<span class="number">0</span>].length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span>)</span><br><span class="line">              num=<span class="number">0</span>;</span><br><span class="line">          dp[<span class="number">0</span>][i]=num;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;obstacleGrid.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;obstacleGrid[<span class="number">0</span>].length;j++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)</span><br><span class="line">                  dp[i][j]=<span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h4><p>计算其二进制数中的1的数目并将它们作为数组返回。<br>这是一道典型的动态规划题，我一开始想找相邻两个数之间的关系结果不行，一个<br>大牛的解法就是对于一个二进制数来说，如果它的最低位为1（%2为1）,则它与<br>n/2的1个数相差1。如果它的最低位为0，则它与n/2的1个数相同。有些动态规划题<br>并不一定是相邻的数之间有关系也有可能有间隔</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=num/<span class="number">2</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              array[i*<span class="number">2</span>]=array[i];</span><br><span class="line">              <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span>&lt;=num)</span><br><span class="line">                  array[i*<span class="number">2</span>+<span class="number">1</span>]=array[i]+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<h4 id="做菜顺序"><a href="#做菜顺序" class="headerlink" title="做菜顺序"></a>做菜顺序</h4><p>首先应该想到倒序排序，从最大值开始累加，如果出现负数就说明已经结束了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(satisfaction);</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=satisfaction.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(num&gt;=<span class="number">0</span>)</span><br><span class="line">          &#123;       </span><br><span class="line">              num=num+satisfaction[i]+sum;</span><br><span class="line">              sum+=satisfaction[i];</span><br><span class="line">              max=Math.max(num,max);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长湍流子数组"><a href="#最长湍流子数组" class="headerlink" title="最长湍流子数组"></a>最长湍流子数组</h4><p>核心就是找当前状态与前一个状态和前一个状态与前前一个状态的关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">      dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(A.length&gt;<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(A[<span class="number">1</span>]==A[<span class="number">0</span>])</span><br><span class="line">              dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  dp[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                  max=<span class="number">2</span>;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;A.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">int</span> num1=A[i]-A[i-<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">int</span> num2=A[i-<span class="number">2</span>]-A[i-<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span>((num1&gt;<span class="number">0</span>&amp;&amp;num2&gt;<span class="number">0</span>)||(num1&lt;<span class="number">0</span>&amp;&amp;num2&lt;<span class="number">0</span>))</span><br><span class="line">              dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>((num1&gt;<span class="number">0</span>&amp;&amp;num2&lt;<span class="number">0</span>)||(num1&lt;<span class="number">0</span>&amp;&amp;num2&gt;<span class="number">0</span>))</span><br><span class="line">              dp[i]=<span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(num1==<span class="number">0</span>)</span><br><span class="line">                  dp[i]=<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  dp[i]=<span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          max=Math.max(max,dp[i]);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h4><p>当前位置与上一个和左一个位置的关系，但是注意选最小的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          dp[i][<span class="number">0</span>]=grid[i][<span class="number">0</span>]+dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid[<span class="number">0</span>].length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          dp[<span class="number">0</span>][i]=grid[<span class="number">0</span>][i]+dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].length;j++)</span><br><span class="line">          &#123;</span><br><span class="line">              dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用最小花费爬阶梯"><a href="#使用最小花费爬阶梯" class="headerlink" title="使用最小花费爬阶梯"></a>使用最小花费爬阶梯</h4><p>数组的每个下标作为一个阶梯，第i个阶梯对应着一个非负数的体力花费<br>值cost[i]。核心就是找到当前状态与前一个和前两个之间的关系，先得<br>到小问题的解，小问题是最优解最后累积为大问题的解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[cost.length+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span>(cost.length&gt;<span class="number">2</span>)</span><br><span class="line">          dp[<span class="number">2</span>]=cost[<span class="number">0</span>]&gt;cost[<span class="number">1</span>]?cost[<span class="number">1</span>]:cost[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=cost.length;i++)</span><br><span class="line">          dp[i]=Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">      <span class="keyword">return</span> dp[cost.length];</span><br></pre></td></tr></table></figure>
<h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><p>可以定义一个数组保存当前位置为止的最长上升子序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    max=Math.max(max,array[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            array[i]=max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;array[i])</span><br><span class="line">                max=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p>给定两个字符串text1 和text2，返回这两个字符串的最长公共子序列的长度。<br>这是典型的动态规划问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1=text1.length();</span><br><span class="line">        <span class="keyword">int</span> length2=text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i)==text2.charAt(j))</span><br><span class="line">                &#123;</span><br><span class="line">                    array[i+<span class="number">1</span>][j+<span class="number">1</span>]=array[i][j]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(array[i+<span class="number">1</span>][j]&gt;array[i][j+<span class="number">1</span>])</span><br><span class="line">                    array[i+<span class="number">1</span>][j+<span class="number">1</span>]=array[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    array[i+<span class="number">1</span>][j+<span class="number">1</span>]=array[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[length1][length2];</span><br></pre></td></tr></table></figure>
<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><p>给你两个单词word1 和word2，请你计算出将word1 转换成word2 所使用<br>的最少操作数。其实跟平常的动态规划题差别不大，核心就是分析最优情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=word1.length();</span><br><span class="line">        <span class="keyword">int</span> n=word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] cost=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            cost[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            cost[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    cost[i][j] = cost[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cost[i][j] = <span class="number">1</span> + </span><br><span class="line">                    Math.min(cost[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(cost[i][j-<span class="number">1</span>], </span><br><span class="line">                    cost[i-<span class="number">1</span>][j]));</span><br><span class="line">                &#125;             </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = coin; x &lt; amount + <span class="number">1</span>; ++x) &#123;</span><br><span class="line">        dp[x] += dp[x - coin];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h3><h4 id="买股票最佳时机I"><a href="#买股票最佳时机I" class="headerlink" title="买股票最佳时机I"></a>买股票最佳时机I</h4><p>区间和可以转换成求差的问题，求差问题，也可以转换成区间和的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       num=Math.max(<span class="number">0</span>,num+prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">       profit=Math.max(num,profit);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>也可以用动态规划的思想，前i天的最大收益 = max{前i-1天的最大收益，第i天<br>的价格-前i-1天中的最小价格}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">          dp[i] = Math.max(dp[i - <span class="number">1</span>], prices[i] - min);</span><br><span class="line">          min = Math.min(min, prices[i]);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="买股票的最佳时机II"><a href="#买股票的最佳时机II" class="headerlink" title="买股票的最佳时机II"></a>买股票的最佳时机II</h4><p>你可以尽可能地完成更多的交易（多次买卖一支股票）。这道题的条件其实很<br>宽松，可以进行多次买卖，所以只关注眼前每次遇到更大的就买卖，贪心算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;prices[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                sum=sum+prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="括号系列"><a href="#括号系列" class="headerlink" title="括号系列"></a>括号系列</h3><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><h3 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h3><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="只出现一次的数字，使用异或"><a href="#只出现一次的数字，使用异或" class="headerlink" title="只出现一次的数字，使用异或"></a>只出现一次的数字，使用异或</h4><p>考察异或的用法<br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。<br>找出那个只出现了一次的元素，使用异或求解，异或的用法就是对于两个相同的数<br>异或结果是0，一个数跟0异或结果还是这个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
<h4 id="判断一个数是回文数"><a href="#判断一个数是回文数" class="headerlink" title="判断一个数是回文数"></a>判断一个数是回文数</h4><ol>
<li>第一种方式就是将这个数变为字符串然后反转<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String reversedStr = (<span class="keyword">new</span> StringBuilder(x + <span class="string">""</span>)).reverse().toString();</span><br></pre></td></tr></table></figure></li>
<li>通过左右两边的位进行比较<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边界判断</span></span><br><span class="line">      <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) div *= <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> left = x / div;</span><br><span class="line">          <span class="keyword">int</span> right = x % <span class="number">10</span>;</span><br><span class="line">          <span class="keyword">if</span> (left != right) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//左右各减去1位，先取余减去高位，再取整减去低位</span></span><br><span class="line">          x = (x % div) / <span class="number">10</span>;</span><br><span class="line">          div /= <span class="number">100</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li>
<li>取出后半段数字进行反转<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">           revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">           x /= <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//位数分为奇偶情况</span></span><br><span class="line">       <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="反转一个数字"><a href="#反转一个数字" class="headerlink" title="反转一个数字"></a>反转一个数字</h4><p>给你一个32位的有符号整数x，返回x中每位上的数字反转后的结果。结果不能超过<br>32位有符号数的范围，可以考虑先用long表示反转的数，然后强转为int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)n==n? (<span class="keyword">int</span>)n:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="平方数之和"><a href="#平方数之和" class="headerlink" title="平方数之和"></a>平方数之和</h4><p>给定一个非负整数c，你要判断是否存在两个整数a和b，使得a^2+b^2=c。<br>使用双指针，从左右两边开始遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> low=<span class="number">0</span>,high=(<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">      <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">          <span class="keyword">int</span> sum = low*low + high*high;</span><br><span class="line">          <span class="keyword">if</span>(sum == c)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;c)&#123;</span><br><span class="line">              low++;</span><br><span class="line">          &#125;<span class="keyword">else</span></span><br><span class="line">              high--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h4 id="完美数"><a href="#完美数" class="headerlink" title="完美数"></a>完美数</h4><p>这个题最直接的思路就是遍历，但是会超出时间限制，实际上除了1和平方根<br>之外，正因子都是成对出现的，所以只需要遍历平方根之前的数就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">1</span>; <span class="comment">// 正整数一定会有一个1，同时不用考虑自身，所以单独处理</span></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">double</span> sqrt = Math.sqrt(num);</span><br><span class="line">      <span class="keyword">for</span>(;i &lt; sqrt;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(num % i == <span class="number">0</span>) &#123;</span><br><span class="line">              sum += i;</span><br><span class="line">              sum += num / i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 此处单独处理的原因在于只需要加1次i值，如果在循环中会加2次</span></span><br><span class="line">      <span class="keyword">if</span>(i * i == num) &#123;</span><br><span class="line">          sum += i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum == num;</span><br></pre></td></tr></table></figure>
<h4 id="卡牌分组"><a href="#卡牌分组" class="headerlink" title="卡牌分组"></a>卡牌分组</h4><p>统计每个数出现的次数，然后求最大公约数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> c: deck)</span><br><span class="line">           count[c]++;</span><br><span class="line">       <span class="keyword">int</span> g = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">           <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (g == -<span class="number">1</span>)</span><br><span class="line">                   g = count[i];</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   g = gcd(g, count[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> g &gt;= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> x == <span class="number">0</span> ? y : gcd(y%x, x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大交换"><a href="#最大交换" class="headerlink" title="最大交换"></a>最大交换</h4><p>把尽可能低位的最大数字与尽可能高位的小数字交换。不好理解的地方可能在于<br>低位的数字会存在重复，交换时因为高位换过来的是更小的数所以要保证换到<br>重复数字中最低位的那一个，所以要从低往高遍历记录每个位置经过交换能得<br>到的最大数字，因为要交换，所以数组里存的是下标</p>
<ol>
<li>先从低位往高位遍历，保存每一位经过交换能得到的最大值的下标</li>
<li>再从高位往低位遍历，直到某一位小于该位可以取到的最大值，上一步保存<br>了该位置最大值的下标，交换即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] nums = Integer.toString(num).toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] index_arr = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> max_index = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//低位往高位遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[max_index]) max_index = i;</span><br><span class="line">            index_arr[i] = max_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//高位往低位遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[index_arr[i]]) &#123;</span><br><span class="line">                <span class="keyword">char</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[index_arr[i]];</span><br><span class="line">                nums[index_arr[i]] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> String(nums));</span><br></pre></td></tr></table></figure>

<h4 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h4><p>这个题的n是无符号数，区分正负会有问题，最简明的思路是按位与，还有一种<br>思路是利用n&amp;(n-1)，n-1的意思是二进制数字n最右边的1变成0，此1右边的0<br>都变成1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum=sum+(n&amp;<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//无符号右移</span></span><br><span class="line">            n=n&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="comment">//每次都消去一个1</span></span><br><span class="line">            n&amp;=(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="颠倒二进制位"><a href="#颠倒二进制位" class="headerlink" title="颠倒二进制位"></a>颠倒二进制位</h4><p>循环32次，每次将右边最后1位获取保存，同时已经保存的位左移</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//注意在获取最后一位之前必须确保之前的结果左移</span></span><br><span class="line">            res&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            res=res|(n&amp;<span class="number">1</span>);</span><br><span class="line">            n&gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p>排序+双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; a=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            start=i+<span class="number">1</span>;</span><br><span class="line">            end=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[start]+nums[end]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ArrayList&lt;Integer&gt; b=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    b.add(nums[i]);</span><br><span class="line">                    b.add(nums[start]);</span><br><span class="line">                    b.add(nums[end]);</span><br><span class="line">                    a.add(b);</span><br><span class="line">                    <span class="keyword">while</span>(start&lt;end&amp;&amp;nums[start]==nums[start+<span class="number">1</span>])</span><br><span class="line">                    start++;</span><br><span class="line">                    <span class="keyword">while</span>(start&lt;end&amp;&amp;nums[end]==nums[end-<span class="number">1</span>])</span><br><span class="line">                    end--;</span><br><span class="line">                    start++;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[start]+nums[end]&gt;<span class="number">0</span>)</span><br><span class="line">                    end--;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    start++;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h4><p>给定n=13，返回[1,10,11,12,13,2,3,4,5,6,7,8,9]。N叉树前序遍历一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            dfs(n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        res.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">            dfs(n, cur * <span class="number">10</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="一组数的所有排列"><a href="#一组数的所有排列" class="headerlink" title="一组数的所有排列"></a>一组数的所有排列</h4><p>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的<br>过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时<br>候，它将取消上一步甚至是上几步的计算。这个题中采用回溯思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    	<span class="comment">//1 2 3 从第一个开始进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            array.add(nums[i]);</span><br><span class="line">            cut(array,nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(ArrayList&lt;Integer&gt; array,<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">//回溯终止条件就是遍历完成</span></span><br><span class="line">        <span class="keyword">if</span>(array.size()==nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(array));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!array.contains(nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">//满足条件加入</span></span><br><span class="line">                array.add(nums[i]);</span><br><span class="line">                <span class="comment">//继续回溯</span></span><br><span class="line">                cut(array,nums);</span><br><span class="line">                <span class="comment">//回退</span></span><br><span class="line">                array.remove(array.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dfs(root, sum, <span class="keyword">new</span> ArrayList&lt;&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;Integer&gt; list,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果节点为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//把当前节点值加入到list中</span></span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(root.val));</span><br><span class="line">    <span class="comment">//如果到达叶子节点，就不能往下走了，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果到达叶子节点，并且sum等于叶子节点的值，说明我们找到了一组，</span></span><br><span class="line">        <span class="comment">//要把它放到result中</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val)</span><br><span class="line">        	<span class="comment">//注意这里必须返回一个新对象，将一条路径上的值都赋值到新对象中</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">        <span class="comment">//注意别忘了把最后加入的结点值给移除掉，因为下一步直接return了，</span></span><br><span class="line">        <span class="comment">//不会再走最后一行的remove了，所以这里在rerurn之前提前把最后</span></span><br><span class="line">        <span class="comment">//一个结点的值给remove掉。</span></span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//到叶子节点之后直接返回，因为在往下就走不动了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没到达叶子节点，就继续从他的左右两个子节点往下找，注意到</span></span><br><span class="line">    <span class="comment">//下一步的时候，sum值要减去当前节点的值</span></span><br><span class="line">    dfs(root.left, sum - root.val, list, result);</span><br><span class="line">    dfs(root.right, sum - root.val, list, result);</span><br><span class="line">    <span class="comment">//我们要理解递归的本质，当递归往下传递的时候他最后还是会往回走，</span></span><br><span class="line">    <span class="comment">//我们把这个值使用完之后还要把它给移除，这就是回溯</span></span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="交换一次的先前排列"><a href="#交换一次的先前排列" class="headerlink" title="交换一次的先前排列"></a>交换一次的先前排列</h4><p>这道题应该从后往前找而不是从前往后找，注意是要小于原数组的最大数组，如果<br>从前往后就不满足条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = A.length;</span><br><span class="line">      <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> A;</span><br><span class="line">      <span class="comment">//1.从后往前找，如果是A[i]&gt;=A[i-1]则继续</span></span><br><span class="line">      <span class="comment">//2. 碰到A[i]&lt;A[i-1]记录下需要交换的位置</span></span><br><span class="line">      <span class="comment">//3. 找到比他小的再交换即可(需要找到位置最前的元素)</span></span><br><span class="line">      <span class="comment">// 123456这样的没法换</span></span><br><span class="line">      <span class="comment">//987654321 这样的可以换</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">          <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;A[i]&gt;=A[i-<span class="number">1</span>])</span><br><span class="line">              i--;</span><br><span class="line">          <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> A;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = len-<span class="number">1</span>;j &gt;= i;j--)&#123;<span class="comment">//注意此处的边界</span></span><br><span class="line">              <span class="keyword">if</span>(A[j]&lt;A[i-<span class="number">1</span>])&#123;</span><br><span class="line">                  <span class="comment">//swap(A,i-1,j);</span></span><br><span class="line">                  <span class="keyword">int</span> tmp = j;</span><br><span class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> k = j-<span class="number">1</span>;k&gt;=i;k--)&#123;</span><br><span class="line">                      <span class="keyword">if</span>(A[k]==A[j])</span><br><span class="line">                          tmp = k;</span><br><span class="line">                  &#125;</span><br><span class="line">                  swap(A,tmp,i-<span class="number">1</span>);</span><br><span class="line">                  <span class="keyword">return</span> A;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> A;</span><br></pre></td></tr></table></figure>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><p>这道题的核心就是说从倒数第二个位置开始向左遍历，如果这个位置能够到达<br>最后指定位置，继续向左遍历，既然要到最后一个位置，那么如果能够达到在<br>这之前的位置，一直不断放宽条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last=nums.length-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">      	<span class="comment">//这里要用&gt;= 因为可以有多种选择</span></span><br><span class="line">          <span class="keyword">if</span>(i+nums[i]&gt;=last)</span><br><span class="line">              last=i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> last==<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="对称数组的交换"><a href="#对称数组的交换" class="headerlink" title="对称数组的交换"></a>对称数组的交换</h4><p>我们可以旋转第i张多米诺，使得A[i]和B[i]的值交换。返回能使A中所有值或<br>者B中所有值都相同的最小旋转次数，值的范围是1到6。可以使用两个记录数组<br>，把元素的个数都记录在记录数组中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">      <span class="keyword">int</span>[] array2=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          array1[A[i]]++;</span><br><span class="line">          array2[B[i]]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          flag=<span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(array1[i]+array2[i]&gt;=A.length)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A.length;j++)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span>(A[j]!=i&amp;&amp;B[j]!=i)</span><br><span class="line">                      &#123;</span><br><span class="line">                          flag=<span class="keyword">true</span>;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(flag)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">int</span> min=Math.min(A.length-array1[i],A.length-array2[i]);</span><br><span class="line">                  <span class="keyword">return</span> min;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><h4 id="求逆序对"><a href="#求逆序对" class="headerlink" title="求逆序对"></a>求逆序对</h4><p>大佬提供了一种分治思想，实际上就是利用归并排序求得所有逆序对，事实上归<br>并排序的过程就是消除所有逆序对的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//暂时保存值</span></span><br><span class="line">        <span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=reverse(nums,array,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//恢复原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> numleft=reverse(nums,array,left,mid);</span><br><span class="line">        <span class="keyword">int</span> numright=reverse(nums,array,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="comment">//这里可以判断一下是否需要合并</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;=nums[mid+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> numleft+numright;</span><br><span class="line">        <span class="comment">//合并操作</span></span><br><span class="line">        <span class="keyword">int</span> num=merge(nums,array,left,right,mid);</span><br><span class="line">        <span class="keyword">return</span> num+numleft+numright;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//逆序对总数</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//注意这个地方必须有=，如果没有等号会多算逆序对</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums[j])</span><br><span class="line">                array[index++]=nums[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    核心在这个地方，可以这样想，比如归并的时候第一个</span></span><br><span class="line"><span class="comment">                    是nums[j]归并到前面，那么说明左半部分的元素都比</span></span><br><span class="line"><span class="comment">                    这个nums[j]大，这就有mid-i+1个逆序对，以此就可以</span></span><br><span class="line"><span class="comment">                    得到所有逆序对，如果nums[i]在前那么对于i来说往后</span></span><br><span class="line"><span class="comment">                    就不存在逆序对了</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                count+=(mid-i+<span class="number">1</span>);</span><br><span class="line">                array[index++]=nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">            array[index++]=nums[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">            array[index++]=nums[j++];</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[left++]=array[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h3><ol>
<li>先手必胜策略</li>
</ol>
<h3 id="剪绳子I"><a href="#剪绳子I" class="headerlink" title="剪绳子I"></a>剪绳子I</h3><p>给你一根长度为n 的绳子，请把绳子剪成整数长度的m 段，求最大乘积。</p>
<ol>
<li>动态规划<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//dp[i]表示长度为i的绳子剪成m段后的最大乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        	<span class="comment">//如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="comment">//剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话</span></span><br><span class="line">            <span class="comment">//长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]</span></span><br><span class="line">            <span class="comment">//取两者最大值max(j * (i - j), j * dp[i - j])</span></span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>贪心算法 尽可能把绳子分成长度为3的小段，这样乘积最大<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="剪绳子II"><a href="#剪绳子II" class="headerlink" title="剪绳子II"></a>剪绳子II</h4><p>考虑大数问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res  = res * <span class="number">3</span> % <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h2><h3 id="高楼扔鸡蛋问题"><a href="#高楼扔鸡蛋问题" class="headerlink" title="高楼扔鸡蛋问题"></a>高楼扔鸡蛋问题</h3><ol>
<li>暴力法 直接从第一层开始往上遍历，用不到第二个鸡蛋</li>
<li>二分法 将鸡蛋从楼层中间位置扔出</li>
</ol>
<ul>
<li>如果没碎，那么继续从剩下楼层的中间位置扔出</li>
<li>如果碎了，第二个鸡蛋就从相应的位置往上遍历</li>
</ul>
<ol start="3">
<li>均匀法 让第一个鸡蛋和第二个鸡蛋的尝试次数更均匀，比如每十层扔一次</li>
<li>最优解法 假设最优解法在最坏情况需要仍X次。接下来就要决定首先在第几<br>层开始仍</li>
</ol>
<ul>
<li>如果在第X+1层开始扔，如果碎了那么就要从第一次往上遍历，需要X+1次</li>
<li>如果在第X-1层开始扔，事实上最优解法的情况应该保证扔X次的话那么临<br>界层的高度应该至少是X，肯定比暴力法要好，所以至少应该更高</li>
<li>从第X层开始扔 如果鸡蛋碎了那么总共就是X次，如果没碎那么还有X-1次<br>机会，那么接下来就应该从X+X-1层开始扔<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X+(X-1)+(X-2)+...1&#x3D;100</span><br><span class="line">X向上取整14</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="找砝码问题"><a href="#找砝码问题" class="headerlink" title="找砝码问题"></a>找砝码问题</h3><p>二分法</p>
<ol>
<li>分为三份 4 4 1 比较两个4，如果相等那么剩下的就是轻的</li>
<li>两个4不相等，将一个4分为两份继续比较</li>
<li>两个1找出轻的</li>
</ol>
<p>三分法</p>
<ol>
<li>分为三份3 3 3 比较其中的两份</li>
<li>继续三分</li>
</ol>
<h3 id="找玻璃球问题"><a href="#找玻璃球问题" class="headerlink" title="找玻璃球问题"></a>找玻璃球问题</h3><p>将十组玻璃珠编号1~10，然后第一组拿一个，第二组拿两个以此类推…第十组拿<br>十个，将这些玻璃珠一起放到秤上称出克数x</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; 1*10 + 2*10 + 3*10 + ... + 10 * 10 - y</span><br><span class="line">y就是轻的那一组</span><br></pre></td></tr></table></figure>
<h3 id="毒药问题"><a href="#毒药问题" class="headerlink" title="毒药问题"></a>毒药问题</h3><p>二进制思路，2^10 = 1024 &gt; 1000，因此10只小白鼠即可。<br>给1000瓶水按照二进制编号，比如3号编为00000 00011，拿10个碗，对应10位，对<br>于3号水来说，最后两位是1，则把水混合进最后两个碗中。 最终把10碗水给对应的<br>小白鼠喝，根据最后小白鼠死亡的情况（死即为1，活即为0），即可确定出有毒的<br>那碗水</p>
<h3 id="生成随机数问题"><a href="#生成随机数问题" class="headerlink" title="生成随机数问题"></a>生成随机数问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要随机得到 1-7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> row, col, idx;</span><br><span class="line">      <span class="comment">// rand5() 返回 1-5</span></span><br><span class="line">      row = rand5(); <span class="comment">// 5 * 5 = 25, 设想一个 5*5 的矩阵</span></span><br><span class="line">      col = rand5(); <span class="comment">// 然后找到小于25的，7的最大倍数21</span></span><br><span class="line">      idx = col + (row - <span class="number">1</span>) * <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> (idx &lt;= <span class="number">21</span>) <span class="comment">// 只考虑 1-21，划分成 7 份</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (idx - <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先手必胜策略"><a href="#先手必胜策略" class="headerlink" title="先手必胜策略"></a>先手必胜策略</h3><p>100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿？</p>
<ul>
<li>卡关键点，每次只能拿1-5本，所以当剩下6本的时候，不论对面怎么拿你<br>都能赢</li>
<li>然后推6的倍数：12、18、…、96，也就是一开始要拿4本</li>
<li>接下来对面拿1，你就拿5，对面拿2，你就拿4，总之让你拿的和对面拿的<br>加起来是6，最终就能赢</li>
</ul>
<h3 id="瓶子换饮料问题"><a href="#瓶子换饮料问题" class="headerlink" title="瓶子换饮料问题"></a>瓶子换饮料问题</h3><ul>
<li>1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶？</li>
<li>1000 % 3 = 333…1 喝掉1000瓶,可以换333瓶汽水, 余1个空瓶</li>
<li>333 % 3 = 111…0　喝掉333瓶，可以换111瓶汽水, 余0个空瓶</li>
<li>111 % 3 = 37…0　 喝掉111瓶，可以换37瓶汽水, 余0个空瓶</li>
<li>37 % 3 = 12…1　 喝掉37瓶，可以换12瓶汽水, 余1个空瓶</li>
<li>12 % 3 = 4…0 喝掉12瓶，可以换4瓶汽水, 余0个空瓶</li>
<li>4 % 3 = 1…1 喝掉4瓶，可以换1瓶汽水, 余1个空瓶</li>
<li>此时剩下1瓶汽水 + 3个空瓶，其中3个空瓶可以再换1瓶</li>
<li>此时剩下2瓶，喝掉2瓶，不能再换了。 总共：<br>1000 + 333 + 111 + 37 + 12 + 4 + 2 = 1499瓶</li>
</ul>
<h3 id="烧香确定时间问题"><a href="#烧香确定时间问题" class="headerlink" title="烧香确定时间问题"></a>烧香确定时间问题</h3><p>有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？<br>设两根香分别为A、B，先把A一端点燃，然后把B的两端都点燃，这样当B烧完<br>的时候，A就还剩下一半（此时能确定半小时），此时把A的另一端也点燃，<br>那么从此刻到A烧完的时间就是15分钟</p>
<h3 id="掰巧克力问题"><a href="#掰巧克力问题" class="headerlink" title="掰巧克力问题"></a>掰巧克力问题</h3><p>N*M块巧克力，每次掰一块的一行或一列，掰成1*1的巧克力需要多少次？<br>淘汰问题：1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛？</p>
<ul>
<li>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有<br>的巧克力共有N*M块，所以要掰N*M-1次，减1是因为最开始的一块是不用算进<br>去的</li>
<li>每一场辩论赛两个人，淘汰一个人，所以可以看作是每一场辩论赛减少一个<br>人，直到最后剩下1个人，所以是1000 - 1 = 999场</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStructure/">DataStructure</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>JAVA基础总结</span></a></div><div class="next-post pull-right"><a href="/2021/01/22/JVM%E6%80%BB%E7%BB%93/"><span>JVM总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/01/22/刷题总结/';
  this.page.title = '刷题总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>