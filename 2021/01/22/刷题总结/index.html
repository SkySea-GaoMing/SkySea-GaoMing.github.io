<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="刷题总结"><meta name="keywords" content="DataStructure"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>刷题总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#刷题分类"><span class="toc-number">1.</span> <span class="toc-text">刷题分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二分查找"><span class="toc-number">1.1.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动窗口"><span class="toc-number">1.2.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">1.3.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一个元素在数组中的次数大于n-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">一个元素在数组中的次数大于n&#x2F;2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大子序和"><span class="toc-number">1.3.2.</span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除排序数组中重复元素"><span class="toc-number">1.3.3.</span> <span class="toc-text">删除排序数组中重复元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回一个数组的所有子集"><span class="toc-number">1.3.4.</span> <span class="toc-text">返回一个数组的所有子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#除自身以外数组的乘积"><span class="toc-number">1.3.5.</span> <span class="toc-text">除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#盛水容器"><span class="toc-number">1.3.6.</span> <span class="toc-text">盛水容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中第k个最大元素"><span class="toc-number">1.3.7.</span> <span class="toc-text">数组中第k个最大元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个正序数组的中位数"><span class="toc-number">1.3.8.</span> <span class="toc-text">两个正序数组的中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乘积最大子数组"><span class="toc-number">1.3.9.</span> <span class="toc-text">乘积最大子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大子序和-1"><span class="toc-number">1.3.10.</span> <span class="toc-text">最大子序和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">1.4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反转一个字符串中的单词"><span class="toc-number">1.4.1.</span> <span class="toc-text">反转一个字符串中的单词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">1.5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不给前置节点条件下删除链表中的节点"><span class="toc-number">1.5.1.</span> <span class="toc-text">不给前置节点条件下删除链表中的节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反转一个单链表"><span class="toc-number">1.5.2.</span> <span class="toc-text">反转一个单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合并两个有序链表"><span class="toc-number">1.5.3.</span> <span class="toc-text">合并两个有序链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#找到相交链表的起始节点"><span class="toc-number">1.5.4.</span> <span class="toc-text">找到相交链表的起始节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#判断一个链表是否有环"><span class="toc-number">1.5.5.</span> <span class="toc-text">判断一个链表是否有环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树"><span class="toc-number">1.6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#求二叉树的最大深度"><span class="toc-number">1.6.1.</span> <span class="toc-text">求二叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#找二叉树的最近公共祖先"><span class="toc-number">1.6.2.</span> <span class="toc-text">找二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第k小的元素"><span class="toc-number">1.6.3.</span> <span class="toc-text">第k小的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从前序与中序遍历序列构造二叉树"><span class="toc-number">1.6.4.</span> <span class="toc-text">从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从中序与后序遍历序列构造二叉树"><span class="toc-number">1.6.5.</span> <span class="toc-text">从中序与后序遍历序列构造二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TopK"><span class="toc-number">1.7.</span> <span class="toc-text">TopK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计题"><span class="toc-number">1.8.</span> <span class="toc-text">设计题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最小栈"><span class="toc-number">1.8.1.</span> <span class="toc-text">最小栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-number">1.9.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二维网格找路径"><span class="toc-number">1.9.1.</span> <span class="toc-text">二维网格找路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二维网格找路径II"><span class="toc-number">1.9.2.</span> <span class="toc-text">二维网格找路径II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比特位计数"><span class="toc-number">1.9.3.</span> <span class="toc-text">比特位计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#做菜顺序"><span class="toc-number">1.9.4.</span> <span class="toc-text">做菜顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最长湍流子数组"><span class="toc-number">1.9.5.</span> <span class="toc-text">最长湍流子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小路径和"><span class="toc-number">1.9.6.</span> <span class="toc-text">最小路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用最小花费爬阶梯"><span class="toc-number">1.9.7.</span> <span class="toc-text">使用最小花费爬阶梯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">1.10.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X数之和系列"><span class="toc-number">1.11.</span> <span class="toc-text">X数之和系列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#股票系列"><span class="toc-number">1.12.</span> <span class="toc-text">股票系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#买股票最佳时机I"><span class="toc-number">1.12.1.</span> <span class="toc-text">买股票最佳时机I</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#括号系列"><span class="toc-number">1.13.</span> <span class="toc-text">括号系列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节"><span class="toc-number">1.14.</span> <span class="toc-text">字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指Offer"><span class="toc-number">1.15.</span> <span class="toc-text">剑指Offer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数学"><span class="toc-number">1.16.</span> <span class="toc-text">数学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#只出现一次的数字，使用异或"><span class="toc-number">1.16.1.</span> <span class="toc-text">只出现一次的数字，使用异或</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#判断一个数是回文数"><span class="toc-number">1.16.2.</span> <span class="toc-text">判断一个数是回文数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反转一个数字"><span class="toc-number">1.16.3.</span> <span class="toc-text">反转一个数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#平方数之和"><span class="toc-number">1.16.4.</span> <span class="toc-text">平方数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完美数"><span class="toc-number">1.16.5.</span> <span class="toc-text">完美数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卡牌分组"><span class="toc-number">1.16.6.</span> <span class="toc-text">卡牌分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大交换"><span class="toc-number">1.16.7.</span> <span class="toc-text">最大交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回溯"><span class="toc-number">1.17.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一组数的所有排列"><span class="toc-number">1.17.1.</span> <span class="toc-text">一组数的所有排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#贪心"><span class="toc-number">1.18.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#交换一次的先前排列"><span class="toc-number">1.18.1.</span> <span class="toc-text">交换一次的先前排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跳跃游戏"><span class="toc-number">1.18.2.</span> <span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对称数组的交换"><span class="toc-number">1.18.3.</span> <span class="toc-text">对称数组的交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#脑筋急转弯"><span class="toc-number">1.19.</span> <span class="toc-text">脑筋急转弯</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">刷题总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/22/刷题总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="刷题分类"><a href="#刷题分类" class="headerlink" title="刷题分类"></a>刷题分类</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="一个元素在数组中的次数大于n-2"><a href="#一个元素在数组中的次数大于n-2" class="headerlink" title="一个元素在数组中的次数大于n/2"></a>一个元素在数组中的次数大于n/2</h4><p>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个<br>数开始计数，总能找到最多的那个。也就是摩尔投票法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> n=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(n!=nums[i])</span><br><span class="line">          &#123;</span><br><span class="line">              num--;</span><br><span class="line">              <span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                  num=<span class="number">0</span>;</span><br><span class="line">                  n=nums[i];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              num++;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>至少要有一个元素。最简单的是动态规划的思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			dp[i] = Math.max(dp[i- <span class="number">1</span>] + nums[i], nums[i]);	</span><br><span class="line">			<span class="keyword">if</span> (max &lt; dp[i]) &#123;</span><br><span class="line">				max = dp[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>贪心的思路跟动态规划很像</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">              num=num+nums[i];</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              num=nums[i];</span><br><span class="line">          max=max&gt;num?max:num;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除排序数组中重复元素"><a href="#删除排序数组中重复元素" class="headerlink" title="删除排序数组中重复元素"></a>删除排序数组中重复元素</h4><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现<br>一次，返回移除后数组的新长度。使用快慢指针，快慢指针的意思就是定义两个<br>索引指针，一个走的快一个走的慢，快的就是正常遍历数组，慢的就是遍历不<br>重复的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> value=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==value)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">//慢指针</span></span><br><span class="line">                index++;</span><br><span class="line">                nums[index]=nums[i];</span><br><span class="line">                value=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回一个数组的所有子集"><a href="#返回一个数组的所有子集" class="headerlink" title="返回一个数组的所有子集"></a>返回一个数组的所有子集</h4><p>主要体现在遍历的设计上，先是添加空数组，然后将每一个元素加入，十分巧妙<br>，遍历时每遇到一个数就把该数加到所有子集中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> all = res.size();</span><br><span class="line">         <span class="comment">//一开始只有空集</span></span><br><span class="line">         <span class="comment">//1加到所有子集上 空集 [1]</span></span><br><span class="line">         <span class="comment">//2加到所有子集上 空集 [2] [1,2]</span></span><br><span class="line">         <span class="comment">//3加到所有子集上...</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; all; j++) &#123;</span><br><span class="line">              List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(res.get(j));</span><br><span class="line">              tmp.add(nums[i]);</span><br><span class="line">              res.add(tmp);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h4><p>返回输出数组，其中output[i]等于nums中除nums[i]之外其余各元素的乘积。对<br>与nums[i]来说，乘积 = 当前数左边的乘积 * 当前数右边的乘积</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">      <span class="keyword">int</span> help=<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//从左边开始获取nums[i]左边的乘积</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          array[i]=help;</span><br><span class="line">          help*=nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      help=<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//从右边开始获取获取nums[i]右边的乘积</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">          array[i]*=help;</span><br><span class="line">          help*=nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br></pre></td></tr></table></figure>
<h4 id="盛水容器"><a href="#盛水容器" class="headerlink" title="盛水容器"></a>盛水容器</h4><p>双指针，每次都移动较短的那个柱子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> right=height.length-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> min=height[right]&lt;height[left]?height[right]:height[left];</span><br><span class="line">      <span class="keyword">int</span> max=(right-left)*min;</span><br><span class="line">      <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">              left++;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              right--;</span><br><span class="line">          min=height[left]&lt;height[right]?height[left]:height[right];</span><br><span class="line">          <span class="keyword">if</span>(max&lt;min*(right-left))</span><br><span class="line">              max=min*(right-left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br></pre></td></tr></table></figure>
<h4 id="数组中第k个最大元素"><a href="#数组中第k个最大元素" class="headerlink" title="数组中第k个最大元素"></a>数组中第k个最大元素</h4><p>在未排序的数组中找到第k个最大的元素。构建一个大顶堆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造一个大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	  &#123;</span><br><span class="line">		sink(nums,i,nums.length);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="comment">//每次移除最大元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;nums.length-<span class="number">1</span>-k;i--)</span><br><span class="line">	  &#123;</span><br><span class="line">		<span class="keyword">int</span> temp=nums[i];</span><br><span class="line">		nums[i]=nums[<span class="number">0</span>];</span><br><span class="line">		nums[<span class="number">0</span>]=temp;</span><br><span class="line">		sink(nums,<span class="number">0</span>,i);</span><br><span class="line">	  &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*k+<span class="number">1</span>;j&lt;length;j=<span class="number">2</span>*j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j+<span class="number">1</span>&lt;length&amp;&amp;array[j]&lt;array[j+<span class="number">1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="keyword">if</span>(array[j]&gt;array[k])</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=array[k];</span><br><span class="line">		array[k]=array[j];</span><br><span class="line">		array[j]=temp;</span><br><span class="line">		k=j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两个正序数组的中位数"><a href="#两个正序数组的中位数" class="headerlink" title="两个正序数组的中位数"></a>两个正序数组的中位数</h4><p>这个题如果要求时间复杂度为O(m+n)其实很简单，就是直接通过遍历比<br>较找到中间位置，但是时间复杂度要求为O(log(m+n))，应该联想到用<br>二分思想，首先要分奇偶来求出中位数，参考力扣一个大牛的话(m+n+1)<br>和(m+n+2)取平均值可以消除奇偶的影响，首先考虑如何找到数组中第k<br>个元素，一种思路是双指针进行比较求得第k个元素，但是时间复杂度为<br>O(m+n)，如果利用二分查找，先分别在两个数组中找到第k/2个元素，<br>比较这两个元素比如nums1[k/2] &lt; nums2[k/2]，那么nums1数组前k/2个<br>一定不存在第k个元素，此时删除nums1前k/2个元素，然后继续找，这个时<br>候实际找的是第k-k/2个元素，因为k/2个元素已经被除去了嘛，所以接下<br>来查找的范围就会越来越小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> m=nums1.length;</span><br><span class="line">      <span class="keyword">int</span> n=nums2.length;</span><br><span class="line">      <span class="keyword">int</span> left=(m+n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> right=(m+n+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> (findk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left)+findk(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right))/<span class="number">2.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findk</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> i,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;=nums1.length)</span><br><span class="line">        <span class="keyword">return</span> nums2[j+k-<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=nums2.length)</span><br><span class="line">        <span class="keyword">return</span> nums1[i+k-<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Math.min(nums1[i],nums2[j]);</span><br><span class="line">      <span class="keyword">int</span> midindex1=(i+k/<span class="number">2</span>-<span class="number">1</span>&lt;nums1.length)?nums1[i+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">int</span> midindex2=(j+k/<span class="number">2</span>-<span class="number">1</span>&lt;nums2.length)?nums2[j+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">if</span>(midindex1&lt;midindex2)</span><br><span class="line">        <span class="keyword">return</span> findk(nums1,i+k/<span class="number">2</span>,nums2,j,k-k/<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> findk(nums1,i,nums2,j+k/<span class="number">2</span>,k-k/<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h4><p>核心思路就是以0为分界遍历数组更新最大值，对于负数的数量影响可以<br>想到从开头和结尾两个方向遍历解决奇数情况</p>
<ol>
<li>负数为偶数个，则整个数组的各个值相乘为最大值</li>
<li>负数为奇数个，则从左边开始，乘到最后一个负数停止有一个“最大值”，<br>从右边也有一个“最大值”，比较，得出最大值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          num*=nums[i];</span><br><span class="line">          max=Math.max(num,max);</span><br><span class="line">          <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">              num=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">          num*=nums[i];</span><br><span class="line">          max=Math.max(num,max);</span><br><span class="line">          <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)</span><br><span class="line">              num=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大子序和-1"><a href="#最大子序和-1" class="headerlink" title="最大子序和"></a>最大子序和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(num&gt;=<span class="number">0</span>)</span><br><span class="line">              num+=nums[i];</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              num=nums[i];</span><br><span class="line">          max=Math.max(max,num);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="反转一个字符串中的单词"><a href="#反转一个字符串中的单词" class="headerlink" title="反转一个字符串中的单词"></a>反转一个字符串中的单词</h4><p>你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。获取<br>字符串的字符数组，设置start和end两个位置，开始遍历，每次取得一个单词然后<br>反转字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] array=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;array.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((array[end]==<span class="string">' '</span>)||(end==array.length-<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cut=end;</span><br><span class="line">                <span class="keyword">if</span>(array[end]==<span class="string">' '</span>)</span><br><span class="line">                end--;</span><br><span class="line">            	<span class="comment">//这个操作就是反转一个字符串的核心</span></span><br><span class="line">                <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> tempt=array[end];</span><br><span class="line">                    array[end]=array[start];</span><br><span class="line">                    array[start]=tempt;</span><br><span class="line">                    start++;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125;</span><br><span class="line">                start=cut+<span class="number">1</span>;</span><br><span class="line">                end=cut+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end++;</span><br><span class="line">        &#125;</span><br><span class="line">        s=<span class="keyword">new</span> String(array);</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="不给前置节点条件下删除链表中的节点"><a href="#不给前置节点条件下删除链表中的节点" class="headerlink" title="不给前置节点条件下删除链表中的节点"></a>不给前置节点条件下删除链表中的节点</h4><p>这里只给了要删除的节点，没有给其前置节点，只需要把要删除节点的值设置<br>为下一个节点的值，然后next设置为下一个节点的next</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.val=node.next.val;</span><br><span class="line">   node.next=node.next.next;</span><br></pre></td></tr></table></figure>
<h4 id="反转一个单链表"><a href="#反转一个单链表" class="headerlink" title="反转一个单链表"></a>反转一个单链表</h4><ol>
<li>迭代方式 这个反转过程需要三个指针 pre cur next。每遍历到一个节点都要<br>改变节点的pre和next，比如遍历到第一个节点，此时获取next，然后把第一个节<br>点的next指向pre，然后pre更新为第一个节点，接下来遍历到下一个<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li>
<li>递归方式 既然使用递归首先要考虑递归的终止方式，有两个终止条件</li>
</ol>
<ul>
<li>终止条件是当前节点或者下一个节点==null</li>
<li>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函<br>数那句 head.next.next = head<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如1 2 3 4 5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> head;</span><br><span class="line">    	<span class="comment">//cur得到的值始终都是5</span></span><br><span class="line">    	ListNode cur=reverseList(head.next);</span><br><span class="line">    	<span class="comment">//得到head的顺序是4 3 2 1</span></span><br><span class="line">    	<span class="comment">//反转相邻节点4-5 3-4 2-3 1-2</span></span><br><span class="line">    	head.next.next=head;</span><br><span class="line">    	<span class="comment">//防止链表循环，需要将head.next设置为空，实际上就是1到2的引用必须除去</span></span><br><span class="line">    	head.next=<span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>将两个升序链表合并为一个新的 升序链表并返回。新链表是通过拼接给定的<br>两个链表的所有节点组成的。注意不能创建新节点。可以使用dummyHead，也<br>就是临时创建一个头节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  	ListNode prehead=pre;</span><br><span class="line">  	<span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> l2;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> l1;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">      	<span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      	<span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">      		pre.next=l1;</span><br><span class="line">      		l1=l1.next;</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">else</span>&#123;</span><br><span class="line">      		pre.next=l2;</span><br><span class="line">      		l2=l2.next;</span><br><span class="line">      	&#125;</span><br><span class="line">      	pre=pre.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">      	pre.next=l2;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      	pre.next=l1;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> prehead.next;</span><br></pre></td></tr></table></figure>
<p>也可以使用递归解决，终止条件就是l1或l2为null，返回的是排序好的<br>链表头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="找到相交链表的起始节点"><a href="#找到相交链表的起始节点" class="headerlink" title="找到相交链表的起始节点"></a>找到相交链表的起始节点</h4><p>如果两个链表存在相交部分，那么从相交位置开始到末尾的长度都是相同的。<br>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这<br>个位置只能是较短链表的头结点位置。为此我们必须消除两个链表的长度差，<br>两个指针从相同位置开始遍历过程如果能相遇那么就有相交</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode node1=headA;</span><br><span class="line">      ListNode node2=headB;</span><br><span class="line">      <span class="keyword">while</span>(node1!=node2)</span><br><span class="line">      &#123;</span><br><span class="line">      	<span class="comment">//消除长度差的本质就是各自从另一条路走</span></span><br><span class="line">          node1=node1==<span class="keyword">null</span>?headB:node1.next;</span><br><span class="line">          node2=node2==<span class="keyword">null</span>?headA:node2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node1;</span><br></pre></td></tr></table></figure>
<h4 id="判断一个链表是否有环"><a href="#判断一个链表是否有环" class="headerlink" title="判断一个链表是否有环"></a>判断一个链表是否有环</h4><p>依然是使用快慢指针的思想，一个每次跳转到下一个节点，慢指针每次跳转两个<br>节点，最终如果有环一定可以相遇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ListNode node=head;</span><br><span class="line">      ListNode first=head;</span><br><span class="line">      ListNode second=head;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(first.next!=<span class="keyword">null</span>)</span><br><span class="line">              first=first.next;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(second.next!=<span class="keyword">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(second.next.next!=<span class="keyword">null</span>)</span><br><span class="line">                  second=second.next.next;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(first==second)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>接下来不仅判断有环，还要判断环的起始位置。</p>
<ol>
<li>fast 走的步数是slow步数的2倍，即 f= 2s</li>
<li>fast 比 slow多走了 n个环的长度，即 f = s + nb</li>
</ol>
<p>如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时<br>的步数是：k=a+nb（先走a步到入口节点，之后每绕1圈环都会再次到入口节点）<br>所以第一次重合之后让快指针从head开始走a步那么就与慢指针重合，这时就是<br>在环的入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode fast = head, slow = head;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          fast = fast.next.next;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fast = head;</span><br><span class="line">      <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          fast = fast.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fast;</span><br></pre></td></tr></table></figure>


<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="求二叉树的最大深度"><a href="#求二叉树的最大深度" class="headerlink" title="求二叉树的最大深度"></a>求二叉树的最大深度</h4><p>使用递归的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=deep(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=deep(root.right);</span><br><span class="line">        <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left=deep(node.left);</span><br><span class="line">            <span class="keyword">int</span> right=deep(node.right);</span><br><span class="line">            <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="找二叉树的最近公共祖先"><a href="#找二叉树的最近公共祖先" class="headerlink" title="找二叉树的最近公共祖先"></a>找二叉树的最近公共祖先</h4><p>这里是二叉树而不是二叉搜索树，不能直接根据节点的值判断。但是依然根据<br>节点的位置来判断公共祖先，遍历到某个节点时，判断左右子树中p和q的情<br>况，如果左右都有那么就是root，如果只有左或右那么p和q中一定有一个<br>是公共祖先</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//当遍历到叶结点后就会返回null</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当找到p或者q的是时候就会返回pq</span></span><br><span class="line">        <span class="comment">/*当然，值得一提的是，如果公共祖先是自己（pq），并不需要寻找另外</span></span><br><span class="line"><span class="comment">       一个，我们在执行前序遍历会先找上面的，后找下面的，我们会直接返回公共祖先。*/</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的结点进行保存，可能是null</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="comment">//也可能是pq，还可能是公共祖先</span></span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果左右都存在，就说明pq都出现了，这就是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//否则我们返回已经找到的那个值（存储在left，与right中），p或者q</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//还有一种可能就是，由下面返回的公共祖先，并将这个值一路返回到最表层</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="第k小的元素"><a href="#第k小的元素" class="headerlink" title="第k小的元素"></a>第k小的元素</h4><p>中序遍历得到的就是一个有序序列，最简单的思路是得到树中元素个数，<br>然后中序遍历存放到数组中，当遍历到第k个就停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       count=k;</span><br><span class="line">       search(root);</span><br><span class="line">       <span class="keyword">return</span> val;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode node)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       </span><br><span class="line">       search(node.left);</span><br><span class="line">       index++;</span><br><span class="line">       <span class="keyword">if</span>(index==count)</span><br><span class="line">           &#123;</span><br><span class="line">               val=node.val;</span><br><span class="line">               <span class="keyword">return</span> ;</span><br><span class="line">           &#125;</span><br><span class="line">       search(node.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h4><p>要利用好中序和前序的性质，注意边界关系 <img src="/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<ol>
<li>从左到右遍历preorder、inorder</li>
<li>preorder的第一个元素一定是根元素</li>
</ol>
<ul>
<li>2.1. 找到根元素后，可以在inorder中区分左、右子树</li>
<li>2.2. 当前根的左子树范围：inorder[inorder未查找的最左边（从0开始），<br>和根元素相等的索引位置</li>
<li>2.3. 当前根的左子树范围：preorder(当前根索引位置（从0开始）, 当前<br>根的索引位置 + inorder已知左子树长度，原因：因为preorder、inorder中<br>左、右子树的长度相等（只是观察得出，为什么这么巧，还没想透彻）</li>
</ul>
<ol start="3">
<li>当preorder的指针向右移动到”左子树长度”，说明当前根节点的左子树已经处理完毕</li>
<li>递归开始查找，如果没有超出左子树范围，preorder指针向右移动一位继续搜索</li>
</ol>
<ul>
<li>4.1. 此时的节点最多只可能有2种身份：A + B<br>A. 根节点<br>B. 左节点或右节点</li>
<li>4.2. inorder的起始节点是”最左的节点”，当preorder中的值与他相等时，可<br>以判断无后续数据，结束搜索</li>
<li>4.3  inorder指针向右移动一位（排除已使用节点），缩小搜索范围</li>
</ul>
<ol start="5">
<li>右节点确定规则：因为上一步确定的是一个左节点，preorder顺序为根左右，<br>所以preorder的下一个节点就是右节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">           &#123; <span class="keyword">if</span>(preorder[<span class="number">0</span>]==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        root.left=sear(<span class="number">1</span>,index,<span class="number">0</span>,index-<span class="number">1</span>,preorder,inorder);</span><br><span class="line">        root.right=sear(index+<span class="number">1</span>,preorder.length-<span class="number">1</span>,index+<span class="number">1</span>,</span><br><span class="line">        	inorder.length-<span class="number">1</span>,preorder,inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sear</span><span class="params">(<span class="keyword">int</span> left1,<span class="keyword">int</span> right1,<span class="keyword">int</span> left2,<span class="keyword">int</span> right2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] preorder,<span class="keyword">int</span>[] inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left1&gt;right1||left2&gt;right2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> TreeNode(preorder[left1]);</span><br><span class="line">        <span class="keyword">int</span> index=left1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left2;i&lt;=right2;i++)</span><br><span class="line">            &#123;<span class="keyword">if</span>(preorder[left1]==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        node.left=sear(left1+<span class="number">1</span>,left1+index-left2,left2,index-<span class="number">1</span>,preorder</span><br><span class="line">        ,inorder);</span><br><span class="line">        node.right=sear(left1+<span class="number">1</span>+index-left2,right1,index+<span class="number">1</span>,right2</span><br><span class="line">        ,preorder,inorder);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[postorder.length-<span class="number">1</span>]==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left=sear(<span class="number">0</span>,index-<span class="number">1</span>,<span class="number">0</span>,index-<span class="number">1</span>,inorder,postorder);</span><br><span class="line">        root.right=sear(index+<span class="number">1</span>,inorder.length-<span class="number">1</span>,index,inorder.length-<span class="number">2</span>,</span><br><span class="line">        inorder,postorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sear</span><span class="params">(<span class="keyword">int</span> left1,<span class="keyword">int</span> right1,<span class="keyword">int</span> left2,<span class="keyword">int</span> right2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] inorder,<span class="keyword">int</span>[] postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left1&gt;right1||left2&gt;right2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> TreeNode(postorder[right2]);</span><br><span class="line">        <span class="keyword">int</span> index=left1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left1;i&lt;=right1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==postorder[right2])</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left=sear(left1,index-<span class="number">1</span>,left2,left2+index-<span class="number">1</span>-left1,inorder,</span><br><span class="line">        postorder);</span><br><span class="line">        node.right=sear(index+<span class="number">1</span>,right1,left2+index-left1,right2-<span class="number">1</span>,</span><br><span class="line">        inorder,postorder);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h3><h3 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h3><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>前三种操作都可以完成，如何获取最小元素，每次入栈的时候都要判断这个元素是<br>不是最小的，如果不是最小的那么直接入栈，如果是最小的，那么首先把之前最小<br>的入栈，然后该元素入栈。这样做的目的是如果该元素要出栈，那么出栈时判断这<br>个元素是最小的，那么继续出栈就获取之前最小的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(min&gt;=x)</span><br><span class="line">      &#123;</span><br><span class="line">          stack.push(min);</span><br><span class="line">          min=x;</span><br><span class="line">      &#125;</span><br><span class="line">       stack.push(x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(stack.pop()==min)</span><br><span class="line">           min=stack.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol>
<li>斐波那契数列 dp[n]=dp[n−1]+dp[n−2]</li>
</ol>
<h4 id="二维网格找路径"><a href="#二维网格找路径" class="headerlink" title="二维网格找路径"></a>二维网格找路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        array[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        array[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">             array[i][j]=array[i-<span class="number">1</span>][j]+array[i][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="二维网格找路径II"><a href="#二维网格找路径II" class="headerlink" title="二维网格找路径II"></a>二维网格找路径II</h4><p>网格中有障碍物</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid.length][obstacleGrid[<span class="number">0</span>].length];</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">          dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;obstacleGrid.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line">              num=<span class="number">0</span>;</span><br><span class="line">          dp[i][<span class="number">0</span>]=num;</span><br><span class="line">      &#125;</span><br><span class="line">      num=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;obstacleGrid[<span class="number">0</span>].length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span>)</span><br><span class="line">              num=<span class="number">0</span>;</span><br><span class="line">          dp[<span class="number">0</span>][i]=num;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;obstacleGrid.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;obstacleGrid[<span class="number">0</span>].length;j++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)</span><br><span class="line">                  dp[i][j]=<span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h4><p>计算其二进制数中的1的数目并将它们作为数组返回。<br>这是一道典型的动态规划题，我一开始想找相邻两个数之间的关系结果不行，一个<br>大牛的解法就是对于一个二进制数来说，如果它的最低位为1（%2为1）,则它与<br>n/2的1个数相差1。如果它的最低位为0，则它与n/2的1个数相同。有些动态规划题<br>并不一定是相邻的数之间有关系也有可能有间隔</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=num/<span class="number">2</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              array[i*<span class="number">2</span>]=array[i];</span><br><span class="line">              <span class="keyword">if</span>(i*<span class="number">2</span>+<span class="number">1</span>&lt;=num)</span><br><span class="line">                  array[i*<span class="number">2</span>+<span class="number">1</span>]=array[i]+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<h4 id="做菜顺序"><a href="#做菜顺序" class="headerlink" title="做菜顺序"></a>做菜顺序</h4><p>首先应该想到倒序排序，从最大值开始累加，如果出现负数就说明已经结束了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(satisfaction);</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=satisfaction.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(num&gt;=<span class="number">0</span>)</span><br><span class="line">          &#123;       </span><br><span class="line">              num=num+satisfaction[i]+sum;</span><br><span class="line">              sum+=satisfaction[i];</span><br><span class="line">              max=Math.max(num,max);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长湍流子数组"><a href="#最长湍流子数组" class="headerlink" title="最长湍流子数组"></a>最长湍流子数组</h4><p>核心就是找当前状态与前一个状态和前一个状态与前前一个状态的关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">      dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(A.length&gt;<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(A[<span class="number">1</span>]==A[<span class="number">0</span>])</span><br><span class="line">              dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  dp[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                  max=<span class="number">2</span>;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;A.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">int</span> num1=A[i]-A[i-<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">int</span> num2=A[i-<span class="number">2</span>]-A[i-<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span>((num1&gt;<span class="number">0</span>&amp;&amp;num2&gt;<span class="number">0</span>)||(num1&lt;<span class="number">0</span>&amp;&amp;num2&lt;<span class="number">0</span>))</span><br><span class="line">              dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>((num1&gt;<span class="number">0</span>&amp;&amp;num2&lt;<span class="number">0</span>)||(num1&lt;<span class="number">0</span>&amp;&amp;num2&gt;<span class="number">0</span>))</span><br><span class="line">              dp[i]=<span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(num1==<span class="number">0</span>)</span><br><span class="line">                  dp[i]=<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  dp[i]=<span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          max=Math.max(max,dp[i]);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h4><p>当前位置与上一个和左一个位置的关系，但是注意选最小的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          dp[i][<span class="number">0</span>]=grid[i][<span class="number">0</span>]+dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid[<span class="number">0</span>].length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          dp[<span class="number">0</span>][i]=grid[<span class="number">0</span>][i]+dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].length;j++)</span><br><span class="line">          &#123;</span><br><span class="line">              dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用最小花费爬阶梯"><a href="#使用最小花费爬阶梯" class="headerlink" title="使用最小花费爬阶梯"></a>使用最小花费爬阶梯</h4><p>数组的每个下标作为一个阶梯，第i个阶梯对应着一个非负数的体力花费<br>值cost[i]。核心就是找到当前状态与前一个和前两个之间的关系，先得<br>到小问题的解，小问题是最优解最后累积为大问题的解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[cost.length+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span>(cost.length&gt;<span class="number">2</span>)</span><br><span class="line">          dp[<span class="number">2</span>]=cost[<span class="number">0</span>]&gt;cost[<span class="number">1</span>]?cost[<span class="number">1</span>]:cost[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=cost.length;i++)</span><br><span class="line">          dp[i]=Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">      <span class="keyword">return</span> dp[cost.length];</span><br></pre></td></tr></table></figure>


<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h3 id="X数之和系列"><a href="#X数之和系列" class="headerlink" title="X数之和系列"></a>X数之和系列</h3><h3 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h3><h4 id="买股票最佳时机I"><a href="#买股票最佳时机I" class="headerlink" title="买股票最佳时机I"></a>买股票最佳时机I</h4><p>区间和可以转换成求差的问题，求差问题，也可以转换成区间和的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       num=Math.max(<span class="number">0</span>,num+prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">       profit=Math.max(num,profit);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>也可以用动态规划的思想，前i天的最大收益 = max{前i-1天的最大收益，第i天<br>的价格-前i-1天中的最小价格}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 前i天的最大收益 = max&#123;前i-1天的最大收益，第i天的价格-前i-1天中的最小价格&#125;</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">          dp[i] = Math.max(dp[i - <span class="number">1</span>], prices[i] - min);</span><br><span class="line">          min = Math.min(min, prices[i]);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="括号系列"><a href="#括号系列" class="headerlink" title="括号系列"></a>括号系列</h3><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><h3 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h3><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="只出现一次的数字，使用异或"><a href="#只出现一次的数字，使用异或" class="headerlink" title="只出现一次的数字，使用异或"></a>只出现一次的数字，使用异或</h4><p>考察异或的用法<br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。<br>找出那个只出现了一次的元素，使用异或求解，异或的用法就是对于两个相同的数<br>异或结果是0，一个数跟0异或结果还是这个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
<h4 id="判断一个数是回文数"><a href="#判断一个数是回文数" class="headerlink" title="判断一个数是回文数"></a>判断一个数是回文数</h4><ol>
<li>第一种方式就是将这个数变为字符串然后反转<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String reversedStr = (<span class="keyword">new</span> StringBuilder(x + <span class="string">""</span>)).reverse().toString();</span><br></pre></td></tr></table></figure></li>
<li>通过左右两边的位进行比较<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边界判断</span></span><br><span class="line">      <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) div *= <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> left = x / div;</span><br><span class="line">          <span class="keyword">int</span> right = x % <span class="number">10</span>;</span><br><span class="line">          <span class="keyword">if</span> (left != right) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//左右各减去1位，先取余减去高位，再取整减去低位</span></span><br><span class="line">          x = (x % div) / <span class="number">10</span>;</span><br><span class="line">          div /= <span class="number">100</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li>
<li>取出后半段数字进行反转<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">           revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">           x /= <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//位数分为奇偶情况</span></span><br><span class="line">       <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="反转一个数字"><a href="#反转一个数字" class="headerlink" title="反转一个数字"></a>反转一个数字</h4><p>给你一个32位的有符号整数x，返回x中每位上的数字反转后的结果。结果不能超过<br>32位有符号数的范围，可以考虑先用long表示反转的数，然后强转为int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)n==n? (<span class="keyword">int</span>)n:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="平方数之和"><a href="#平方数之和" class="headerlink" title="平方数之和"></a>平方数之和</h4><p>给定一个非负整数c，你要判断是否存在两个整数a和b，使得a^2+b^2=c。<br>使用双指针，从左右两边开始遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> low=<span class="number">0</span>,high=(<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">      <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">          <span class="keyword">int</span> sum = low*low + high*high;</span><br><span class="line">          <span class="keyword">if</span>(sum == c)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;c)&#123;</span><br><span class="line">              low++;</span><br><span class="line">          &#125;<span class="keyword">else</span></span><br><span class="line">              high--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h4 id="完美数"><a href="#完美数" class="headerlink" title="完美数"></a>完美数</h4><p>这个题最直接的思路就是遍历，但是会超出时间限制，实际上除了1和平方根<br>之外，正因子都是成对出现的，所以只需要遍历平方根之前的数就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">1</span>; <span class="comment">// 正整数一定会有一个1，同时不用考虑自身，所以单独处理</span></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">double</span> sqrt = Math.sqrt(num);</span><br><span class="line">      <span class="keyword">for</span>(;i &lt; sqrt;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(num % i == <span class="number">0</span>) &#123;</span><br><span class="line">              sum += i;</span><br><span class="line">              sum += num / i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 此处单独处理的原因在于只需要加1次i值，如果在循环中会加2次</span></span><br><span class="line">      <span class="keyword">if</span>(i * i == num) &#123;</span><br><span class="line">          sum += i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum == num;</span><br></pre></td></tr></table></figure>
<h4 id="卡牌分组"><a href="#卡牌分组" class="headerlink" title="卡牌分组"></a>卡牌分组</h4><p>统计每个数出现的次数，然后求最大公约数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> c: deck)</span><br><span class="line">           count[c]++;</span><br><span class="line">       <span class="keyword">int</span> g = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">           <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (g == -<span class="number">1</span>)</span><br><span class="line">                   g = count[i];</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   g = gcd(g, count[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> g &gt;= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> x == <span class="number">0</span> ? y : gcd(y%x, x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大交换"><a href="#最大交换" class="headerlink" title="最大交换"></a>最大交换</h4><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="一组数的所有排列"><a href="#一组数的所有排列" class="headerlink" title="一组数的所有排列"></a>一组数的所有排列</h4><p>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的<br>过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时<br>候，它将取消上一步甚至是上几步的计算。这个题中采用回溯思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    	<span class="comment">//1 2 3 从第一个开始进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            array.add(nums[i]);</span><br><span class="line">            cut(array,nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(ArrayList&lt;Integer&gt; array,<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">//回溯终止条件就是遍历完成</span></span><br><span class="line">        <span class="keyword">if</span>(array.size()==nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(array));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!array.contains(nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="comment">//满足条件加入</span></span><br><span class="line">                array.add(nums[i]);</span><br><span class="line">                <span class="comment">//继续回溯</span></span><br><span class="line">                cut(array,nums);</span><br><span class="line">                <span class="comment">//回退</span></span><br><span class="line">                array.remove(array.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="交换一次的先前排列"><a href="#交换一次的先前排列" class="headerlink" title="交换一次的先前排列"></a>交换一次的先前排列</h4><p>这道题应该从后往前找而不是从前往后找，注意是要小于原数组的最大数组，如果<br>从前往后就不满足条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = A.length;</span><br><span class="line">      <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> A;</span><br><span class="line">      <span class="comment">//1.从后往前找，如果是A[i]&gt;=A[i-1]则继续</span></span><br><span class="line">      <span class="comment">//2. 碰到A[i]&lt;A[i-1]记录下需要交换的位置</span></span><br><span class="line">      <span class="comment">//3. 找到比他小的再交换即可(需要找到位置最前的元素)</span></span><br><span class="line">      <span class="comment">// 123456这样的没法换</span></span><br><span class="line">      <span class="comment">//987654321 这样的可以换</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">          <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;A[i]&gt;=A[i-<span class="number">1</span>])</span><br><span class="line">              i--;</span><br><span class="line">          <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> A;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = len-<span class="number">1</span>;j &gt;= i;j--)&#123;<span class="comment">//注意此处的边界</span></span><br><span class="line">              <span class="keyword">if</span>(A[j]&lt;A[i-<span class="number">1</span>])&#123;</span><br><span class="line">                  <span class="comment">//swap(A,i-1,j);</span></span><br><span class="line">                  <span class="keyword">int</span> tmp = j;</span><br><span class="line">                  <span class="keyword">for</span>(<span class="keyword">int</span> k = j-<span class="number">1</span>;k&gt;=i;k--)&#123;</span><br><span class="line">                      <span class="keyword">if</span>(A[k]==A[j])</span><br><span class="line">                          tmp = k;</span><br><span class="line">                  &#125;</span><br><span class="line">                  swap(A,tmp,i-<span class="number">1</span>);</span><br><span class="line">                  <span class="keyword">return</span> A;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> A;</span><br></pre></td></tr></table></figure>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><p>这道题的核心就是说从倒数第二个位置开始向左遍历，如果这个位置能够到达<br>最后指定位置，继续向左遍历，既然要到最后一个位置，那么如果能够达到在<br>这之前的位置，一直不断放宽条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last=nums.length-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">      &#123;</span><br><span class="line">      	<span class="comment">//这里要用&gt;= 因为可以有多种选择</span></span><br><span class="line">          <span class="keyword">if</span>(i+nums[i]&gt;=last)</span><br><span class="line">              last=i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> last==<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="对称数组的交换"><a href="#对称数组的交换" class="headerlink" title="对称数组的交换"></a>对称数组的交换</h4><p>我们可以旋转第i张多米诺，使得A[i]和B[i]的值交换。返回能使A中所有值或<br>者B中所有值都相同的最小旋转次数，值的范围是1到6。可以使用两个记录数组<br>，把元素的个数都记录在记录数组中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">      <span class="keyword">int</span>[] array2=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          array1[A[i]]++;</span><br><span class="line">          array2[B[i]]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          flag=<span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(array1[i]+array2[i]&gt;=A.length)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A.length;j++)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span>(A[j]!=i&amp;&amp;B[j]!=i)</span><br><span class="line">                      &#123;</span><br><span class="line">                          flag=<span class="keyword">true</span>;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(flag)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">int</span> min=Math.min(A.length-array1[i],A.length-array2[i]);</span><br><span class="line">                  <span class="keyword">return</span> min;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<h3 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h3><ol>
<li>先手必胜策略</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStructure/">DataStructure</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>JAVA基础总结</span></a></div><div class="next-post pull-right"><a href="/2021/01/22/JVM%E6%80%BB%E7%BB%93/"><span>JVM总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/01/22/刷题总结/';
  this.page.title = '刷题总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>