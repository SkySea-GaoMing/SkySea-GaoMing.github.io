<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JVM总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>JVM总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题"><span class="toc-number">1.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java与c-的区别？"><span class="toc-number">1.1.</span> <span class="toc-text">Java与c++的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK和JRE的区别？"><span class="toc-number">1.2.</span> <span class="toc-text">JDK和JRE的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是虚拟机？"><span class="toc-number">1.3.</span> <span class="toc-text">什么是虚拟机？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈式架构和寄存器架构的区别？"><span class="toc-number">1.4.</span> <span class="toc-text">栈式架构和寄存器架构的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说一下JVM的主要组成部分及其作用？"><span class="toc-number">1.5.</span> <span class="toc-text">说一下JVM的主要组成部分及其作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java程序运行机制是什么样的？"><span class="toc-number">1.6.</span> <span class="toc-text">Java程序运行机制是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说一下JVM运行时数据区？"><span class="toc-number">1.7.</span> <span class="toc-text">说一下JVM运行时数据区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时数据区中哪些线程私有哪些线程共享？"><span class="toc-number">1.8.</span> <span class="toc-text">运行时数据区中哪些线程私有哪些线程共享？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么程序计数器是线程私有？"><span class="toc-number">1.9.</span> <span class="toc-text">为什么程序计数器是线程私有？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈中可能出现的异常是什么？"><span class="toc-number">1.10.</span> <span class="toc-text">栈中可能出现的异常是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何设置栈空间？"><span class="toc-number">1.11.</span> <span class="toc-text">如何设置栈空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何设置堆空间？"><span class="toc-number">1.12.</span> <span class="toc-text">如何设置堆空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何设置方法区空间？"><span class="toc-number">1.13.</span> <span class="toc-text">如何设置方法区空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是运行时常量池？"><span class="toc-number">1.14.</span> <span class="toc-text">什么是运行时常量池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的演进过程是怎样的？"><span class="toc-number">1.15.</span> <span class="toc-text">方法区的演进过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元空间和方法区的本质区别是什么？"><span class="toc-number">1.16.</span> <span class="toc-text">元空间和方法区的本质区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的创建有哪几种方式？"><span class="toc-number">1.17.</span> <span class="toc-text">对象的创建有哪几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象创建的流程是怎样的？"><span class="toc-number">1.18.</span> <span class="toc-text">对象创建的流程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的实例化过程是怎样的？"><span class="toc-number">1.19.</span> <span class="toc-text">对象的实例化过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的内存是如何分配的？"><span class="toc-number">1.20.</span> <span class="toc-text">对象的内存是如何分配的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发情况如何分配内存？"><span class="toc-number">1.21.</span> <span class="toc-text">并发情况如何分配内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的访问定位有哪几种情况？"><span class="toc-number">1.22.</span> <span class="toc-text">对象的访问定位有哪几种情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏和内存溢出的区别？"><span class="toc-number">1.23.</span> <span class="toc-text">内存泄漏和内存溢出的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏的原因是什么？如何解决？"><span class="toc-number">1.24.</span> <span class="toc-text">内存泄漏的原因是什么？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是垃圾？"><span class="toc-number">1.25.</span> <span class="toc-text">什么是垃圾？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-和Java在垃圾回收上的区别？"><span class="toc-number">1.26.</span> <span class="toc-text">c++和Java在垃圾回收上的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动内存管理是什么？"><span class="toc-number">1.27.</span> <span class="toc-text">自动内存管理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC是什么？为什么要GC？"><span class="toc-number">1.28.</span> <span class="toc-text">GC是什么？为什么要GC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收机制是什么？"><span class="toc-number">1.29.</span> <span class="toc-text">垃圾回收机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收的优点是什么？"><span class="toc-number">1.30.</span> <span class="toc-text">垃圾回收的优点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断对象是否可回收的方法有哪些？"><span class="toc-number">1.31.</span> <span class="toc-text">判断对象是否可回收的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用计数算法的优缺点？"><span class="toc-number">1.32.</span> <span class="toc-text">引用计数算法的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java为什么使用可达性分析算法？"><span class="toc-number">1.33.</span> <span class="toc-text">Java为什么使用可达性分析算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-Roots有哪几种类型？"><span class="toc-number">1.34.</span> <span class="toc-text">GC Roots有哪几种类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中都有哪些引用类型？"><span class="toc-number">1.35.</span> <span class="toc-text">Java中都有哪些引用类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的finalization机制是什么？"><span class="toc-number">1.36.</span> <span class="toc-text">对象的finalization机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法区的回收过程是怎样的？"><span class="toc-number">1.37.</span> <span class="toc-text">方法区的回收过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说一下JVM有哪些垃圾回收算法？"><span class="toc-number">1.38.</span> <span class="toc-text">说一下JVM有哪些垃圾回收算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集理论是什么？"><span class="toc-number">1.39.</span> <span class="toc-text">分代收集理论是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-清除算法是什么？优缺点是什么？"><span class="toc-number">1.40.</span> <span class="toc-text">标记-清除算法是什么？优缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-复制算法是什么？优缺点是什么？"><span class="toc-number">1.41.</span> <span class="toc-text">标记-复制算法是什么？优缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-整理算法是什么？优缺点是什么？"><span class="toc-number">1.42.</span> <span class="toc-text">标记-整理算法是什么？优缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#根节点枚举具体过程是什么？"><span class="toc-number">1.43.</span> <span class="toc-text">根节点枚举具体过程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全点的作用是什么？"><span class="toc-number">1.44.</span> <span class="toc-text">安全点的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC发生时，检查所有线程都跑到最近的安全点的方法有哪些？"><span class="toc-number">1.45.</span> <span class="toc-text">GC发生时，检查所有线程都跑到最近的安全点的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全区域是什么？"><span class="toc-number">1.46.</span> <span class="toc-text">安全区域是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#记忆集合卡表的作用是什么？"><span class="toc-number">1.47.</span> <span class="toc-text">记忆集合卡表的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写屏障的作用是什么？"><span class="toc-number">1.48.</span> <span class="toc-text">写屏障的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发标记的两种解决方法是什么？"><span class="toc-number">1.49.</span> <span class="toc-text">并发标记的两种解决方法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说一下JVM有哪些垃圾回收器？"><span class="toc-number">1.50.</span> <span class="toc-text">说一下JVM有哪些垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器是如何组合的？"><span class="toc-number">1.51.</span> <span class="toc-text">垃圾收集器是如何组合的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial收集器是什么样的？"><span class="toc-number">1.52.</span> <span class="toc-text">Serial收集器是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial收集器的优点是什么？"><span class="toc-number">1.53.</span> <span class="toc-text">Serial收集器的优点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew收集器是什么样的？"><span class="toc-number">1.54.</span> <span class="toc-text">ParNew收集器是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器语境下的并行和并发是什么？"><span class="toc-number">1.55.</span> <span class="toc-text">垃圾收集器语境下的并行和并发是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge收集器是什么？"><span class="toc-number">1.56.</span> <span class="toc-text">Parallel Scavenge收集器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old收集器是什么？"><span class="toc-number">1.57.</span> <span class="toc-text">Serial Old收集器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old收集器是什么？"><span class="toc-number">1.58.</span> <span class="toc-text">Parallel Old收集器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS收集器是什么？"><span class="toc-number">1.59.</span> <span class="toc-text">CMS收集器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS运作过程是什么样的？"><span class="toc-number">1.60.</span> <span class="toc-text">CMS运作过程是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS的优缺点是什么？"><span class="toc-number">1.61.</span> <span class="toc-text">CMS的优缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS为什么不使用标记-整理算法？"><span class="toc-number">1.62.</span> <span class="toc-text">CMS为什么不使用标记-整理算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1收集器是什么？"><span class="toc-number">1.63.</span> <span class="toc-text">G1收集器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深拷贝和浅拷贝的区别？"><span class="toc-number">1.64.</span> <span class="toc-text">深拷贝和浅拷贝的区别？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JVM总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/22/JVM%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/22/JVM总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Java与c-的区别？"><a href="#Java与c-的区别？" class="headerlink" title="Java与c++的区别？"></a>Java与c++的区别？</h3><ol>
<li>c/c++编译生成的可执行文件跟操作系统和指令集架构都有关系</li>
<li>Java的一大特点就是摆脱了硬件平台的束缚，一次编写到处运行，<br>java虚拟机的功能比Java 要强大，实际上是跨语言的平台，不同的编<br>程语言编写的程序也可以编译成字节码文件，如果符合虚拟机规范也可<br>以在虚拟机上运行，实际上能在jvm平台执行的字节码格式都是一样的<br>，统称为jvm字节码</li>
</ol>
<h3 id="JDK和JRE的区别？"><a href="#JDK和JRE的区别？" class="headerlink" title="JDK和JRE的区别？"></a>JDK和JRE的区别？</h3><p>JDK是用于支持Java程序开发的最小环境，JRE是支持Java程序运行的标<br>准环境</p>
<ol>
<li>Java程序设计语言，Java虚拟机，JavaAPI类库组成JDK</li>
<li>Java虚拟机，Java SE API组成JRE</li>
</ol>
<h3 id="什么是虚拟机？"><a href="#什么是虚拟机？" class="headerlink" title="什么是虚拟机？"></a>什么是虚拟机？</h3><p>是一台虚拟的计算机，也就是一个软件，用来执行一系列虚拟计算机指令</p>
<ol>
<li>系统虚拟机 VisualBox VMware 完全对物理计算机的仿真，提供一个<br>可运行完整操作系统的软件平台，实际上模拟的是硬件</li>
<li>程序虚拟机 Java虚拟机 专门为执行单个计算机程序而设计，Java虚<br>拟机中执行的指令称为Java字节码指令，Java字节码是可以运行在任何<br>支持Java虚拟机的硬件平台和操作系统上的二进制文件，字节码的执行<br>实际上是被翻译成机器代码而执行的过程。实际上模拟的是JVM</li>
</ol>
<h3 id="栈式架构和寄存器架构的区别？"><a href="#栈式架构和寄存器架构的区别？" class="headerlink" title="栈式架构和寄存器架构的区别？"></a>栈式架构和寄存器架构的区别？</h3><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构 <img src="/2021/01/22/JVM%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<h3 id="说一下JVM的主要组成部分及其作用？"><a href="#说一下JVM的主要组成部分及其作用？" class="headerlink" title="说一下JVM的主要组成部分及其作用？"></a>说一下JVM的主要组成部分及其作用？</h3><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、<br>Execution engine(执行引擎)，两个组件为Runtime data area(运行<br>时数据区)、Native Interface(本地接口)</p>
<ol>
<li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.<br>Object)来装载class文件到Runtime data area中的method area</li>
<li>Execution engine（执行引擎）：执行classes中的指令</li>
<li>Native Interface(本地接口)：与native libraries交互，是其它<br>编程语言交互的接口</li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存</li>
</ol>
<h3 id="Java程序运行机制是什么样的？"><a href="#Java程序运行机制是什么样的？" class="headerlink" title="Java程序运行机制是什么样的？"></a>Java程序运行机制是什么样的？</h3><p>Java程序运行机制步骤</p>
<ol>
<li>首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java</li>
<li>再利用编译器(javac)将源代码编译成字节码文件，也叫前端编译器，<br>字节码文件的后缀名为.class。因为操作系统并不能识别字节码，所以<br>Java虚拟机中的执行引擎中的JIT编译器要将字节码翻译成机器指令被<br>CPU执行，所以JIT被称为后端编译器</li>
<li>运行过程Java虚拟机能够将字节码解释成具体平台的机器码</li>
</ol>
<h3 id="说一下JVM运行时数据区？"><a href="#说一下JVM运行时数据区？" class="headerlink" title="说一下JVM运行时数据区？"></a>说一下JVM运行时数据区？</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存区域划分为若干<br>个不同的数据区域</p>
<ol>
<li>程序计数器（Program Counter Register）：当前线程所执行的字节<br>码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选<br>取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复<br>等基础功能，都需要依赖这个计数器来完成。任何时间一个线程都只有一<br>个方法在执行，也就是当前方法，程序计数器会存储当前线程正在执行的<br>Java方法的虚拟机字节码指令地址，如果执行native方法则未指定值。是<br>唯一不存在OOM的区域</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）：描述Java方法<br>执行的线程内存模型。其内部保存一个个栈帧，对应一次次的Java方法调<br>用，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>
<li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，<br>只不过虚拟机栈是服务Java方法的，而本地方法栈是为虚拟机调用Native<br>方法服务的</li>
<li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线<br>程共享的，几乎所有的对象实例都在这里分配内存。还可以分配多个线程私<br>有的分配缓冲区(TLAB)，以提升对象分配时的效率</li>
<li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静<br>态变量、即时编译后的代码等数据</li>
</ol>
<h3 id="运行时数据区中哪些线程私有哪些线程共享？"><a href="#运行时数据区中哪些线程私有哪些线程共享？" class="headerlink" title="运行时数据区中哪些线程私有哪些线程共享？"></a>运行时数据区中哪些线程私有哪些线程共享？</h3><ol>
<li>线程私有 程序计数器、Java虚拟机栈、本地方法栈</li>
<li>线程共享 堆、方法区</li>
</ol>
<h3 id="为什么程序计数器是线程私有？"><a href="#为什么程序计数器是线程私有？" class="headerlink" title="为什么程序计数器是线程私有？"></a>为什么程序计数器是线程私有？</h3><p>多线程在一个特定时间只会执行一个线程的方法，CPU会不停地做任务切换，<br>这样必然导致中断和恢复，为了能够准确记录各个线程正在执行的当前字节<br>码指令的地址，最好就是为每个线程分配一个PC寄存器</p>
<h3 id="栈中可能出现的异常是什么？"><a href="#栈中可能出现的异常是什么？" class="headerlink" title="栈中可能出现的异常是什么？"></a>栈中可能出现的异常是什么？</h3><p>HotSpot虚拟机的栈容量是不可以动态扩展的，所以不会出现虚拟机栈无法<br>扩展而导致的OOM异常，只要申请栈空间成功了就不会OOM，如果申请时就<br>失败会出现OOM <img src="/2021/01/22/JVM%E6%80%BB%E7%BB%93/2.jpg" alt></p>
<h3 id="如何设置栈空间？"><a href="#如何设置栈空间？" class="headerlink" title="如何设置栈空间？"></a>如何设置栈空间？</h3><p>设置线程最大栈空间，注意不区分Java虚拟机栈和本地方法栈。1m=1024k<br>HotSpot虚拟机不支持扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss256k</span><br></pre></td></tr></table></figure>
<h3 id="如何设置堆空间？"><a href="#如何设置堆空间？" class="headerlink" title="如何设置堆空间？"></a>如何设置堆空间？</h3><p>堆空间的最小值和最大值，参数都是在 VM options 中设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20m -Xmx20m</span><br></pre></td></tr></table></figure>
<h3 id="如何设置方法区空间？"><a href="#如何设置方法区空间？" class="headerlink" title="如何设置方法区空间？"></a>如何设置方法区空间？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;100m  -XX:MaxMetaspaceSize</span><br></pre></td></tr></table></figure>

<h3 id="什么是运行时常量池？"><a href="#什么是运行时常量池？" class="headerlink" title="什么是运行时常量池？"></a>什么是运行时常量池？</h3><p>运行时常量池是方法区的一部分。Class文件除了类的版本信息、字段、方法、<br>接口等描述信息外，还有一项信息就是常量池表，用于存放编译期生成的各<br>种字面量、符号引用和直接引用，在类加载后存放到方法区的运行时常量池</p>
<h3 id="方法区的演进过程是怎样的？"><a href="#方法区的演进过程是怎样的？" class="headerlink" title="方法区的演进过程是怎样的？"></a>方法区的演进过程是怎样的？</h3><ol>
<li>jdk1.6以前 有永久代，静态变量存放在永久代上</li>
<li>jdk1.7 有永久代但是逐步去永久代，字符串常量池、静态变量移除保留在堆中</li>
<li>jdk1.8及以后 无永久代，类型信息、字段、方法、常量保存在本地内存的元<br>空间中，当字符串常量池、静态变量仍在堆中</li>
</ol>
<h3 id="元空间和方法区的本质区别是什么？"><a href="#元空间和方法区的本质区别是什么？" class="headerlink" title="元空间和方法区的本质区别是什么？"></a>元空间和方法区的本质区别是什么？</h3><p>元空间不在虚拟机设置的内存中，而是使用本地内存，因此元空间依赖于内存<br>大小。JVM在启动时会分配一个内存大小，因此永久代是存在OOM的</p>
<h3 id="对象的创建有哪几种方式？"><a href="#对象的创建有哪几种方式？" class="headerlink" title="对象的创建有哪几种方式？"></a>对象的创建有哪几种方式？</h3><ol>
<li>使用new关键字    调用了构造函数</li>
<li>使用Class的newInstance方法 调用了构造函数</li>
<li>使用Constructor类的newInstance方法 调用了构造函数</li>
<li>使用clone方法    没有调用构造函数</li>
<li>使用反序列化 没有调用构造函数</li>
</ol>
<h3 id="对象创建的流程是怎样的？"><a href="#对象创建的流程是怎样的？" class="headerlink" title="对象创建的流程是怎样的？"></a>对象创建的流程是怎样的？</h3><ol>
<li>当Java虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常<br>量池中定位到一个类的符号引用</li>
<li>检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有<br>先执行相应类加载过程</li>
<li>对象所需的内存大小在类加载完成后便可确定，内存分配完成后将分配到<br>的空间（不包括对象头）都初始化为零值，这步操作保证对象的实例字段在<br>Java代码中不赋初始值就可以使用</li>
<li>接着是做一些必要的对象设置，比如确定对象是哪个类的实例，如何找到<br>类的元数据信息，对象的哈希码，对象的GC分代年龄等</li>
</ol>
<h3 id="对象的实例化过程是怎样的？"><a href="#对象的实例化过程是怎样的？" class="headerlink" title="对象的实例化过程是怎样的？"></a>对象的实例化过程是怎样的？</h3><p>调用完构造器对象才算创建完成，new之后是默认赋值，调用构造器是显式赋<br>值，是否执行构找函数是由new指令后面是否跟随invokespecial指令决定<br>，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令</p>
<h3 id="对象的内存是如何分配的？"><a href="#对象的内存是如何分配的？" class="headerlink" title="对象的内存是如何分配的？"></a>对象的内存是如何分配的？</h3><p>若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整<br>的，就从空闲列表中分配，叫做”空闲列表“方式。Serial、ParNew带有压缩整<br>理过程的收集器使用指针碰撞，CMS基于清除算法的收集器使用空闲列表</p>
<h3 id="并发情况如何分配内存？"><a href="#并发情况如何分配内存？" class="headerlink" title="并发情况如何分配内存？"></a>并发情况如何分配内存？</h3><ol>
<li>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新<br>操作的原子性）</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java<br>堆预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation<br>Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有<br>TLAB 用完并分配新的TLAB时，才需要同步锁。通过-XX:+/-UserTLAB参数来<br>设定虚拟机是否使用TLAB</li>
</ol>
<h3 id="对象的访问定位有哪几种情况？"><a href="#对象的访问定位有哪几种情况？" class="headerlink" title="对象的访问定位有哪几种情况？"></a>对象的访问定位有哪几种情况？</h3><p>栈帧中的对象引用访问到内部对象实例有两种方式</p>
<ol>
<li>句柄访问 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向<br>对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象<br>的指针指向对象的真实内存地址，好处是reference中存储的是稳定句柄地址，<br>在对象被移动时只会句柄中的实例数据指针，而reference本身不需要修改</li>
<li>直接接指针 指向对象，代表一个对象在内存中的起始地址。好处是速度快，<br>节省一次指针定位的时间开销，HotSpot采用这种方式</li>
</ol>
<h3 id="内存泄漏和内存溢出的区别？"><a href="#内存泄漏和内存溢出的区别？" class="headerlink" title="内存泄漏和内存溢出的区别？"></a>内存泄漏和内存溢出的区别？</h3><ol>
<li>内存溢出 没有空闲内存，并且垃圾收集器也无法提供更多内存。没有空闲<br>内存有两种情况，一是Java虚拟机的堆内存设置不够，二是代码中创建了大<br>量大对象，并且长时间不能被垃圾收集器收集</li>
<li>内存泄漏 只有对象不会再被程序用到，但是GC又不能回收的情况才叫内<br>存泄漏，尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，<br>程序中的可用内存就会逐步被蚕食直至耗尽所有内存，最终出现OOM</li>
</ol>
<h3 id="内存泄漏的原因是什么？如何解决？"><a href="#内存泄漏的原因是什么？如何解决？" class="headerlink" title="内存泄漏的原因是什么？如何解决？"></a>内存泄漏的原因是什么？如何解决？</h3><p>java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的<br>引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为<br>长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露<br>的发生场景。<br>解决方法：通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是<br>通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回<br>收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一<br>般可以准确定位这些对象创建的位置，进而找到内存泄漏的代码的具体<br>位置</p>
<h3 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p>垃圾就是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回<br>收的垃圾，如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的<br>内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用</p>
<h3 id="c-和Java在垃圾回收上的区别？"><a href="#c-和Java在垃圾回收上的区别？" class="headerlink" title="c++和Java在垃圾回收上的区别？"></a>c++和Java在垃圾回收上的区别？</h3><ol>
<li>早期的c/c++时代，垃圾回收基本是手工进行，可以使用new进行内存申请，<br>并使用delete进行内存释放，但是给开发人员带来频繁申请和释放内存的管理<br>负担，万一有一块内存忘记delete了那么这块内存就永远没有被清除</li>
<li>Java、C#、Python、Ruby等语言都使用了自动垃圾回收</li>
</ol>
<h3 id="自动内存管理是什么？"><a href="#自动内存管理是什么？" class="headerlink" title="自动内存管理是什么？"></a>自动内存管理是什么？</h3><p>自动内存管理，开发人员无需手动参与内存的分配和回收，降低内存泄漏和内存<br>溢出的风险，更加专注于业务的开发。但是也弱化了Java开发人员在程序出现内<br>存溢出时定位问题和解决问题的能力，所以了解JVM的自动内存分配和内存回收<br>原理就尤为重要</p>
<h3 id="GC是什么？为什么要GC？"><a href="#GC是什么？为什么要GC？" class="headerlink" title="GC是什么？为什么要GC？"></a>GC是什么？为什么要GC？</h3><p>GC是垃圾收集的意思(Gabage Collection)，内存处理是编程人员容易出现问<br>题的地方，忘记或错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java<br>提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的<br>，Java 语言没有提供释放已分配内存的显示操作方法</p>
<h3 id="垃圾回收机制是什么？"><a href="#垃圾回收机制是什么？" class="headerlink" title="垃圾回收机制是什么？"></a>垃圾回收机制是什么？</h3><p>在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行<br>执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会<br>执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些<br>没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收</p>
<h3 id="垃圾回收的优点是什么？"><a href="#垃圾回收的优点是什么？" class="headerlink" title="垃圾回收的优点是什么？"></a>垃圾回收的优点是什么？</h3><ol>
<li>java程序员在编写程序时不再考虑内存管理的问题</li>
<li>有效的防止了内存泄露，可以有效的使用可使用的内存</li>
</ol>
<h3 id="判断对象是否可回收的方法有哪些？"><a href="#判断对象是否可回收的方法有哪些？" class="headerlink" title="判断对象是否可回收的方法有哪些？"></a>判断对象是否可回收的方法有哪些？</h3><ol>
<li>引用计数算法 对每个对象保存一个整型的引用计数器属性，用于记录对象被<br>引用的情况，如果对象的引用计数器的值为0那么这个对象就不再使用可以被回收</li>
<li>可达性分析算法 从 GC Roots开始向下搜索，搜索所走过的路径称为引用<br>链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回<br>收的</li>
</ol>
<h3 id="引用计数算法的优缺点？"><a href="#引用计数算法的优缺点？" class="headerlink" title="引用计数算法的优缺点？"></a>引用计数算法的优缺点？</h3><ol>
<li>优点是实现简单，垃圾对象容易辨识，判定效率高，回收没有延迟性</li>
<li>缺点是需要单独的字段存储计数器，这样增加存储空间的开销，每次赋值<br>都需要更新计数器，伴随加法和减法操作增加时间开销，尤其是无法处理循<br>环引用的情况，导致Java的垃圾回收期中没有使用这种算法</li>
</ol>
<h3 id="Java为什么使用可达性分析算法？"><a href="#Java为什么使用可达性分析算法？" class="headerlink" title="Java为什么使用可达性分析算法？"></a>Java为什么使用可达性分析算法？</h3><p>可达性分析算法不仅同样具备实现简单和执行高效等特点，而且有效解决在引用<br>计数器中循环利用的问题防止内存泄漏的发生，这种类型的垃圾收集也叫追踪性<br>垃圾收集</p>
<h3 id="GC-Roots有哪几种类型？"><a href="#GC-Roots有哪几种类型？" class="headerlink" title="GC Roots有哪几种类型？"></a>GC Roots有哪几种类型？</h3><p>如果要使用可达性分析算法来判断内存是否可以回收，那么分析工作必须在一<br>个能保障一致性的快照中进行，这点不满足分析结果的正确性就无法保证，这<br>点也是导致GC时必须”stop the world”的一个重要原因，及时在CMS 收集器<br>中枚举根节点也是必须要停顿的 <img src="/2021/01/22/JVM%E6%80%BB%E7%BB%93/3.jpg" alt></p>
<h3 id="Java中都有哪些引用类型？"><a href="#Java中都有哪些引用类型？" class="headerlink" title="Java中都有哪些引用类型？"></a>Java中都有哪些引用类型？</h3><ol>
<li>强引用 发生 gc 的时候不会被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li>
<li>软引用 有用但不是必须的对象，在发生内存溢出之前会被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; sf=<span class="keyword">new</span> SoftReference&lt;Object&gt;();</span><br></pre></td></tr></table></figure></li>
<li>弱引用 有用但不是必须的对象，在下一次GC时会被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wr=<span class="keyword">new</span> WeakReference&lt;Object&gt;();</span><br></pre></td></tr></table></figure></li>
<li>虚引用 无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引<br>用的用途是在 gc 时返回一个通知，必须和引用队列一起使用</li>
</ol>
<h3 id="对象的finalization机制是什么？"><a href="#对象的finalization机制是什么？" class="headerlink" title="对象的finalization机制是什么？"></a>对象的finalization机制是什么？</h3><ol>
<li>Java语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义<br>处理逻辑</li>
<li>当垃圾回收器发现没有一个引用指向一个对象，即垃圾回收此对象之前总会<br>先调用这个对象的finalize()方法，这个方法只能被调用一次</li>
<li>在finalize()时可能导致对象复活，比如把自己(this)赋给某个类变量或<br>对象的成员变量</li>
</ol>
<h3 id="方法区的回收过程是怎样的？"><a href="#方法区的回收过程是怎样的？" class="headerlink" title="方法区的回收过程是怎样的？"></a>方法区的回收过程是怎样的？</h3><p>废弃的常量和不再使用的类型</p>
<h3 id="说一下JVM有哪些垃圾回收算法？"><a href="#说一下JVM有哪些垃圾回收算法？" class="headerlink" title="说一下JVM有哪些垃圾回收算法？"></a>说一下JVM有哪些垃圾回收算法？</h3><p>这些算法都属于追踪式垃圾收集算法</p>
<ol>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法<br>清除垃圾碎片</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活<br>着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存<br>使用率不高，只有原来的一半</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接<br>清除掉端边界以外的内存</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老<br>年代，新生代基本采用复制算法，老年代采用标记整理算法</li>
</ol>
<h3 id="分代收集理论是什么？"><a href="#分代收集理论是什么？" class="headerlink" title="分代收集理论是什么？"></a>分代收集理论是什么？</h3><p>垃圾收集器大多遵循分代收集理论进行设计，建立在两个分代假说之上</p>
<ol>
<li>弱分代假说 绝大多数对象都是朝生夕灭的</li>
<li>强分代假说 熬过多次垃圾收集过程的对象就越难以消亡</li>
</ol>
<p>奠定多个垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域<br>，然后将回收对象依据其年龄分配到不同区域</p>
<h3 id="标记-清除算法是什么？优缺点是什么？"><a href="#标记-清除算法是什么？优缺点是什么？" class="headerlink" title="标记-清除算法是什么？优缺点是什么？"></a>标记-清除算法是什么？优缺点是什么？</h3><p>标记无用对象，然后进行清除回收。标记过程就是使用可达性分析算法</p>
<ol>
<li>优点 实现简单，不需要对象进行移动</li>
<li>缺点 效率并不高，需要停止整个应用程序，导致用户体验差，这种方式清理<br>出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表</li>
</ol>
<h3 id="标记-复制算法是什么？优缺点是什么？"><a href="#标记-复制算法是什么？优缺点是什么？" class="headerlink" title="标记-复制算法是什么？优缺点是什么？"></a>标记-复制算法是什么？优缺点是什么？</h3><p>它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历<br>当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的<br>可回收的对象进行回收</p>
<ol>
<li>优点 按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片</li>
<li>缺点 可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制</li>
</ol>
<h3 id="标记-整理算法是什么？优缺点是什么？"><a href="#标记-整理算法是什么？优缺点是什么？" class="headerlink" title="标记-整理算法是什么？优缺点是什么？"></a>标记-整理算法是什么？优缺点是什么？</h3><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年<br>代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除<br>算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存<br>碎片。标记-压缩算法的最终效果等同于标记-清除算法执行完成后再进行一次<br>内存碎片整理，因此也可以称为标记-清除-压缩算法，二者的本质区别是前<br>者是一种移动式的回收算法，后者是非移动式算法。</p>
<ol>
<li>优点 解决了标记-清理算法存在的内存碎片问题</li>
<li>缺点 从效率来说标记-整理算法要低于复制算法，移动对象的过程中如果<br>对象被其他对象引用，则还需要调整引用的地址，移动过程中需要全程暂停<br>用户应用程序即STW</li>
</ol>
<h3 id="根节点枚举具体过程是什么？"><a href="#根节点枚举具体过程是什么？" class="headerlink" title="根节点枚举具体过程是什么？"></a>根节点枚举具体过程是什么？</h3><ol>
<li>所有收集器在根节点枚举这一步骤都是必须暂停用户线程，查找引用链的<br>过程还是可以与用户线程一起并发，但根节点枚举必须保证在一个一致性快<br>照中进行–一致性就是整个枚举期间执行子系统看起来就是冻结在某个时间<br>点一样</li>
<li>不需要检查所有上下文和全局的引用位置，通过一组称为OopMap的数据<br>结构找到对象引用</li>
</ol>
<h3 id="安全点的作用是什么？"><a href="#安全点的作用是什么？" class="headerlink" title="安全点的作用是什么？"></a>安全点的作用是什么？</h3><p>在特定位置才会进行GC，这些位置就是安全点。强制要求必须执行到安全点才<br>能够暂停，并且生成OopMap。安全定位置的选取基本上以是否具有让程序长<br>时间执行的特征为标准进行选定。这个特征就是指令序列的复用，例如方法<br>调用、循环跳转、异常跳转等，只有具有这些功能的指定才会产生安全点</p>
<h3 id="GC发生时，检查所有线程都跑到最近的安全点的方法有哪些？"><a href="#GC发生时，检查所有线程都跑到最近的安全点的方法有哪些？" class="headerlink" title="GC发生时，检查所有线程都跑到最近的安全点的方法有哪些？"></a>GC发生时，检查所有线程都跑到最近的安全点的方法有哪些？</h3><ol>
<li>抢先式中断 首先中断所有线程，如果还有线程不在安全点就恢复线程，<br>让线程跑到安全点，目前没有虚拟机采用</li>
<li>主动式中断 设置一个中断标志，各个线程运行到中断点的时候主动轮<br>询这个标志，如果中断标志为真，则将自己进行中断挂起，轮询标志的<br>地方和安全点是重合的</li>
</ol>
<h3 id="安全区域是什么？"><a href="#安全区域是什么？" class="headerlink" title="安全区域是什么？"></a>安全区域是什么？</h3><p>安全点机制保证程序执行时在不太长时间进入垃圾收集过程。但是程序不执<br>行时，也就是没有分配处理器时间，比如线程处于Sleep状态或Blocked状<br>态，这时无法响应中断请求。安全区域是指能够确保在某一段代码片段之中<br>引用关系不会再发生变换，这个区域中任意地方开始垃圾收集都是安全的</p>
<h3 id="记忆集合卡表的作用是什么？"><a href="#记忆集合卡表的作用是什么？" class="headerlink" title="记忆集合卡表的作用是什么？"></a>记忆集合卡表的作用是什么？</h3><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代建立了名为记忆<br>集的数据结构，用以避免老年代加进GC Roots扫描范围</p>
<h3 id="写屏障的作用是什么？"><a href="#写屏障的作用是什么？" class="headerlink" title="写屏障的作用是什么？"></a>写屏障的作用是什么？</h3><p>写屏障可以看成在虚拟机层面对引用类型字段赋值这个动作的AOP切面</p>
<h3 id="并发标记的两种解决方法是什么？"><a href="#并发标记的两种解决方法是什么？" class="headerlink" title="并发标记的两种解决方法是什么？"></a>并发标记的两种解决方法是什么？</h3><ol>
<li>增量更新 当黑色对象插入新的指向白色对象的引用关系时，就将这个<br>新插入的引用记录下来，等并发扫描结束后再将这些记录过的引用关系中<br>的黑色对象为根，重新扫描。CMS使用这种方式</li>
<li>原始快照 当灰色对象要删除指向白色对象的引用关系时，将这个删除<br>的引用记录下来，并发扫描结束后一记录过的灰色对象为根，重新扫描，<br>G1和Shenandoah使用这种方式</li>
</ol>
<h3 id="说一下JVM有哪些垃圾回收器？"><a href="#说一下JVM有哪些垃圾回收器？" class="headerlink" title="说一下JVM有哪些垃圾回收器？"></a>说一下JVM有哪些垃圾回收器？</h3><p>用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回<br>收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收<br>整个Java堆的G1收集器</p>
<h3 id="垃圾收集器是如何组合的？"><a href="#垃圾收集器是如何组合的？" class="headerlink" title="垃圾收集器是如何组合的？"></a>垃圾收集器是如何组合的？</h3><p><img src="/2021/01/22/JVM%E6%80%BB%E7%BB%93/4.jpg" alt> <img src="/2021/01/22/JVM%E6%80%BB%E7%BB%93/5.jpg" alt></p>
<h3 id="Serial收集器是什么样的？"><a href="#Serial收集器是什么样的？" class="headerlink" title="Serial收集器是什么样的？"></a>Serial收集器是什么样的？</h3><p>是一个单线程收集器，不仅是只会使用一个处理器或一条收集线程完成收集<br>工作，更重要的是进行垃圾收集时，必须暂停所有工作线程，直到收集结束<br>，与Serial Old搭配使用，也是一个单线程收集器。新生代采用标记-复制<br>算法收集，老年代采用标记-整理算法收集</p>
<h3 id="Serial收集器的优点是什么？"><a href="#Serial收集器的优点是什么？" class="headerlink" title="Serial收集器的优点是什么？"></a>Serial收集器的优点是什么？</h3><ol>
<li>简单高效，对于限定单个CPU 的环境来说，Serial收集器由于没有<br>线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率<br>，运行在Client模式下的虚拟机是个不错的选择</li>
<li>-XX:+UseSerialGC 参数可以指定年轻代和老年代都是用串行收集器</li>
<li>对于交互性较强的应用而言，这种垃圾收集器是不能接受的</li>
</ol>
<h3 id="ParNew收集器是什么样的？"><a href="#ParNew收集器是什么样的？" class="headerlink" title="ParNew收集器是什么样的？"></a>ParNew收集器是什么样的？</h3><p>实际上是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外<br>其余行为与Serial收集器一样。目前与CMS搭配使用</p>
<h3 id="垃圾收集器语境下的并行和并发是什么？"><a href="#垃圾收集器语境下的并行和并发是什么？" class="headerlink" title="垃圾收集器语境下的并行和并发是什么？"></a>垃圾收集器语境下的并行和并发是什么？</h3><ol>
<li>并行 多条垃圾收集线程可以同时工作，默认用户线程处于等待状态</li>
<li>并发 同一时间垃圾收集器线程与用户线程都在运行</li>
</ol>
<h3 id="Parallel-Scavenge收集器是什么？"><a href="#Parallel-Scavenge收集器是什么？" class="headerlink" title="Parallel Scavenge收集器是什么？"></a>Parallel Scavenge收集器是什么？</h3><p>新生代并行收集器，追求高吞吐量，高效利用CPU，采用标记-复制算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)</span><br></pre></td></tr></table></figure>
<p>高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台<br>应用等对交互相应要求不高的分析任务场景</p>
<h3 id="Serial-Old收集器是什么？"><a href="#Serial-Old收集器是什么？" class="headerlink" title="Serial Old收集器是什么？"></a>Serial Old收集器是什么？</h3><p>老年代单线程收集器，Serial收集器的老年代版本，采用标记-整理算法</p>
<h3 id="Parallel-Old收集器是什么？"><a href="#Parallel-Old收集器是什么？" class="headerlink" title="Parallel Old收集器是什么？"></a>Parallel Old收集器是什么？</h3><p>老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本<br>，采用标记-整理算法</p>
<h3 id="CMS收集器是什么？"><a href="#CMS收集器是什么？" class="headerlink" title="CMS收集器是什么？"></a>CMS收集器是什么？</h3><p>老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发<br>、低停顿的特点，追求最短GC回收停顿时间，是以牺牲吞吐量为代价来获得<br>最短回收停顿时间的垃圾回收器。是第一款真正意义支持并发的垃圾收集器<br>，首次实现让垃圾收集线程和用户线程同时工作，所以整体的回收是低停<br>顿的。采用标记-清除算法</p>
<h3 id="CMS运作过程是什么样的？"><a href="#CMS运作过程是什么样的？" class="headerlink" title="CMS运作过程是什么样的？"></a>CMS运作过程是什么样的？</h3><p><img src="/2021/01/22/JVM%E6%80%BB%E7%BB%93/6.jpg" alt> <img src="/2021/01/22/JVM%E6%80%BB%E7%BB%93/7.jpg" alt></p>
<h3 id="CMS的优缺点是什么？"><a href="#CMS的优缺点是什么？" class="headerlink" title="CMS的优缺点是什么？"></a>CMS的优缺点是什么？</h3><p><img src="/2021/01/22/JVM%E6%80%BB%E7%BB%93/8.jpg" alt></p>
<h3 id="CMS为什么不使用标记-整理算法？"><a href="#CMS为什么不使用标记-整理算法？" class="headerlink" title="CMS为什么不使用标记-整理算法？"></a>CMS为什么不使用标记-整理算法？</h3><p>CMS收集器的垃圾收集算法是标记-清除算法，会产生垃圾碎片，如果使用<br>Compact整理内存的话，但是还要保证用户线程能够继续执行，用户的运<br>行资源不能受影响，所以标记-清除算法更合适</p>
<h3 id="G1收集器是什么？"><a href="#G1收集器是什么？" class="headerlink" title="G1收集器是什么？"></a>G1收集器是什么？</h3><p>Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p>
<h3 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h3><ol>
<li>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址</li>
<li>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这<br>个增加的指针指向这个新的内存，使用深拷贝的情况下，释放内存的时候不<br>会因为出现浅拷贝时释放同一个内存的错误</li>
<li>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅<br>复制出来的对象也会相应的改变</li>
<li>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/22/JVM%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/01/22/JVM%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/22/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>刷题总结</span></a></div><div class="next-post pull-right"><a href="/2021/01/22/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"><span>抢课项目总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/22/JVM%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/01/22/JVM总结/';
  this.page.title = 'JVM总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>