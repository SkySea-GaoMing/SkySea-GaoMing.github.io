<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MySQL总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>MySQL总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题"><span class="toc-number">2.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL三范式是什么？"><span class="toc-number">2.1.</span> <span class="toc-text">MySQL三范式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL与Oracle的区别？"><span class="toc-number">2.2.</span> <span class="toc-text">MySQL与Oracle的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储引擎是什么？"><span class="toc-number">2.3.</span> <span class="toc-text">存储引擎是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL有几种存储引擎，有什么区别？"><span class="toc-number">2.4.</span> <span class="toc-text">MySQL有几种存储引擎，有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何选择存储引擎？"><span class="toc-number">2.5.</span> <span class="toc-text">如何选择存储引擎？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB和MyISAM的比较"><span class="toc-number">2.5.1.</span> <span class="toc-text">InnoDB和MyISAM的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM索引与InnoDB索引的区别？"><span class="toc-number">2.6.</span> <span class="toc-text">MyISAM索引与InnoDB索引的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB引擎的特性是什么？"><span class="toc-number">2.7.</span> <span class="toc-text">InnoDB引擎的特性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是索引？"><span class="toc-number">2.8.</span> <span class="toc-text">什么是索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引有哪些优缺点？"><span class="toc-number">2.9.</span> <span class="toc-text">索引有哪些优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引有哪几种类型？"><span class="toc-number">2.10.</span> <span class="toc-text">索引有哪几种类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引创建方式有哪些？"><span class="toc-number">2.11.</span> <span class="toc-text">索引创建方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何创建主键？"><span class="toc-number">2.12.</span> <span class="toc-text">如何创建主键？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么自增列作为主键？"><span class="toc-number">2.13.</span> <span class="toc-text">为什么自增列作为主键？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#约束和索引的区别"><span class="toc-number">2.14.</span> <span class="toc-text">约束和索引的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#varchar和char的区别？"><span class="toc-number">2.15.</span> <span class="toc-text">varchar和char的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聚集索引和非聚集索引的区别是什么？"><span class="toc-number">2.16.</span> <span class="toc-text">聚集索引和非聚集索引的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么Innodb-使用B-树"><span class="toc-number">2.17.</span> <span class="toc-text">为什么Innodb 使用B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM和InnoDB实现BTree索引方式的区别？"><span class="toc-number">2.18.</span> <span class="toc-text">MyISAM和InnoDB实现BTree索引方式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树和B-树的区别是什么？"><span class="toc-number">2.19.</span> <span class="toc-text">B树和B+树的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash索引和B-树的区别是什么？"><span class="toc-number">2.20.</span> <span class="toc-text">Hash索引和B+树的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的基本原理是什么？"><span class="toc-number">2.21.</span> <span class="toc-text">索引的基本原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用索引查询一定能提高查询的性能吗"><span class="toc-number">2.22.</span> <span class="toc-text">使用索引查询一定能提高查询的性能吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是前缀索引？"><span class="toc-number">2.23.</span> <span class="toc-text">什么是前缀索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是最左前缀原则？"><span class="toc-number">2.24.</span> <span class="toc-text">什么是最左前缀原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库为什么使用B-树而不是B树？"><span class="toc-number">2.25.</span> <span class="toc-text">数据库为什么使用B+树而不是B树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候索引会失效？"><span class="toc-number">2.26.</span> <span class="toc-text">什么时候索引会失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL注入了解吗？"><span class="toc-number">2.27.</span> <span class="toc-text">SQL注入了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何防止SQL注入？"><span class="toc-number">2.28.</span> <span class="toc-text">如何防止SQL注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql有关权限的表都有哪几个？"><span class="toc-number">2.29.</span> <span class="toc-text">mysql有关权限的表都有哪几个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当我们输入一条SQL查询语句时，发生了什么？"><span class="toc-number">2.30.</span> <span class="toc-text">当我们输入一条SQL查询语句时，发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL可以分为哪两层"><span class="toc-number">2.31.</span> <span class="toc-text">MySQL可以分为哪两层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接器的作用？"><span class="toc-number">2.32.</span> <span class="toc-text">连接器的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析器的作用？"><span class="toc-number">2.33.</span> <span class="toc-text">分析器的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化器的作用？"><span class="toc-number">2.34.</span> <span class="toc-text">优化器的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行器的作用？"><span class="toc-number">2.35.</span> <span class="toc-text">执行器的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是数据库事务？"><span class="toc-number">2.36.</span> <span class="toc-text">什么是数据库事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务的ACID分别是什么？"><span class="toc-number">2.37.</span> <span class="toc-text">事务的ACID分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是脏读？幻读？不可重复读？"><span class="toc-number">2.38.</span> <span class="toc-text">什么是脏读？幻读？不可重复读？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><span class="toc-number">2.39.</span> <span class="toc-text">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？"><span class="toc-number">2.40.</span> <span class="toc-text">MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快照读和当前读的区别是什么？"><span class="toc-number">2.41.</span> <span class="toc-text">快照读和当前读的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是版本号？"><span class="toc-number">2.42.</span> <span class="toc-text">什么是版本号？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVC的原理是什么？"><span class="toc-number">2.43.</span> <span class="toc-text">MVVC的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隐式字段的作用？"><span class="toc-number">2.44.</span> <span class="toc-text">隐式字段的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo日志和Read-review的作用？"><span class="toc-number">2.45.</span> <span class="toc-text">undo日志和Read review的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log的作用？"><span class="toc-number">2.46.</span> <span class="toc-text">undo log的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-review的作用？"><span class="toc-number">2.47.</span> <span class="toc-text">read review的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RC-RR级别下的InnoDB快照读的区别是什么？"><span class="toc-number">2.48.</span> <span class="toc-text">RC,RR级别下的InnoDB快照读的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC有哪些好处？"><span class="toc-number">2.49.</span> <span class="toc-text">MVCC有哪些好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL是如何实现事务的？"><span class="toc-number">2.50.</span> <span class="toc-text">MySQL是如何实现事务的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隔离级别与锁的关系是什么？"><span class="toc-number">2.51.</span> <span class="toc-text">隔离级别与锁的关系是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按照锁的粒度分数据库锁有哪些？"><span class="toc-number">2.52.</span> <span class="toc-text">按照锁的粒度分数据库锁有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从锁的类别上分MySQL都有哪些锁呢？"><span class="toc-number">2.53.</span> <span class="toc-text">从锁的类别上分MySQL都有哪些锁呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行锁锁的到底是什么？"><span class="toc-number">2.54.</span> <span class="toc-text">行锁锁的到底是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？"><span class="toc-number">2.55.</span> <span class="toc-text">InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是死锁？怎么解决？"><span class="toc-number">2.56.</span> <span class="toc-text">什么是死锁？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乐观锁和悲观锁是什么？如何实现？"><span class="toc-number">2.57.</span> <span class="toc-text">乐观锁和悲观锁是什么？如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS是什么？"><span class="toc-number">2.58.</span> <span class="toc-text">CAS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句？"><span class="toc-number">2.59.</span> <span class="toc-text">数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog-redolog-undolog都是什么，起什么作用？"><span class="toc-number">2.60.</span> <span class="toc-text">binlog redolog undolog都是什么，起什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制日志和重做日志的区别？"><span class="toc-number">2.61.</span> <span class="toc-text">二进制日志和重做日志的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL的binlog有有几种录入格式？分别有什么区别？"><span class="toc-number">2.62.</span> <span class="toc-text">MySQL的binlog有有几种录入格式？分别有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-如何优化？"><span class="toc-number">2.63.</span> <span class="toc-text">MySQL 如何优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain的作用？"><span class="toc-number">2.64.</span> <span class="toc-text">explain的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-的explain关键字的select-type？"><span class="toc-number">2.65.</span> <span class="toc-text">MySQL 的explain关键字的select_type？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-的explain关键字的type？"><span class="toc-number">2.66.</span> <span class="toc-text">MySQL 的explain关键字的type？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#慢查询日志的作用？"><span class="toc-number">2.67.</span> <span class="toc-text">慢查询日志的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL查询慢如何定位？"><span class="toc-number">2.68.</span> <span class="toc-text">MySQL查询慢如何定位？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何优化数据访问？"><span class="toc-number">2.69.</span> <span class="toc-text">如何优化数据访问？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#水平切分和垂直切分的区别？"><span class="toc-number">2.70.</span> <span class="toc-text">水平切分和垂直切分的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引设计的原则是什么？"><span class="toc-number">2.71.</span> <span class="toc-text">索引设计的原则是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建索引的原则有哪些？"><span class="toc-number">2.72.</span> <span class="toc-text">创建索引的原则有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建索引时需要注意什么？"><span class="toc-number">2.73.</span> <span class="toc-text">创建索引时需要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表分区与分表的区别？"><span class="toc-number">2.74.</span> <span class="toc-text">表分区与分表的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表分区有什么好处？"><span class="toc-number">2.75.</span> <span class="toc-text">表分区有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区表的限制因素？"><span class="toc-number">2.76.</span> <span class="toc-text">分区表的限制因素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL支持的分区类型有哪些？"><span class="toc-number">2.77.</span> <span class="toc-text">MySQL支持的分区类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回表是什么意思？"><span class="toc-number">2.78.</span> <span class="toc-text">回表是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的优化方式有哪些？"><span class="toc-number">2.79.</span> <span class="toc-text">索引的优化方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联合索引？"><span class="toc-number">2.80.</span> <span class="toc-text">联合索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引覆盖是什么？"><span class="toc-number">2.81.</span> <span class="toc-text">索引覆盖是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最左匹配？"><span class="toc-number">2.82.</span> <span class="toc-text">最左匹配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引下推？"><span class="toc-number">2.83.</span> <span class="toc-text">索引下推？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非聚簇索引一定会回表查询吗？"><span class="toc-number">2.84.</span> <span class="toc-text">非聚簇索引一定会回表查询吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drop、truncate和delete的区别？"><span class="toc-number">2.85.</span> <span class="toc-text">drop、truncate和delete的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-20-中20的含义？"><span class="toc-number">2.86.</span> <span class="toc-text">int(20)中20的含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字段为什么要求定义为not-null？"><span class="toc-number">2.87.</span> <span class="toc-text">字段为什么要求定义为not null？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join的原理及应用？"><span class="toc-number">2.88.</span> <span class="toc-text">join的原理及应用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by原理？"><span class="toc-number">2.89.</span> <span class="toc-text">order by原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建表时用了哪些索引？"><span class="toc-number">2.90.</span> <span class="toc-text">建表时用了哪些索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当数据量很大时，如何优化？"><span class="toc-number">2.91.</span> <span class="toc-text">当数据量很大时，如何优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式事务？"><span class="toc-number">2.92.</span> <span class="toc-text">分布式事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式事务的提交协议？"><span class="toc-number">2.93.</span> <span class="toc-text">分布式事务的提交协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两阶段提交协议的基本思想？"><span class="toc-number">2.94.</span> <span class="toc-text">两阶段提交协议的基本思想？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式事务的缺点？"><span class="toc-number">2.95.</span> <span class="toc-text">分布式事务的缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式了解吗？"><span class="toc-number">2.96.</span> <span class="toc-text">分布式了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式系统？"><span class="toc-number">2.97.</span> <span class="toc-text">分布式系统？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式和集群的区别？"><span class="toc-number">2.98.</span> <span class="toc-text">分布式和集群的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可串行化会导致死锁吗？"><span class="toc-number">2.99.</span> <span class="toc-text">可串行化会导致死锁吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash跟b-在什么场景用？"><span class="toc-number">2.100.</span> <span class="toc-text">hash跟b+在什么场景用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树有几层？"><span class="toc-number">2.101.</span> <span class="toc-text">B+树有几层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式有了解过是吧？知道分布式事务吗？CAP？讲一下"><span class="toc-number">2.102.</span> <span class="toc-text">分布式有了解过是吧？知道分布式事务吗？CAP？讲一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联合索引的后面的索引存放在哪？"><span class="toc-number">2.103.</span> <span class="toc-text">联合索引的后面的索引存放在哪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL怎么做数据容灾"><span class="toc-number">2.104.</span> <span class="toc-text">MySQL怎么做数据容灾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#myisam为什么适合读多写少的情况，举个具体例子？"><span class="toc-number">2.105.</span> <span class="toc-text">myisam为什么适合读多写少的情况，举个具体例子？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-主从同步机制，如果同步失败会怎么样？"><span class="toc-number">2.106.</span> <span class="toc-text">MySQL 主从同步机制，如果同步失败会怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql主从复制原理？"><span class="toc-number">2.107.</span> <span class="toc-text">mysql主从复制原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主从复制的优点？"><span class="toc-number">2.108.</span> <span class="toc-text">主从复制的优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#每一页有多少数据？"><span class="toc-number">2.109.</span> <span class="toc-text">每一页有多少数据？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">MySQL总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/04/MySQL面试题/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/williamjie/p/11081592.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/11081592.html</a><br><a href="https://blog.csdn.net/cheidou123/article/details/91442955" target="_blank" rel="noopener">https://blog.csdn.net/cheidou123/article/details/91442955</a></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="MySQL三范式是什么？"><a href="#MySQL三范式是什么？" class="headerlink" title="MySQL三范式是什么？"></a>MySQL三范式是什么？</h3><ol>
<li>第一范式 保证每列的原子性，数据库中所有表的字段值都是不可分解的原<br>子值。第一范式是对关系模型的基本要求，不满足第一范式就不是关系数据库</li>
<li>第二范式 在第一范式的基础上，非主键列完全依赖于主键，而不能是依<br>赖于主键的一部分。完全依赖是针对于属性组来说，当一组属性X能推出来Y<br>的时候就说Y完全依赖于X。一组属性X中的其中一个或几个属性能推出Y就说<br>Y部分依赖于X</li>
<li>第三范式 在第二范式的基础上，保证每列和主键都直接相关，也就是说<br>决定某些字段值的必须是主键，第二范式与第三范式的区别在于第三范式消<br>除了传递依赖</li>
</ol>
<h3 id="MySQL与Oracle的区别？"><a href="#MySQL与Oracle的区别？" class="headerlink" title="MySQL与Oracle的区别？"></a>MySQL与Oracle的区别？</h3><ol>
<li>MySQL是一个单进程多线程架构的数据库，Oracle是一个多进程数据库</li>
<li>MySQL 数据库是插件式表存储引擎，存储引擎是基于表而不是基于数据库<br>，不同的表可以使用不同的存储引擎。而Oracle只有一种存储引擎，所有数据<br>存储管理机制都是一样的</li>
</ol>
<h3 id="存储引擎是什么？"><a href="#存储引擎是什么？" class="headerlink" title="存储引擎是什么？"></a>存储引擎是什么？</h3><p>数据库存储引擎是数据库底层软件组织，不同的存储引擎提供不同的存储机<br>制，索引技巧、锁定水平等功能。通过show engines可以查看所有存储引擎</p>
<h3 id="MySQL有几种存储引擎，有什么区别？"><a href="#MySQL有几种存储引擎，有什么区别？" class="headerlink" title="MySQL有几种存储引擎，有什么区别？"></a>MySQL有几种存储引擎，有什么区别？</h3><p>InnoDB MyISAM MEMROY ARCHIVE</p>
<ol>
<li>InnoDB 支持事务，实现了四个标准的隔离级别，默认级别是可重复读。<br>对于数据的存储采用了聚集索引的方式，底层使用的是B+树。支持自适应哈<br>希索引，行锁和表锁和外键和全文索引，支持在线热备份，适合大量insert<br>delete update</li>
<li>MyISAM 不支持事务、行级锁和外键，支持全文索引，索引和数据分开存<br>储，只缓存索引文件，不缓存数据文件。适合大量select的情况，底层使用<br>的也是B+树</li>
<li>MEMORY 存储引擎将表中的数据存储在内存中，为查询和引用其他表数<br>据提供快速访问。默认使用哈希索引，适用于存储临时数据的临时表</li>
<li>ARCHIVE 只支持insert和select操作，提供了压缩功能，拥有高效的<br>插入速度，但是这种引擎不支持索引，所以查询性能较差一些</li>
</ol>
<h3 id="如何选择存储引擎？"><a href="#如何选择存储引擎？" class="headerlink" title="如何选择存储引擎？"></a>如何选择存储引擎？</h3><ol>
<li>如果要提供提交、回滚和崩溃恢复能力的事务安全能力，并要求实现并发<br>控制，InnoDB 是个很好的选择</li>
<li>如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理<br>效率，很适合管理邮件或Web服务器日志数据</li>
<li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，<br>可以将数据保存在内存中的Memory 引擎。MySQL中使用该引擎作为临时表<br>，存放查询的中间结果</li>
<li>如果只有INSERT和SELECT操作，可以选择Archive引擎，Archive存<br>储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive引<br>擎非常适合存储归档数据，如历史记录和记录日志信息可以使用<br>Archive引擎</li>
</ol>
<h4 id="InnoDB和MyISAM的比较"><a href="#InnoDB和MyISAM的比较" class="headerlink" title="InnoDB和MyISAM的比较"></a>InnoDB和MyISAM的比较</h4><ol>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li>
<li>外键：InnoDB 支持外键</li>
<li>备份：InnoDB 支持在线热备份，热备份是系统处于正常运转状态下的备份</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复<br>的速度也更慢</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引</li>
<li>索引结构 InnoDB索引和数据存储在一起，表结构保存在frm文件，数据和<br>索引保存在ibd文件。MyISAM 索引和数据分开存储，只缓存索引文件，不缓<br>存数据文件。表结构保存在frm文件，数据保存在MYD文件，索引保存在MYI<br>文件</li>
</ol>
<h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ol>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查<br>询时做到覆盖索引会非常高效</li>
</ol>
<h3 id="InnoDB引擎的特性是什么？"><a href="#InnoDB引擎的特性是什么？" class="headerlink" title="InnoDB引擎的特性是什么？"></a>InnoDB引擎的特性是什么？</h3><ol>
<li>插入缓冲（insert buffer) 对于非聚集索引的插入或更新，并不是每一<br>次直接插入到索引页中，而是先判断缓冲池中是否有要插入的非聚集索引页<br>，如果有则直接插入，否则放入Insert Buffer 对象中，然后再以一定的<br>频率和情况进行和辅助索引页子节点的merge</li>
<li>二次写(double write) 重做日志记录的是对页的物理操作，如果页本身<br>已经损坏那么重做无意义，在重做之前用户需要一个页的副本，当写入失效<br>时，先通过页的副本还原该页，然后重做</li>
<li>自适应哈希索引(ahi) 如果观察到建立索引可以带来速度上的提升，则建立<br>哈希索引</li>
<li>预读(read ahead) 磁盘也会从这个位置开始顺序向后读取一定长度的数<br>据放入内存，这个理论基础就是局部性原理：当一个数据被用到其附近的数<br>据也通常会被马上使用。所以程序运行期间需要的数据通常应当比较集中。<br>预读的长度一般为页的整数倍</li>
<li>异步IO 异步IO就是说用户在发送一个IO请求后能立即发送下一个IO请求，<br>这就是AIO。AIO的另一个优势是可以进行IO merge操作</li>
<li>刷新邻接页 当刷新一脏页时，同时检测所在区(extent)的所有页，如果有<br>脏页则一并刷新</li>
</ol>
<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，<br>以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树</p>
<h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h3><ol>
<li>优点</li>
</ol>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ul>
<ol start="2">
<li>缺点如下</li>
</ol>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行<br>增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率</li>
<li>空间方面：索引需要占物理空间</li>
</ul>
<h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h3><ol>
<li>普通索引：最基本的索引，没有任何约束，允许为NULL值<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (<span class="keyword">column</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(column1, column2, column3);</span><br></pre></td></tr></table></figure></li>
<li>唯一索引：与普通索引类似，但具有唯一性约束，唯一索引数据列不能重复<br>，可以提高效率，也可以防重<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (<span class="keyword">column</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column1,column2);</span><br></pre></td></tr></table></figure></li>
<li>主键索引：特殊的唯一索引，不允许有空值</li>
<li>复合索引：将多个列组合在一起创建索引，可以覆盖多个列</li>
<li>外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致<br>性、完整性和实现级联操作</li>
<li>全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM，是目前<br>搜索引擎使用的一种关键技术<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> FULLTEXT (<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="索引创建方式有哪些？"><a href="#索引创建方式有哪些？" class="headerlink" title="索引创建方式有哪些？"></a>索引创建方式有哪些？</h3><ol>
<li>表建立时就进行约束定义</li>
<li>使用alter table创建约束，Unique Key还可以通过create unique<br>index 来创建</li>
</ol>
<h3 id="如何创建主键？"><a href="#如何创建主键？" class="headerlink" title="如何创建主键？"></a>如何创建主键？</h3><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式<br>的表称为索引组织表。每张表都有一个主键</p>
<ul>
<li>首先判断表中是否有非空的唯一索引，如果有则该列为主键。当有多个<br>非空唯一索引时，将选择建表时第一个定义的非空唯一索引为主键</li>
<li>如果不符上述条件则InnoDB自动创建一个6字节大小的指针</li>
</ul>
<h3 id="为什么自增列作为主键？"><a href="#为什么自增列作为主键？" class="headerlink" title="为什么自增列作为主键？"></a>为什么自增列作为主键？</h3><ol>
<li>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同<br>一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺<br>序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入<br>适当的节点和位置，如果页面达到装载因子，则开辟一个新的页（节点）</li>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当<br>前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li>
<li>如果使用非自增主键，由于每次插入主键的值近似于随机，因此每次新<br>纪录都要被插到现有索引页得中间某个位置，不得不为了将新记录插到合<br>适位置而移动数据，频繁的移动、分页操作造成了大量的碎片</li>
</ol>
<h3 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h3><p>约束是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，<br>既有逻辑的概念，在数据库中还代表物理存储的方式</p>
<ol>
<li>key 是数据库的逻辑结构，它包含两层意义和作用，一是约束（偏重于约<br>束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary<br>key, unique key, foreign key 等</li>
<li>index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表<br>空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类<br>的话，分为前缀索引、全文本索引等</li>
</ol>
<h3 id="varchar和char的区别？"><a href="#varchar和char的区别？" class="headerlink" title="varchar和char的区别？"></a>varchar和char的区别？</h3><p>varchar会动态分配长度，char指定长度是固定的</p>
<h3 id="聚集索引和非聚集索引的区别是什么？"><a href="#聚集索引和非聚集索引的区别是什么？" class="headerlink" title="聚集索引和非聚集索引的区别是什么？"></a>聚集索引和非聚集索引的区别是什么？</h3><ol>
<li>Innodb存储引擎插入数据时必须要将数据跟某一个索引绑定在一起，这<br>个索引就是聚集索引。一个表中有多个索引列，但是数据只有一份，其他索<br>引没有与数据的值绑定在一起，这些索引就是非聚集索引</li>
<li>Innodb中存在聚集索引和非聚集索引，MyISAM中只有非聚集索引</li>
<li>正文内容按照一个特定维度排序存储，这个特定的维度就是聚集索引，表<br>中只能由一个，一般是表中的主键索引，如果表中没有显示指定主键，则会<br>选择表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用<br>Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。聚集索引<br>性能在精确查找和范围查找上面效果要好</li>
<li>非聚集索引索引项顺序存储，但索引项对应的内容却是随机存储的</li>
<li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物<br>理存储并不连续，聚集索引是一种索引组织形式，索引的键值逻辑顺序决定<br>了表数据行的物理存储顺序，按照聚集索引排序</li>
<li>非聚集索引物理存储不按照索引排序，非聚集索引则就是普通索引了，仅<br>仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序</li>
<li>聚集索引插入数据时速度要慢（时间花费在“物理存储的排序”上，也就是首<br>先要找到位置然后插入），查询数据比非聚集数据的速度快</li>
</ol>
<h3 id="为什么Innodb-使用B-树"><a href="#为什么Innodb-使用B-树" class="headerlink" title="为什么Innodb 使用B+树"></a>为什么Innodb 使用B+树</h3><p>使用索引就是为了减少IO操作的次数</p>
<ol>
<li>哈希索引为什么不行 必须要具备好的hash算法，如果算法不合适会导<br>致数据散列不均匀，造成很大空间的浪费，如果某些链表过长则需要顺序<br>遍历，效率太低。不支持范围查询，当进行范围查询时必须要进行挨个遍<br>历。对内存空间的要求比较高，如果是等值查询还是很快的。Memory存储<br>引擎使用哈希索引，innodb支持自适应哈希索引</li>
<li>二叉树为什么不行 二叉树本身是无序的，一般使用二分查找树BST，左<br>子树小于根节点，右子树大于根节点，这样这棵树就有序了。如果是递增插<br>入或递减插入那么这棵树就退化成一个链表，那么查询复杂度又变成O(n)<br>，所以接下来的优化应该是保证这棵树的平衡</li>
<li>平衡二叉树AVL为什么不行 AVL树最短子树和最长子树高度差不能超过1<br>，为了保证平衡在插入数据的时候必须进行旋转，通过插入性能的损失来弥<br>补查询性能的提升。如果读写请求一样多那么AVL树就不合适，优化思路就<br>是在插入情况多的时候提升性能</li>
<li>红黑树为什么不行 红黑树的最长子树只要不超过最短子树的两倍即可<br>，查询性能和插入性能近似相同。但是随着数据的插入，树的深度会变深<br>，依然会影响性能。优化思路就是减少树的深度，注意这几个树都是每个<br>节点最多两个分支，把有序二叉树变为有序多叉树，那么每个节点至少<br>要有两个记录</li>
<li>B树为什么不行 每个节点都存储key和data和子节点指针，一个节点可<br>以有多个key，所有节点组成一棵B树，假设1条记录占用1KB，一个节点占<br>用一个磁盘块的空间，那么一个节点可以有16条记录，三层的B树最多能<br>够保存4096条记录，随着深度的增大保存的数据越多，IO操作次数也会<br>越多，优化的思路依然是减少深度，B树占用的大部分空间都是因为数<br>据占用</li>
<li>B+树为什么行 B+树只有叶子节点才会存储数据，非叶子节点不存储数据<br>， 假设节点指针和key一共占用10个字节，一个磁盘块可以保存1600个范围<br>，那么到了第三层就有1600*1600*16个数据，MySQL的B+树一般情况下是<br>3~4层，根据插入的数据量决定树的深度，如果说继续优化的话，那么就要<br>根据key和子节点占用的空间决定，占用的空间越小每个磁盘块能够表示的<br>范围就越大，所以在创建索引的时候要注意 key 占用的空间，如果使用<br>varchar大于4个字节那么就用int作为索引，否则就使用varchar，key<br>越小就能存储越多的数据，注意叶子节点构成一个双向循环链表，节点<br>的度是根据key和指针的大小来计算的。key值最好能够自增，这样可以<br>避免叶子节点和非叶子节点的分裂。B+树有两种数据访问的方式，一种<br>是从根节点开始查找，另一种是从叶子节点开始顺序查找，无法使用<br>索引的时候就可以采用第二种方式</li>
</ol>
<h3 id="MyISAM和InnoDB实现BTree索引方式的区别？"><a href="#MyISAM和InnoDB实现BTree索引方式的区别？" class="headerlink" title="MyISAM和InnoDB实现BTree索引方式的区别？"></a>MyISAM和InnoDB实现BTree索引方式的区别？</h3><ol>
<li>MyISAM B+Tree叶节点的data域存放的是数据记录的地址，在索引检索<br>的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出<br>其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被<br>称为“非聚簇索引”。 索引文件和数据文件是分离的</li>
<li>InnoDB InnoDB 的 B+Tree 索引分为聚集索引和非聚集索引。一张表一<br>定包含一个聚集索引构成的B+ 树以及若干辅助索引的构成的B+ 树</li>
</ol>
<h3 id="B树和B-树的区别是什么？"><a href="#B树和B-树的区别是什么？" class="headerlink" title="B树和B+树的区别是什么？"></a>B树和B+树的区别是什么？</h3><ol>
<li>在B树中，你可以将键和值存放在内部节点和叶子节点，但在B+树中，内<br>部节点都是键没有值，叶子节点同时存放键和值</li>
<li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立</li>
<li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近<br>根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数<br>据重复多次查询的场景中更加高效</li>
<li>由于B+树的内部节点只存放键，不存放值，因此一次读取可以在内存页中<br>获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，<br>因此当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到<br>最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树<br>的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更<br>多的时间</li>
</ol>
<h3 id="Hash索引和B-树的区别是什么？"><a href="#Hash索引和B-树的区别是什么？" class="headerlink" title="Hash索引和B+树的区别是什么？"></a>Hash索引和B+树的区别是什么？</h3><ol>
<li>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取<br>到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡<br>查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得<br>所查键值，然后根据查询判断是否需要回表查询数据，从根节点到每个叶<br>子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有<br>序的</li>
<li>hash索引进行等值查询更快(前提是没有大量重复键值)，但是却无法<br>进行范围查询</li>
<li>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无<br>法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于<br>父节点，右节点大于父节点，多叉树也类似)，天然支持范围</li>
<li>hash索引不支持使用索引进行排序，原理同上</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为<br>hash函数的不可预测。AAAA和AAAAB的索引没有相关性</li>
<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(<br>聚簇索引，覆盖索引等)的时候可以只通过索引完成查询</li>
<li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个<br>键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的<br>查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高<br>度较低</li>
</ol>
<h3 id="索引的基本原理是什么？"><a href="#索引的基本原理是什么？" class="headerlink" title="索引的基本原理是什么？"></a>索引的基本原理是什么？</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行<br>查询时遍历整张表。索引的原理很简单，就是把无序的数据变成有序的查询</p>
<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h3 id="使用索引查询一定能提高查询的性能吗"><a href="#使用索引查询一定能提高查询的性能吗" class="headerlink" title="使用索引查询一定能提高查询的性能吗?"></a>使用索引查询一定能提高查询的性能吗?</h3><p>索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改<br>时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将<br>为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些<br>不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询<br>性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<ul>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h3><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用<br>字段的全部内容建立索引。前提：前缀的标识度高。比如密码就适合建立前缀<br>索引，因为密码几乎各不相同。对于BLOB、TEXT或者很长的VARCHAR类型的<br>列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度</p>
<h3 id="什么是最左前缀原则？"><a href="#什么是最左前缀原则？" class="headerlink" title="什么是最左前缀原则？"></a>什么是最左前缀原则？</h3><ol>
<li>就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最<br>频繁的一列放在最左边</li>
<li>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配<br>，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的<br>索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的<br>顺序可以任意调整。=和in可以乱序，比如a = 1 and b = 2 and c = 3 建<br>立(a,b,c)</li>
<li>索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ol>
<h3 id="数据库为什么使用B-树而不是B树？"><a href="#数据库为什么使用B-树而不是B树？" class="headerlink" title="数据库为什么使用B+树而不是B树？"></a>数据库为什么使用B+树而不是B树？</h3><ol>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索</li>
<li>B+树空间利用率更高，可减少I/O 次数，磁盘读写代价更低。一般来说，<br>索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形<br>式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O 消耗。B+树<br>的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内<br>部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存<br>中可以查找的关键字也就越多，相对的，IO 读写次数也就降低了。而IO<br>读写次数是影响索引检索效率的最大因素</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根<br>节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等<br>价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随<br>机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有<br>关键字的查找路径长度相同，导致每一个关键字的查询效率相当</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。<br>B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整<br>棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持<br>这样的操作</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并<br>以有序的链表结构存储，这样可很好提高增删效率</li>
</ol>
<h3 id="什么时候索引会失效？"><a href="#什么时候索引会失效？" class="headerlink" title="什么时候索引会失效？"></a>什么时候索引会失效？</h3><ol>
<li>对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引</li>
<li>对于使用 like 查询， 查询如果是’%aaa’或’_aaa’ 不会使用索引，而<br>‘aaa%’’会使用到索引</li>
<li>如果条件中有 or， 有条件没有使用索引，即使其中有条件带索引也不会<br>使用，换言之就是要求使用的所有字段，都必须单独使用时能使用索引</li>
<li>如果列类型是字符串，那么一定要在条件中使用引号引用起来，否则不使<br>用索引</li>
<li>如果mysql认为全表扫描要比使用索引快，则不使用索引</li>
</ol>
<h3 id="SQL注入了解吗？"><a href="#SQL注入了解吗？" class="headerlink" title="SQL注入了解吗？"></a>SQL注入了解吗？</h3><p>参考 <a href="https://www.cnblogs.com/myseries/p/10821372.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/10821372.html</a><br>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求<br>的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String sql = "<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> username=</span><br><span class="line"><span class="string">' "+userName+" '</span> <span class="keyword">and</span> <span class="keyword">password</span>=<span class="string">' "+password+" '</span><span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--当输入了上面的用户名和密码，上面的SQL语句变成：</span></span><br><span class="line"><span class="string">SELECT * FROM user_table WHERE username=</span></span><br><span class="line"><span class="string">'' or 1 = 1 -- and password='';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--分析SQL语句：</span></span><br><span class="line"><span class="string">--条件后面username=”or 1=1 用户名等于 ” 或1=1 那么这个条件一定会成功；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用，这样</span></span><br><span class="line"><span class="string">语句永远都--能正确执行，用户轻易骗过系统，获取合法身份。*/</span></span><br><span class="line"><span class="string">--这还是比较温柔的，如果是执行</span></span><br><span class="line"><span class="string">SELECT * FROM user_table WHERE</span></span><br><span class="line"><span class="string">username='' ;DROP DATABASE (DB Name) --' and password=''</span></span><br><span class="line"><span class="string">--其后果可想而知…</span></span><br></pre></td></tr></table></figure>
<h3 id="如何防止SQL注入？"><a href="#如何防止SQL注入？" class="headerlink" title="如何防止SQL注入？"></a>如何防止SQL注入？</h3><ol>
<li>检查变量数据类型和格式 只要是有固定格式的变量，在SQL语句执行前，<br>应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度<br>上可以避免SQL注入攻击</li>
<li>过滤特殊符号 对于无法确定固定格式的变量，一定要进行特殊符号过滤<br>或转义处理</li>
<li>绑定变量，使用预编译语句 预编译语句就是将这类语句中的值用占位符<br>替代，可以视为将sql语句模板化或者说参数化。预编译语句的优势在于归纳<br>为：一次编译、多次运行，省去了解析优化等过程，此外预编译语句能防止<br>sql注入。原理是采用了预编译的方法，先将SQL语句中可被客户端控制的<br>参数集进行编译，生成对应的临时变量集，再使用对应的设置方法，为临<br>时变量集里面的元素进行赋值，赋值函数setString()，会对传入的参数<br>进行强制类型检查和安全检查，所以就避免了SQL注入的产生。参数化能防<br>注入的原因在于，语句是语句，参数是参数，参数的值并不是语句的一部<br>分，数据库只按语句的语义跑</li>
</ol>
<h3 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h3><p>user，db，table_priv，columns_priv和host</p>
<ol>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全<br>局级的</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限</li>
<li>table_priv权限表：记录数据表级的操作权限</li>
<li>columns_priv权限表：记录数据列级的操作权限</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的<br>控制。这个权限表不受GRANT和REVOKE语句的影响</li>
</ol>
<h3 id="当我们输入一条SQL查询语句时，发生了什么？"><a href="#当我们输入一条SQL查询语句时，发生了什么？" class="headerlink" title="当我们输入一条SQL查询语句时，发生了什么？"></a>当我们输入一条SQL查询语句时，发生了什么？</h3><ol>
<li>客户端通过连接器连接到MySQL服务器</li>
<li>连接器通过数据库权限身份验证后会先查询数据库缓存是否存在（之前执<br>行过相同条件的SQL查询），如果有就直接返回缓存中的数据，没有的话就会<br>进入分析器。之前的执行语句很可能以key-value的形式直接缓存在内存中，<br>key是查询语句，value 是查询结果</li>
<li>进入分析器后会对查询语句进行词法语法的分析，判断该SQL语句是否存<br>在语法错误，如果存在查询语法词法错误会直接返回给客户端错误，不存在<br>的话就进入优化器</li>
<li>优化器会对查询语句进行优化处理，如果一条语句用了多个索引就会判断<br>那个索引性能最好</li>
<li>最终会进入执行器，开始执行查询语句直到查询出满足条件的所有数据</li>
</ol>
<h3 id="MySQL可以分为哪两层"><a href="#MySQL可以分为哪两层" class="headerlink" title="MySQL可以分为哪两层"></a>MySQL可以分为哪两层</h3><p>大体可以把MySQL分为Server层和存储引擎两部分</p>
<ol>
<li>存储引擎 负责数据的存储和提取，目前的版本MySQL默认使用InnoDB，创<br>建table的时候可以通过engine=memory 来指定存储引擎</li>
<li>包括连接器、分析器、查询缓存、优化器、执行器等</li>
</ol>
<h3 id="连接器的作用？"><a href="#连接器的作用？" class="headerlink" title="连接器的作用？"></a>连接器的作用？</h3><p>连接器的主要工作就是跟客户端建立连接、获取权限、维持和管理连接</p>
<h3 id="分析器的作用？"><a href="#分析器的作用？" class="headerlink" title="分析器的作用？"></a>分析器的作用？</h3><p>分析器首先进行词法分析，比如从输入的select可知这是一个查询语句，然<br>后还要识别出表名和列字段。词法分析结束后还要进行语法分析，如果不符<br>合MySQL的语法规则会提示错误</p>
<h3 id="优化器的作用？"><a href="#优化器的作用？" class="headerlink" title="优化器的作用？"></a>优化器的作用？</h3><p>优化器是在表里有多个索引的时候，决定使用哪个索引。或者在一个语句有<br>多个表关联的时候决定各个表的连接顺序</p>
<h3 id="执行器的作用？"><a href="#执行器的作用？" class="headerlink" title="执行器的作用？"></a>执行器的作用？</h3><p>开始执行的时候首先判断是否有操作这个表的权限，如果没有权限就会返回<br>没有权限的错误，如果有权限就会继续执行，根据这个表的引擎定义使用这<br>个引擎提供的接口</p>
<h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><p>事务指的是满足 ACID 特性的一组操作，要么都执行，要么都不执行，事务<br>会把数据库从一种一致性状态转换到另一种一致性状态</p>
<h3 id="事务的ACID分别是什么？"><a href="#事务的ACID分别是什么？" class="headerlink" title="事务的ACID分别是什么？"></a>事务的ACID分别是什么？</h3><ol>
<li>原子性 Atomicity 原子性是指事务是一个不可分割的工作单位，事务<br>中的操作要么全部成功，要么全部失败。事务在执行过程中出现错误时，就<br>会回滚到事务开始前的状态，好像事务从来没有执行过一样，通过回滚日<br>志实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些<br>修改操作即可</li>
<li>一致性 Consistency 事务必须使数据库从一个一致性状态变换到另外<br>一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱<br>加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的<br>钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性，一致性是<br>通过原子性、隔离性和持久性一起实现的。一致性是事务的根本追求，数据<br>库系统通过并发控制技术和日志恢复技术来避免错误情况</li>
<li>隔离性 Isolation 事务的隔离性是多个用户并发访问数据库时，数据<br>库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并<br>发事务之间要相互隔离，通过锁和mvvc实现</li>
<li>持久性 Durability 持久性是指一个事务一旦被提交，它对数据库中<br>数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任<br>何影响，系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实<br>现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数<br>据页的物理修改</li>
</ol>
<h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ol>
<li>脏读 脏读指一个事务读取了另外一个事务未提交的数据</li>
<li>不可重复读 一个事务读取数据，多次读取结果不同。与脏读的区别在<br>于脏读是读取前一事务未提交的脏数据，而不可重复读是读取前一事务<br>已提交的数据</li>
<li>幻读 一个事务读取数据，另一个事务插入新的数据，前后数据不一样，<br>幻读本质上也属于不可重复读的情况，T1读取某个范围的数据，T2在这个范<br>围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一<br>次读取的结果不同。根本原因是行锁只能锁住行，但是新插入记录这个动作<br>，要更新的是记录之间的“间隙”。<br>幻读与不可重复读的差别在于不可重复读对应的是update，可以通过可重复<br>读防止别的事务update数据，但是幻读对应的是insert操作，所以可重复<br>读无法阻止幻读，需要通过mvvc+next-key lock实现</li>
</ol>
<h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>读未提交 读已提交 可重复读 可串行话</p>
<ol>
<li>read uncommitted 事务中的修改，即使没有提交，对其它事务也是可<br>见的，没有解决脏读、不可重复读和幻读。本质是该隔离级别下非锁定读读<br>取的都是最新的行数据，并没有使用MVVC机制</li>
<li>read committed 一个事务只能读取已经提交的事务所做的修改。换句<br>话说，一个事务所做的修改在提交之前对其它事务是不可见的。解决了脏读<br>，没有解决不可重复读和幻读</li>
<li>repeatable read 保证在同一个事务中多次读取同一数据的结果是一<br>样的，解决了脏读和不可重复读，没有解决幻读</li>
<li>serializable 强制事务串行执行，这样多个事务互不干扰，不会出现<br>并发一致性问题。该隔离级别需要加锁实现，因为要使用加锁机制保证同一<br>时间只有一个事务执行，也就是保证事务串行执行，解决所有读问题</li>
</ol>
<h3 id="MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？"><a href="#MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？" class="headerlink" title="MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？"></a>MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？</h3><p>Mysql 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的<br>READ_COMMITTED隔离级别。事务隔离机制的实现基于锁机制和并发调度<br>。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧<br>版本信息来支持并发一致性读和回滚等特性。在读已提交和可重复读两<br>种隔离级别下用到了MVVC。<br>可重复读隔离级别下没有解决幻读，通过MVCC + Next-Key Locks 可以<br>解决幻读问题。MVVC解决的是普通读(快照读)的幻读，next-key locks<br>解决的是当前读情况下的幻读</p>
<h3 id="快照读和当前读的区别是什么？"><a href="#快照读和当前读的区别是什么？" class="headerlink" title="快照读和当前读的区别是什么？"></a>快照读和当前读的区别是什么？</h3><ol>
<li>快照读 像不加锁的select操作就是快照读，即不加锁的非阻塞读，快<br>照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前<br>读，之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实<br>现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但<br>它在很多情况下，避免了加锁操作，降低了开销，既然是基于多版本，即<br>快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版<br>本</li>
<li>当前读像select lock in share mode (共享锁), select for<br>update;update, insert ,delete(排他锁)这些操作都是一种当前<br>读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要<br>保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</li>
</ol>
<h3 id="什么是版本号？"><a href="#什么是版本号？" class="headerlink" title="什么是版本号？"></a>什么是版本号？</h3><ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号<br>就会自动递增</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号</li>
</ul>
<h3 id="MVVC的原理是什么？"><a href="#MVVC的原理是什么？" class="headerlink" title="MVVC的原理是什么？"></a>MVVC的原理是什么？</h3><ol>
<li>3个隐式字段</li>
<li>undo日志</li>
<li>Read View</li>
</ol>
<p>实现原理主要是依赖记录中的3个隐式字段，undo日志和 Read View 来实现<br>的，主要实现思想是通过数据多版本来做到读写分离，从而实现不加锁而做到<br>读写并行。 写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥<br>关系。在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新<br>增一个版本快照。MVCC 规定只能读取已经提交的快照</p>
<h3 id="隐式字段的作用？"><a href="#隐式字段的作用？" class="headerlink" title="隐式字段的作用？"></a>隐式字段的作用？</h3><p>三个隐藏的列分别是最近修改(修改/插入)事务ID、回滚指针和隐含的自增ID<br>（隐藏主键）</p>
<ol>
<li>事务ID 记录创建这条记录/最后一次修改该记录的事务ID</li>
<li>回滚指针 指向这条记录的上一个版本</li>
<li>如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
</ol>
<h3 id="undo日志和Read-review的作用？"><a href="#undo日志和Read-review的作用？" class="headerlink" title="undo日志和Read review的作用？"></a>undo日志和Read review的作用？</h3><ol>
<li>undo log 记录某行数据的多个版本的数据</li>
<li>read review 用来判断当前版本数据的可见性</li>
</ol>
<h3 id="undo-log的作用？"><a href="#undo-log的作用？" class="headerlink" title="undo log的作用？"></a>undo log的作用？</h3><ol>
<li>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日<br>志通过回滚指针 ROLL_PTR把一个数据行的所有快照连接起来，不同事务或<br>者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录<br>版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早<br>的旧记录</li>
</ol>
<h3 id="read-review的作用？"><a href="#read-review的作用？" class="headerlink" title="read review的作用？"></a>read review的作用？</h3><ol>
<li>Read View就是事务进行快照读操作的时候生产的读视图(Read View)，<br>在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录<br>并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这<br>个ID是递增的，所以最新的事务，ID值越大)。Read View主要是用来做可<br>见性判断的，即当我们某个事务执行快照读的时候，对该记录创建一个<br>Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本<br>的数据，既可能是当前最新的数据，也有可能是该行记录的undo log<br>里面的某个版本的数据</li>
</ol>
<p>提交读和可重复读读取的快照不一样</p>
<ul>
<li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事<br>务还未提交，则该快照不可使用。否则表示已经提交，可以使用</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读<br>到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就<br>会发生改变，也就是出现了不可重复读问题</li>
</ul>
<h3 id="RC-RR级别下的InnoDB快照读的区别是什么？"><a href="#RC-RR级别下的InnoDB快照读的区别是什么？" class="headerlink" title="RC,RR级别下的InnoDB快照读的区别是什么？"></a>RC,RR级别下的InnoDB快照读的区别是什么？</h3><ol>
<li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及<br>Read View ，将当前系统活跃的其他事务记录起来，此后在调用快照读的<br>时候，还是使用的是同一个Read View ，所以只要当前事务在其他事务提<br>交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read<br>View，所以对之后的修改不可见</li>
<li>即RR级别下，快照读生成Read View 时，Read View会记录此时所有其<br>他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于<br>Read View创建的事务所做的修改均是可见</li>
<li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read<br>View，这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</li>
</ol>
<p>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View，而在RR<br>隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快<br>照读获取的都是同一个Read View</p>
<h3 id="MVCC有哪些好处？"><a href="#MVCC有哪些好处？" class="headerlink" title="MVCC有哪些好处？"></a>MVCC有哪些好处？</h3><p>主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有<br>读写冲突时，也能做到不加锁，非阻塞并发读。解决读-写冲突的无锁并发控制<br>，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事<br>务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为<br>数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用<br>阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新<br>丢失问题</li>
</ul>
<h3 id="MySQL是如何实现事务的？"><a href="#MySQL是如何实现事务的？" class="headerlink" title="MySQL是如何实现事务的？"></a>MySQL是如何实现事务的？</h3><p>MySQL事务的ACID，一致性是最终目的。<br>保证一致性的措施有：</p>
<ul>
<li>A原子性：靠undo log来保证（异常或执行失败后进行回滚）</li>
<li>D持久性：靠redo log来保证（保证当MySQL宕机或停电后，可以通过redo<br>log 最终将数据保存至磁盘中）</li>
<li>I隔离性：事务间的读写靠MySQL的锁机制来保证隔离，事务间的写操作靠<br>MVCC机制（快照读、当前读）来保证隔离性</li>
<li>C一致性：事务的最终目的，即需要数据库层面保证，又需要应用层面进行<br>保证，并且MySQL底层通过两阶段提交事务保证了事务持久化时的一致性</li>
</ul>
<h3 id="隔离级别与锁的关系是什么？"><a href="#隔离级别与锁的关系是什么？" class="headerlink" title="隔离级别与锁的关系是什么？"></a>隔离级别与锁的关系是什么？</h3><ul>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修<br>改的数据上的排他锁冲突，会读取最新数据</li>
<li>在Read Committed级别下，读操作使用MVVC机制，读取最新的快照</li>
<li>在Repeatable Read级别下，读操作使用MVVC机制，读取事务开始时读取的<br>快照</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并<br>一直持有锁，直到事务完成</li>
</ul>
<h3 id="按照锁的粒度分数据库锁有哪些？"><a href="#按照锁的粒度分数据库锁有哪些？" class="headerlink" title="按照锁的粒度分数据库锁有哪些？"></a>按照锁的粒度分数据库锁有哪些？</h3><p>按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页<br>级锁(BDB引擎)</p>
<ol>
<li>行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作<br>的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但<br>加锁的开销也最大。行级锁分为共享锁和排他锁。<br>特点：开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最<br>低，并发度也最高</li>
<li>表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整<br>张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使<br>用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁<br>）与表独占写锁（排他锁）<br>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最<br>高，并发度最低</li>
<li>页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。<br>表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级<br>，一次锁定相邻的一组记录<br>特点：开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表<br>锁和行锁之间，并发度一般</li>
</ol>
<h3 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h3><ol>
<li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。<br>共享锁可以同时加上多个</li>
<li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。<br>排他锁只可以加一个，他和其他的排他锁，共享锁都相斥</li>
</ol>
<h3 id="行锁锁的到底是什么？"><a href="#行锁锁的到底是什么？" class="headerlink" title="行锁锁的到底是什么？"></a>行锁锁的到底是什么？</h3><p>表中有索引就索索引，否则就锁整个表。所以InnoDB的行锁就是靠锁住索引来<br>实现的</p>
<ol>
<li>如果一个表没有索引 因为没有索引所以会自动创建一个主键，查询没有使<br>用索引所以会全表扫描把每一个隐藏的聚集索引都锁住了</li>
<li>如果一个表有主键索引id，但是不通过索引来对数据进行加锁，那么锁的依<br>然是整个表</li>
<li>表有主键索引id和非主键索引name，如果操作非主键索引name，那么先<br>锁定非主键索引，然后锁定相关的主键索引。 在UPDATE、DELETE操作时，<br>MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键<br>值，即所谓的next-key locking</li>
<li>如果明确指定主键但是表中没有该值那么不会锁定任何数据，如果主键不<br>明确的话会锁表，不明确就是没有使用等于而是使用像like等</li>
</ol>
<h3 id="InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？"><a href="#InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？" class="headerlink" title="InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？"></a>InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？</h3><ol>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ol>
<p>不同的情况使用的锁也不一样</p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导<br>致幻读问题的产生有两种方式显式关闭gap锁：（除了外键约束和唯一性检查<br>外，其余情况仅使用record lock） </li>
</ol>
<ul>
<li>将事务隔离级别设置为RC </li>
<li>将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ul>
<h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><p>死锁是两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相<br>等待现象。解决死锁的方法如下</p>
<ol>
<li>最简单的方式就是设置超时时间，当两个事务相互等待时当一个事务的等<br>待时间超时其中一个事务就会回滚，另一个事务继续执行</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生<br>概率</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过<br>表级锁定来减少死锁产生的概率</li>
</ol>
<h3 id="乐观锁和悲观锁是什么？如何实现？"><a href="#乐观锁和悲观锁是什么？如何实现？" class="headerlink" title="乐观锁和悲观锁是什么？如何实现？"></a>乐观锁和悲观锁是什么？如何实现？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数<br>据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观<br>并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技<br>术手段。无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为<br>是一种思想</p>
<ol>
<li>悲观锁 这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式<br>被称之为悲观并发控制。总是假设最坏的情况，每次读取数据的时候都默认<br>其他线程会更改数据，因此需要进行加锁操作。为数据处理的安全提供了保<br>证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增<br>加产生死锁的机会。另外还会降低并行性。实现场景如下</li>
</ol>
<ul>
<li>传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等<br>，都是在做操作之前先上锁</li>
</ul>
<ol start="2">
<li>乐观锁 乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交<br>更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返<br>回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景<br>，这样可以提高程序的吞吐量</li>
</ol>
<ul>
<li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使<br>用了乐观锁的一种 CAS 实现方式</li>
<li>版本号控制：一般是在数据表中加上一个数据版本号 version字段，表示<br>数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据<br>值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读<br>取到的 version 值与当前数据库中的version值相等时才更新，否则重试<br>更新操作，直到更新成功</li>
</ul>
<h3 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h3><p>乐观锁不需要借助数据库的锁机制，主要就是冲突检测和数据更新。<br>CAS 即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制<br>，CAS 操作包含三个操作数——内存位置(V)、预期原值(A)和新值(B)。如果内<br>存位置的值(V)与预期原值(A)相匹配，那么处理器会自动将该位置值更新为<br>新值(B)。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令<br>之前返回该位置的值。CAS 有效地说明了“我认为位置(V)应该包含值(A)。<br>如果包含该值，则将新值(B)放到这个位置，否则，不要更改该位置，只<br>告诉我这个位置现在的值即可”。Java 中，sun.misc.Unsafe 类提供了<br>硬件级别的原子操作来实现这个 CAS。java.util.concurrent包下大量<br>的类都使用了这个 Unsafe.java 类的 CAS 操作</p>
<h3 id="数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句？"><a href="#数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句？" class="headerlink" title="数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句？"></a>数据库乐观锁悲观锁具体是什么，写一个典型的乐观锁SQL语句？</h3><ol>
<li>悲观锁 select…for update / select … in share mode</li>
<li>乐观锁 我们为表添加一个字段 version，读取数据时将此版本号一同<br>读出，之后更新时，对此版本号+1，同时将提交数据的version 与数据库<br>中对应记录的当前version进行比对，如果提交的数据版本号大于数据库<br>表当前版本号，则予以更新，否则认为是过期数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> <span class="keyword">num</span> = <span class="comment">#&#123;num&#125;</span></span><br><span class="line">, <span class="keyword">version</span> = <span class="keyword">version</span> + <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="comment">#&#123;version&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="binlog-redolog-undolog都是什么，起什么作用？"><a href="#binlog-redolog-undolog都是什么，起什么作用？" class="headerlink" title="binlog redolog undolog都是什么，起什么作用？"></a>binlog redolog undolog都是什么，起什么作用？</h3><ol>
<li>redo log 重做日志，用来保证事务的持久性，基本是按顺序写的。在事务<br>开始时就会产生redo log，逐步写入日志文件，归属于存储引擎</li>
<li>undo log 回滚日志，用来帮助事务回滚及MVCC功能，需要进行随机读写<br>，保存了事务发生之前的一个版本，在事务提交之后 undo log 并不会马上<br>删除，而是放入待清理的链表，purge线程判断是否由其他事务在使用undo<br>段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志<br>空间，归属于存储引擎</li>
<li>binlog 二进制日志 归属于Server层，error log 和realy log 也是<br>在Server层。记录所有与MySQL相关的日志记录，包括所有的存储引擎。用于<br>PIT POINT-IN-TIME的恢复以及主从复制环境的建立</li>
</ol>
<h3 id="二进制日志和重做日志的区别？"><a href="#二进制日志和重做日志的区别？" class="headerlink" title="二进制日志和重做日志的区别？"></a>二进制日志和重做日志的区别？</h3><ol>
<li>产生位置不同 二进制文件是在数据库的上层产生，重做日志是在InnoDB<br>存储引擎中产生，不管是什么存储引擎，对数据库进行了修改都会产生二进<br>制日志</li>
<li>内容形式不同 两种日志记录的内容形式不同，二进制日志是一种逻辑日<br>志，记录的是对应的SQL语句，关于一个事务的具体操作内容，InnoDB存储<br>引擎层面的重做日志是物理格式日志，记录的是对于每个页的修改</li>
<li>写入磁盘的时间不同 二进制日志只在事务提交完成后进行一次写入，而<br>InnoDB存储引擎的重做日志在事务进行中不断地被写入，也就是说并不是按<br>照事务提交的顺序进行写入。而且二进制日志只包含对应事务的一个日志，<br>重做日志包含每个事务的多个物理操作日志s</li>
</ol>
<h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><ol>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog 中。不需<br>要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql<br>的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一<br>些使用了函数之类的语句无法被记录复制</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记<br>录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致<br>大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多<br>，日志量太大</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用<br>statement的时候使用row</li>
</ol>
<h3 id="MySQL-如何优化？"><a href="#MySQL-如何优化？" class="headerlink" title="MySQL 如何优化？"></a>MySQL 如何优化？</h3><ol>
<li>开启查询缓存，优化查询 可以查看缓存信息</li>
<li>explain你的select查询，这可以帮你分析你的查询语句或是表结构的<br>性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你<br>的数据表是如何被搜索和排序的</li>
<li>当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据<br>后停止搜索，而不是继续往后查少下一条符合记录的数据</li>
<li>为搜索字段建索引</li>
<li>使用 ENUM 而不是 VARCHAR，有一个字段的情况</li>
<li>预编译 是一种运行在后台的SQL语句集合，可以检查一些你绑定好的变<br>量，这样可以保护你的程序不会受到“SQL注入式”攻击</li>
<li>垂直分表</li>
</ol>
<h3 id="explain的作用？"><a href="#explain的作用？" class="headerlink" title="explain的作用？"></a>explain的作用？</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain<br>结果来优化查询语句，并输出 SELECT 执行的详细信息，在 SELECT 语<br>句前加上 Explain 就可以了。能够获取的信息如下</p>
<ol>
<li>select_type 查询的类型，有简单查询、联合查询、子查询等</li>
<li>key 此次查询中确切使用到的索引</li>
<li>rows 扫描的行数</li>
<li>id是用来顺序标识整个查询中SELELCT 语句的，在嵌套查询中id越大<br>的语句越先执行。该值可能为NULL，如果这一行用来说明的是其他行的联<br>合结果</li>
</ol>
<h3 id="MySQL-的explain关键字的select-type？"><a href="#MySQL-的explain关键字的select-type？" class="headerlink" title="MySQL 的explain关键字的select_type？"></a>MySQL 的explain关键字的select_type？</h3><p>select的子句类型</p>
<ol>
<li>SIMPLE 简单select类型，不使用union和子查询的</li>
<li>PRIMARY 查询中包任何复杂的子部分的最外层查询</li>
<li>UNION union子句中的第二个或者往后的select</li>
</ol>
<h3 id="MySQL-的explain关键字的type？"><a href="#MySQL-的explain关键字的type？" class="headerlink" title="MySQL 的explain关键字的type？"></a>MySQL 的explain关键字的type？</h3><p>表示mysql在表中找到所需行的方式，优化查询的关键字段</p>
<ol>
<li>system 表只有一行数据，const的特例</li>
<li>const 表示该表只有一行匹配的数据，比如主键和唯一键的查询方式，<br>速度仅次于system</li>
<li>eq_ref 多只返回一条符合条件的记录。使用唯一性索引或主键查找时会<br>发生 </li>
<li>ref 表示所有行都匹配索引值，表中有多行记录匹配，此类索引访问只有<br>当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生</li>
<li>ALL 最坏的情况，全表扫描</li>
<li>NULL 意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到<br>访问表或索引</li>
<li>范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用<br>=、 &lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN 或者 IN 操作符，用常量比<br>较关键字列时,可以使用 range</li>
<li>index 和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。<br>如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数<br>据，它比按索引次序全表扫描的开销要小很多</li>
</ol>
<h3 id="慢查询日志的作用？"><a href="#慢查询日志的作用？" class="headerlink" title="慢查询日志的作用？"></a>慢查询日志的作用？</h3><p>某些sql语句执行完毕所花费的时间特别长，我们将这种响应比较慢的语句<br>记录在慢查询日志中，通过慢查询日志，可以查找出哪些查询语句的执行<br>效率低，以便进行优化。通过 slow_query_log[={0|1}]选项来启用慢<br>查询日志。所有执行时间超过long_query_time秒的SQL语句都会被记<br>录到慢查询日志</p>
<h3 id="MySQL查询慢如何定位？"><a href="#MySQL查询慢如何定位？" class="headerlink" title="MySQL查询慢如何定位？"></a>MySQL查询慢如何定位？</h3><ol>
<li>show variables like ‘slow_query%’; 首先查看两个参数</li>
<li>how variables like ‘long_query_time’; 查询慢查询时间</li>
<li>show status like ‘slow_queries’; 显示慢查询次数</li>
<li>set long_query_time = 1;</li>
<li>set global slow_query_log=’ON’;</li>
<li>show status like ‘slow_queries’; 查看慢查询的数量是否增加</li>
<li>select sleep(2); 执行一条慢查询 SQL 语句</li>
</ol>
<h3 id="如何优化数据访问？"><a href="#如何优化数据访问？" class="headerlink" title="如何优化数据访问？"></a>如何优化数据访问？</h3><ol>
<li>减少请求的数据量</li>
</ol>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要<br>查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的</li>
</ul>
<ol start="2">
<li>减少服务器端扫描的行数<br>最有效的方式是使用索引来覆盖查询</li>
</ol>
<h3 id="水平切分和垂直切分的区别？"><a href="#水平切分和垂直切分的区别？" class="headerlink" title="水平切分和垂直切分的区别？"></a>水平切分和垂直切分的区别？</h3><ol>
<li>水平切分 水平切分又称为 Sharding，它是将同一个表中的记录拆分到<br>多个结构相同的表中。当一个表的数据不断增多时，Sharding 是必然的选<br>择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力</li>
<li>垂直切分 垂直切分是将一张表按列切分成多个表，通常是按照列的关系<br>密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用<br>的列切分到不同的表中。在数据库的层面使用垂直切分将按数据库中表的密<br>集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据<br>库、用户数据库等</li>
</ol>
<h3 id="索引设计的原则是什么？"><a href="#索引设计的原则是什么？" class="headerlink" title="索引设计的原则是什么？"></a>索引设计的原则是什么？</h3><ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样<br>能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改<br>表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长<br>。所以只保持需要的索引有利于查询即可</li>
</ol>
<h3 id="创建索引的原则有哪些？"><a href="#创建索引的原则有哪些？" class="headerlink" title="创建索引的原则有哪些？"></a>创建索引的原则有哪些？</h3><ol>
<li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到<br>遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2and<br>c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果<br>建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</li>
<li>较频繁作为查询条件的字段才去创建索引</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列。索引的选择性是指，不重复的<br>索引值和数据表的记录总数的比值。索引的选择性越高则查询效率越高，因为<br>选择性高的索引可以让MySQL在查找时过滤掉更多的行</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)<br>的索引，那么只需要修改原来的索引即可</li>
<li>定义有外键的数据列一定要建立索引</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引</li>
</ol>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ol>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，<br>含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以<br>及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的<br>前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一<br>值越多字段的离散程度高</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次<br>IO操作获取的数据越大效率越高</li>
</ol>
<h3 id="表分区与分表的区别？"><a href="#表分区与分表的区别？" class="headerlink" title="表分区与分表的区别？"></a>表分区与分表的区别？</h3><ol>
<li>表分区 是指根据一定规则，将数据库中的一张表分解成多个更小的，容易<br>管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成</li>
<li>分表 指的是通过一定规则，将一张表分解成多张不同的表，分区从逻辑上<br>来讲只有一张表，而分表则是将一张表分解成多张表</li>
</ol>
<h3 id="表分区有什么好处？"><a href="#表分区有什么好处？" class="headerlink" title="表分区有什么好处？"></a>表分区有什么好处？</h3><ol>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备<br>，和单个磁盘或者文件系统相比，可以存储更多数据</li>
<li>优化查询 在where语句中包含分区条件时，可以只扫描一个或多个分区表<br>来提高查询效率，涉及sum和count语句时，也可以在多个分区上并行处理，<br>最后汇总结果</li>
<li>分区表更容易维护。例如：想批量删除大量数据可以清除整个分区</li>
<li>可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问</li>
</ol>
<h3 id="分区表的限制因素？"><a href="#分区表的限制因素？" class="headerlink" title="分区表的限制因素？"></a>分区表的限制因素？</h3><ol>
<li>一个表最多只能有1024个分区</li>
<li>如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列<br>都必须包含进来。即分区字段要么不包含主键或者索引列，要么包含全部主<br>键和索引列</li>
<li>分区表中无法使用外键约束</li>
<li>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对<br>索引分区，也不能只对索引分区而不对表分区，也不能只对表一部分数据分区</li>
</ol>
<h3 id="MySQL支持的分区类型有哪些？"><a href="#MySQL支持的分区类型有哪些？" class="headerlink" title="MySQL支持的分区类型有哪些？"></a>MySQL支持的分区类型有哪些？</h3><ol>
<li>RANGE分区：这种模式允许将数据划分不同范围。例如可以将一个表通过年<br>份划分成若干个分区</li>
<li>LIST分区：这种模式允许系统通过预定义的列表的值来对数据进行分割。<br>按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的</li>
<li>HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算<br>，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一<br>个对表主键进行分区的表</li>
<li>KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的</li>
</ol>
<h3 id="回表是什么意思？"><a href="#回表是什么意思？" class="headerlink" title="回表是什么意思？"></a>回表是什么意思？</h3><p>先根据普通索引查询到聚集索引的key值，然后根据key值在聚集索引中查询到<br>对应的行记录，这就是回表</p>
<h3 id="索引的优化方式有哪些？"><a href="#索引的优化方式有哪些？" class="headerlink" title="索引的优化方式有哪些？"></a>索引的优化方式有哪些？</h3><p>联合索引、最左匹配原则、覆盖索引、索引下推</p>
<h3 id="联合索引？"><a href="#联合索引？" class="headerlink" title="联合索引？"></a>联合索引？</h3><p>对查询语句中多个常用字段建立索引，尽量减少同一个表上的索引数量，减少<br>因为数据更新带来的索引更新成本，同时还可以减少因为索引所消耗的存储空<br>间。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个<br>使用，否则无法命中索引</p>
<h3 id="索引覆盖是什么？"><a href="#索引覆盖是什么？" class="headerlink" title="索引覆盖是什么？"></a>索引覆盖是什么？</h3><p>从索引的叶子节点中获取到全量查询列的过程叫做索引覆盖，不需要从聚集索引<br>中查任何数据，不需要回表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select id,name from table where name&#x3D;&#39;zhangsan&#39;</span><br><span class="line">从索引的叶子节点中获取到全量查询列的过程叫做索引覆盖</span><br><span class="line">explain的输出结果Extra字段为Using index时，能够触发索引覆盖。</span><br><span class="line">select id,name,sex ... where name&#x3D;&#39;shenjian&#39;;</span><br><span class="line">单列索升级为联合索引(name, sex)后，索引叶子节点存储了主键id，name，sex，</span><br><span class="line">都能够命中索引覆盖，无需回表。</span><br></pre></td></tr></table></figure>
<h3 id="最左匹配？"><a href="#最左匹配？" class="headerlink" title="最左匹配？"></a>最左匹配？</h3><p>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查<br>询(&gt;、&lt;、between、like)就会停止匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id name age gender id是主键，name和age是组合索引</span><br><span class="line">select * from stu where name&#x3D;&#39;ff&#39; and age&#x3D;11</span><br><span class="line">符合最左匹配原则</span><br><span class="line">select * from stu where name&#x3D;&#39;ff&#39;</span><br><span class="line">符合最左匹配原则</span><br><span class="line">select * from stu where age&#x3D;11</span><br><span class="line">不符合最左匹配原则</span><br><span class="line">select * from stu where age&#x3D;11 and name&#x3D;&#39;ff&#39;</span><br><span class="line">符合最左匹配原则，优化器会改变列的顺序，选择合适的顺序执行</span><br></pre></td></tr></table></figure>
<h3 id="索引下推？"><a href="#索引下推？" class="headerlink" title="索引下推？"></a>索引下推？</h3><ol>
<li>不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给<br>MySQL服务器，服务器然后判断数据是否符合条件</li>
<li>当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，<br>MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过<br>判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会<br>将数据检索出来返回给MySQL服务器。索引条件下推优化可以减少存储引<br>擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的<br>次数，减少回表次数</li>
</ol>
<p>这个优化技术关键的操作就是将与索引相关的条件由MySQL服务器向下传递至存<br>储引擎，由此减少IO次数。MySQL服务器到存储引擎是向下，传递的是与索引列<br>相关的查询条件。索引下推优化技术其实就是充分利用了索引中的数据，尽量在<br>查询出整行数据之前过滤掉无效的数据，只适用于二级索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM person  WHERE &#96;name&#96; &#x3D; &quot;1&quot; AND &#96;address&#96; LIKE &quot;%222&quot; </span><br><span class="line">and first_name LIKE &quot;%222&quot;;</span><br><span class="line">如果不使用索引条件下推优化的话，MySQL只能根据索引查询出name&#x3D;1的所有行，然</span><br><span class="line">后再依次比较是否符合全部条件。</span><br><span class="line">当使用了索引条件下推优化技术后，可以通过索引中存储的数据判断当前索引对应的</span><br><span class="line">数据是否符合条件，只有符合条件的数据才将整行数据查询出来。查看执行计划时发</span><br><span class="line">现extra一栏中有Using index condition信息，说明使用了索引下推。</span><br></pre></td></tr></table></figure>

<h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再<br>次进行回表查询。非聚簇索引不一定，这涉及到查询语句所要求的字段是否全部<br>命中了索引，如果全部命中了索引，那么就不必再进行回表查询</p>
<h3 id="drop、truncate和delete的区别？"><a href="#drop、truncate和delete的区别？" class="headerlink" title="drop、truncate和delete的区别？"></a>drop、truncate和delete的区别？</h3><ol>
<li>delete DELETE语句执行删除的过程是每次从表中删除一行，并且同时将<br>该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作，会保留<br>标识计数值</li>
<li>truncate TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把<br>单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过<br>程中不会激活与表有关的删除触发器。执行速度快，会恢复到默认标识计<br>数值</li>
<li>drop drop语句删除表结构及所有数据，并将表所占用的空间全部释放</li>
</ol>
<h3 id="int-20-中20的含义？"><a href="#int-20-中20的含义？" class="headerlink" title="int(20)中20的含义？"></a>int(20)中20的含义？</h3><p>int(20)的作用与int 的范围明显是无关的，int(20)只是用来显示数据的<br>宽度是20，当你输入的数据不足20位时，会自动帮你补全位数，范围固定<br>是4个字节</p>
<h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a>字段为什么要求定义为not null？</h3><p>影响优化器对索引的选择，索引效率会下降很多，因为NULL是一种比较特殊<br>的数据类型。数据库在处理的时候，需要进行特殊的处理。就会增加数据库<br>处理记录的复杂性。当表中有比较多的空字段时，在同等条件下，数据库<br>处理的性能会降低许多</p>
<h3 id="join的原理及应用？"><a href="#join的原理及应用？" class="headerlink" title="join的原理及应用？"></a>join的原理及应用？</h3><ol>
<li>left join，保留左表所有数据，左边没有数据设置为 null</li>
<li>right join，保留右表所有数据，游标没有数据设置为 null</li>
<li>inner join，取左右表数据的交集</li>
</ol>
<p>Oracle 和 MySQL 都使用了嵌套循环（Nested-Loop Join）的实现方式。<br>使用 Nested-Loop Join 算法，需要区分驱动表和被驱动表，先访问驱动表<br>，筛选出结果集，然后将这个结果集作为循环的基础，访问被驱动表过滤出需<br>要的数据</p>
<ol>
<li>SNLJ 简单嵌套循环，这里会扫描 A 表，将记录一行一行地取出来进行匹<br>配。其实就是用A 的结果集做为外循环，读取每一行都会触发一个内循环（扫<br>描B 表）。对B 表的数据进行比较，加入结果集</li>
<li>INLJ 索引嵌套循环 整个算法过程和 SNL 一致，最大的区别在于，用来<br>进行join 的字段已经在被驱动表中建立了索引。A 的行数为N，所以内循环<br>个数没变也是N，因为还是要对 N 行 A 数据进行比较。但是内循环次数被<br>优化了，之前的 SNLJ 算法，因为没有索引，每个内循环要扫码一次B表。<br>有了索引后，不需要再全表扫描 B 表，而是进行 B 表的索引查询</li>
</ol>
<h3 id="order-by原理？"><a href="#order-by原理？" class="headerlink" title="order by原理？"></a>order by原理？</h3><p>order by 有两种排序模式。全字段排序和rowid排序</p>
<ol>
<li>全字段排序 首先在sort buffer中初始化select的字段，根据where<br>条件进行过滤，然后按照order by的字段进行排序</li>
<li>rowid排序</li>
</ol>
<h3 id="建表时用了哪些索引？"><a href="#建表时用了哪些索引？" class="headerlink" title="建表时用了哪些索引？"></a>建表时用了哪些索引？</h3><ol>
<li>聚集索引</li>
<li>非聚集索引</li>
<li>惟一索引</li>
<li>复合索引</li>
</ol>
<h3 id="当数据量很大时，如何优化？"><a href="#当数据量很大时，如何优化？" class="headerlink" title="当数据量很大时，如何优化？"></a>当数据量很大时，如何优化？</h3><ol>
<li>创建索引</li>
<li>缓存的配置 由server端来维护的。它会随着你查询与修改等相应不同操<br>作进行不断更新</li>
<li>分库分表</li>
<li>子查询优化</li>
<li>加速磁盘io，使用高速固态硬盘作数据库的交换临时文件存储</li>
</ol>
<h3 id="分布式事务？"><a href="#分布式事务？" class="headerlink" title="分布式事务？"></a>分布式事务？</h3><ol>
<li>不同的是单机事务只是在单机上执行，而分布式事务则是在多台机器上执行<br>，对于分布式数据库系统，事务的一系列操作序列会被拆分为子操作序列，然<br>后在多台机器上执行</li>
<li>分布式事务同样具有ACID四个特性，但是因为分布式数据库的分布特性，使<br>其又有一些不同，也叫全局事务，被拆分为在各个机器上执行的子操作序列，<br>称为子事务</li>
<li>必须保证组成该全局事务的所有子事务要么全部提交，要么全部回滚，不允<br>许出现有些场地上的子事务提交，而有些场地上的子事务回滚。分布式事务除了<br>要保证各个子事务的ACID特性外，还需要对这些子事务进行协调，决定各个子<br>事务的提交与回滚，以保证全局事务的ACID特性。另外，在分布式事务中，还<br>涉及大量的网络通信，需要考虑到网络的影响</li>
</ol>
<h3 id="分布式事务的提交协议？"><a href="#分布式事务的提交协议？" class="headerlink" title="分布式事务的提交协议？"></a>分布式事务的提交协议？</h3><ol>
<li>全局事务的正确执行依赖各个子事务的正确执行。只有当各个局部操作都<br>正确执行后，全局事务才可以提交，当发生异常要回滚全局事务时，所有局<br>部操作也应回滚</li>
<li>用两阶段提交协议，简称2PC协议，通过引入协调者来协调参与者的行为<br>，并最终决定这些参与者是否要真正执行事务</li>
<li>协调者：协调各个子事务的执行，负责决定所有子事务的提交或回滚</li>
<li>参与者：负责各个子事务的提交与回滚，并向协调者提出子事务的提交或<br>回滚意向</li>
<li>协调者和每个参与者均拥有一个本地日志文件，用来记录各自的执行过程</li>
</ol>
<h3 id="两阶段提交协议的基本思想？"><a href="#两阶段提交协议的基本思想？" class="headerlink" title="两阶段提交协议的基本思想？"></a>两阶段提交协议的基本思想？</h3><p>两阶段提交协议是为了实现分布式事务提交而采用的协议。其基本思想是把全<br>局事务的提交分为如下两个阶段</p>
<ol>
<li>决定阶段 由协调者向各个参与者发出“预提交”（Prepare）命令，然后等<br>待应答，若所有的参与者返回“准备提交”（Ready）应答，则该事务满足提交<br>条件。如果至少有一个子事务返回“准备废弃”（Abort）应答，则该事务不能<br>提交</li>
<li>执行阶段 在事务具备提交条件的情况下，协调者向各个参与者发出“提交”<br>（Commit）命令，各个参与者执行提交；否则，协调者向各个参与者发出“废<br>弃”（Abort）命令，各个参与者执行回滚，放弃对数据库的修改</li>
</ol>
<h3 id="分布式事务的缺点？"><a href="#分布式事务的缺点？" class="headerlink" title="分布式事务的缺点？"></a>分布式事务的缺点？</h3><ol>
<li>同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等<br>待状态，无法进行其它操作</li>
<li>单点问题 在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完<br>成其它操作</li>
<li>数据不一致 在提交阶段，如果协调者只发送了部分 Commit消息，此时网<br>络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分<br>参与者提交了事务，使得系统数据不一致</li>
<li>太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制</li>
</ol>
<h3 id="分布式了解吗？"><a href="#分布式了解吗？" class="headerlink" title="分布式了解吗？"></a>分布式了解吗？</h3><p>分布式就是将一个系统的各个组件(MySQL、PHP、Apache …)分布在网络上的各<br>台主机, 并且各组件之间仅通过消息传递来通信并协调工作</p>
<h3 id="分布式系统？"><a href="#分布式系统？" class="headerlink" title="分布式系统？"></a>分布式系统？</h3><ol>
<li>单块系统 将所有的代码都放在一个工程里，可能用maven等构件工具拆分<br>一下代码工程模块，不同的模块可以放在不同的工程代码中</li>
<li>分布式系统 是一个硬件或软件组件分布在不同的网络计算机上，彼此之间<br>仅仅通过消息传递进行通信和协调的系统</li>
</ol>
<h3 id="分布式和集群的区别？"><a href="#分布式和集群的区别？" class="headerlink" title="分布式和集群的区别？"></a>分布式和集群的区别？</h3><ol>
<li>分布式（distributed）是指在多台不同的服务器中部署不同的服务模块，<br>通过远程调用协同工作，对外提供服务</li>
<li>集群（cluster）是指在多台不同的服务器中部署相同应用或服务模块，<br>构成一个集群，通过负载均衡设备对外提供服务</li>
</ol>
<h3 id="可串行化会导致死锁吗？"><a href="#可串行化会导致死锁吗？" class="headerlink" title="可串行化会导致死锁吗？"></a>可串行化会导致死锁吗？</h3><p>会，当多个事务同时持有和请求同一资源上的锁而产生循环依赖的时候就产生<br>了死锁</p>
<h3 id="hash跟b-在什么场景用？"><a href="#hash跟b-在什么场景用？" class="headerlink" title="hash跟b+在什么场景用？"></a>hash跟b+在什么场景用？</h3><ol>
<li>如果是等值查询，那么hash索引具有绝对优势</li>
<li>范围查询检索，就需要用到B+树</li>
<li>如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查<br>询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引</li>
</ol>
<h3 id="B-树有几层？"><a href="#B-树有几层？" class="headerlink" title="B+树有几层？"></a>B+树有几层？</h3><ol>
<li>1-3层，约 2 千万行数据</li>
<li>在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是 512 字节，<br>而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是 4k，而对<br>于我们的InnoDB 存储引擎也有自己的最小储存单元——页（Page），一个页<br>的大小是16K</li>
</ol>
<h3 id="分布式有了解过是吧？知道分布式事务吗？CAP？讲一下"><a href="#分布式有了解过是吧？知道分布式事务吗？CAP？讲一下" class="headerlink" title="分布式有了解过是吧？知道分布式事务吗？CAP？讲一下"></a>分布式有了解过是吧？知道分布式事务吗？CAP？讲一下</h3><ol>
<li>分区容错性、高可用性、数据一致性；</li>
<li>三者不能同时满足，一般的分布式系统都会优先满足高可用、放弃强一致性<br>选择最终一致性</li>
<li>从单应用架构的事务说起，介绍分布式事务的出现意义，目前分布式事务常<br>用的2PC、3PC都讲了一下</li>
</ol>
<h3 id="联合索引的后面的索引存放在哪？"><a href="#联合索引的后面的索引存放在哪？" class="headerlink" title="联合索引的后面的索引存放在哪？"></a>联合索引的后面的索引存放在哪？</h3><p>联合索引的所有索引列都出现在索引数上，并依次比较三列的大小</p>
<h3 id="MySQL怎么做数据容灾"><a href="#MySQL怎么做数据容灾" class="headerlink" title="MySQL怎么做数据容灾"></a>MySQL怎么做数据容灾</h3><p>双机热备的概念简单说一下，就是要保持两个数据库的状态自动同步。对任何一<br>个数据库的操作都自动应用到另外一个数据库，始终保持两个数据库数据一致</p>
<ol>
<li>可以做灾备，其中一个坏了可以切换到另一个</li>
<li>可以做负载均衡，可以将请求分摊到其中任何一台上，提高网站吞吐量</li>
</ol>
<h3 id="myisam为什么适合读多写少的情况，举个具体例子？"><a href="#myisam为什么适合读多写少的情况，举个具体例子？" class="headerlink" title="myisam为什么适合读多写少的情况，举个具体例子？"></a>myisam为什么适合读多写少的情况，举个具体例子？</h3><ol>
<li>数据块，INNODB要缓存，MYISAM只缓存索引块，这中间还有换进换出的减少</li>
<li>innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定<br>位比INNODB要快</li>
<li>INNODB还需要维护MVCC一致</li>
</ol>
<h3 id="MySQL-主从同步机制，如果同步失败会怎么样？"><a href="#MySQL-主从同步机制，如果同步失败会怎么样？" class="headerlink" title="MySQL 主从同步机制，如果同步失败会怎么样？"></a>MySQL 主从同步机制，如果同步失败会怎么样？</h3><ol>
<li>在主库那边（master）清除日志</li>
<li>重新执行</li>
</ol>
<h3 id="mysql主从复制原理？"><a href="#mysql主从复制原理？" class="headerlink" title="mysql主从复制原理？"></a>mysql主从复制原理？</h3><ol>
<li>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数<br>据库，主数据库一般是准实时的业务数据库</li>
<li>作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避<br>免数据丢失</li>
</ol>
<p>主从复制的方式有5种</p>
<ol>
<li>一主一从，基础的主从结构</li>
<li>主主复制(两个主机在同一等级上，没有主从之分)</li>
<li>一主多从，适用于增删改少，查询多的业务</li>
<li>多主一从适用于增删改较多，查询少的业务</li>
<li>联级复制</li>
</ol>
<p>实现原理</p>
<ol>
<li>数据库有个bin-log二进制文件，记录了所有sql语句</li>
<li>我们的目标就是把主数据库的bin-log文件的sql语句复制到从数据库</li>
<li>让其转为从数据库的relay-log中继日志，通过中继日志将主数据库中的<br>SQL语句同步到从数据库，保证主从数据库一致</li>
<li>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程</li>
</ol>
<ul>
<li>binlog输出线程:每当有从库连接到主库发送请求时，主库都会创建一个线<br>程然后发送binlog内容到从库<br>在从库里，当复制开始的时候，从库就会创建两个线程进行处理：</li>
<li>从库I/O 线程:当START SLAVE 语句在从库开始执行之后，从库创建一个<br>I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库<br>上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到<br>本地文件，其中包括relay log文件</li>
<li>从库的SQL 线程:从库创建一个SQL 线程，这个线程读取从库I/O 线程写到<br>relay log 的更新事件并执行</li>
</ul>
<h3 id="主从复制的优点？"><a href="#主从复制的优点？" class="headerlink" title="主从复制的优点？"></a>主从复制的优点？</h3><ol>
<li>实现服务器负载均衡 主服务器处理写操作以及实时性要求比较高的读操<br>作，而从服务器处理读操作</li>
<li>确保数据安全 在从主服务器进行备份，避免备份期间影响主服务器服务</li>
</ol>
<h3 id="每一页有多少数据？"><a href="#每一页有多少数据？" class="headerlink" title="每一页有多少数据？"></a>每一页有多少数据？</h3><ol>
<li>操作系统中 一页大小4KB</li>
<li>MySQL中 数据页大小是16KB</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">https://skysea-gaoming.github.io/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>操作系统总结</span></a></div><div class="next-post pull-right"><a href="/2020/12/31/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"><span>2020年度总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/';
  this.page.identifier = '2021/01/04/MySQL面试题/';
  this.page.title = 'MySQL总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>