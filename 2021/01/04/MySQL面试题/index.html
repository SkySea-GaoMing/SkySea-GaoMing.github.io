<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MySQL总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>MySQL总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题"><span class="toc-number">2.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL三范式是什么？"><span class="toc-number">2.1.</span> <span class="toc-text">MySQL三范式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql有关权限的表都有哪几个？"><span class="toc-number">2.2.</span> <span class="toc-text">mysql有关权限的表都有哪几个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL的binlog有有几种录入格式？分别有什么区别？"><span class="toc-number">2.3.</span> <span class="toc-text">MySQL的binlog有有几种录入格式？分别有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL有几种存储引擎，有什么区别？"><span class="toc-number">2.4.</span> <span class="toc-text">MySQL有几种存储引擎，有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM索引与InnoDB索引的区别？"><span class="toc-number">2.5.</span> <span class="toc-text">MyISAM索引与InnoDB索引的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB引擎的4大特性是什么？"><span class="toc-number">2.6.</span> <span class="toc-text">InnoDB引擎的4大特性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是索引？"><span class="toc-number">2.7.</span> <span class="toc-text">什么是索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引有哪些优缺点？"><span class="toc-number">2.8.</span> <span class="toc-text">索引有哪些优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引有哪几种类型？"><span class="toc-number">2.9.</span> <span class="toc-text">索引有哪几种类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聚集索引和非聚集索引的区别是什么？"><span class="toc-number">2.10.</span> <span class="toc-text">聚集索引和非聚集索引的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树和B树的区别，为什么Innodb用B-树"><span class="toc-number">2.11.</span> <span class="toc-text">B+树和B树的区别，为什么Innodb用B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树和B-树的区别是什么？"><span class="toc-number">2.12.</span> <span class="toc-text">B树和B+树的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash索引和B-树的区别是什么？"><span class="toc-number">2.13.</span> <span class="toc-text">Hash索引和B+树的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的基本原理是什么？"><span class="toc-number">2.14.</span> <span class="toc-text">索引的基本原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引设计的原则是什么？"><span class="toc-number">2.15.</span> <span class="toc-text">索引设计的原则是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建索引的原则有哪些？"><span class="toc-number">2.16.</span> <span class="toc-text">创建索引的原则有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建索引时需要注意什么？"><span class="toc-number">2.17.</span> <span class="toc-text">创建索引时需要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用索引查询一定能提高查询的性能吗"><span class="toc-number">2.18.</span> <span class="toc-text">使用索引查询一定能提高查询的性能吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是前缀索引？"><span class="toc-number">2.19.</span> <span class="toc-text">什么是前缀索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是最左前缀原则？"><span class="toc-number">2.20.</span> <span class="toc-text">什么是最左前缀原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回表是什么意思？"><span class="toc-number">2.21.</span> <span class="toc-text">回表是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引覆盖是什么意思？"><span class="toc-number">2.22.</span> <span class="toc-text">索引覆盖是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非聚簇索引一定会回表查询吗？"><span class="toc-number">2.23.</span> <span class="toc-text">非聚簇索引一定会回表查询吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联合索引是什么？为什么需要注意联合索引中的顺序？"><span class="toc-number">2.24.</span> <span class="toc-text">联合索引是什么？为什么需要注意联合索引中的顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库为什么使用B-树而不是B树？"><span class="toc-number">2.25.</span> <span class="toc-text">数据库为什么使用B+树而不是B树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候索引会失效？"><span class="toc-number">2.26.</span> <span class="toc-text">什么时候索引会失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL注入了解吗？"><span class="toc-number">2.27.</span> <span class="toc-text">SQL注入了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何防止SQL注入？"><span class="toc-number">2.28.</span> <span class="toc-text">如何防止SQL注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当我们输入一条SQL查询语句时，发生了什么？"><span class="toc-number">2.29.</span> <span class="toc-text">当我们输入一条SQL查询语句时，发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是数据库事务？"><span class="toc-number">2.30.</span> <span class="toc-text">什么是数据库事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务的ACID分别是什么？"><span class="toc-number">2.31.</span> <span class="toc-text">事务的ACID分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是脏读？幻读？不可重复读？"><span class="toc-number">2.32.</span> <span class="toc-text">什么是脏读？幻读？不可重复读？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><span class="toc-number">2.33.</span> <span class="toc-text">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？"><span class="toc-number">2.34.</span> <span class="toc-text">MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快照读和当前读的区别是什么？"><span class="toc-number">2.35.</span> <span class="toc-text">快照读和当前读的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是版本号？"><span class="toc-number">2.36.</span> <span class="toc-text">什么是版本号？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVC的原理是什么？"><span class="toc-number">2.37.</span> <span class="toc-text">MVVC的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log和read-review的作用"><span class="toc-number">2.38.</span> <span class="toc-text">undo log和read review的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RC-RR级别下的InnoDB快照读的区别是什么？"><span class="toc-number">2.39.</span> <span class="toc-text">RC,RR级别下的InnoDB快照读的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVC有哪些好处？"><span class="toc-number">2.40.</span> <span class="toc-text">MVVC有哪些好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL是如何实现事务的？"><span class="toc-number">2.41.</span> <span class="toc-text">MySQL是如何实现事务的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隔离级别与锁的关系是什么？"><span class="toc-number">2.42.</span> <span class="toc-text">隔离级别与锁的关系是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按照锁的粒度分数据库锁有哪些？"><span class="toc-number">2.43.</span> <span class="toc-text">按照锁的粒度分数据库锁有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从锁的类别上分MySQL都有哪些锁呢？"><span class="toc-number">2.44.</span> <span class="toc-text">从锁的类别上分MySQL都有哪些锁呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行锁锁的到底是什么？"><span class="toc-number">2.45.</span> <span class="toc-text">行锁锁的到底是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？"><span class="toc-number">2.46.</span> <span class="toc-text">InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是死锁？怎么解决？"><span class="toc-number">2.47.</span> <span class="toc-text">什么是死锁？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乐观锁和悲观锁是什么？如何实现？"><span class="toc-number">2.48.</span> <span class="toc-text">乐观锁和悲观锁是什么？如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS是什么？"><span class="toc-number">2.49.</span> <span class="toc-text">CAS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制文件、undo、redo，这些文件有什么关系"><span class="toc-number">2.50.</span> <span class="toc-text">二进制文件、undo、redo，这些文件有什么关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL如何进行性能优化？（explain、慢查询日志）"><span class="toc-number">2.51.</span> <span class="toc-text">SQL如何进行性能优化？（explain、慢查询日志）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分库分表（水平切分、垂直切分）"><span class="toc-number">2.52.</span> <span class="toc-text">分库分表（水平切分、垂直切分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL主从复制"><span class="toc-number">2.53.</span> <span class="toc-text">MySQL主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog-redolog-undolog都是什么，起什么作用"><span class="toc-number">2.54.</span> <span class="toc-text">binlog,redolog,undolog都是什么，起什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB的行锁-表锁"><span class="toc-number">2.55.</span> <span class="toc-text">InnoDB的行锁&#x2F;表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain是如何解析sql的"><span class="toc-number">2.56.</span> <span class="toc-text">explain是如何解析sql的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用mysql索引都有什么原则"><span class="toc-number">2.57.</span> <span class="toc-text">使用mysql索引都有什么原则</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">57</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">MySQL总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/04/MySQL面试题/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/williamjie/p/11081592.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/11081592.html</a><br><a href="https://blog.csdn.net/cheidou123/article/details/91442955" target="_blank" rel="noopener">https://blog.csdn.net/cheidou123/article/details/91442955</a></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="MySQL三范式是什么？"><a href="#MySQL三范式是什么？" class="headerlink" title="MySQL三范式是什么？"></a>MySQL三范式是什么？</h3><ol>
<li>第一范式 保证每列的原子性，数据库中所有表的字段值都是不可分解的原<br>子值。第一范式是对关系模型的基本要求，不满足第一范式就不是关系数据库</li>
<li>第二范式 在第一范式的基础上，非主键列完全依赖于主键，而不能是依<br>赖于主键的一部分。完全依赖是针对于属性组来说，当一组属性X能推出来Y<br>的时候就说Y完全依赖于X。一组属性X中的其中一个或几个属性能推出Y就说<br>Y部分依赖于X</li>
<li>第三范式 在第二范式的基础上，保证每列和主键都直接相关，也就是说<br>决定某些字段值的必须是主键，第二范式与第三范式的区别在于第三范式消<br>除了传递依赖</li>
</ol>
<h3 id="mysql有关权限的表都有哪几个？"><a href="#mysql有关权限的表都有哪几个？" class="headerlink" title="mysql有关权限的表都有哪几个？"></a>mysql有关权限的表都有哪几个？</h3><p>user，db，table_priv，columns_priv和host</p>
<ol>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全<br>局级的</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限</li>
<li>table_priv权限表：记录数据表级的操作权限</li>
<li>columns_priv权限表：记录数据列级的操作权限</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的<br>控制。这个权限表不受GRANT和REVOKE语句的影响</li>
</ol>
<h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><ol>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog 中。不需<br>要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql<br>的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一<br>些使用了函数之类的语句无法被记录复制</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记<br>录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致<br>大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多<br>，日志量太大</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用<br>statement的时候使用row</li>
</ol>
<h3 id="MySQL有几种存储引擎，有什么区别？"><a href="#MySQL有几种存储引擎，有什么区别？" class="headerlink" title="MySQL有几种存储引擎，有什么区别？"></a>MySQL有几种存储引擎，有什么区别？</h3><p>InnoDB MyISAM MEMROY ARCHIVE<br>存储引擎表示数据在磁盘的不同组织形式，如何实现存储数据，如何为存储的<br>数据建立索引以及如何更新，查询数据等技术实现的方法。<br>通过 show engines; 可以查看所有存储引擎</p>
<ol>
<li>InnoDB 支持事务，实现了四个标准的隔离级别，默认级别是可重复读。在可<br>重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking防止幻<br>影读。索引和数据存储在一起，表结构保存在frm文件，数据和索引保存在ibd文<br>件。对于数据的存储采用了聚集索引的方式，底层使用的是B+树。支持自适应哈<br>希索引，行锁和表锁和外键和全文索引，支持在线热备份，适合大量insert<br>delete update</li>
<li>MyISAM 不支持事务、行级锁和外键，支持全文索引，索引和数据分开存储，<br>只缓存索引文件，不缓存数据文件。表结构保存在frm文件，数据保存在MYD文件<br>，索引保存在MYI文件，适合大量select的情况，底层使用的也是B+树</li>
<li>MEMORY 存储引擎将表中的数据存储在内存中，为查询和引用其他表数据提供<br>快速访问。默认使用哈希索引，适用于存储临时数据的临时表</li>
<li>ARCHIVE 只支持insert和select操作，提供了压缩功能，拥有高效的插入<br>速度，但是这种引擎不支持索引，所以查询性能较差一些。适合存储大量独立的<br>、作为历史记录的数据</li>
</ol>
<h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ol>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查<br>询时做到覆盖索引会非常高效</li>
</ol>
<h3 id="InnoDB引擎的4大特性是什么？"><a href="#InnoDB引擎的4大特性是什么？" class="headerlink" title="InnoDB引擎的4大特性是什么？"></a>InnoDB引擎的4大特性是什么？</h3><ol>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ol>
<h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，<br>以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树</p>
<h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h3><p>优点如下</p>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ul>
<p>缺点如下</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行<br>增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率</li>
<li>空间方面：索引需要占物理空间</li>
</ul>
<h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h3><ol>
<li>普通索引：最基本的索引，没有任何约束，允许为NULL值<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (<span class="keyword">column</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(column1, column2, column3);</span><br></pre></td></tr></table></figure></li>
<li>唯一索引：与普通索引类似，但具有唯一性约束，唯一索引数据列不能重复<br>，可以提高效率，也可以防重<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (<span class="keyword">column</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column1,column2);</span><br></pre></td></tr></table></figure></li>
<li>主键索引：特殊的唯一索引，不允许有空值</li>
<li>复合索引：将多个列组合在一起创建索引，可以覆盖多个列</li>
<li>外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致<br>性、完整性和实现级联操作</li>
<li>全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且5.7<br>之前只能对英文进行全文检索，5.7之后开始支持中文,是目前搜索引擎使用<br>的一种关键技术<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> FULLTEXT (<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="聚集索引和非聚集索引的区别是什么？"><a href="#聚集索引和非聚集索引的区别是什么？" class="headerlink" title="聚集索引和非聚集索引的区别是什么？"></a>聚集索引和非聚集索引的区别是什么？</h3><ol>
<li>innodb存储引擎插入数据时必须要将数据跟某一个索引绑定在一起，这个<br>索引就是聚集索引。一个表中有多个索引列，但是数据只有一份，其他索引没有<br>与数据的值绑定在一起，这些索引就是非聚集索引。</li>
<li>innodb中存在聚集索引和非聚集索引，myisam中只有非聚集索引</li>
<li>正文内容按照一个特定维度排序存储，这个特定的维度就是聚集索引，表中<br>只能由一个，一般是表中的主键索引，如果表中没有显示指定主键，则会选择<br>表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用Innodb存<br>储引擎为每行数据内置的6字节ROWID作为聚集索引。聚集索引性能在精确查<br>找和范围查找上面效果要好</li>
<li>非聚集索引索引项顺序存储，但索引项对应的内容却是随机存储的</li>
<li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理<br>存储并不连续</li>
<li>聚集索引物理存储按照索引排序，聚集索引是一种索引组织形式，索引的键<br>值逻辑顺序决定了表数据行的物理存储顺序</li>
<li>非聚集索引物理存储不按照索引排序；非聚集索引则就是普通索引了，仅<br>仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序</li>
<li>聚集索引插入数据时速度要慢（时间花费在“物理存储的排序”上，也就是首<br>先要找到位置然后插入），查询数据比非聚集数据的速度快</li>
</ol>
<h3 id="B-树和B树的区别，为什么Innodb用B-树"><a href="#B-树和B树的区别，为什么Innodb用B-树" class="headerlink" title="B+树和B树的区别，为什么Innodb用B+树"></a>B+树和B树的区别，为什么Innodb用B+树</h3><p>使用索引就是为了减少IO操作的次数</p>
<ol>
<li>哈希索引为什么不行 必须要具备好的hash算法，如果算法不合适会导<br>致数据散列不均匀，造成很大空间的浪费，如果某些链表过长则需要顺序<br>遍历，效率太低。不支持范围查询，当进行范围查询时必须要进行挨个遍<br>历。对内存空间的要求比较高，如果是等值查询还是很快的。Memory存储<br>引擎使用哈希索引，innodb支持自适应哈希索引</li>
<li>二叉树为什么不行 二叉树本身是无序的，一般使用二分查找树BST，左<br>子树小于根节点，右子树大于根节点，这样这棵树就有序了。如果是递增插<br>入或递减插入那么这棵树就退化成一个链表，那么查询复杂度又变成O(n)<br>，所以接下来的优化应该是保证这棵树的平衡</li>
<li>平衡二叉树AVL为什么不行 AVL树最短子树和最长子树高度差不能超过1<br>，为了保证平衡在插入数据的时候必须进行旋转，通过插入性能的损失来弥<br>补查询性能的提升。如果读写请求一样多那么AVL树就不合适，优化思路就<br>是在插入情况多的时候提升性能</li>
<li>红黑树为什么不行 红黑树的最长子树只要不超过最短子树的两倍即可<br>，查询性能和插入性能近似相同。但是随着数据的插入，树的深度会变深<br>，依然会影响性能。优化思路就是减少树的深度，注意这几个树都是每个<br>节点最多两个分支，把有序二叉树变为有序多叉树，那么每个节点至少<br>要有两个记录</li>
<li>B树为什么不行 每个节点都存储key和data和子节点指针，一个节点可<br>以有多个key，所有节点组成一棵B树，假设1条记录占用1KB，一个节点占<br>用一个磁盘块的空间，那么一个节点可以有16条记录，三层的B树最多能<br>够保存4096条记录，随着深度的增大保存的数据越多，IO操作次数也会<br>越多，优化的思路依然是减少深度，B树占用的大部分空间都是因为数<br>据占用</li>
<li>B+树为什么行 B+树只有叶子节点才会存储数据，非叶子节点不存储数据<br>， 假设节点指针和key一共占用10个字节，一个磁盘块可以保存1600个范围<br>，那么到了第三层就有1600*1600*16个数据，MySQL的B+树一般情况下是<br>3~4层，根据插入的数据量决定树的深度，如果说继续优化的话，那么就要<br>根据key和子节点占用的空间决定，占用的空间越小每个磁盘块能够表示的<br>范围就越大，所以在创建索引的时候要注意 key 占用的空间，如果使用<br>varchar大于4个字节那么就用int作为索引，否则就使用varchar，key<br>越小就能存储越多的数据，注意叶子节点构成一个双向循环链表，节点<br>的度是根据key和指针的大小来计算的。key值最好能够自增，这样可以<br>避免叶子节点和非叶子节点的分裂。B+树有两种数据访问的方式，一种<br>是从根节点开始查找，另一种是从叶子节点开始顺序查找，无法使用<br>索引的时候就可以采用第二种方式</li>
</ol>
<h3 id="B树和B-树的区别是什么？"><a href="#B树和B-树的区别是什么？" class="headerlink" title="B树和B+树的区别是什么？"></a>B树和B+树的区别是什么？</h3><ol>
<li>在B树中，你可以将键和值存放在内部节点和叶子节点，但在B+树中，内<br>部节点都是键，没有值，叶子节点同时存放键和值</li>
<li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立</li>
<li>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近<br>根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数<br>据重复多次查询的场景中更加高效</li>
<li>由于B+树的内部节点只存放键，不存放值，因此一次读取可以在内存页中<br>获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，<br>因此当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到<br>最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树<br>的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更<br>多的时间</li>
</ol>
<h3 id="Hash索引和B-树的区别是什么？"><a href="#Hash索引和B-树的区别是什么？" class="headerlink" title="Hash索引和B+树的区别是什么？"></a>Hash索引和B+树的区别是什么？</h3><ol>
<li>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取<br>到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡<br>查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得<br>所查键值，然后根据查询判断是否需要回表查询数据</li>
<li>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询</li>
<li>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无<br>法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于<br>父节点，右节点大于父节点，多叉树也类似)，天然支持范围</li>
<li>hash索引不支持使用索引进行排序，原理同上</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为<br>hash函数的不可预测。AAAA和AAAAB的索引没有相关性</li>
<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(<br>聚簇索引，覆盖索引等)的时候可以只通过索引完成查询</li>
<li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个<br>键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的<br>查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高<br>度较低</li>
</ol>
<h3 id="索引的基本原理是什么？"><a href="#索引的基本原理是什么？" class="headerlink" title="索引的基本原理是什么？"></a>索引的基本原理是什么？</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行<br>查询时遍历整张表。索引的原理很简单，就是把无序的数据变成有序的查询</p>
<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h3 id="索引设计的原则是什么？"><a href="#索引设计的原则是什么？" class="headerlink" title="索引设计的原则是什么？"></a>索引设计的原则是什么？</h3><ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样<br>能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改<br>表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长<br>。所以只保持需要的索引有利于查询即可</li>
</ol>
<h3 id="创建索引的原则有哪些？"><a href="#创建索引的原则有哪些？" class="headerlink" title="创建索引的原则有哪些？"></a>创建索引的原则有哪些？</h3><ol>
<li>最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到<br>遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2and<br>c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果<br>建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</li>
<li>较频繁作为查询条件的字段才去创建索引</li>
<li>更新频繁字段不适合创建索引</li>
<li>若是不能有效区分数据的列不适合做索引列</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)<br>的索引，那么只需要修改原来的索引即可</li>
<li>定义有外键的数据列一定要建立索引</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引</li>
</ol>
<h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h3><ol>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有<br>空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算<br>更加复杂。你应该用0、一个特殊的值或者一个空串代替空值</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的<br>前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一<br>值越多字段的离散程度高</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次<br>IO操作获取的数据越大效率越高</li>
</ol>
<h3 id="使用索引查询一定能提高查询的性能吗"><a href="#使用索引查询一定能提高查询的性能吗" class="headerlink" title="使用索引查询一定能提高查询的性能吗?"></a>使用索引查询一定能提高查询的性能吗?</h3><p>索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改<br>时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将<br>为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些<br>不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询<br>性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<ul>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h3><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用<br>字段的全部内容建立索引。前提：前缀的标识度高。比如密码就适合建立前缀<br>索引，因为密码几乎各不相同</p>
<h3 id="什么是最左前缀原则？"><a href="#什么是最左前缀原则？" class="headerlink" title="什么是最左前缀原则？"></a>什么是最左前缀原则？</h3><ol>
<li>就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最<br>频繁的一列放在最左边</li>
<li>mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配<br>，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的<br>索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的<br>顺序可以任意调整。=和in可以乱序，比如a = 1 and b = 2 and c = 3 建<br>立(a,b,c)</li>
<li>索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ol>
<h3 id="回表是什么意思？"><a href="#回表是什么意思？" class="headerlink" title="回表是什么意思？"></a>回表是什么意思？</h3><p>先根据普通索引查询到聚集索引的key值，然后根据key值在聚集索引中查询到<br>对应的行记录，这就是回表</p>
<h3 id="索引覆盖是什么意思？"><a href="#索引覆盖是什么意思？" class="headerlink" title="索引覆盖是什么意思？"></a>索引覆盖是什么意思？</h3><p>从索引的叶子节点中获取到全量查询列的过程叫做索引覆盖，不需要从聚集索引<br>中查任何数据</p>
<h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h3><p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再<br>次进行回表查询。非聚簇索引不一定，这涉及到查询语句所要求的字段是否全部<br>命中了索引，如果全部命中了索引，那么就不必再进行回表查询</p>
<h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果<br>想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<h3 id="数据库为什么使用B-树而不是B树？"><a href="#数据库为什么使用B-树而不是B树？" class="headerlink" title="数据库为什么使用B+树而不是B树？"></a>数据库为什么使用B+树而不是B树？</h3><ol>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索</li>
<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引<br>本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的<br>磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没<br>有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块<br>能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越<br>多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最<br>大因素</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节<br>点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在<br>关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，<br>任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路<br>径长度相同，导致每一个关键字的查询效率相当</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+<br>树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树<br>的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的<br>操作</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并<br>以有序的链表结构存储，这样可很好提高增删效率</li>
</ol>
<h3 id="什么时候索引会失效？"><a href="#什么时候索引会失效？" class="headerlink" title="什么时候索引会失效？"></a>什么时候索引会失效？</h3><ol>
<li>对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引</li>
<li>对于使用 like 查询， 查询如果是’%aaa’或’_aaa’ 不会使用索引，而<br>‘aaa%’’会使用到索引</li>
<li>如果条件中有 or， 有条件没有使用索引，即使其中有条件带索引也不会<br>使用，换言之就是要求使用的所有字段，都必须单独使用时能使用索引</li>
<li>如果列类型是字符串，那么一定要在条件中使用引号引用起来，否则不使<br>用索引</li>
<li>如果mysql认为全表扫描要比使用索引快，则不使用索引</li>
</ol>
<h3 id="SQL注入了解吗？"><a href="#SQL注入了解吗？" class="headerlink" title="SQL注入了解吗？"></a>SQL注入了解吗？</h3><p>参考 <a href="https://www.cnblogs.com/myseries/p/10821372.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/10821372.html</a><br>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求<br>的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String sql = "<span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> username=</span><br><span class="line"><span class="string">' "+userName+" '</span> <span class="keyword">and</span> <span class="keyword">password</span>=<span class="string">' "+password+" '</span><span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--当输入了上面的用户名和密码，上面的SQL语句变成：</span></span><br><span class="line"><span class="string">SELECT * FROM user_table WHERE username=</span></span><br><span class="line"><span class="string">'' or 1 = 1 -- and password='';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--分析SQL语句：</span></span><br><span class="line"><span class="string">--条件后面username=”or 1=1 用户名等于 ” 或1=1 那么这个条件一定会成功；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用，这样</span></span><br><span class="line"><span class="string">语句永远都--能正确执行，用户轻易骗过系统，获取合法身份。*/</span></span><br><span class="line"><span class="string">--这还是比较温柔的，如果是执行</span></span><br><span class="line"><span class="string">SELECT * FROM user_table WHERE</span></span><br><span class="line"><span class="string">username='' ;DROP DATABASE (DB Name) --' and password=''</span></span><br><span class="line"><span class="string">--其后果可想而知…</span></span><br></pre></td></tr></table></figure>
<h3 id="如何防止SQL注入？"><a href="#如何防止SQL注入？" class="headerlink" title="如何防止SQL注入？"></a>如何防止SQL注入？</h3><ol>
<li>检查变量数据类型和格式 只要是有固定格式的变量，在SQL语句执行前，<br>应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度<br>上可以避免SQL注入攻击</li>
<li>过滤特殊符号 对于无法确定固定格式的变量，一定要进行特殊符号过滤<br>或转义处理</li>
<li>绑定变量，使用预编译语句　</li>
</ol>
<h3 id="当我们输入一条SQL查询语句时，发生了什么？"><a href="#当我们输入一条SQL查询语句时，发生了什么？" class="headerlink" title="当我们输入一条SQL查询语句时，发生了什么？"></a>当我们输入一条SQL查询语句时，发生了什么？</h3><h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h3><p>事务指的是满足 ACID 特性的一组操作，要么都执行，要么都不执行，事务<br>会把数据库从一种一致性状态转换到另一种一致性状态</p>
<h3 id="事务的ACID分别是什么？"><a href="#事务的ACID分别是什么？" class="headerlink" title="事务的ACID分别是什么？"></a>事务的ACID分别是什么？</h3><ol>
<li>原子性 Atomicity 原子性是指事务是一个不可分割的工作单位，事务<br>中的操作要么全部成功，要么全部失败。事务在执行过程中出现错误时，就<br>会回滚到事务开始前的状态，好像事务从来没有执行过一样，通过回滚日<br>志实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些<br>修改操作即可</li>
<li>一致性 Consistency 事务必须使数据库从一个一致性状态变换到另外<br>一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱<br>加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的<br>钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性，一致性是<br>通过原子性、隔离性和持久性一起实现的。一致性是事务的根本追求，数据<br>库系统通过并发控制技术和日志恢复技术来避免错误情况</li>
<li>隔离性 Isolation 事务的隔离性是多个用户并发访问数据库时，数据<br>库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并<br>发事务之间要相互隔离，通过锁和mvvc实现</li>
<li>持久性 Durability 持久性是指一个事务一旦被提交，它对数据库中<br>数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任<br>何影响，系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实<br>现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数<br>据页的物理修改</li>
</ol>
<h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a>什么是脏读？幻读？不可重复读？</h3><ol>
<li>脏读 脏读指一个事务读取了另外一个事务未提交的数据</li>
<li>不可重复读 一个事务读取数据，多次读取结果不同。与脏读的区别在<br>于脏读是读取前一事务未提交的脏数据，而不可重复读是读取前一事务<br>已提交的数据</li>
<li>幻读 一个事务读取数据，另一个事务插入新的数据，前后数据不一样，<br>幻读本质上也属于不可重复读的情况，T1读取某个范围的数据，T2在这个范<br>围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一<br>次读取的结果不同。根本原因是行锁只能锁住行，但是新插入记录这个动作<br>，要更新的是记录之间的“间隙”。<br>幻读与不可重复读的差别在于不可重复读对应的是update，可以通过可重复<br>读防止别的事务update数据，但是幻读对应的是insert操作，所以可重复<br>读无法阻止幻读，需要通过mvvc+next-key lock实现</li>
</ol>
<h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>读未提交 读已提交 可重复读 可串行话</p>
<ol>
<li>read uncommitted 事务中的修改，即使没有提交，对其它事务也是可<br>见的，没有解决脏读、不可重复读和幻读。本质是该隔离级别下非锁定读读<br>取的都是最新的行数据，并没有使用MVVC机制</li>
<li>read committed 一个事务只能读取已经提交的事务所做的修改。换句<br>话说，一个事务所做的修改在提交之前对其它事务是不可见的。解决了脏读<br>，没有解决不可重复读和幻读</li>
<li>repeatable read 保证在同一个事务中多次读取同一数据的结果是一<br>样的，解决了脏读和不可重复读，没有解决幻读</li>
<li>serializable 强制事务串行执行，这样多个事务互不干扰，不会出现<br>并发一致性问题。该隔离级别需要加锁实现，因为要使用加锁机制保证同一<br>时间只有一个事务执行，也就是保证事务串行执行，解决所有读问题</li>
</ol>
<h3 id="MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？"><a href="#MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？" class="headerlink" title="MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？"></a>MySQL默认使用哪种隔离级别？是否解决了幻读问题，如何解决的？</h3><p>Mysql 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的<br>READ_COMMITTED隔离级别。事务隔离机制的实现基于锁机制和并发调度<br>。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧<br>版本信息来支持并发一致性读和回滚等特性。在读已提交和可重复读两<br>种隔离级别下用到了MVVC。<br>可重复读隔离级别下没有解决幻读，通过MVCC + Next-Key Locks 可以<br>解决幻读问题。MVVC解决的是普通读(快照读)的幻读，next-key locks<br>解决的是当前读情况下的幻读</p>
<h3 id="快照读和当前读的区别是什么？"><a href="#快照读和当前读的区别是什么？" class="headerlink" title="快照读和当前读的区别是什么？"></a>快照读和当前读的区别是什么？</h3><ol>
<li>快照读 像不加锁的select操作就是快照读，即不加锁的非阻塞读，快照读<br>的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所<br>以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版<br>本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，<br>避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不<br>一定是数据的最新版本，而有可能是之前的历史版本</li>
<li>当前读像select lock in share mode(共享锁), select for update<br>;update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当<br>前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能<br>修改当前记录，会对读取的记录进行加锁</li>
</ol>
<h3 id="什么是版本号？"><a href="#什么是版本号？" class="headerlink" title="什么是版本号？"></a>什么是版本号？</h3><ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号<br>就会自动递增</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号</li>
</ul>
<h3 id="MVVC的原理是什么？"><a href="#MVVC的原理是什么？" class="headerlink" title="MVVC的原理是什么？"></a>MVVC的原理是什么？</h3><p>实现原理主要是依赖记录中的3个隐式字段，undo日志和 Read View 来实现<br>的，主要实现思想是通过数据多版本来做到读写分离，从而实现不加锁而做到<br>读写并行。 写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥<br>关系。在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新<br>增一个版本快照。MVCC 规定只能读取已经提交的快照</p>
<ul>
<li>undo log 记录某行数据的多个版本的数据</li>
<li>read review 用来判断当前版本数据的可见性</li>
</ul>
<p>三个隐藏的列分别是最近修改(修改/插入)事务ID、回滚指针和隐含的自增ID<br>（隐藏主键）</p>
<ol>
<li>事务ID 记录创建这条记录/最后一次修改该记录的事务ID</li>
<li>回滚指针 指向这条记录的上一个版本</li>
<li>如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
</ol>
<h3 id="undo-log和read-review的作用"><a href="#undo-log和read-review的作用" class="headerlink" title="undo log和read review的作用"></a>undo log和read review的作用</h3><ol>
<li>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日<br>志通过回滚指针 ROLL_PTR把一个数据行的所有快照连接起来，不同事务或<br>者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录<br>版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早<br>的旧记录</li>
<li>Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在<br>该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维<br>护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是<br>递增的，所以最新的事务，ID值越大)。<br>Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候<br>，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够<br>看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo<br>log里面的某个版本的数据</li>
</ol>
<p>提交读和可重复读读取的快照不一样</p>
<ul>
<li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事<br>务还未提交，则该快照不可使用。否则表示已经提交，可以使用</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读<br>到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就<br>会发生改变，也就是出现了不可重复读问题</li>
</ul>
<h3 id="RC-RR级别下的InnoDB快照读的区别是什么？"><a href="#RC-RR级别下的InnoDB快照读的区别是什么？" class="headerlink" title="RC,RR级别下的InnoDB快照读的区别是什么？"></a>RC,RR级别下的InnoDB快照读的区别是什么？</h3><ul>
<li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read<br>View，将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是<br>使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用<br>过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修<br>改不可见</li>
<li>即RR级别下，快照读生成Read View 时，Read View会记录此时所有其他活<br>动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View<br>创建的事务所做的修改均是可见</li>
<li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View，<br>这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</li>
</ul>
<p>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View，而在RR<br>隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快<br>照读获取的都是同一个Read View</p>
<h3 id="MVVC有哪些好处？"><a href="#MVVC有哪些好处？" class="headerlink" title="MVVC有哪些好处？"></a>MVVC有哪些好处？</h3><p>主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有<br>读写冲突时，也能做到不加锁，非阻塞并发读。解决读-写冲突的无锁并发控制<br>，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事<br>务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为<br>数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻<br>塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢<br>失问题</li>
</ul>
<h3 id="MySQL是如何实现事务的？"><a href="#MySQL是如何实现事务的？" class="headerlink" title="MySQL是如何实现事务的？"></a>MySQL是如何实现事务的？</h3><p>MySQL事务的ACID，一致性是最终目的。<br>保证一致性的措施有：</p>
<ul>
<li>A原子性：靠undo log来保证（异常或执行失败后进行回滚）</li>
<li>D持久性：靠redo log来保证（保证当MySQL宕机或停电后，可以通过redo log<br>最终将数据保存至磁盘中）</li>
<li>I隔离性：事务间的读写靠MySQL的锁机制来保证隔离，事务间的写操作靠<br>MVCC机制（快照读、当前读）来保证隔离性</li>
<li>C一致性：事务的最终目的，即需要数据库层面保证，又需要应用层面进行保<br>证，并且MySQL底层通过两阶段提交事务保证了事务持久化时的一致性</li>
</ul>
<h3 id="隔离级别与锁的关系是什么？"><a href="#隔离级别与锁的关系是什么？" class="headerlink" title="隔离级别与锁的关系是什么？"></a>隔离级别与锁的关系是什么？</h3><ul>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修<br>改的数据上的排他锁冲突，会读取最新数据</li>
<li>在Read Committed级别下，读操作使用MVVC机制，读取最新的快照</li>
<li>在Repeatable Read级别下，读操作使用MVVC机制，读取事务开始时读取的<br>快照</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并<br>一直持有锁，直到事务完成</li>
</ul>
<h3 id="按照锁的粒度分数据库锁有哪些？"><a href="#按照锁的粒度分数据库锁有哪些？" class="headerlink" title="按照锁的粒度分数据库锁有哪些？"></a>按照锁的粒度分数据库锁有哪些？</h3><p>按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页<br>级锁(BDB引擎)</p>
<ol>
<li>行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行<br>进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开<br>销也最大。行级锁分为共享锁和排他锁。<br>特点：开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，<br>并发度也最高</li>
<li>表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张<br>表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的<br>MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表<br>独占写锁（排他锁）<br>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高<br>，并发度最低</li>
<li>页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表<br>级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次<br>锁定相邻的一组记录<br>特点：开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁<br>和行锁之间，并发度一般</li>
</ol>
<h3 id="从锁的类别上分MySQL都有哪些锁呢？"><a href="#从锁的类别上分MySQL都有哪些锁呢？" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？"></a>从锁的类别上分MySQL都有哪些锁呢？</h3><ol>
<li>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。<br>共享锁可以同时加上多个</li>
<li>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。<br>排他锁只可以加一个，他和其他的排他锁，共享锁都相斥</li>
</ol>
<h3 id="行锁锁的到底是什么？"><a href="#行锁锁的到底是什么？" class="headerlink" title="行锁锁的到底是什么？"></a>行锁锁的到底是什么？</h3><p>表中有索引就索索引，否则就锁整个表。所以InnoDB的行锁就是靠锁住索引来<br>实现的</p>
<ol>
<li>如果一个表没有索引 因为没有索引所以会自动创建一个主键，查询没有使<br>用索引所以会全表扫描把每一个隐藏的聚集索引都锁住了</li>
<li>如果一个表有主键索引id，但是不通过索引来对数据进行加锁，那么锁的依<br>然是整个表</li>
<li>表有主键索引id和非主键索引name，如果操作非主键索引name，那么先锁<br>定非主键索引，然后锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL<br>不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓<br>的next-key locking</li>
<li>如果明确指定主键但是表中没有该值那么不会锁定任何数据，如果主键不<br>明确的话会锁表，不明确就是没有使用等于而是使用像like等</li>
</ol>
<h3 id="InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？"><a href="#InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？" class="headerlink" title="InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？"></a>InnoDB存储引擎的锁的算法有哪些？应用场景有哪些？</h3><ol>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ol>
<p>不同的情况使用的锁也不一样</p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导<br>致幻读问题的产生有两种方式显式关闭gap锁：（除了外键约束和唯一性检查<br>外，其余情况仅使用record lock） </li>
</ol>
<ul>
<li>将事务隔离级别设置为RC </li>
<li>将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ul>
<h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a>什么是死锁？怎么解决？</h3><p>死锁是两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相<br>等待现象。解决死锁的方法如下</p>
<ol>
<li>最简单的方式就是设置超时时间，当两个事务相互等待时当一个事务的等<br>待时间超时其中一个事务就会回滚，另一个事务继续执行</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生<br>概率</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过<br>表级锁定来减少死锁产生的概率</li>
</ol>
<h3 id="乐观锁和悲观锁是什么？如何实现？"><a href="#乐观锁和悲观锁是什么？如何实现？" class="headerlink" title="乐观锁和悲观锁是什么？如何实现？"></a>乐观锁和悲观锁是什么？如何实现？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数<br>据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观<br>并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技<br>术手段。无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为<br>是一种思想</p>
<ol>
<li>悲观锁 这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式<br>被称之为悲观并发控制。总是假设最坏的情况，每次读取数据的时候都默认<br>其他线程会更改数据，因此需要进行加锁操作。为数据处理的安全提供了保<br>证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增<br>加产生死锁的机会。另外还会降低并行性。实现场景如下</li>
</ol>
<ul>
<li>传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等<br>，都是在做操作之前先上锁</li>
<li>Java 里面的同步synchronized关键字的实现</li>
</ul>
<ol start="2">
<li>乐观锁 乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交<br>更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返<br>回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景<br>，这样可以提高程序的吞吐量</li>
</ol>
<ul>
<li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使<br>用了乐观锁的一种 CAS 实现方式</li>
<li>版本号控制：一般是在数据表中加上一个数据版本号 version字段，表示<br>数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据<br>值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读<br>取到的 version 值与当前数据库中的version值相等时才更新，否则重试<br>更新操作，直到更新成功</li>
</ul>
<h3 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h3><p>乐观锁不需要借助数据库的锁机制，主要就是冲突检测和数据更新。<br>CAS 即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制<br>，CAS 操作包含三个操作数——内存位置(V)、预期原值(A)和新值(B)。如果内<br>存位置的值(V)与预期原值(A)相匹配，那么处理器会自动将该位置值更新为<br>新值(B)。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令<br>之前返回该位置的值。CAS 有效地说明了“我认为位置(V)应该包含值(A)。<br>如果包含该值，则将新值(B)放到这个位置，否则，不要更改该位置，只<br>告诉我这个位置现在的值即可”。Java 中，sun.misc.Unsafe 类提供了<br>硬件级别的原子操作来实现这个 CAS。java.util.concurrent包下大量<br>的类都使用了这个 Unsafe.java 类的 CAS 操作</p>
<h3 id="二进制文件、undo、redo，这些文件有什么关系"><a href="#二进制文件、undo、redo，这些文件有什么关系" class="headerlink" title="二进制文件、undo、redo，这些文件有什么关系"></a>二进制文件、undo、redo，这些文件有什么关系</h3><p>首先，范围不同。二进制文件记录所有与MySQL相关的日志记录，包括InnoDB，<br>MyISAM，Heap等存储引擎的日志。而InnoDB的重做日志只记录InnoDB相关的事<br>务日志。其次，内容不同。二进制文件记录的是关于一个事务的具体操作内容，<br>而InnoDB的重做日志记录每个数据页（page）更改的物理情况。写入的时间不<br>同。二进制文件在事务提交之前记录，在事务进行过程中，不断有重做日志条<br>目写入重做日志文件中</p>
<h3 id="SQL如何进行性能优化？（explain、慢查询日志）"><a href="#SQL如何进行性能优化？（explain、慢查询日志）" class="headerlink" title="SQL如何进行性能优化？（explain、慢查询日志）"></a>SQL如何进行性能优化？（explain、慢查询日志）</h3><h3 id="分库分表（水平切分、垂直切分）"><a href="#分库分表（水平切分、垂直切分）" class="headerlink" title="分库分表（水平切分、垂直切分）"></a>分库分表（水平切分、垂直切分）</h3><h3 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h3><p>主从复制（也称 AB 复制）允许将来自一个MySQL数据库服务器（主服务器）的数据<br>复制到一个或多个MySQL数据库服务器（从服务器）</p>
<h3 id="binlog-redolog-undolog都是什么，起什么作用"><a href="#binlog-redolog-undolog都是什么，起什么作用" class="headerlink" title="binlog,redolog,undolog都是什么，起什么作用"></a>binlog,redolog,undolog都是什么，起什么作用</h3><h3 id="InnoDB的行锁-表锁"><a href="#InnoDB的行锁-表锁" class="headerlink" title="InnoDB的行锁/表锁"></a>InnoDB的行锁/表锁</h3><p>参考 <a href="https://www.hollischuang.com/archives/914" target="_blank" rel="noopener">https://www.hollischuang.com/archives/914</a><br>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁<br>能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共<br>享锁和排他锁。特点开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概<br>率最低，并发度也最高。<br>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单<br>，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级<br>锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点开销小，<br>加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。<br>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突<br>多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支<br>持页级锁。特点开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表<br>锁和行锁之间，并发度一般</p>
<h3 id="explain是如何解析sql的"><a href="#explain是如何解析sql的" class="headerlink" title="explain是如何解析sql的"></a>explain是如何解析sql的</h3><h3 id="使用mysql索引都有什么原则"><a href="#使用mysql索引都有什么原则" class="headerlink" title="使用mysql索引都有什么原则"></a>使用mysql索引都有什么原则</h3><p>回表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name&#x3D;&#39;zhangsan&#39;</span><br><span class="line">从某一个索引的叶子节点获取聚集索引id的值，然后根据id在聚集索引中获取</span><br><span class="line">整行数据</span><br></pre></td></tr></table></figure>
<p>索引覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name from table where name&#x3D;&#39;zhangsan&#39;</span><br><span class="line">从索引的叶子节点中获取到全量查询列的过程叫做索引覆盖</span><br></pre></td></tr></table></figure>
<p>最左匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id name age gender id是主键，name和age是组合索引</span><br><span class="line">select * from stu where name&#x3D;&#39;ff&#39; and age&#x3D;11</span><br><span class="line">符合最左匹配原则</span><br><span class="line">select * from stu where name&#x3D;&#39;ff&#39;</span><br><span class="line">符合最左匹配原则</span><br><span class="line">select * from stu where age&#x3D;11</span><br><span class="line">不符合最左匹配原则</span><br><span class="line">select * from stu where age&#x3D;11 and name&#x3D;&#39;ff&#39;</span><br><span class="line">符合最左匹配原则，优化器会改变列的顺序，选择合适的顺序执行</span><br></pre></td></tr></table></figure>
<p>索引下推<br>MySQL可以分为三层架构，第一层架构是client，第二层架构是server<br>，第三层是存储引擎。client 就是可视化的一些工具，server 是程序<br>开始运行后所提供的服务，数据是放在存储引擎中。所以会涉及server<br>与磁盘之间的交互</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where name&#x3D;&#39;ff&#39; and age&#x3D;11</span><br><span class="line">没有索引下推之前先根据name从存储引擎中获取符合规则的数据，</span><br><span class="line">然后在server层对age进行过滤。</span><br><span class="line">有索引下推之后根据name,age两个条件从存储引擎获取对应的数据，</span><br><span class="line">也就是说原来需要在server层进行的操作全部放到存储引擎中完成，</span><br><span class="line">减少了server层和存储引擎层的交互量，这样可以提高性能</span><br></pre></td></tr></table></figure>


</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">https://skysea-gaoming.github.io/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>操作系统总结</span></a></div><div class="next-post pull-right"><a href="/2020/12/31/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"><span>2020年度总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/';
  this.page.identifier = '2021/01/04/MySQL面试题/';
  this.page.title = 'MySQL总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>