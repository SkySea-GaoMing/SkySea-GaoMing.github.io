<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="操作系统总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>操作系统总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题"><span class="toc-number">2.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux常用命令"><span class="toc-number">2.1.</span> <span class="toc-text">Linux常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ls"><span class="toc-number">2.1.1.</span> <span class="toc-text">ls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cat"><span class="toc-number">2.1.2.</span> <span class="toc-text">cat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wc"><span class="toc-number">2.1.3.</span> <span class="toc-text">wc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#more"><span class="toc-number">2.1.4.</span> <span class="toc-text">more</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#less"><span class="toc-number">2.1.5.</span> <span class="toc-text">less</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cd"><span class="toc-number">2.1.6.</span> <span class="toc-text">cd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top"><span class="toc-number">2.1.7.</span> <span class="toc-text">top</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cp"><span class="toc-number">2.1.8.</span> <span class="toc-text">cp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mv"><span class="toc-number">2.1.9.</span> <span class="toc-text">mv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rm"><span class="toc-number">2.1.10.</span> <span class="toc-text">rm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwd"><span class="toc-number">2.1.11.</span> <span class="toc-text">pwd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mkdir"><span class="toc-number">2.1.12.</span> <span class="toc-text">mkdir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps"><span class="toc-number">2.1.13.</span> <span class="toc-text">ps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kill"><span class="toc-number">2.1.14.</span> <span class="toc-text">kill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chmod"><span class="toc-number">2.1.15.</span> <span class="toc-text">chmod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grep"><span class="toc-number">2.1.16.</span> <span class="toc-text">grep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync"><span class="toc-number">2.1.17.</span> <span class="toc-text">sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed"><span class="toc-number">2.1.18.</span> <span class="toc-text">sed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk"><span class="toc-number">2.1.19.</span> <span class="toc-text">awk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-number">2.1.20.</span> <span class="toc-text">find</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file"><span class="toc-number">2.2.</span> <span class="toc-text">file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tar"><span class="toc-number">2.3.</span> <span class="toc-text">tar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc"><span class="toc-number">2.4.</span> <span class="toc-text">gcc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time"><span class="toc-number">2.5.</span> <span class="toc-text">time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发和并行的区别？"><span class="toc-number">2.6.</span> <span class="toc-text">并发和并行的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分时系统和实时系统有什么区别？"><span class="toc-number">2.7.</span> <span class="toc-text">分时系统和实时系统有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是进程？"><span class="toc-number">2.8.</span> <span class="toc-text">什么是进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程状态如何切换？"><span class="toc-number">2.9.</span> <span class="toc-text">进程状态如何切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护进程是什么？"><span class="toc-number">2.10.</span> <span class="toc-text">守护进程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何创建守护进程？"><span class="toc-number">2.11.</span> <span class="toc-text">如何创建守护进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#孤儿进程是什么？"><span class="toc-number">2.12.</span> <span class="toc-text">孤儿进程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#僵尸进程是什么？"><span class="toc-number">2.13.</span> <span class="toc-text">僵尸进程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程描述符是什么？"><span class="toc-number">2.14.</span> <span class="toc-text">进程描述符是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#僵尸进程的危害？"><span class="toc-number">2.15.</span> <span class="toc-text">僵尸进程的危害？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么子进程不直接结束？"><span class="toc-number">2.16.</span> <span class="toc-text">为什么子进程不直接结束？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决僵尸进程？"><span class="toc-number">2.17.</span> <span class="toc-text">如何解决僵尸进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是进程组ID？"><span class="toc-number">2.18.</span> <span class="toc-text">什么是进程组ID？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特级权是什么意思？"><span class="toc-number">2.19.</span> <span class="toc-text">特级权是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态和内核态的区别？"><span class="toc-number">2.20.</span> <span class="toc-text">用户态和内核态的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要区分内核态和用户态？"><span class="toc-number">2.21.</span> <span class="toc-text">为什么要区分内核态和用户态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态和内核态的区别？-1"><span class="toc-number">2.22.</span> <span class="toc-text">用户态和内核态的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态进入内核态的方式有哪些？"><span class="toc-number">2.23.</span> <span class="toc-text">用户态进入内核态的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程？"><span class="toc-number">2.24.</span> <span class="toc-text">什么是线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程有哪两种？"><span class="toc-number">2.25.</span> <span class="toc-text">线程有哪两种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界资源是什么？"><span class="toc-number">2.26.</span> <span class="toc-text">临界资源是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区是什么？"><span class="toc-number">2.27.</span> <span class="toc-text">临界区是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享是什么？"><span class="toc-number">2.28.</span> <span class="toc-text">共享是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量是什么？"><span class="toc-number">2.29.</span> <span class="toc-text">信号量是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AND信号量是什么？"><span class="toc-number">2.30.</span> <span class="toc-text">AND信号量是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一般信号量是什么？"><span class="toc-number">2.31.</span> <span class="toc-text">一般信号量是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞和非阻塞区别？"><span class="toc-number">2.32.</span> <span class="toc-text">阻塞和非阻塞区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步的区别？"><span class="toc-number">2.33.</span> <span class="toc-text">同步和异步的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宏内核和微内核的区别？"><span class="toc-number">2.34.</span> <span class="toc-text">宏内核和微内核的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux内核？"><span class="toc-number">2.35.</span> <span class="toc-text">Linux内核？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程的区别"><span class="toc-number">2.36.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程之间共享和私有的资源？"><span class="toc-number">2.37.</span> <span class="toc-text">进程之间共享和私有的资源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程之间共享和私有的资源？"><span class="toc-number">2.38.</span> <span class="toc-text">线程之间共享和私有的资源？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候适合用多线程和多进程？"><span class="toc-number">2.39.</span> <span class="toc-text">什么时候适合用多线程和多进程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作业和管程是什么？"><span class="toc-number">2.40.</span> <span class="toc-text">作业和管程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程调度策略有哪几种？"><span class="toc-number">2.41.</span> <span class="toc-text">进程调度策略有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抢占式和非抢占式的区别？"><span class="toc-number">2.42.</span> <span class="toc-text">抢占式和非抢占式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU上下文是什么？"><span class="toc-number">2.43.</span> <span class="toc-text">CPU上下文是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU上下文切换？"><span class="toc-number">2.44.</span> <span class="toc-text">CPU上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程上下文切换？"><span class="toc-number">2.45.</span> <span class="toc-text">进程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程上下文切换？"><span class="toc-number">2.46.</span> <span class="toc-text">线程上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断上下文切换？"><span class="toc-number">2.47.</span> <span class="toc-text">中断上下文切换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么线程切换会有消耗，消耗啥？"><span class="toc-number">2.48.</span> <span class="toc-text">为什么线程切换会有消耗，消耗啥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何查看上下文切换情况？"><span class="toc-number">2.49.</span> <span class="toc-text">如何查看上下文切换情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步、互斥和通信的区别？"><span class="toc-number">2.50.</span> <span class="toc-text">进程同步、互斥和通信的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界资源和临界区的区别？"><span class="toc-number">2.51.</span> <span class="toc-text">临界资源和临界区的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态链接和动态链接的区别？"><span class="toc-number">2.52.</span> <span class="toc-text">静态链接和动态链接的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译有哪些阶段？"><span class="toc-number">2.53.</span> <span class="toc-text">编译有哪些阶段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"><span class="toc-number">2.54.</span> <span class="toc-text">进程间通信方式（六种方式，各自的概念，区别都要搞清楚）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管道、消息队列、共享内存它们三者哪个开销最小？"><span class="toc-number">2.55.</span> <span class="toc-text">管道、消息队列、共享内存它们三者哪个开销最小？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号与信号量的区别？"><span class="toc-number">2.56.</span> <span class="toc-text">信号与信号量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程同步的方式"><span class="toc-number">2.57.</span> <span class="toc-text">进程同步的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步的方式？"><span class="toc-number">2.58.</span> <span class="toc-text">线程同步的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁是什么？"><span class="toc-number">2.59.</span> <span class="toc-text">死锁是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁产生的必要条件？"><span class="toc-number">2.60.</span> <span class="toc-text">死锁产生的必要条件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决死锁？"><span class="toc-number">2.61.</span> <span class="toc-text">如何解决死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是鸵鸟策略？"><span class="toc-number">2.62.</span> <span class="toc-text">什么是鸵鸟策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何预防死锁？"><span class="toc-number">2.63.</span> <span class="toc-text">如何预防死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何避免死锁？"><span class="toc-number">2.64.</span> <span class="toc-text">如何避免死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何死锁检测与恢复？"><span class="toc-number">2.65.</span> <span class="toc-text">如何死锁检测与恢复？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址空间是什么？"><span class="toc-number">2.66.</span> <span class="toc-text">地址空间是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是虚拟内存？"><span class="toc-number">2.67.</span> <span class="toc-text">什么是虚拟内存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是分页系统"><span class="toc-number">2.68.</span> <span class="toc-text">什么是分页系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页是什么？"><span class="toc-number">2.69.</span> <span class="toc-text">分页是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是页表？"><span class="toc-number">2.70.</span> <span class="toc-text">什么是页表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页表项的结构是什么样的？"><span class="toc-number">2.71.</span> <span class="toc-text">页表项的结构是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加速分页过程是怎样的？"><span class="toc-number">2.72.</span> <span class="toc-text">加速分页过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页面置换算法"><span class="toc-number">2.73.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分页和分段有什么区别？"><span class="toc-number">2.74.</span> <span class="toc-text">分页和分段有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部性原理？"><span class="toc-number">2.75.</span> <span class="toc-text">局部性原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件描述符是什么？"><span class="toc-number">2.76.</span> <span class="toc-text">文件描述符是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-是什么？"><span class="toc-number">2.77.</span> <span class="toc-text">Socket 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O模型中的输入操作？"><span class="toc-number">2.78.</span> <span class="toc-text">I&#x2F;O模型中的输入操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O模型分为几种？"><span class="toc-number">2.79.</span> <span class="toc-text">I&#x2F;O模型分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式I-O-是什么？"><span class="toc-number">2.80.</span> <span class="toc-text">阻塞式I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞式I-O-是什么？"><span class="toc-number">2.81.</span> <span class="toc-text">非阻塞式I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-多路复用？"><span class="toc-number">2.82.</span> <span class="toc-text">I&#x2F;O 多路复用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-是什么？"><span class="toc-number">2.83.</span> <span class="toc-text">select 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll-是什么？"><span class="toc-number">2.84.</span> <span class="toc-text">poll 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-是什么？"><span class="toc-number">2.85.</span> <span class="toc-text">epoll 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select和poll的区别？"><span class="toc-number">2.86.</span> <span class="toc-text">select和poll的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recvfrom-是什么？"><span class="toc-number">2.87.</span> <span class="toc-text">recvfrom 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Epoll和Poll和Select？"><span class="toc-number">2.88.</span> <span class="toc-text">Epoll和Poll和Select？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式I-O和I-O复用的区别？"><span class="toc-number">2.89.</span> <span class="toc-text">阻塞式I&#x2F;O和I&#x2F;O复用的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号驱动I-O-是什么？"><span class="toc-number">2.90.</span> <span class="toc-text">信号驱动I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步I-O-是什么？"><span class="toc-number">2.91.</span> <span class="toc-text">异步I&#x2F;O 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步是什么？"><span class="toc-number">2.92.</span> <span class="toc-text">异步是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步的异步的区别？"><span class="toc-number">2.93.</span> <span class="toc-text">同步的异步的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO分为哪几种？"><span class="toc-number">2.94.</span> <span class="toc-text">Java IO分为哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-是什么？"><span class="toc-number">2.95.</span> <span class="toc-text">BIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-是什么？"><span class="toc-number">2.96.</span> <span class="toc-text">NIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-和IO-多路复用的关系？"><span class="toc-number">2.97.</span> <span class="toc-text">NIO 和IO 多路复用的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO-是什么？"><span class="toc-number">2.98.</span> <span class="toc-text">AIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程是什么？"><span class="toc-number">2.99.</span> <span class="toc-text">协程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么是轻量级的线程？"><span class="toc-number">2.100.</span> <span class="toc-text">为什么是轻量级的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程和线程的区别？"><span class="toc-number">2.101.</span> <span class="toc-text">协程和线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux下如何查看tcp连接？"><span class="toc-number">2.102.</span> <span class="toc-text">Linux下如何查看tcp连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络监听需要什么函数？"><span class="toc-number">2.103.</span> <span class="toc-text">网络监听需要什么函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁和信号量的区别？"><span class="toc-number">2.104.</span> <span class="toc-text">互斥锁和信号量的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁与自旋锁的区别？"><span class="toc-number">2.105.</span> <span class="toc-text">互斥锁与自旋锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"><span class="toc-number">2.106.</span> <span class="toc-text">sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘坏掉了，操作系统是怎么处理应对的？"><span class="toc-number">2.107.</span> <span class="toc-text">磁盘坏掉了，操作系统是怎么处理应对的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存？"><span class="toc-number">2.108.</span> <span class="toc-text">缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的内存空间分布？"><span class="toc-number">2.109.</span> <span class="toc-text">进程的内存空间分布？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是中断？"><span class="toc-number">2.110.</span> <span class="toc-text">什么是中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU在中断时会干嘛？"><span class="toc-number">2.111.</span> <span class="toc-text">CPU在中断时会干嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断分为几种？"><span class="toc-number">2.112.</span> <span class="toc-text">中断分为几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何处理中断？"><span class="toc-number">2.113.</span> <span class="toc-text">如何处理中断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断程序处理过程？"><span class="toc-number">2.114.</span> <span class="toc-text">中断程序处理过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要内核态-用户态？"><span class="toc-number">2.115.</span> <span class="toc-text">为什么要内核态&#x2F;用户态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用的那三种方式有什么区别？"><span class="toc-number">2.116.</span> <span class="toc-text">多路复用的那三种方式有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fd是什么？"><span class="toc-number">2.117.</span> <span class="toc-text">fd是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多路复用怎么解决阻塞IO-存在的问题？"><span class="toc-number">2.118.</span> <span class="toc-text">多路复用怎么解决阻塞IO 存在的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看内存的命令？"><span class="toc-number">2.119.</span> <span class="toc-text">查看内存的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查看日志的命令？"><span class="toc-number">2.120.</span> <span class="toc-text">查看日志的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-查看文件中是否存在某字符"><span class="toc-number">2.121.</span> <span class="toc-text">Linux 查看文件中是否存在某字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux如何分割文件字符串？"><span class="toc-number">2.122.</span> <span class="toc-text">linux如何分割文件字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的消息队列以及区别？"><span class="toc-number">2.123.</span> <span class="toc-text">常用的消息队列以及区别？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">61</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">操作系统总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/04/操作系统总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《现代操作系统》</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><p>命令的格式一般为 command [-options] param1 param2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls cat wc more less cd top cp mv rm pwd mkdir ps kill chmod grep sync</span><br><span class="line">sed awk</span><br></pre></td></tr></table></figure>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>显示文件的文件名与相关属性，选项-al表示列出所有文件的详细权限与属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">ls -al</span><br></pre></td></tr></table></figure>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>查看文本文件的内容，后接要查看的文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 1.txt</span><br></pre></td></tr></table></figure>
<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>统计指定文件的字节数，字数，行数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wc -c 1.txt #字节数</span><br><span class="line">wc -l 1.txt #行数</span><br><span class="line">wc -m 1.txt #字符数</span><br><span class="line">wc -w 1.txt #统计字数，一个字被定义为由空白、调格或换行字符分割的字符串</span><br><span class="line">wc -L 1.txt #打印最长行的长度</span><br><span class="line">以上打印在打印数字的同时也会打印文件名</span><br><span class="line">以下命令只会打印数字</span><br><span class="line">cat 1.txt |wc -l</span><br><span class="line">ls |wc -w #当前目录下的文件数</span><br></pre></td></tr></table></figure>
<h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>与cat类似，将整个文件的内容由上到下显示到屏幕上，会一页一页的显示，<br>按空格下显示下一页，按b显示上一页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more 1.txt</span><br></pre></td></tr></table></figure>
<h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less也是显示文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 1.txt</span><br></pre></td></tr></table></figure>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>切换目录，可以是绝对路径或相对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F; #进入系统根目录</span><br><span class="line">cd .. #退回到前一个目录</span><br></pre></td></tr></table></figure>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top是Linux常用的性能分析工具，能够实时显示系统中各个进程的资源占用<br>情况，类似于Windows的任务管理器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top #显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</span><br></pre></td></tr></table></figure>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a ：将文件的特性一起复制</span><br><span class="line">cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2</span><br><span class="line">cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中</span><br></pre></td></tr></table></figure>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>该命令用于移动文件、目录或更名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”</span><br><span class="line">mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中</span><br><span class="line">mv file1 file2 # 把文件file1重命名为file2</span><br></pre></td></tr></table></figure>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除文件或目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</span><br><span class="line">rm -i file # 删除文件file，在删除之前会询问是否进行该操作</span><br><span class="line">rm -fr dir # 强制删除目录dir中的所有文件</span><br></pre></td></tr></table></figure>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>显示当前目录的完整路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>建立一个新目录，要求创建目录的用户在当前目录中具有写权限，并且指<br>定的目录名不能是当前目录中已有的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir gg</span><br></pre></td></tr></table></figure>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>该命令用于将某个时间点的进程运行情况选取下来并输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-A ：所有的进程均显示出来</span><br><span class="line">-a ：不与terminal有关的所有进程</span><br><span class="line">-u ：有效用户的相关进程</span><br><span class="line">-x ：一般与a参数一起使用，可列出较完整的信息</span><br><span class="line">-l ：较长，较详细地将PID的信息列出</span><br><span class="line"></span><br><span class="line">ps aux # 查看系统所有的进程数据</span><br><span class="line">ps ax # 查看不与terminal有关的所有进程</span><br><span class="line">ps -lA # 查看系统所有的进程数据</span><br><span class="line">ps axjf # 查看连同一部分进程树状态</span><br></pre></td></tr></table></figure>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>终止一个指定的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 4395 #终止进程号为4395的进程</span><br></pre></td></tr></table></figure>
<h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>修改文件权限，在Linux中每一个文件都具有用户，所属群组及其他人三种身份<br>的个别权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 1.txt # r4 w2 x1</span><br></pre></td></tr></table></figure>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出<br>来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grep [-acinv] [--color&#x3D;auto] &#39;查找字符串&#39; filename</span><br><span class="line">-a ：将binary文件以text文件的方式查找数据</span><br><span class="line">-c ：计算找到‘查找字符串’的次数</span><br><span class="line">-i ：忽略大小写的区别，即把大小写视为相同</span><br><span class="line">-v ：反向选择，即显示出没有‘查找字符串’内容的那一行</span><br><span class="line"># 取出文件&#x2F;etc&#x2F;man.config中包含MANPATH的行，并把找到的关键字加上颜色</span><br><span class="line">grep --color&#x3D;auto &#39;MANPATH&#39; &#x2F;etc&#x2F;man.config</span><br><span class="line"># 把ls -l的输出中包含字母file（不区分大小写）的内容输出</span><br><span class="line">ls -l | grep -i file</span><br></pre></td></tr></table></figure>
<h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><p>数据同步写入磁盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync</span><br></pre></td></tr></table></figure>
<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>利用脚本来处理文本文件，sed可按照脚本的指令来处理、编辑文本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br><span class="line">-e&lt;script&gt;或--expression&#x3D;&lt;script&gt; 以选项中指定的script来处理输入的文本文件</span><br><span class="line">-f&lt;script文件&gt;或--file&#x3D;&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件</span><br><span class="line">-h或--help 显示帮助</span><br><span class="line">-n或--quiet或--silent 仅显示script处理后的结果</span><br><span class="line">-V或--version 显示版本信息</span><br><span class="line"></span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 </span><br><span class="line">1,20s&#x2F;old&#x2F;new&#x2F;g 就是啦！</span><br><span class="line"></span><br><span class="line">sed -e 4a\newLine testfile</span><br><span class="line">nl &#x2F;etc&#x2F;passwd | sed &#39;2,5d&#39; #将&#x2F;etc&#x2F;passwd 的内容列出并且列印行号，同时，</span><br><span class="line">请将第 2~5 行删除！</span><br></pre></td></tr></table></figure>
<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>是一种处理文本文件的语言，是一个强大的文本分析工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] &#39;script&#39; var&#x3D;value file(s)</span><br><span class="line">或</span><br><span class="line">awk [选项参数] -f scriptfile var&#x3D;value file(s)</span><br></pre></td></tr></table></figure>
<p>grep 更适合单纯的查找或匹配文本<br>sed 更适合编辑匹配到的文本<br>awk 更适合格式化文本，对文本进行较复杂格式处理</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find是一个基于查找的功能非常强大的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line">find &#x2F;root -mtime 0 # 在当前目录下查找今天之内有改动的文件</span><br></pre></td></tr></table></figure>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>用于判断接在file命令后的文件的基本数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file filename</span><br><span class="line">#例如：</span><br><span class="line">file .&#x2F;test</span><br></pre></td></tr></table></figure>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调<br>用相应的压缩程序（如gzip和bzip等）进行压缩和解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称</span><br><span class="line">查询：tar -jtv -f filename.tar.bz2</span><br><span class="line">解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</span><br></pre></td></tr></table></figure>
<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>它用于把C语言的源程序文件，编译成可执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 把源文件test.c按照c99标准编译成可执行程序test</span><br><span class="line">gcc -o test test.c -lm -std&#x3D;c99</span><br><span class="line"># 把源文件test.c转换为相应的汇编程序源文件test.s</span><br><span class="line">gcc -S test.c</span><br></pre></td></tr></table></figure>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>用于测算一个命令（即程序）的执行时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time .&#x2F;process</span><br><span class="line">time ps aux</span><br><span class="line"># 最后输出了三个时间:用户CPU时间 系统CPU时间 实际时间</span><br></pre></td></tr></table></figure>

<h3 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h3><ol>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能<br>运行多个指令</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行</li>
</ol>
<h3 id="分时系统和实时系统有什么区别？"><a href="#分时系统和实时系统有什么区别？" class="headerlink" title="分时系统和实时系统有什么区别？"></a>分时系统和实时系统有什么区别？</h3><ol>
<li>分时系统 系统把CPU时间分成很短的时间片，轮流地分配给多个作业。它<br>的优点就是对多个用户的多个作业都能保证足够快的响应时间，并且有效提<br>高了资源的利用率</li>
<li>实时系统 系统对外部输入的信息，能够在规定的时间内（截止期限）处<br>理完毕并做出反应。它的优点是能够集中地及时地处理并作出反应，高可靠<br>性，安全性，例如工业生产的控制，信息采集的控制等</li>
</ol>
<h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h3><p>进程是资源分配的基本单位。由三部分组成：程序、数据及进程控制块(PCB)。<br>进程控制块描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，<br>都是指对PCB的操作，PCB中保存程序运行的现场（进程标识、处理机状态<br>、进程调度、进程控制等信息）</p>
<ul>
<li>优点 内存隔离，单个进程的崩溃不会导致这个系统的崩溃。而且进程方便<br>测试以及编程简单</li>
<li>缺点 创建销毁比较麻烦，进程间数据的共享麻烦，并且消耗的资源比较多</li>
</ul>
<h3 id="进程状态如何切换？"><a href="#进程状态如何切换？" class="headerlink" title="进程状态如何切换？"></a>进程状态如何切换？</h3><p>进程有三个状态</p>
<ol>
<li>就绪状态 等待被调度，获得了除处理机CPU之外的所有资源</li>
<li>运行状态 正在处理机上执行</li>
<li>阻塞状态 因发生某事件（如请求I/O，申请缓存空间等）而暂停执行的状态</li>
</ol>
<ul>
<li>处于执行状态的进程，可以主动用阻塞原语(block)将其变为阻塞状态</li>
<li>处于阻塞状态的进程，可以用唤醒(wakeup)原语将其变为就绪状态</li>
</ul>
<h3 id="守护进程是什么？"><a href="#守护进程是什么？" class="headerlink" title="守护进程是什么？"></a>守护进程是什么？</h3><p>守护进程是运行在后台的一种特殊进程，它是独立于控制终端的，并周期性地<br>执行某些任务，这些进程大部分时候处于休眠状态，只有当有需求的时候才会<br>唤醒这些进程，比如接收电子邮件的进程、接收Web 访问的进程和处理打印活<br>动的进程等</p>
<h3 id="如何创建守护进程？"><a href="#如何创建守护进程？" class="headerlink" title="如何创建守护进程？"></a>如何创建守护进程？</h3><p>因为守护进程是脱离终端控制的，所以要造成一种在终端里已经运行完的假象<br>，把所有的工作都放在子进程中去完成。我们知道，父进程退出后，子进程其<br>实就是变成了孤儿进程，孤儿进程一般是由1号进程收养，也就是我们所谓的<br>init进程，也就是说原来的子进程变成了init的子进程</p>
<h3 id="孤儿进程是什么？"><a href="#孤儿进程是什么？" class="headerlink" title="孤儿进程是什么？"></a>孤儿进程是什么？</h3><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为<br>孤儿进程，孤儿进程将被init 进程（进程号为 1）所收养，并由init 进程<br>对它们完成状态收集工作。孤儿进程由于有init进程循环的wait()回收资源<br>，因此并没有什么危害</p>
<h3 id="僵尸进程是什么？"><a href="#僵尸进程是什么？" class="headerlink" title="僵尸进程是什么？"></a>僵尸进程是什么？</h3><p>僵尸进程就是当子进程比父进程先结束，而父进程又没有释放子进程占用的资<br>源，此时子进程将成为一个僵尸进程，一个子进程的进程描述符在子进程退出<br>时不会释放</p>
<h3 id="进程描述符是什么？"><a href="#进程描述符是什么？" class="headerlink" title="进程描述符是什么？"></a>进程描述符是什么？</h3><p>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息</p>
<ol>
<li>进程id</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器的值</li>
<li>描述虚拟地址空间的信息（如虚拟地址与物理地址之间的映射关系）</li>
</ol>
<h3 id="僵尸进程的危害？"><a href="#僵尸进程的危害？" class="headerlink" title="僵尸进程的危害？"></a>僵尸进程的危害？</h3><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的<br>进程号而导致系统不能产生新的进程</p>
<h3 id="为什么子进程不直接结束？"><a href="#为什么子进程不直接结束？" class="headerlink" title="为什么子进程不直接结束？"></a>为什么子进程不直接结束？</h3><p>因为父进程有时候需要获取到子进程的退出状态，如果是正常退出，可以直接<br>将其释放，如果是异常退出，又可以根据异常信息进行进一步的相关操作</p>
<h3 id="如何解决僵尸进程？"><a href="#如何解决僵尸进程？" class="headerlink" title="如何解决僵尸进程？"></a>如何解决僵尸进程？</h3><p>可以使用wait函数和waitpid函数来处理</p>
<ol>
<li>对于wait函数，父进程调用该函数的时候，如果子进程还没有运行结束，那<br>么父进程就会阻塞在这里，直到有子进程结束变为僵尸进程后，会获取子进程<br>的退出信息，并将它销毁返回</li>
<li>对于waitpid函数来说，它的作用和wait函数是一样的，只不过多了两个参<br>数，可以让用户更灵活的去操作，首先第一个参数是一个pid(进程号)</li>
</ol>
<ul>
<li>当pid &gt; 0时，只等待进程ID等于pid的子进程</li>
<li>当pid = -1时，等待任何一个子进程退出</li>
<li>当pid = 0时，等待和父进程相同进程组中的任何子进程</li>
<li>当pid &lt; -1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于<br>pid的绝对值</li>
</ul>
<h3 id="什么是进程组ID？"><a href="#什么是进程组ID？" class="headerlink" title="什么是进程组ID？"></a>什么是进程组ID？</h3><p>对于一个父进程，它的进程组ID就是它本身的PID，那么它的所有子进程的组进<br>程ID也都是父进程的PID</p>
<h3 id="特级权是什么意思？"><a href="#特级权是什么意思？" class="headerlink" title="特级权是什么意思？"></a>特级权是什么意思？</h3><p>为各种操作定义一个安全级别，通过安全级别的高低可以做到集中管理，减少有<br>限资源的访问和使用冲突。分为0-3级，0级特权级最高，3级特权级最低。每个<br>级别能够执行的指令是不一样的。例如创建进程要做很多工作，会消耗很多物<br>理资源。比如分配物理内存，父子进程拷贝信息，拷贝设置页目录页表等等，<br>这些工作得由特定的进程去做</p>
<h3 id="用户态和内核态的区别？"><a href="#用户态和内核态的区别？" class="headerlink" title="用户态和内核态的区别？"></a>用户态和内核态的区别？</h3><ol>
<li>内核态 本质上说就是我们所说的内核，它是一种特殊的软件程序，控制计算<br>机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用<br>程序运行，处于特权级别的0级。进程在执行用户自己的代码时，则称其处于用<br>户运行态</li>
<li>用户态 用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管<br>理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就<br>叫系统调用，处于特权级别的3级</li>
</ol>
<h3 id="为什么要区分内核态和用户态？"><a href="#为什么要区分内核态和用户态？" class="headerlink" title="为什么要区分内核态和用户态？"></a>为什么要区分内核态和用户态？</h3><ol>
<li>内核态和用户态的概念，是操作系统为了有效实现CPU的权限分级和数据隔<br>离而提出的，用户态即上层应用程序的活动空间，应用程序的执行必须依托于<br>内核提供的资源，包括CPU资源、存储资源、I/O 资源等。为了使上层应用能<br>够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用</li>
<li>运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而<br>运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。在用户<br>态运行的程序，在运行过程中，一些操作需要内核的权限才能执行，这是就会<br>涉及到一个从用户态切换到内核态的过程</li>
</ol>
<h3 id="用户态和内核态的区别？-1"><a href="#用户态和内核态的区别？-1" class="headerlink" title="用户态和内核态的区别？"></a>用户态和内核态的区别？</h3><ol>
<li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称<br>进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的<br>（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用<br>当前进程的内核栈。每个进程都有自己的内核栈</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此<br>时处理器在特权级最低的（3级）用户代码中运行</li>
<li>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户<br>程序的代码和数据</li>
<li>操作系统运行在内核态，在这个模式中操作系统具有对所有硬件的访问<br>权限，可以执行机器能够执行的任何指令，软件的其余部分运行在用户态<br>，用户接口层（shell）运行在用户态的最低层次，允许用户运行其他程<br>序</li>
<li>内核态具有最高权限，可以访问所有资源，用户态只能访问受限资源，<br>想要访问物理设备需要陷入内核态中，在内核空间(Ring3)中，才可以访<br>问特权资源</li>
</ol>
<h3 id="用户态进入内核态的方式有哪些？"><a href="#用户态进入内核态的方式有哪些？" class="headerlink" title="用户态进入内核态的方式有哪些？"></a>用户态进入内核态的方式有哪些？</h3><p>系统调用时主动的，其余两种是被动的</p>
<ol>
<li>系统调用 用户态进程通过系统调用申请使用操作系统提供的服务程序完成<br>工作，比如fork() 实际上就是执行了一个创建新进程的系统调用</li>
<li>异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异<br>常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就<br>转到了内核态，比如缺页异常</li>
<li>外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的<br>中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信<br>号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换<br>的过程自然也就发生了由用户态到内核态的切换</li>
</ol>
<h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程是调度和执行的基本单位。一个进程中可以有多个线程，它们共享进程资源<br>。线程自身是不能拥有系统资源的，但是它可以拥有自己的堆、栈、局部变量以<br>及程序计算器</p>
<ul>
<li>优点 可以提高系统的并行性，数据共享比较方便，切换比较快</li>
<li>缺点 没有内存隔离，一个线程的崩溃会导致整个进程的崩溃。编程复杂以<br>及调试困难</li>
</ul>
<h3 id="线程有哪两种？"><a href="#线程有哪两种？" class="headerlink" title="线程有哪两种？"></a>线程有哪两种？</h3><ol>
<li>用户级线程 线程的处理不通过内核实现，线程的状态信息等全部存放在用户<br>空间中，内核不能感知用户级线程</li>
</ol>
<ul>
<li>优点 线程的调度不需要内核直接参与，控制简单</li>
<li>缺点 一个用户级线程的阻塞将会引起整个进程的阻塞</li>
</ul>
<ol start="2">
<li>内核级线程 线程的处理均由内核实现，内核为线程保留TCB，并通过TCB<br>感知线程</li>
</ol>
<ul>
<li>优点 当有多个处理机时，一个进程的多个线程可以同时执行</li>
<li>缺点 线程在用户态的运行，而线程的调度和管理在内核实现</li>
</ul>
<h3 id="临界资源是什么？"><a href="#临界资源是什么？" class="headerlink" title="临界资源是什么？"></a>临界资源是什么？</h3><p>临界资源是一个时刻只能由一个进程使用的资源</p>
<ol>
<li>硬件资源：许多都属于临界资源，如打印机，磁带机等</li>
<li>软件资源：如变量、表格、队列等</li>
</ol>
<h3 id="临界区是什么？"><a href="#临界区是什么？" class="headerlink" title="临界区是什么？"></a>临界区是什么？</h3><p>进程中访问临界资源的代码段</p>
<ol>
<li>同类临界区 涉及同一临界资源的不同进程中的临界区</li>
<li>进入区 临界区前检查临界资源使用情况的代码段</li>
<li>退出区 临界区后面恢复临界资源访问标志的代码段</li>
</ol>
<h3 id="共享是什么？"><a href="#共享是什么？" class="headerlink" title="共享是什么？"></a>共享是什么？</h3><ol>
<li>共享是指系统中的资源可以被多个并发进程共同使用</li>
<li>有两种共享方式：互斥共享和同时共享</li>
<li>互斥共享的资源称为临界资源，在同一时刻只允许一个进程访问，需要用同<br>步机制来实现互斥访问</li>
</ol>
<h3 id="信号量是什么？"><a href="#信号量是什么？" class="headerlink" title="信号量是什么？"></a>信号量是什么？</h3><p>信号量是一种特殊的调度变量，由一个初始值为1的整数 mutex，和一个任<br>务队列queue 组成，并且提供两个原子操作，wait 和signal，用于管理</p>
<ol>
<li>wait(S):等待操作（也叫P操作）首先执行-1操作，如果信号量小于0<br>，调用block 将任务放入阻塞队列。否则就可以进入临界区</li>
<li>signal(S):发信号操作（也叫V操作）对信号量执行+1 操作，如果信号<br>量小于等于0，说明还有其他任务在阻塞队列，就调用wakeup 方法唤醒等<br>待队列中的一个进程重新开始进入临界区</li>
</ol>
<h3 id="AND信号量是什么？"><a href="#AND信号量是什么？" class="headerlink" title="AND信号量是什么？"></a>AND信号量是什么？</h3><p>将进程运行过程中需要的所有临界资源，一次性地全部分配给进程，也就是<br>说有多个mutex</p>
<ol>
<li>wait 一次性为任务分配所有资源，然后再执行，判断si是否大于等于1<br>，一旦有任何一个资源没有获取，那么阻塞</li>
<li>signal 同样在结束之后将所有si 加一，但是这里是取出阻塞队列里面<br>，与所有si 有关的任务，并且唤醒他们</li>
</ol>
<h3 id="一般信号量是什么？"><a href="#一般信号量是什么？" class="headerlink" title="一般信号量是什么？"></a>一般信号量是什么？</h3><p>AND 信号量描述了竞争多种资源的并发，但是每一种资源数量都为 1。假设任<br>务需要n 个同种类的资源才能运行，那么就不能简单的通过si≥1 来判断是否<br>符合任务的要求了。一般信号量机制当信号量si 的值大于某个阈值ti 的时<br>候，才表示能够分配该资源给任务，否则阻塞</p>
<ol>
<li>wait 当信号量 si 的值大于某个阈值 ti 的时候，才表示能够分配该资<br>源给任务，否则阻塞，所有si 减去di</li>
<li>signal 所有si 加上di，将与si 有关的进程从阻塞队列中唤醒</li>
</ol>
<h3 id="阻塞和非阻塞区别？"><a href="#阻塞和非阻塞区别？" class="headerlink" title="阻塞和非阻塞区别？"></a>阻塞和非阻塞区别？</h3><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态</p>
<ol>
<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到<br>结果之后才会返回，比如现在我们的程序想要通过网络读取数据，如果是阻塞<br>IO模式，一旦发起请求到操作系统内核去从网络中读取数据，就会阻塞在那里<br>，必须要等待网络中的数据到达了之后，才能从网络读取数据到内核，再从内<br>核返回给程序</li>
<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程，程序<br>发送请求给内核要从网络读取数据，但是此时网络中的数据还没到，此时不<br>会阻塞住，内核会返回一个异常消息给程序，程序可以干点别的，然后不断<br>去轮询去访问内核，看请求的数据是否读取到了 </li>
</ol>
<h3 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h3><p>同步和异步关注的是消息通信机制</p>
<ol>
<li>同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但<br>是一旦调用返回，就得到返回值了，就是由调用者主动等待这个调用的结果，<br>用者必须要等待这个接口的磁盘读写或者网络通信的操作执行完毕了，调用者<br>才能返回</li>
<li>异步，调用在发出之后，这个调用就直接返回了，所以没有返回结果，当<br>一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被<br>调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用</li>
</ol>
<h3 id="宏内核和微内核的区别？"><a href="#宏内核和微内核的区别？" class="headerlink" title="宏内核和微内核的区别？"></a>宏内核和微内核的区别？</h3><ol>
<li>宏内核是将操作系统功能作为一个紧密结合的整体放到内核，不管是用户<br>服务还是内核服务事实上都是内核在统一管理，它们是运行在同一地址空间<br>中的。由于各模块共享信息，因此有很高的性能，但是很难定位bug，拓展<br>性比较差，每次需要增加新的功能，都要将新的代码和原来的内核代码重<br>新编译</li>
<li>在微内核中用户服务和内核服务在不同的地址空间中实现。在内核架构中，<br>用户服务是独立于内核服务的，因此任何用户服务崩溃都不会影响到内核服务<br>，这就加强了操作系统的健壮性，这是微内核的优势所在。另一点，微内核的<br>扩展性强，添加一个功能，只需要建立一个新的服务到用户空间当中，而内<br>核空间不需要任何的修改。因此，微内核可移植性强、安全并且易于扩展。</li>
</ol>
<h3 id="Linux内核？"><a href="#Linux内核？" class="headerlink" title="Linux内核？"></a>Linux内核？</h3><ol>
<li>内核是操作系统的核心部分，它管理着系统的各种资源</li>
<li>将应用程序的请求传递给硬件，并充当底层驱动程序，对系统中各种设备<br>和组件进行寻址</li>
</ol>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ol>
<li>资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问<br>隶属进程的资源</li>
<li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切<br>换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</li>
<li>系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内<br>存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似<br>地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进<br>程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开<br>销很小</li>
<li>通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进<br>程通信需要借助其他方式</li>
</ol>
<h3 id="进程之间共享和私有的资源？"><a href="#进程之间共享和私有的资源？" class="headerlink" title="进程之间共享和私有的资源？"></a>进程之间共享和私有的资源？</h3><p>资源：进程之间私有和共享的资源</p>
<ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
<h3 id="线程之间共享和私有的资源？"><a href="#线程之间共享和私有的资源？" class="headerlink" title="线程之间共享和私有的资源？"></a>线程之间共享和私有的资源？</h3><p>线程之间私有和共享的资源</p>
<ul>
<li>私有：线程栈，寄存器，程序计数器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
</ul>
<h3 id="什么时候适合用多线程和多进程？"><a href="#什么时候适合用多线程和多进程？" class="headerlink" title="什么时候适合用多线程和多进程？"></a>什么时候适合用多线程和多进程？</h3><ol>
<li>需要频繁创建销毁的优先使用线程，因为创建和销毁一个进程代价是很<br>大的</li>
<li>线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时<br>的操作使用线程可提高应用程序的响应</li>
<li>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好</li>
</ol>
<h3 id="作业和管程是什么？"><a href="#作业和管程是什么？" class="headerlink" title="作业和管程是什么？"></a>作业和管程是什么？</h3><ol>
<li>作业 用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集<br>合，它包括用户程序、所需要的数据及控制命令等</li>
<li>管程 管程实际上是定义了一个数据结构和在该数据结构上的能为并发进程<br>所执行的一组操作，这组操作能同步进程和改变管程中的数据</li>
</ol>
<h3 id="进程调度策略有哪几种？"><a href="#进程调度策略有哪几种？" class="headerlink" title="进程调度策略有哪几种？"></a>进程调度策略有哪几种？</h3><ol>
<li>先进先出算法  按照进程进入就绪队列的先后次序来选择。即每当进入进<br>程调度，总是把就绪队列的队首进程投入运行</li>
<li>时间片轮转算法 分时系统的一种调度算法。轮转的基本思想是，将CPU的<br>处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。<br>当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一<br>次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一<br>个时间片</li>
<li>最高优先级算法 为每个进程分配一个优先级，按优先级进行调度。为了防<br>止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优<br>先级</li>
<li>多级队列反馈法 时间片轮转调度算法和优先级调度算法的结合</li>
</ol>
<h3 id="抢占式和非抢占式的区别？"><a href="#抢占式和非抢占式的区别？" class="headerlink" title="抢占式和非抢占式的区别？"></a>抢占式和非抢占式的区别？</h3><ol>
<li>抢占式就是说操作系统将正在运行的进程强行暂停，由调度器将CPU分配给<br>其他就绪进程</li>
<li>非抢占式是调度器一旦把处理机分配给某进程后便让它一直运行下去，直<br>到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另<br>一个进程</li>
</ol>
<h3 id="CPU上下文是什么？"><a href="#CPU上下文是什么？" class="headerlink" title="CPU上下文是什么？"></a>CPU上下文是什么？</h3><p>CPU寄存器包含指令寄存器(IR)和程序计数器(PC)。他们用来暂存指令，数据<br>和地址，程序运行的下一条指令地址，这些都是任务运行时的必要环境。因此<br>也被称作CPU上下文</p>
<h3 id="CPU上下文切换？"><a href="#CPU上下文切换？" class="headerlink" title="CPU上下文切换？"></a>CPU上下文切换？</h3><p>上下文切换就是把前一个任务的CPU上下文保存起来，然后加载新任务的上下<br>文到这些指令寄存器(IR)和程序寄存器(PC)等寄存器中。这些被保存下来的<br>上下文会存储在操作系统的内核中，等待任务重新调度执行时再次加载进来<br>，这样就能保证任务的原来状态不受影响。<br>CPU的上下文切换又分为进程上下文切换，线程上下文切换以及中断上下文切换</p>
<h3 id="进程上下文切换？"><a href="#进程上下文切换？" class="headerlink" title="进程上下文切换？"></a>进程上下文切换？</h3><p>进程执行过程中所涉及到的CPU上下文切换，我们称之为特权模式切换。从用<br>户态到内核态的转变就发生一次特权模式切换，如从磁盘上读取一个文件，<br>就发生了一次内核调用，也就发生一次特权模式切换</p>
<ol>
<li>CPU需要将寄存器中的用户态的指令位置保存起来，截至执行内核态的代码</li>
<li>CPU寄存器需要更新为内核态的新位置，最后跳转到内核态执行内核调用。<br>之后再恢复之前的用户态，这样的一次系统调用过程实际上发生了两次CPU上<br>下文切换</li>
</ol>
<p>这不是进程上下文切换，进程上下文切换只是说一个进程切换到另一个进程<br>首先进程的管理是有内核进行管理和调度的。进程的切换只能发生在内核态<br>所以进程的上下文切换不仅仅包括了虚拟内存，栈，全局变量等用户空间<br>资源，还包括了内核态堆栈，寄存器等内核空间状态</p>
<h3 id="线程上下文切换？"><a href="#线程上下文切换？" class="headerlink" title="线程上下文切换？"></a>线程上下文切换？</h3><ol>
<li>当进程拥有多个线程时，线程会共享虚拟内存和全局变量等资源，这些资<br>源在上下文切换中不需要修改</li>
<li>线程的上下文切换也需要保存自己的一些数据，比如栈，寄存器。这些在上<br>下文切换时是需要保存的</li>
<li>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</li>
</ol>
<h3 id="中断上下文切换？"><a href="#中断上下文切换？" class="headerlink" title="中断上下文切换？"></a>中断上下文切换？</h3><p>中断是为了快速响应硬件事件的，跟进程上下文不同，中断上下文不涉及进程<br>的用户态。即便打断的是一个用户态的进程，也不需要保存和恢复这个进程的<br>虚拟内存，全局变量等用户态资源。中断上下文只包括内核态中断服务程序执<br>行必需的状态。CPU寄存器，内核堆栈，硬件中断参数</p>
<h3 id="为什么线程切换会有消耗，消耗啥？"><a href="#为什么线程切换会有消耗，消耗啥？" class="headerlink" title="为什么线程切换会有消耗，消耗啥？"></a>为什么线程切换会有消耗，消耗啥？</h3><p>线程切换过程包括：线程上下文的保存和恢复，用户态和内核态的转换，CPU<br>上下文的切换，这些工作都需要CPU去完成</p>
<ol>
<li>CPU上下文切换 CPU寄存器和程序计数器切换</li>
<li>线程上下文切换 涉及线程状态的保存和恢复，包括寄存器、栈等私有数据</li>
<li>特权模式切换 线程的调度是需要内核级别的权限的（操作CPU和内存），<br>也就是说线程的调度工作是在内核态完成的，因此会有一个从用户态到内核态<br>的切换。而且，不管是线程本身的切换还是特权模式的切换，都要进行CPU的<br>上下文切换</li>
</ol>
<h3 id="如何查看上下文切换情况？"><a href="#如何查看上下文切换情况？" class="headerlink" title="如何查看上下文切换情况？"></a>如何查看上下文切换情况？</h3><ol>
<li>vmstat 查看系统的上下文切换情况</li>
<li>pidstat 可以看到具体的某个应用程序的上下文切换情况</li>
</ol>
<h3 id="进程同步、互斥和通信的区别？"><a href="#进程同步、互斥和通信的区别？" class="headerlink" title="进程同步、互斥和通信的区别？"></a>进程同步、互斥和通信的区别？</h3><p>进程之间存在两种基本关系：竞争关系和协作关系。进程的互斥、同步、通信都<br>是基于这两种基本关系而存在的</p>
<ol>
<li>为了解决进程间竞争关系（间接制约关系）而引入进程互斥</li>
<li>为了解决进程间松散的协作关系（直接制约关系）而引入进程同步</li>
<li>为了解决进程间紧密的协作关系而引入进程通信</li>
</ol>
<ul>
<li>资源竞争会产生两个问题：一个是死锁问题，一个是饥饿问题。进程的互斥<br>是解决进程间竞争关系(间接制约关系 ) 的手段。 进程互斥指若干个进程要<br>使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资<br>源的进程必须等待，直到占有资源的进程释放该资源。</li>
<li>某些进程为完成同一任务需要分工协作，这就需要相互协作的进程在某些协<br>调点上协调各自的工作。这种协作进程之间相互等待对方消息或信号的协调关<br>系称为进程同步，也就是说进程同步指两个以上进程基于某个条件来协调它<br>们的活动。一个进程的执行依赖于另一个协作进程的消息或信号，当一个进<br>程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号<br>到达才被唤醒</li>
<li>进程之间互相交换信息的工作称之为进程通信IPC，主要是指大量数据的交换</li>
</ul>
<h3 id="临界资源和临界区的区别？"><a href="#临界资源和临界区的区别？" class="headerlink" title="临界资源和临界区的区别？"></a>临界资源和临界区的区别？</h3><ol>
<li>临界资源 临界资源是一次仅允许一个进程使用的共享资源。各进程采取互<br>斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，<br>磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方<br>式，实现对这种资源的共享</li>
<li>临界区 每个进程中访问临界资源的那段代码称为临界区。每次只允许一个<br>进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软<br>件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界<br>资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长<br>，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会<br>被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</li>
<li>临界区是用户态下的对象，即只能在同一进程中实现线程互斥。因无需在用<br>户态和核心态之间切换</li>
</ol>
<h3 id="静态链接和动态链接的区别？"><a href="#静态链接和动态链接的区别？" class="headerlink" title="静态链接和动态链接的区别？"></a>静态链接和动态链接的区别？</h3><ol>
<li>静态链接就是在编译期间，由编译器和连接器将静态库集成到应用程序内<br>，并制作成目标文件以及可以独立运作的可执行文件。静态库一般是一些外<br>部函数与变量的集合</li>
<li>动态链接可以在首次载入的时候执行，也可以在程序开始执行的时候完成<br>。这个是由动态链接器完成，比方标准 C 库(libc.so) 通常就是动态链接<br>的，这样所有的程序可以共享同一个库，而不用分别进行封装</li>
</ol>
<h3 id="编译有哪些阶段？"><a href="#编译有哪些阶段？" class="headerlink" title="编译有哪些阶段？"></a>编译有哪些阶段？</h3><ol>
<li>预处理阶段：处理以 # 开头的预处理命令</li>
<li>编译阶段：翻译成汇编文件</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件</li>
<li>链接阶段：将可重定位目标文件和 printf.o</li>
<li>等单独预编译好的目标文件进行合并，得到最终的可执行目标文件</li>
</ol>
<h3 id="进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"><a href="#进程间通信方式（六种方式，各自的概念，区别都要搞清楚）" class="headerlink" title="进程间通信方式（六种方式，各自的概念，区别都要搞清楚）"></a>进程间通信方式（六种方式，各自的概念，区别都要搞清楚）</h3><p><a href="https://blog.csdn.net/watermelonmk/article/details/109002753" target="_blank" rel="noopener">https://blog.csdn.net/watermelonmk/article/details/109002753</a><br><a href="https://blog.csdn.net/qq_34796146/article/details/107825875" target="_blank" rel="noopener">https://blog.csdn.net/qq_34796146/article/details/107825875</a></p>
<ol>
<li>管道 管道传输数据是单向的，如果想相互通信，我们需要创建两个管道<br>才行。管道这种通信方式效率低，不适合进程间频繁地交换数据，所谓的管<br>道，就是内核里面的一串缓存。从管道的一端写入的数据，实际上是缓存在<br>内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的<br>数据是无格式的流且大小受限</li>
</ol>
<ul>
<li>匿名管道 没有名字标识，匿名管道是特殊文件只存在于内存，没有存在<br>于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无<br>格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上<br>流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于<br>存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立<br>，随着进程终止而消失</li>
<li>命名管道 突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用<br>命名管道的前提，需要在文件系统创建一个类型为p 的设备文件，那么毫<br>无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道<br>还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数<br>据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不<br>支持lseek 之类的文件定位操作</li>
</ul>
<ol start="2">
<li>消息队列 A 进程要给B 进程发送消息，A 进程把数据放在对应的消息<br>队列后就可以正常返回了，B进程需要的时候再去读取数据就可以了。同理<br>，B 进程要给A 进程发送消息也是如此。<br>消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际<br>上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数<br>据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时<br>，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的<br>数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入<br>和读取都需要经过用户态与内核态之间的拷贝过程。消息队列生命周期随<br>内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直<br>存在，如果进程从消息队列中读取了消息体，内核就会把这个消息体删<br>除而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程<br>的结束而销毁</li>
<li>共享内存 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相<br>同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到<br>了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。<br>共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来<br>的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问<br>进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提<br>高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享<br>内存通信，这种方式需要依靠某种同步操作，如互斥锁和信号量等</li>
<li>信号量 信号量其实是一个整型的计数器，主要用于实现进程间的互斥<br>与同步，而不是用于缓存进程间通信的数据</li>
<li>信号 信号是进程间通信机制中唯一的异步通信机制，信号可以在应用<br>进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发<br>生了哪些系统事件</li>
<li>SOCKET 前面提到的方式都是在同一台主机上进行进程间通信，那要想<br>跨网络与不同主机上的进程之间通信，就需要Socket 通信了。可根据创建<br>Socket 的类型不同，分为三种常见的通信方式，一个是基于TCP 协议的<br>通信方式，一个是基于UDP协议的通信方式，一个是本地进程间通信方式</li>
</ol>
<h3 id="管道、消息队列、共享内存它们三者哪个开销最小？"><a href="#管道、消息队列、共享内存它们三者哪个开销最小？" class="headerlink" title="管道、消息队列、共享内存它们三者哪个开销最小？"></a>管道、消息队列、共享内存它们三者哪个开销最小？</h3><p><a href="https://blog.csdn.net/qq_41999455/article/details/105275981" target="_blank" rel="noopener">https://blog.csdn.net/qq_41999455/article/details/105275981</a></p>
<ol>
<li>进程间的通信手段大体可以分为两类：通信类和同步类</li>
<li>本质来讲管道也是一片内存区域，默认大小是65536字节</li>
<li>相比于管道来讲，消息队列机制中，双方是通过消息来通信的，无需花<br>费精力从字节流中解析出完整的消息</li>
<li>消息队列的作用是进程之间传递消息。而信号量的作用是为了同步多个<br>进程的操作</li>
<li>共享内存是所有IPC手段中最快的一种。它之所以快是因为共享内存一旦<br>映射到进程的地址空间，进程之间数据的传递就不须要涉及内核了</li>
<li>共享内存是开销最小的通信方式，源于它和内核的交流比较少，从而降<br>低了开销</li>
</ol>
<h3 id="信号与信号量的区别？"><a href="#信号与信号量的区别？" class="headerlink" title="信号与信号量的区别？"></a>信号与信号量的区别？</h3><ol>
<li>信号事件的来源主要有两种</li>
</ol>
<ul>
<li>硬件来源（如键盘Cltr+C ） 产生SIGINT 信号，表示终止该进程</li>
<li>Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束</li>
<li>软件来源（如kill命令）</li>
</ul>
<p>信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给<br>某一进程，一旦有信号产生一旦有信号发生，进程有三种方式响应信号</p>
<ol>
<li>执行默认操作 Linux 对每种信号都规定了默认操作，例如，上面列表中<br>的SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即<br>终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方<br>便程序员事后进行分析问题在哪里</li>
<li>捕捉信号 我们可以为信号定义一个信号处理函数。当信号发生时，我们就<br>执行相应的信号处理函数</li>
<li>忽略信号 当我们不希望处理某些信号的时候，就可以忽略该信号，不做任<br>何处理。有两个信号是应用进程无法捕捉和忽略的，即SIGKILL 和SEGSTOP，<br>它们用于在任何时候中断或结束某一进程</li>
</ol>
<h3 id="进程同步的方式"><a href="#进程同步的方式" class="headerlink" title="进程同步的方式"></a>进程同步的方式</h3><ol>
<li>信号量 用于进程间传递信号的一个整数值。用于实现进程间的互斥与同步<br>，在信号量上只有三种操作可以进行，这三种操作都是原子操作</li>
</ol>
<ul>
<li>初始化</li>
<li>P操作 可以用于阻塞一个进程</li>
<li>V操作 用于解除阻塞一个进程</li>
</ul>
<p>基本原理是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫<br>在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量</p>
<ol start="2">
<li>管程 管程是由一个或多个过程、一个初始化序列和局部数据组成的软件<br>模块。局部数据变量只能被管程的过程访问，任何外部过程都不能访问。一<br>个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程<br>在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。管<br>程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，<br>并且只有在管程中才能被访问。有两个函数可以操作条件变量</li>
</ol>
<ul>
<li>cwait(c) 调用进程的执行在条件c上阻塞，管程现在可被另一个进程使用</li>
<li>csignal(c) 恢复执行在cwait之后因为某些条件而阻塞的进程。如果有多<br>个这样的进程，选择其中一个，如果没有这样的进程，什么也不做</li>
</ul>
<ol start="3">
<li>消息传递 消息传递的实际功能以一对原语的形式提供</li>
</ol>
<ul>
<li>send(destination,message)</li>
<li>receive(source,message)</li>
</ul>
<p>这是进程间进程消息传递所需要的最小操作集，一个进程以消息的形式给另一<br>个指定的目标进程发送消息，进程通过执行receive原语接收消息，receive<br>原语中指明发送消息的源进程和消息</p>
<h3 id="线程同步的方式？"><a href="#线程同步的方式？" class="headerlink" title="线程同步的方式？"></a>线程同步的方式？</h3><ol>
<li>信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程<br>访问同一个资源，PV操作</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可<br>以方便的实现多线程优先级的比较操作</li>
<li>互斥量 互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核<br>对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程<br>间实现同步，从而实现资源的安全共享</li>
<li>临界区 临界区对应着一个CcriticalSection对象，当线程需要访问保护数<br>据时，调用EnterCriticalSection函数，当对保护数据的操作完成之后，调用<br>LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以<br>夺取临界区对象并访问受保护的数据</li>
</ol>
<h3 id="死锁是什么？"><a href="#死锁是什么？" class="headerlink" title="死锁是什么？"></a>死锁是什么？</h3><p>在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该<br>进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁</p>
<h3 id="死锁产生的必要条件？"><a href="#死锁产生的必要条件？" class="headerlink" title="死锁产生的必要条件？"></a>死锁产生的必要条件？</h3><ol>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有<br>它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程<br>都在等待下一个进程所占有的资源</li>
</ol>
<h3 id="如何解决死锁？"><a href="#如何解决死锁？" class="headerlink" title="如何解决死锁？"></a>如何解决死锁？</h3><p>对于死锁，主要有4种解决策略</p>
<ol>
<li>鸵鸟策略</li>
<li>死锁预防</li>
<li>死锁避免</li>
<li>死锁检测和恢复</li>
</ol>
<h3 id="什么是鸵鸟策略？"><a href="#什么是鸵鸟策略？" class="headerlink" title="什么是鸵鸟策略？"></a>什么是鸵鸟策略？</h3><p>不采取任务措施，当发生死锁时不会对用户造成多大影响，或发生死锁的概<br>率很低</p>
<h3 id="如何预防死锁？"><a href="#如何预防死锁？" class="headerlink" title="如何预防死锁？"></a>如何预防死锁？</h3><p>死锁预防是指通过破坏死锁产生的四个必要条件中的一个或多个，以避免发生死锁</p>
<ol>
<li>破坏互斥条件 不让资源被一个进程独占</li>
<li>破坏占有和等待条件 已拥有资源的进程不能再去请求其他资源，要求进程在<br>开始执行前请求需要的所有资源或先暂时释放其当前拥有的所有资源，再尝试</li>
<li>破坏不可抢占条件 有些资源可以通过虚拟化方式实现可抢占</li>
<li>破坏环路等待 每个进程在任何时刻只能占用一个资源，如果要请求另一个<br>资源，必须先释放第一个资源或要求进程必须按照顺序请求资源</li>
<li>锁排序法 指定获取锁的顺序，比如某个线程只有获得A锁和B锁，才能对某资<br>源进行操作，通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格<br>获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种<br>方法</li>
<li>使用显式锁中的ReentrantLock.try(long,TimeUnit)来申请锁</li>
</ol>
<h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><p>为了避免因为预防死锁而导致所有线程变慢，死锁避免采用了与死锁预防相反<br>的措施，通过算法判断资源请求是否可能导致循环等待的形成并相应决策，来<br>避免死锁点的产生，其前提是知道当前资源使用的整体情况，以及申请资源线<br>程本身所占有的资源细节</p>
<ol>
<li>线程启动拒绝：如果一个线程的请求会引发死锁，则不允许其启动</li>
<li>资源分配拒绝：如果一个线程增加的资源请求会导致死锁，则不允许此申请</li>
</ol>
<h3 id="如何死锁检测与恢复？"><a href="#如何死锁检测与恢复？" class="headerlink" title="如何死锁检测与恢复？"></a>如何死锁检测与恢复？</h3><ol>
<li>死锁检测 维护一个系统的资源分配图，找到不会阻塞又不独立的进程结点<br>，使该进程获得其所需资源并运行，运行完毕后，再释放其所占有的全部资源</li>
<li>死锁恢复</li>
</ol>
<ul>
<li>取消所有死锁相关线程</li>
<li>把每个死锁线程回滚到某些检查点，然后重启</li>
<li>连续取消死锁线程直到死锁解除，顺序基于特定最小代价原则</li>
<li>连续抢占资源直到死锁解除</li>
</ul>
<h3 id="地址空间是什么？"><a href="#地址空间是什么？" class="headerlink" title="地址空间是什么？"></a>地址空间是什么？</h3><p>引入地址空间的概念就是为了在内存中同时运行多个程序并且互不影响，解决<br>了保护和重定位问题。<br>概念：地址空间是一个进程可以用于寻址内存的一套地址集合。每个进程都有<br>自己的地址空间，并且这个地址空间独立于其他进程的地址空间</p>
<h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>虚拟内存：每个程序有自己的地址空间，把这个空间分割为多块，每一块称为<br>页，每一页都有连续的地址范围，执行时这些页映射到物理内存。但并不是所<br>有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地<br>址空间时，由硬件立刻进行必要的映射，当程序引用到一部分不在物理内存<br>中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失<br>败的命令</p>
<h3 id="什么是分页系统"><a href="#什么是分页系统" class="headerlink" title="什么是分页系统"></a>什么是分页系统</h3><p>程序产生的地址是虚拟地址，构成了一个地址空间。虚拟地址不是被送到<br>内存总线上而是送到内存管理单元MMU，MMU把虚拟地址映射为物理地址。<br>虚拟空间被划分为若干页面，物理地址中页面对应的空间叫做页框。<br>MMU管理地址空间和物理空间的转换，如果一个页面没有被映射就是缺页<br>中断或缺页错误</p>
<h3 id="分页是什么？"><a href="#分页是什么？" class="headerlink" title="分页是什么？"></a>分页是什么？</h3><p>分页机制的思想是:通过映射，可以使连续的线性地址与物理地址相关联，<br>逻辑上连续的线性地址对应的物理地址可以不连续。 分页的作用- 将线<br>性地址转换为物理地址 - 用大小相同的页替换大小不同的段</p>
<h3 id="什么是页表？"><a href="#什么是页表？" class="headerlink" title="什么是页表？"></a>什么是页表？</h3><p>页表存储页和页框的映射表。一个虚拟地址被分为两部分，一部分存储页<br>号，另一部分存储偏移量。一个页面存储16个页，那么需要4位比特来表<br>示在索引定位，所以虚拟地址的前4位就可表示页的索引，后12位是偏<br>移量，页表中第二个子段就是页框号，页框号加上偏移量就是实际的<br>物理地址，页表的第三个字段就是在/不在</p>
<h3 id="页表项的结构是什么样的？"><a href="#页表项的结构是什么样的？" class="headerlink" title="页表项的结构是什么样的？"></a>页表项的结构是什么样的？</h3><p>页框号：该页需要映射到的物理页<br>在/不在位：如果是1表示该表项有效可以使用，如果是0表示对应的虚拟<br>页面不在内存中<br>保护位：一个页运行什么类型的访问，可以使用3位，对应读、写或修改<br>修改位：重新分配页框时如果该页已经被修改需要写回磁盘，如果没有<br>被修改直接丢弃即可，有时也叫脏位<br>访问位：不管读还是写该页面被访问时都会设置访问位，不再使用的页<br>面比正在使用的页面更适合淘汰<br>高速缓存禁止位：保证硬件是不断从设备总读取数据而不是访问旧的被<br>高速缓存的副本时使用</p>
<h3 id="加速分页过程是怎样的？"><a href="#加速分页过程是怎样的？" class="headerlink" title="加速分页过程是怎样的？"></a>加速分页过程是怎样的？</h3><p>大量程序总是对少量页面进行多次访问，可以设置一个小型的硬件设备<br>，将虚拟地址直接映射到物理地址。这种设备就是转换检测缓冲区TLB，<br>有时也称为相连存储器或块表。软失效是页面不在TLB中，需要从内存<br>中获取。硬失效是页面不在内存中，那么必须从磁盘读取。<br>TLB能够加速虚拟地址到物理地址的转换，还有一个问题是处理巨大的<br>虚拟地址空间。有两种解决办法</p>
<ol>
<li>多级页表<br>引入多级页表是避免把全部页表一直保存在内存中。把32位虚拟地址分<br>为10位的PT1域、10位的PT2域和12位的PT3域，顶级页表对应10位的<br>PT1域，有1024个表项，每一个表项都表示4M的块地址范围，二级页<br>表的索引是PT2域</li>
<li>倒排页表<br>每个页框对应一个表项，而不是每个虚拟页面对应一个表项，这样可以<br>节省大量空间，但是从虚拟地址到物理地址的转换会非常困难</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在发送缺页中断时，需要选择一个页面，将其换出内存，如果每次都选择<br>不常使用的页面会提升系统性能，如果一个频繁使用的页面被置换出去会<br>带来不必要的开销</p>
<ol>
<li>最佳 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证<br>获得最低的缺页率</li>
<li>最近最久未使用 虽然无法知道将来要使用的页面情况，但是可以知道过<br>去使用页面的情况。LRU 将最近最久未使用的页面换出。为了实现 LRU，需<br>要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移<br>到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次<br>访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</li>
<li>最近未使用 每个页面都有两个状态位：R 与 M，当页面被访问时设置页<br>面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。优先换出被<br>修改并且没有再被访问的页面</li>
<li>先进先出FIFO 选择换出的页面是最先进入的页面。该算法会将那些经常<br>被访问的页面换出，导致缺页率升高</li>
</ol>
<h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ol>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 </li>
<li>页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间，将用户程序地址空<br>间分为若干固定大小的区域</li>
<li>分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助<br>于共享和保护</li>
<li>段的大小不固定，由它所完成的功能决定，页大大小固定，由系统决定</li>
<li>分段是二维的，如代码段，数据段，堆栈段，这样每个进程有一个二维地址<br>空间，相互独立，互不干扰</li>
</ol>
<h3 id="局部性原理？"><a href="#局部性原理？" class="headerlink" title="局部性原理？"></a>局部性原理？</h3><ol>
<li>时间上的局部性：最近被访问的页在不久的将来还会被访问</li>
<li>空间上的局部性：内存中被访问的页周围的页也很可能被访问</li>
</ol>
<h3 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h3><p>文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打<br>开的文件，对文件所有I/O 操作相关的系统调用都需要通过文件描述符</p>
<ol>
<li>进程级别的文件描述符表：内核为每个进程维护一个文件描述符表，该表<br>记录了文件描述符的相关信息，包括文件描述符、指向打开文件表中记录的<br>指针</li>
<li>系统级别的打开文件表：内核对所有打开文件维护了一个进程共享的打开<br>文件描述表，表中存储了处于打开状态文件的相关信息，包括文件类型、访<br>问权限、文件操作函数等</li>
<li>系统级别的i-node 表：i-node 结构体记录了文件相关的信息，包括文<br>件长度，文件所在设备，文件物理位置，创建、修改和更新时间等，”ls -i”<br>命令可以查看文件i-node 节点</li>
</ol>
<h3 id="Socket-是什么？"><a href="#Socket-是什么？" class="headerlink" title="Socket 是什么？"></a>Socket 是什么？</h3><p>Socket是应用层与TCP/IP协议通信的中间软件抽象层，它是一组接口</p>
<h3 id="I-O模型中的输入操作？"><a href="#I-O模型中的输入操作？" class="headerlink" title="I/O模型中的输入操作？"></a>I/O模型中的输入操作？</h3><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所<br>等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核<br>缓冲区复制到应用进程缓冲区</p>
<ol>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ol>
<h3 id="I-O模型分为几种？"><a href="#I-O模型分为几种？" class="headerlink" title="I/O模型分为几种？"></a>I/O模型分为几种？</h3><ol>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ol>
<h3 id="阻塞式I-O-是什么？"><a href="#阻塞式I-O-是什么？" class="headerlink" title="阻塞式I/O 是什么？"></a>阻塞式I/O 是什么？</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回，<br>在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系<br>统都被阻塞</p>
<ol>
<li>CPU把数据从磁盘读到内核缓冲区</li>
<li>CPU把数据从内核缓冲区拷贝到用户缓冲区</li>
</ol>
<h3 id="非阻塞式I-O-是什么？"><a href="#非阻塞式I-O-是什么？" class="headerlink" title="非阻塞式I/O 是什么？"></a>非阻塞式I/O 是什么？</h3><p>非阻塞IO发出read请求后发现数据没准备好，会继续往下执行，此时应用程<br>序会不断轮询polling内核询问数据是否准备好，当数据没有准备好时，内<br>核立即返回EWOULDBLOCK错误。直到数据被拷贝到应用程序缓冲区，read请<br>求才获取到结果。这里最后一次read 调用获取数据的过程，是一个同步的<br>过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序<br>的缓存区这个过程</p>
<h3 id="I-O-多路复用？"><a href="#I-O-多路复用？" class="headerlink" title="I/O 多路复用？"></a>I/O 多路复用？</h3><ol>
<li>非阻塞情况下无可用数据时，应用程序每次轮询内核看数据是否准备好<br>了也耗费CPU</li>
<li>I/O复用就是不让它轮询，当内核缓冲区数据准备好了，以事件通知当机<br>制告知应用进程数据准备好，应用进程在没有收到数据准备好的事件通知信<br>号时可以忙写其他的工作</li>
<li>I/O就是指的我们网络I/O，多路指多个TCP连接(或多个Channel)，复<br>用指复用一个或少量线程。串起来理解就是很多个网络I/O复用一个或少量<br>的线程来处理这些连接。发明它的目的是尽量多的提高服务器的吞吐能力。<br>实现一个线程监控多个IO请求，哪个IO有请求就把数据从内核拷贝到进程<br>缓冲区，拷贝期间是阻塞的</li>
<li>通过一种机制可以监视多个文件描述符，一旦某个文件描述符就绪（一<br>般是读就绪或者写就绪），就能够通知进程进行相应的读写操作，select<br>poll epoll都是IO 多路复用的一种机制，他们三个本质上都是同步IO，<br>因为 它们都需要在读写事件就绪后自己负责读写操作，也就是读写过程<br>中是阻塞的，而异步IO无需自己进行读写，它只负责发起事件具体的实<br>现由别的完成</li>
<li>使用select 或者poll 等待数据，并且可以等待多个套接字中的任何<br>一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再<br>使用recvfrom 把数据从内核复制到进程中，它可以让单个进程具有处<br>理多个I/O 事件的能力</li>
<li>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event<br>Driven I/O，即事件驱动 I/O</li>
<li>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需<br>要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数<br>量的线程</li>
</ol>
<h3 id="select-是什么？"><a href="#select-是什么？" class="headerlink" title="select 是什么？"></a>select 是什么？</h3><p>该函数会等待多个I/O事件(比如读就绪，写)的任何一个发生，并且只要<br>有一个网络事件发生，select 线程就会执行。如果没有任何一个事件发<br>生则阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int select(int maxfdpl,fd_set *readset,fd_set *writeset,fd_set *exceptset,</span><br><span class="line">	const struct timeval *timeout);</span><br></pre></td></tr></table></figure>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为<br>就绪状态，从而完成 I/O 操作</p>
<h3 id="poll-是什么？"><a href="#poll-是什么？" class="headerlink" title="poll 是什么？"></a>poll 是什么？</h3><p>poll 的功能与select 类似，也是等待一组描述符中的一个成为就绪状态</p>
<h3 id="epoll-是什么？"><a href="#epoll-是什么？" class="headerlink" title="epoll 是什么？"></a>epoll 是什么？</h3><p>epoll 是线程安全的，不仅告诉你sock组里面数据，还会告诉你具体哪个<br>sock有数据，你不用自己去找了</p>
<h3 id="select和poll的区别？"><a href="#select和poll的区别？" class="headerlink" title="select和poll的区别？"></a>select和poll的区别？</h3><ol>
<li>select 会修改描述符，而 poll 不会</li>
</ol>
<h3 id="recvfrom-是什么？"><a href="#recvfrom-是什么？" class="headerlink" title="recvfrom 是什么？"></a>recvfrom 是什么？</h3><p>recvfrom一般用于UDP协议中，但是如果在TCP中connect函数调用后也可以<br>用。用于从（已连接）套接口上接收数据，并捕获数据发送源的地址</p>
<h3 id="Epoll和Poll和Select？"><a href="#Epoll和Poll和Select？" class="headerlink" title="Epoll和Poll和Select？"></a>Epoll和Poll和Select？</h3><p>select/poll/epoll 都是 I/O 多路复用的具体实现</p>
<ol>
<li>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为<br>就绪状态，从而完成 I/O 操作</li>
<li>poll poll 的功能与 select 类似，也是等待一组描述符中的一个成为就<br>绪状态，poll 中的描述符是pollfd 类型的数组</li>
<li>epoll 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注<br>册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将I/O 准<br>备好的描述符加入到一个链表中管理</li>
</ol>
<h3 id="阻塞式I-O和I-O复用的区别？"><a href="#阻塞式I-O和I-O复用的区别？" class="headerlink" title="阻塞式I/O和I/O复用的区别？"></a>阻塞式I/O和I/O复用的区别？</h3><ol>
<li>阻塞式I/O和I/O复用，两个阶段都阻塞，等待数据和将数据复制到用户进<br>程这两个阶段都是阻塞的</li>
<li>虽然第一阶段都是阻塞，但是阻塞式I/O如果要接收更多的连接，就必须创<br>建更多的线程。I/O复用模式下在第一个阶段大量的连接统统都可以过来直接注<br>册到Selector复用器上面，同时只要单个或者少量的线程来循环处理这些连<br>接事件就可以了，一旦达到“就绪”的条件，就可以立即执行真正的I/O操作。<br>这就是I/O复用与传统的阻塞式I/O最大的不同</li>
</ol>
<h3 id="信号驱动I-O-是什么？"><a href="#信号驱动I-O-是什么？" class="headerlink" title="信号驱动I/O 是什么？"></a>信号驱动I/O 是什么？</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续<br>执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向<br>应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用<br>recvfrom 将数据从内核复制到应用进程中</p>
<h3 id="异步I-O-是什么？"><a href="#异步I-O-是什么？" class="headerlink" title="异步I/O 是什么？"></a>异步I/O 是什么？</h3><p>真正的异步I/O 是内核数据准备好和数据从内核态拷贝到用户态这两个过<br>程都不用等待，当用户发起aio_read请求后就会自动返回。内核会自动将<br>数据从内核缓冲区拷贝到用户进程空间，应用进程啥都不用管，内核会在<br>所有操作完成之后向应用进程发送信号。<br>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用<br>进程I/O 完成，而信号驱动I/O 的信号是通知应用进程可以开始 I/O</p>
<h3 id="异步是什么？"><a href="#异步是什么？" class="headerlink" title="异步是什么？"></a>异步是什么？</h3><p>对于异步来说，用户进行读或者写后，将立刻返回，由内核去完成数据读取<br>以及拷贝工作，完成后通知用户，并执行回调函数（用户提供的callback<br>），此时数据已从内核拷贝到用户空间，用户线程只需要对数据进行处理<br>即可，不需要关注读写，用户不需要等待内核对数据的复制操作，用户在<br>得到通知时数据已经被复制到用户空间</p>
<h3 id="同步的异步的区别？"><a href="#同步的异步的区别？" class="headerlink" title="同步的异步的区别？"></a>同步的异步的区别？</h3><ol>
<li>同步跟异步的区别在于数据从内核空间拷贝到用户空间是否由用户线程<br>完成，这里又分为同步阻塞跟同步非阻塞两种</li>
<li>同步阻塞 此时一个线程维护一个连接，该线程完成数据到读写跟处理<br>到全部过程，数据读写时时线程是被阻塞的</li>
<li>同步非阻塞 非阻塞的意思是用户线程发出读请求后，读请求不会阻塞<br>当前用户线程，不过用户线程还是要不断的去主动判断数据是否准备OK了<br>。此时还是会阻塞等待内核复制数据到用户进程。他与同步BIO区别是使用<br>一个连接全程等待</li>
<li>同步在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一<br>旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用<br>的结果</li>
<li>异步调用在发出之后，这个调用就直接返回了，所以没有返回结果。换<br>句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<br>调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处<br>理这个调用</li>
</ol>
<h3 id="Java-IO分为哪几种？"><a href="#Java-IO分为哪几种？" class="headerlink" title="Java IO分为哪几种？"></a>Java IO分为哪几种？</h3><ol>
<li>BIO：同步阻塞IO</li>
<li>NIO：同步非阻塞IO</li>
<li>AIO：异步非阻塞IO</li>
</ol>
<h3 id="BIO-是什么？"><a href="#BIO-是什么？" class="headerlink" title="BIO 是什么？"></a>BIO 是什么？</h3><ol>
<li>同步阻塞IO，每个客户端的Socket连接请求，服务端都会对应有个处理<br>线程与之对应，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当<br>于是一个连接一个线程</li>
<li>使用一个独立的线程维护一个socket连接，随着连接数量的增多，对虚<br>拟机造成一定压力</li>
<li>使用流来读取数据，流是阻塞的，当没有可读/可写数据时，线程等待<br>，会造成资源的浪费</li>
</ol>
<h3 id="NIO-是什么？"><a href="#NIO-是什么？" class="headerlink" title="NIO 是什么？"></a>NIO 是什么？</h3><ol>
<li>同步非阻塞，也就是说如果你调用NIO接口去执行IO操作，其实还是同步<br>等待的，但是在底层的IO操作上 ，会对系统内核发起非阻塞IO请求，以非<br>阻塞的形式来执行IO。也就是说，如果底层数据没到位，那么内核返回异常<br>信息，不会阻塞住，但是NIO接口内部会采用非阻塞方式过一会儿再次调用<br>内核发起IO请求，直到成功为止。但是之所以说是同步非阻塞，这里的“同<br>步”指的就是因为在你的Java代码调用NIO接口层面是同步的，你还是要同<br>步等待底层IO操作真正完成了才可以返回，只不过在执行底层IO的时候采<br>用了非阻塞的方式来执行罢了</li>
<li>服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发<br>现某个Socket端口上有数据可读时说明读就绪，则调用该socket连接的相<br>应读操作。如果发现某个 Socket端口上有数据可写时说明写就绪，则调用<br>该socket连接的相应写操作。如果某个端口的Socket连接已经中断，则调<br>用相应的析构方法关闭该端口</li>
<li>每个线程中包含一个Selector对象，它相当于一个通道管理器，可以实<br>现在一个线程中处理多个通道的目的，减少线程的创建数量。远程连接对应<br>一个channel，数据的读写通过buffer均在同一个channel中完成，并且<br>数据的读写是非阻塞的</li>
<li>通道创建后需要注册在selector中，同时需要为该通道注册感兴趣事件<br>（客户端连接服务端事件、服务端接收客户端连接事件、读事件、写事件），<br>selector线程需要采用轮训的方式调用selector的select函数，直到所<br>有注册通道中有兴趣的事件发生，则返回，否则一直阻塞。而后循环处理<br>所有就绪的感兴趣事件。以上步骤解决BIO的两个瓶颈：</li>
</ol>
<ul>
<li>不必对每个连接分别创建线程</li>
<li>数据读写非阻塞</li>
</ul>
<p>Java NIO由以下三个核心部分组成</p>
<ol>
<li>selector：Selector 允许单线程处理多个Channel。如果你的应用打开<br>了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便<br>。要使用Selector，得向Selector注册Channel，然后调用他的select 方<br>法，这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回<br>，线程就可以处理这些事件，事件的例子入有新连接接进来，数据接收等</li>
<li>Channel：基本上所有的IO在NIO中都从一个Channel开始。Channel有点<br>像流，数据可以从channel读到buffer，也可以从buffer写到channel</li>
<li>Buffer：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个<br>容器对象( 含数组)，该对象提供了一组方法，可以更轻松的使用内存块，缓<br>冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变换情况，Channel<br>提供从文件，网络读取数据的渠道，但是读取或者写入的数据都必须经由Buffer</li>
</ol>
<h3 id="NIO-和IO-多路复用的关系？"><a href="#NIO-和IO-多路复用的关系？" class="headerlink" title="NIO 和IO 多路复用的关系？"></a>NIO 和IO 多路复用的关系？</h3><ol>
<li>实际上，如果基于NIO进行网络通信，采取的就是多路复用的IO模型，这个<br>多路复用IO模型针对的是网络通信中的IO场景来说的</li>
<li>简单来说，就是在基于Socket进行网络通信的时候，如果有多个客户端跟<br>你的服务端建立了Socket连接，那你就需要维护多个Socket连接</li>
<li>而所谓的多路复用IO模型，就是说你的Java代码直接通过一个select函数<br>调用，直接会进入一个同步等待的状态。必须在这里同步等待某个Socket连接<br>有请求到来，接着你就要同步等着select函数去对底层的多个Socket 连接<br>进行轮询，不断的查看各个 Socket 连接谁有请求到达，就可以让select<br>函数返回</li>
<li>select函数在底层会通过非阻塞的方式轮询各个Socket，任何一个Socket<br>如果没有数据到达，那么非阻塞的特性会立即返回一个信息，然后select函数<br>可以轮询下一个Socket，不会阻塞在某个Socket上</li>
<li>这就是所谓的“同步非阻塞”，但是因为操作系统把上述工作都封装在一个<br>select函数调用里了，可以对多路Socket连接同时进行监视，所以就把这种<br>模型称之为“IO多路复用”模型</li>
<li>通过这种IO多路复用的模型，就可以用一个线程，调用一个select函数<br>，然后监视大量的客户端连接</li>
</ol>
<h3 id="AIO-是什么？"><a href="#AIO-是什么？" class="headerlink" title="AIO 是什么？"></a>AIO 是什么？</h3><ol>
<li>AIO是异步非阻塞IO，相比NIO更进一步，进程读取数据时只负责发送跟接<br>收指令，数据的准备工作完全由操作系统来处理</li>
<li>可以基于AIO API发起一个请求，比如说接收网络数据，AIO API底层会<br>基于异步IO模型来调用操作系统内核，此时不需要去管这个IO是否成功了，<br>AIO接口会直接返回</li>
<li>BIO、NIO都是同步的，你发起IO请求，都必须同步等待IO操作完成</li>
<li>不过你需要提供一个回调函数给AIO接口，一旦底层系统内核完成了具体<br>的IO请求，比如网络读写之类的，就会回调你提供的回调函数</li>
</ol>
<h3 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h3><p>协程是比线程更小的一种执行单元，你可以认为是轻量级的线程，一个线<br>程也可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程<br>序所控制（也就是在用户态执行）</p>
<h3 id="为什么是轻量级的线程？"><a href="#为什么是轻量级的线程？" class="headerlink" title="为什么是轻量级的线程？"></a>为什么是轻量级的线程？</h3><p>协成是基于线程实现的，协程的创建、切换、销毁都是在某个线程中来进行的<br>，协程占用内存少，只需要极少的栈内存（大概是4～5KB），默认情况下，<br>线程栈的大小为1MB</p>
<h3 id="协程和线程的区别？"><a href="#协程和线程的区别？" class="headerlink" title="协程和线程的区别？"></a>协程和线程的区别？</h3><ol>
<li>线程在进行切换的时候，需要将CPU中的寄存器的信息存储起来，然后读<br>入另外一个线程的数据</li>
<li>线程的切换会涉及到用户模式到内核模式的切换，据说每次模式切换都<br>需要执行上千条指令</li>
<li>线程切换时CPU的高速缓存中的数据，也可能失效，需要重新加载</li>
<li>协程在切换的时候，寄存器需要保存和加载的数据量比较小</li>
<li>协程没有用户模式到内核模式的切换操作</li>
<li>更有效率的调度，因为协程是非抢占式的，前一个协程执行完毕或者堵塞<br>，才会让出CPU，而线程则一般使用了时间片的算法，会进行很多没有必要的<br>切换</li>
<li>无需系统自动切换（系统自动切换会浪费很多的资源），而协程是我们用<br>户手动切换，而且是在同一个栈上执行，速度就会非常快而且省资源</li>
</ol>
<h3 id="Linux下如何查看tcp连接？"><a href="#Linux下如何查看tcp连接？" class="headerlink" title="Linux下如何查看tcp连接？"></a>Linux下如何查看tcp连接？</h3><p>netstat -nat|grep -i “80”|wc -l</p>
<h3 id="网络监听需要什么函数？"><a href="#网络监听需要什么函数？" class="headerlink" title="网络监听需要什么函数？"></a>网络监听需要什么函数？</h3><ol>
<li>listen listent函数创建一个监听队列以存放待处理的客户连接，将套接字<br>sockfd指定为被监听的socket</li>
</ol>
<h3 id="互斥锁和信号量的区别？"><a href="#互斥锁和信号量的区别？" class="headerlink" title="互斥锁和信号量的区别？"></a>互斥锁和信号量的区别？</h3><ol>
<li>互斥锁和互斥量是一个意思，互斥锁的作用就是互斥，是用来保护临界区的</li>
<li>信号量是一种更高级的同步机制，mutex（互斥锁）可以说是信号量在仅取<br>值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而<br>不单单是线程间互斥 </li>
</ol>
<h3 id="互斥锁与自旋锁的区别？"><a href="#互斥锁与自旋锁的区别？" class="headerlink" title="互斥锁与自旋锁的区别？"></a>互斥锁与自旋锁的区别？</h3><ol>
<li>重量级锁需要通过操作系统自身的互斥量（mutex lock，也称为互斥锁）<br>来实现，然而这种实现方式需要通过用户态与和核心态的切换来实现，但这个<br>切换的过程会带来很大的性能开销</li>
<li>申请锁时，从用户态进入内核态，申请到后从内核态返回用户态（两次切<br>换），没有申请到时阻塞睡眠在内核态。使用完资源后释放锁，从用户态进入<br>内核态，唤醒阻塞等待锁的进程，返回用户态（又两次切换），被唤醒进程<br>在内核态申请到锁，返回用户态（可能其他申请锁的进程又要阻塞）。所以<br>，使用一次锁，包括申请，持有到释放，当前进程要进行四次用户态与内<br>核态的切换。同时其他竞争锁的进程在这个过程中也要进行一次切换</li>
<li>自旋锁与互斥锁不同的是自旋锁不会引起调用者睡眠。如果自旋锁已经被<br>别的进程保持，调用者就轮询（不断的消耗CPU的时间）是否该自旋锁的保<br>持者已经释放了锁</li>
<li>在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号<br>量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒<br>休眠的线程</li>
</ol>
<h3 id="sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"><a href="#sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？" class="headerlink" title="sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？"></a>sleep让进程睡眠，那我们能不能做到微妙级别的sleep呢？</h3><ol>
<li>usleep()函数 单位是微秒</li>
</ol>
<h3 id="磁盘坏掉了，操作系统是怎么处理应对的？"><a href="#磁盘坏掉了，操作系统是怎么处理应对的？" class="headerlink" title="磁盘坏掉了，操作系统是怎么处理应对的？"></a>磁盘坏掉了，操作系统是怎么处理应对的？</h3><ol>
<li>磁盘扫描工具扫描磁盘驱动器</li>
</ol>
<h3 id="缓存？"><a href="#缓存？" class="headerlink" title="缓存？"></a>缓存？</h3><p>缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，因此<br>速率很快</p>
<h3 id="进程的内存空间分布？"><a href="#进程的内存空间分布？" class="headerlink" title="进程的内存空间分布？"></a>进程的内存空间分布？</h3><p>用户空间被分为几个段，从高地址到低地址分别为：Stack, Heap, BSS,<br>Data, Text</p>
<ol>
<li>程序段(Text):程序代码在内存中的映射，存放函数体的二进制代码</li>
<li>初始化过的数据(Data):在程序运行初已经对变量进行初始化的数据</li>
<li>未初始化过的数据(BSS):在程序运行初未对变量进行初始化的数据</li>
<li>堆 (Heap):存储动态内存分配，需要程序员手工分配，手工释放</li>
<li>栈 (Stack):存储局部、临时变量，函数调用时，存储函数的返回指针，<br>用于控制函数的调用和返回。在程序块开始时自动分配内存，结束时自动<br>释放内存</li>
</ol>
<h3 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h3><ol>
<li>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的<br>程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处<br>继续执行原来的程序</li>
<li>中断一般三类，一种是由CPU外部引起的，称为外中断。如I/O中断、时钟中<br>断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，<br>地址越界、浮点溢出）称为内中断，或者（异常，陷入），最后一种是在程序<br>中使用了系统调用引起的</li>
<li>中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中<br>断处理主要由软件实施</li>
</ol>
<h3 id="CPU在中断时会干嘛？"><a href="#CPU在中断时会干嘛？" class="headerlink" title="CPU在中断时会干嘛？"></a>CPU在中断时会干嘛？</h3><p>中断是CPU响应外设需求的一种模式，在外设需要CPU时，会向中断控制器发送<br>中断请求，这时CPU 要保护现场，即把正在运行的程序保存起来，一般是把状<br>态压入堆栈，然后读中断号，启动相应的中断服务程序，服务完成后，载入保<br>护现场，即把堆栈的数据弹出，继续运行之前的程序</p>
<h3 id="中断分为几种？"><a href="#中断分为几种？" class="headerlink" title="中断分为几种？"></a>中断分为几种？</h3><ol>
<li>中断(Interruption)，也称外中断，指来自CPU执行指令以外的事件的发<br>生，如设备发出的I/O 结束中断，表示设备输入/输出处理已经完成，希望处<br>理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序<br>继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动<br>定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们<br>与当前处理机运行的程序无关</li>
<li>异常（陷入），也叫内中断。是由CPU内部事件所引起的中断，例如进程在<br>运算中发生了上溢或者下溢，有如程序出错，如非法指令，地址越界等。通常<br>把这类中断称为内中断或者陷入。若系统发现有陷入事件，CPU也将暂停正在<br>执行的程序，转去执行该陷入事件的处理程序</li>
</ol>
<h3 id="如何处理中断？"><a href="#如何处理中断？" class="headerlink" title="如何处理中断？"></a>如何处理中断？</h3><ol>
<li>屏蔽中断 当处理机正在处理一个中断时，将屏蔽掉所有的中断，即处理机<br>对任何新到的中断请求，都暂时不予理睬，而让他们等待，直到处理机已完成<br>本次中断的处理后，处理机再去检查是否有中断发生，不适合用于对实时性要<br>求较高的中断请求</li>
<li>嵌套中断 当同时有多个不同优先级的中断请求时，CPU优先响应最高优先<br>级的中断请求</li>
</ol>
<h3 id="中断程序处理过程？"><a href="#中断程序处理过程？" class="headerlink" title="中断程序处理过程？"></a>中断程序处理过程？</h3><ol>
<li>测定是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU的现场并退出中断</li>
</ol>
<h3 id="为什么要内核态-用户态？"><a href="#为什么要内核态-用户态？" class="headerlink" title="为什么要内核态/用户态？"></a>为什么要内核态/用户态？</h3><ol>
<li>在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃<br>，比如清内存、设置时钟等</li>
<li>CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作<br>系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令</li>
</ol>
<h3 id="多路复用的那三种方式有什么区别？"><a href="#多路复用的那三种方式有什么区别？" class="headerlink" title="多路复用的那三种方式有什么区别？"></a>多路复用的那三种方式有什么区别？</h3><ol>
<li>select</li>
</ol>
<ul>
<li>select能监控的描述符个数由内核中的FD_SETSIZE限制，仅为1024，这也<br>是select最大的缺点，因为现在的服务器并发量远远不止1024</li>
<li>每次调用select都会线性扫描所有描述符的状态，在select结束后，用户<br>也要线性扫描fd_set数组才知道哪些描述符准备就绪，等于说每次调用复杂<br>度都是O（n）的，在并发量大的情况下，每次扫描都是相当耗时的，很有可<br>能有未处理的连接等待超时</li>
<li>每次调用select都要在用户空间和内核空间里进行内存复制fd描述符等信息</li>
</ul>
<ol start="2">
<li>poll</li>
</ol>
<ul>
<li>poll使用pollfd结构来存储fd，突破了select中描述符数目的限制</li>
<li>与select的后两点类似，poll仍然需要将pollfd数组拷贝到内核空间，之<br>后依次扫描fd的状态，整体复杂度依然是O（n）的，在并发量大的情况下服<br>务器性能会快速下降</li>
</ul>
<ol start="3">
<li>epoll</li>
</ol>
<ul>
<li>epoll维护的描述符数目不受到限制，而且性能不会随着描述符数目的增加<br>而下降</li>
<li>epoll在传递内核与用户空间的消息时使用了内存共享，而不是内存拷贝，<br>这也使得epoll的效率比poll和select更高</li>
</ul>
<h3 id="fd是什么？"><a href="#fd是什么？" class="headerlink" title="fd是什么？"></a>fd是什么？</h3><ol>
<li>fd全称是file descriptor，是进程独有的文件描述符表的索引</li>
<li>每当进程用open（）函数打开一个文件，内核便会返回该文件的文件操作<br>符（一个非负的整形值），此后所有对该文件的操作，都会以返回的fd文件<br>操作符为参数</li>
</ol>
<h3 id="多路复用怎么解决阻塞IO-存在的问题？"><a href="#多路复用怎么解决阻塞IO-存在的问题？" class="headerlink" title="多路复用怎么解决阻塞IO 存在的问题？"></a>多路复用怎么解决阻塞IO 存在的问题？</h3><ol>
<li>异步编程框架是说框架内的业务代码与框架的接口是异步的，而框架与操<br>作系统的接口是同步非阻塞</li>
</ol>
<h3 id="查看内存的命令？"><a href="#查看内存的命令？" class="headerlink" title="查看内存的命令？"></a>查看内存的命令？</h3><ol>
<li>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的<br>资源占用状况</li>
<li>pmap -d 5647 可以根据进程查看进程相关信息占用的内存情况</li>
<li>free Linux的free命令是常用来查看内存的命令</li>
</ol>
<h3 id="查看日志的命令？"><a href="#查看日志的命令？" class="headerlink" title="查看日志的命令？"></a>查看日志的命令？</h3><ol>
<li>tail -n 10 test.log 查询日志尾部最后10行的日志</li>
<li>head 跟tail是相反的head是看前多少行日志</li>
</ol>
<h3 id="Linux-查看文件中是否存在某字符"><a href="#Linux-查看文件中是否存在某字符" class="headerlink" title="Linux 查看文件中是否存在某字符"></a>Linux 查看文件中是否存在某字符</h3><ol>
<li>grep “port:8080” pro.sh 查找pro文件中是否包含port:8080 内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep 指定字符串 文件的完整路径</span><br><span class="line">若不清楚字符串的大小写，可以在命令末尾加 -i ，这样查询将忽略字符串的大小写</span><br><span class="line">若需要查询指定字符串在文件中的位置，可以在命令末尾加 -n</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="linux如何分割文件字符串？"><a href="#linux如何分割文件字符串？" class="headerlink" title="linux如何分割文件字符串？"></a>linux如何分割文件字符串？</h3><ol>
<li>cut<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d 指定分隔符，如：按照“：”分割，-d:</span><br><span class="line">-c 提取第n个字节，如：-c5,表示提取每行的第5个字节</span><br><span class="line">-f 指定输出的域</span><br><span class="line">cut –d: -f1,2 &#x2F;&#x2F;按照”:”来分割，并输出第1和2段</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用的消息队列以及区别？"><a href="#常用的消息队列以及区别？" class="headerlink" title="常用的消息队列以及区别？"></a>常用的消息队列以及区别？</h3><p>消息队列是分布式应用间交换信息的重要组件，消息队列可驻留在内存或磁盘<br>上，队列可以存储消息直到它们被应用程序读走</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>计算机网络总结</span></a></div><div class="next-post pull-right"><a href="/2021/01/04/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"><span>MySQL总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/01/04/操作系统总结/';
  this.page.title = '操作系统总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>