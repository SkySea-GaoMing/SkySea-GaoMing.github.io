<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机网络总结"><meta name="keywords" content="NetWork"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>计算机网络总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题总结"><span class="toc-number">2.</span> <span class="toc-text">面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI是什么？"><span class="toc-number">2.1.</span> <span class="toc-text">OSI是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI七层模型与TCP-IP四层模型是怎样的？"><span class="toc-number">2.2.</span> <span class="toc-text">OSI七层模型与TCP&#x2F;IP四层模型是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要分层？"><span class="toc-number">2.3.</span> <span class="toc-text">为什么要分层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分层的缺点？"><span class="toc-number">2.4.</span> <span class="toc-text">分层的缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络协议是什么？"><span class="toc-number">2.5.</span> <span class="toc-text">网络协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-S和C-S和P2P架构？"><span class="toc-number">2.6.</span> <span class="toc-text">B&#x2F;S和C&#x2F;S和P2P架构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-S和C-S的区别？"><span class="toc-number">2.7.</span> <span class="toc-text">B&#x2F;S和C&#x2F;S的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#吞吐量是什么？"><span class="toc-number">2.8.</span> <span class="toc-text">吞吐量是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#往返时间RTT是什么？"><span class="toc-number">2.9.</span> <span class="toc-text">往返时间RTT是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用率是什么？"><span class="toc-number">2.10.</span> <span class="toc-text">利用率是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单工通信是什么？"><span class="toc-number">2.11.</span> <span class="toc-text">单工通信是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#半双工通信是什么？"><span class="toc-number">2.12.</span> <span class="toc-text">半双工通信是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全双工通信是什么？"><span class="toc-number">2.13.</span> <span class="toc-text">全双工通信是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#应用层常见协议，对应的端口有哪些？"><span class="toc-number">2.13.1.</span> <span class="toc-text">应用层常见协议，对应的端口有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#各层的常见协议有哪些？"><span class="toc-number">2.14.</span> <span class="toc-text">各层的常见协议有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#各层传递对象？"><span class="toc-number">2.15.</span> <span class="toc-text">各层传递对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI七层的各自设备？"><span class="toc-number">2.16.</span> <span class="toc-text">OSI七层的各自设备？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI七层各自的作用？"><span class="toc-number">2.17.</span> <span class="toc-text">OSI七层各自的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络层和传输层的区别"><span class="toc-number">2.18.</span> <span class="toc-text">网络层和传输层的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP地址的结构？"><span class="toc-number">2.19.</span> <span class="toc-text">IP地址的结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP地址如何分类？"><span class="toc-number">2.20.</span> <span class="toc-text">IP地址如何分类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子网的作用？"><span class="toc-number">2.21.</span> <span class="toc-text">子网的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子网掩码的作用？"><span class="toc-number">2.22.</span> <span class="toc-text">子网掩码的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是超网？"><span class="toc-number">2.23.</span> <span class="toc-text">什么是超网？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP-RARP协议是什么？"><span class="toc-number">2.24.</span> <span class="toc-text">ARP&#x2F;RARP协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP协议和ARP协议是什么？"><span class="toc-number">2.25.</span> <span class="toc-text">IP协议和ARP协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT协议是什么？"><span class="toc-number">2.26.</span> <span class="toc-text">NAT协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DHCP协议是什么？"><span class="toc-number">2.27.</span> <span class="toc-text">DHCP协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么理解WebSocket协议？"><span class="toc-number">2.28.</span> <span class="toc-text">怎么理解WebSocket协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用WebSocket？"><span class="toc-number">2.29.</span> <span class="toc-text">为什么使用WebSocket？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket和Socket的区别是什么？"><span class="toc-number">2.30.</span> <span class="toc-text">WebSocket和Socket的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Http与WebSocket的区别？"><span class="toc-number">2.31.</span> <span class="toc-text">Http与WebSocket的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输入一个URL，到打开网页的过程中发生了什么？"><span class="toc-number">2.31.1.</span> <span class="toc-text">输入一个URL，到打开网页的过程中发生了什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS什么情况使用UDP和TCP？"><span class="toc-number">2.32.</span> <span class="toc-text">DNS什么情况使用UDP和TCP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP是什么？"><span class="toc-number">2.33.</span> <span class="toc-text">HTTP是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求报文和响应报文的区别？"><span class="toc-number">2.34.</span> <span class="toc-text">请求报文和响应报文的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求方法有哪些？"><span class="toc-number">2.35.</span> <span class="toc-text">请求方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见状态码的含义有哪些？"><span class="toc-number">2.36.</span> <span class="toc-text">常见状态码的含义有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#301和302状态码有什么区别？"><span class="toc-number">2.37.</span> <span class="toc-text">301和302状态码有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-常见字段有哪些？"><span class="toc-number">2.38.</span> <span class="toc-text">http 常见字段有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET和POST的区别？"><span class="toc-number">2.39.</span> <span class="toc-text">GET和POST的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全方法和不安全方法有哪些？"><span class="toc-number">2.40.</span> <span class="toc-text">安全方法和不安全方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#幂等性了解吗？"><span class="toc-number">2.41.</span> <span class="toc-text">幂等性了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP的特性有哪些？"><span class="toc-number">2.42.</span> <span class="toc-text">HTTP的特性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？"><span class="toc-number">2.43.</span> <span class="toc-text">谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1与HTTP-1-0的区别？"><span class="toc-number">2.44.</span> <span class="toc-text">HTTP&#x2F;1.1与HTTP&#x2F;1.0的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1的流水线技术是什么？"><span class="toc-number">2.45.</span> <span class="toc-text">HTTP&#x2F;1.1的流水线技术是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-0了解吗？"><span class="toc-number">2.46.</span> <span class="toc-text">HTTP&#x2F;2.0了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-0优点有哪些？"><span class="toc-number">2.47.</span> <span class="toc-text">HTTP&#x2F;2.0优点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-3是什么？"><span class="toc-number">2.48.</span> <span class="toc-text">HTTP&#x2F;3是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-是什么？"><span class="toc-number">2.49.</span> <span class="toc-text">HTTPS 是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP和HTTPS有什么区别？HTTPS的S是什么意思？"><span class="toc-number">2.49.1.</span> <span class="toc-text">HTTP和HTTPS有什么区别？HTTPS的S是什么意思？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#混合加密如何实现？"><span class="toc-number">2.50.</span> <span class="toc-text">混合加密如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#摘要算法是什么？"><span class="toc-number">2.51.</span> <span class="toc-text">摘要算法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#证书是什么？有什么作用？"><span class="toc-number">2.52.</span> <span class="toc-text">证书是什么？有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie的作用是什么？"><span class="toc-number">2.53.</span> <span class="toc-text">Cookie的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何生成Cookie？"><span class="toc-number">2.54.</span> <span class="toc-text">如何生成Cookie？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session的作用是什么？"><span class="toc-number">2.55.</span> <span class="toc-text">Session的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session与Cookie的区别有哪些？"><span class="toc-number">2.56.</span> <span class="toc-text">Session与Cookie的区别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie被禁用怎么办？"><span class="toc-number">2.57.</span> <span class="toc-text">Cookie被禁用怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-的属性有哪些？"><span class="toc-number">2.58.</span> <span class="toc-text">Cookie 的属性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向代理是什么？"><span class="toc-number">2.59.</span> <span class="toc-text">反向代理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨域产生的原因？"><span class="toc-number">2.60.</span> <span class="toc-text">跨域产生的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie如何跨域？"><span class="toc-number">2.61.</span> <span class="toc-text">Cookie如何跨域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决跨域？"><span class="toc-number">2.62.</span> <span class="toc-text">如何解决跨域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解对称加密算法和非对称加密算法的区别吗？"><span class="toc-number">2.63.</span> <span class="toc-text">了解对称加密算法和非对称加密算法的区别吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是数字签名？"><span class="toc-number">2.64.</span> <span class="toc-text">什么是数字签名？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP采用的加密方式是怎样的？"><span class="toc-number">2.65.</span> <span class="toc-text">HTTP采用的加密方式是怎样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS握手过程是怎样？"><span class="toc-number">2.65.1.</span> <span class="toc-text">TLS握手过程是怎样？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理和网关是什么？"><span class="toc-number">2.66.</span> <span class="toc-text">代理和网关是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的攻击手段（XSS、CSRF）有哪些？"><span class="toc-number">2.67.</span> <span class="toc-text">常见的攻击手段（XSS、CSRF）有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS攻击过程？"><span class="toc-number">2.68.</span> <span class="toc-text">XSS攻击过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何防范XSS攻击？"><span class="toc-number">2.69.</span> <span class="toc-text">如何防范XSS攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie的类型？"><span class="toc-number">2.70.</span> <span class="toc-text">Cookie的类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF攻击过程？"><span class="toc-number">2.71.</span> <span class="toc-text">CSRF攻击过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF攻击如何防范？"><span class="toc-number">2.72.</span> <span class="toc-text">CSRF攻击如何防范？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS的优缺点有哪些？"><span class="toc-number">2.73.</span> <span class="toc-text">HTTPS的优缺点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http通信存在的问题"><span class="toc-number">2.74.</span> <span class="toc-text">http通信存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-怎么建立连接？"><span class="toc-number">2.75.</span> <span class="toc-text">HTTPS 怎么建立连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解哪些加密算法？"><span class="toc-number">2.76.</span> <span class="toc-text">了解哪些加密算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https（问为什么要对称加密数据，而不用非对称加密数据呢）？"><span class="toc-number">2.77.</span> <span class="toc-text">https（问为什么要对称加密数据，而不用非对称加密数据呢）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP和UDP的区别？"><span class="toc-number">2.78.</span> <span class="toc-text">TCP和UDP的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UPD相对TCP优点和缺点？"><span class="toc-number">2.79.</span> <span class="toc-text">UPD相对TCP优点和缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#端口的作用？"><span class="toc-number">2.80.</span> <span class="toc-text">端口的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP首部字段有哪些？"><span class="toc-number">2.81.</span> <span class="toc-text">TCP首部字段有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP三次握手的过程是怎样的（含状态转换，报文中的参数）？"><span class="toc-number">2.82.</span> <span class="toc-text">TCP三次握手的过程是怎样的（含状态转换，报文中的参数）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收端为什么要传回SYN？"><span class="toc-number">2.83.</span> <span class="toc-text">接收端为什么要传回SYN？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传了SYN-为啥还要传ACK？"><span class="toc-number">2.84.</span> <span class="toc-text">传了SYN,为啥还要传ACK？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要三次握手而不是两次？"><span class="toc-number">2.85.</span> <span class="toc-text">为什么要三次握手而不是两次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四次握手是什么情况？"><span class="toc-number">2.86.</span> <span class="toc-text">四次握手是什么情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三次握手失败了怎么办？"><span class="toc-number">2.87.</span> <span class="toc-text">第三次握手失败了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP四次挥手的过程是怎样的（含状态转换，报文中的参数）"><span class="toc-number">2.88.</span> <span class="toc-text">TCP四次挥手的过程是怎样的（含状态转换，报文中的参数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么挥手要四次，而握手只要三次？"><span class="toc-number">2.89.</span> <span class="toc-text">为什么挥手要四次，而握手只要三次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么-TIME-WAIT-状态需要经过-2MSL-才能转换到-CLOSE-状态？"><span class="toc-number">2.90.</span> <span class="toc-text">为什么 TIME_WAIT 状态需要经过 2MSL 才能转换到 CLOSE 状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-time状态是哪个阶段？"><span class="toc-number">2.91.</span> <span class="toc-text">wait_time状态是哪个阶段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timewait一定只能在客户端吗？"><span class="toc-number">2.92.</span> <span class="toc-text">timewait一定只能在客户端吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么优化timewait过多？"><span class="toc-number">2.93.</span> <span class="toc-text">怎么优化timewait过多？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timewait需要等待多少？"><span class="toc-number">2.94.</span> <span class="toc-text">timewait需要等待多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN攻击了解么？"><span class="toc-number">2.95.</span> <span class="toc-text">SYN攻击了解么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么防范SYN攻击？"><span class="toc-number">2.96.</span> <span class="toc-text">怎么防范SYN攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP如何保证可靠传输？"><span class="toc-number">2.97.</span> <span class="toc-text">TCP如何保证可靠传输？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP拥塞控制的过程（四个状态都要解释清楚）是什么样的？"><span class="toc-number">2.98.</span> <span class="toc-text">TCP拥塞控制的过程（四个状态都要解释清楚）是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP滑动窗口机制是什么？"><span class="toc-number">2.99.</span> <span class="toc-text">TCP滑动窗口机制是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#固定窗口机制？"><span class="toc-number">2.100.</span> <span class="toc-text">固定窗口机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动窗口大小机制？"><span class="toc-number">2.101.</span> <span class="toc-text">滑动窗口大小机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动窗口的优势？"><span class="toc-number">2.102.</span> <span class="toc-text">滑动窗口的优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滑动窗口初始值是多少？"><span class="toc-number">2.103.</span> <span class="toc-text">滑动窗口初始值是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送缓存和接收缓存的区别？"><span class="toc-number">2.104.</span> <span class="toc-text">发送缓存和接收缓存的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拥塞窗口与流量窗口有什么区别？"><span class="toc-number">2.105.</span> <span class="toc-text">拥塞窗口与流量窗口有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACK超时会怎么样？"><span class="toc-number">2.106.</span> <span class="toc-text">ACK超时会怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用TCP的协议有哪些？"><span class="toc-number">2.107.</span> <span class="toc-text">使用TCP的协议有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARQ协议是什么？"><span class="toc-number">2.108.</span> <span class="toc-text">ARQ协议是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据包的合成是在哪里进行？"><span class="toc-number">2.109.</span> <span class="toc-text">数据包的合成是在哪里进行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开启Nagle的好处与坏处？"><span class="toc-number">2.110.</span> <span class="toc-text">开启Nagle的好处与坏处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是TCP粘包？"><span class="toc-number">2.111.</span> <span class="toc-text">什么是TCP粘包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#沾包的类型？"><span class="toc-number">2.112.</span> <span class="toc-text">沾包的类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP粘包产生的原因？"><span class="toc-number">2.113.</span> <span class="toc-text">TCP粘包产生的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP粘包如何解决？"><span class="toc-number">2.114.</span> <span class="toc-text">TCP粘包如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP存在粘包问题吗？"><span class="toc-number">2.115.</span> <span class="toc-text">UDP存在粘包问题吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP拆包产生的原因和解法方法是什么？"><span class="toc-number">2.116.</span> <span class="toc-text">TCP拆包产生的原因和解法方法是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#沾包和拆包如何解决？"><span class="toc-number">2.117.</span> <span class="toc-text">沾包和拆包如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP和UDP的区别？各自的应用场景"><span class="toc-number">2.118.</span> <span class="toc-text">TCP和UDP的区别？各自的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现可靠的UDP？"><span class="toc-number">2.119.</span> <span class="toc-text">如何实现可靠的UDP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URI和URL的区别是什么？"><span class="toc-number">2.120.</span> <span class="toc-text">URI和URL的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四次挥手中客户端的-TIME-WAIT-的状态的意义是什么？"><span class="toc-number">2.121.</span> <span class="toc-text">四次挥手中客户端的 TIME-WAIT 的状态的意义是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么http一定要用TCP呢？"><span class="toc-number">2.122.</span> <span class="toc-text">为什么http一定要用TCP呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长连接的好处？"><span class="toc-number">2.123.</span> <span class="toc-text">长连接的好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写一个简单的webserver？"><span class="toc-number">2.124.</span> <span class="toc-text">写一个简单的webserver？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Socket？"><span class="toc-number">2.125.</span> <span class="toc-text">什么是Socket？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是半关闭？什么是半打开？"><span class="toc-number">2.126.</span> <span class="toc-text">什么是半关闭？什么是半打开？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端的close-Wait是什么时候开始的？"><span class="toc-number">2.127.</span> <span class="toc-text">客户端的close-Wait是什么时候开始的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端接收到了服务器的close请求了，客户端不调用close，继续发包会怎么样？"><span class="toc-number">2.128.</span> <span class="toc-text">客户端接收到了服务器的close请求了，客户端不调用close，继续发包会怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么挥手不可以三次？"><span class="toc-number">2.129.</span> <span class="toc-text">为什么挥手不可以三次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何设计http2-0的头部压缩-说了哈夫曼编码或者字典树"><span class="toc-number">2.130.</span> <span class="toc-text">如何设计http2.0的头部压缩(说了哈夫曼编码或者字典树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述一下TCP是怎么发送文件的？"><span class="toc-number">2.131.</span> <span class="toc-text">描述一下TCP是怎么发送文件的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chrome-为什么多进程而不是多线程？"><span class="toc-number">2.132.</span> <span class="toc-text">Chrome 为什么多进程而不是多线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP有了checksum还可能会造成数据错乱吗"><span class="toc-number">2.133.</span> <span class="toc-text">TCP有了checksum还可能会造成数据错乱吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么初始化序列号要随机取，从0开始会出现什么问题？"><span class="toc-number">2.134.</span> <span class="toc-text">为什么初始化序列号要随机取，从0开始会出现什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网页无法响应，分析原因？"><span class="toc-number">2.135.</span> <span class="toc-text">网页无法响应，分析原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-server实现了什么？"><span class="toc-number">2.136.</span> <span class="toc-text">web server实现了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流量控制和拥塞控制有什么区别？"><span class="toc-number">2.137.</span> <span class="toc-text">流量控制和拥塞控制有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#https是用了哪些加密协议？"><span class="toc-number">2.138.</span> <span class="toc-text">https是用了哪些加密协议？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">计算机网络总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/08/计算机网络总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;maybe2030&#x2F;p&#x2F;4781555.html#_label3</span><br><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;468385?type&#x3D;post&amp;order&#x3D;</span><br><span class="line">hot&amp;pos&#x3D;&amp;page&#x3D;1&amp;channel&#x3D;-1&amp;source_id&#x3D;search_post_nctrack</span><br></pre></td></tr></table></figure>
<h2 id="面试题总结"><a href="#面试题总结" class="headerlink" title="面试题总结"></a>面试题总结</h2><h3 id="OSI是什么？"><a href="#OSI是什么？" class="headerlink" title="OSI是什么？"></a>OSI是什么？</h3><p>即开放式系统互联参考模型。 计算机网络的各层及其协议的集合就是网络的<br>体系结构</p>
<h3 id="OSI七层模型与TCP-IP四层模型是怎样的？"><a href="#OSI七层模型与TCP-IP四层模型是怎样的？" class="headerlink" title="OSI七层模型与TCP/IP四层模型是怎样的？"></a>OSI七层模型与TCP/IP四层模型是怎样的？</h3><p>OSI七层模型:应用层、表示层、会话层、运输层、网络层、数据链路层和物理层<br>TCP/IP四层模型：应用层、运输层、网际层（解决不同网络互连）和网络接口层<br>五层协议体系结构：应用层、运输层、网络层、数据链路层和物理层</p>
<h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><p>计算机网络是很复杂的，两个计算机必须高度协调工作才行。分层可以将<br>庞大而复杂的问题转化为若干较小的局部问题，这些较小的局部问题就<br>容易研究和处理，换句话说就是将各种特定的功能分隔开，分层结构使<br>各个层次的设计和测试相对独立，各层分别实现不同的功能，下层为上<br>层提供服务</p>
<h3 id="分层的缺点？"><a href="#分层的缺点？" class="headerlink" title="分层的缺点？"></a>分层的缺点？</h3><p>功能可能出现在多个层里，产生了额外开销</p>
<h3 id="网络协议是什么？"><a href="#网络协议是什么？" class="headerlink" title="网络协议是什么？"></a>网络协议是什么？</h3><p>为网络中的数据交换而建立的规则、标准或约定叫做网络协议，有三部分</p>
<ol>
<li>语法 数据与控制信息的结构或格式</li>
<li>语义 需要发出何种控制信息，完成何种动作以及做出何种响应</li>
<li>同步 事件实现顺序的详细说明</li>
</ol>
<h3 id="B-S和C-S和P2P架构？"><a href="#B-S和C-S和P2P架构？" class="headerlink" title="B/S和C/S和P2P架构？"></a>B/S和C/S和P2P架构？</h3><ol>
<li>B/S 即浏览器/服务器结构 只是要求安装一个浏览器</li>
<li>C/S 即客户机/服务器结构 客户端需要安装专用的客户软件</li>
<li>P2P 不区分请求方和服务方 相同软件对等连接</li>
</ol>
<h3 id="B-S和C-S的区别？"><a href="#B-S和C-S的区别？" class="headerlink" title="B/S和C/S的区别？"></a>B/S和C/S的区别？</h3><ol>
<li>硬件要求不同 c/s一般建立在专用的网络上，是小范围的网络环境，<br>而B/S一般构建于广域网上，不需要专门的网络硬件环境，只要能接入网<br>络即可</li>
<li>维护成本 c/s维护成本高，发生一次升级，则所有客户端的程序都需<br>要改变</li>
<li>响应速度 c/s安全性能高，由于只有一层交互，因此响应速度较快</li>
<li>逻辑处理 c/s会处理一些运算，业务逻辑的处理。b/s极少数事务逻辑<br>在前端实现</li>
</ol>
<h3 id="吞吐量是什么？"><a href="#吞吐量是什么？" class="headerlink" title="吞吐量是什么？"></a>吞吐量是什么？</h3><p>单位时间内通过某个网络的实际的数据量。计算机网络中的带宽是指单位时间内<br>网络中的某信道能通过的最高数据率</p>
<h3 id="往返时间RTT是什么？"><a href="#往返时间RTT是什么？" class="headerlink" title="往返时间RTT是什么？"></a>往返时间RTT是什么？</h3><p>互联网上的信息不仅是单方向传输而是双向交互，RTT就表示双向交互一次所需<br>的时间</p>
<h3 id="利用率是什么？"><a href="#利用率是什么？" class="headerlink" title="利用率是什么？"></a>利用率是什么？</h3><p>信道利用率是指某信道有百分之几的时间是被利用的，网络利用率是全网络的<br>信道利用率的加权平均值，利用率过高会产生非常大的时延</p>
<h3 id="单工通信是什么？"><a href="#单工通信是什么？" class="headerlink" title="单工通信是什么？"></a>单工通信是什么？</h3><p>单向通信，只能有一个方向的通信而没有反方向的交互。无线电广播或有线电<br>广播以及电视广播就是这种类型</p>
<h3 id="半双工通信是什么？"><a href="#半双工通信是什么？" class="headerlink" title="半双工通信是什么？"></a>半双工通信是什么？</h3><p>双向交替通信，通信的双方都可以发送信息，但是不能同时发送或接收信息。<br>一方发送另一方接收，过一段时间可以反过来</p>
<h3 id="全双工通信是什么？"><a href="#全双工通信是什么？" class="headerlink" title="全双工通信是什么？"></a>全双工通信是什么？</h3><p>双向同时通信，通信的双方可以同时发送和接收信息</p>
<h4 id="应用层常见协议，对应的端口有哪些？"><a href="#应用层常见协议，对应的端口有哪些？" class="headerlink" title="应用层常见协议，对应的端口有哪些？"></a>应用层常见协议，对应的端口有哪些？</h4><p>FTP 20/21  TFTP 69  TELNET 23  HTTP 80  SMTP 25  DNS 53<br>DHCP 67/68</p>
<h3 id="各层的常见协议有哪些？"><a href="#各层的常见协议有哪些？" class="headerlink" title="各层的常见协议有哪些？"></a>各层的常见协议有哪些？</h3><ol>
<li>应用层： FTP（文件传送协议）、 Telnet（远程登录协议）、 DNS<br>（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），<br>HTTP协议（Hyper Text Transfer Protocol）</li>
<li>运输层：TCP协议（Transmission Control Protocol，传输控制协议）<br>、UDP协议（User Datagram Protocol，用户数据报协议）</li>
<li>网际层：IP协议（Internet Protocol，因特网互联协议）<br>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）<br>ARP协议（Address Resolution Protocol，地址解析协议）<br>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）<br>在TCP/IP模型中，ARP协议属于IP层，在OSI模型中，ARP协议属于链路层</li>
<li>数据链路层：以太网协议</li>
</ol>
<h3 id="各层传递对象？"><a href="#各层传递对象？" class="headerlink" title="各层传递对象？"></a>各层传递对象？</h3><ul>
<li>应用层：报文</li>
<li>传输层：传输协议分组</li>
<li>网络层：IP数据报</li>
<li>数据链路层：帧</li>
</ul>
<h3 id="OSI七层的各自设备？"><a href="#OSI七层的各自设备？" class="headerlink" title="OSI七层的各自设备？"></a>OSI七层的各自设备？</h3><ol>
<li>物理层 中继器和集线器</li>
<li>数据链路层 网桥和交换机</li>
<li>网络层 路由器</li>
<li>传输层 网关</li>
</ol>
<h3 id="OSI七层各自的作用？"><a href="#OSI七层各自的作用？" class="headerlink" title="OSI七层各自的作用？"></a>OSI七层各自的作用？</h3><ol>
<li>物理层 该层为上层协议提供了一个传输数据的可靠的物理媒体。物理层<br>确保原始的数据可在各种物理媒体上传输</li>
<li>数据链路层 数据链路层在物理层提供的服务的基础上向网络层提供服务<br>，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机<br>网络层。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包<br>括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等</li>
<li>网络层 网络层的任务就是选择合适的网间路由和交换结点，确保数据及<br>时传送。网络层还可以实现拥塞控制、网际互连等功能</li>
<li>传输层 负责向两台主机进程之间的通信提供通用的数据传输服务。负责<br>将上层数据分段并提供端到端的、可靠的或不可靠的传输</li>
<li>会话层 会话层管理主机之间的会话进程，即负责建立、管理、终止进程<br>之间的会话</li>
<li>表示层 表示层对上层数据或信息进行变换以保证一个主机应用层信息<br>可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、<br>压缩、格式转换等</li>
<li>应用层 为操作系统或网络应用程序提供访问网络服务的接口</li>
</ol>
<h3 id="网络层和传输层的区别"><a href="#网络层和传输层的区别" class="headerlink" title="网络层和传输层的区别"></a>网络层和传输层的区别</h3><p>网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层<br>则负责将数据可靠地传送到相应的端口，也就是点到点和端到端的区别</p>
<h3 id="IP地址的结构？"><a href="#IP地址的结构？" class="headerlink" title="IP地址的结构？"></a>IP地址的结构？</h3><ol>
<li>A类 0X.XX.XX.XX    8 24</li>
<li>B类 10X.XX.XX.XX   16 16</li>
<li>C类 110X.XX.XX.XX  24 8</li>
<li>D类 1110XX</li>
<li>E类 1111XX 供以后使用</li>
</ol>
<h3 id="IP地址如何分类？"><a href="#IP地址如何分类？" class="headerlink" title="IP地址如何分类？"></a>IP地址如何分类？</h3><ol>
<li>网络地址 IP地址由网络号（包括子网号）和主机号组成，网络地址的主<br>机号为全0，网络地址代表着整个网络</li>
<li>广播地址 通常称为直接广播地址，是为了区分受限广播地址。广播地址<br>与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络<br>的广播地址发送消息时，该网络内的所有主机都能收到该广播消息</li>
<li>组播地址 D类地址是组播地址，负责一对多的通信</li>
<li>255.255.255.255 受限广播地址与一般广播地址（直接广播地址）的区<br>别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址<br>为目的地址的分组</li>
<li>0.0.0.0 用于寻找自己的IP地址 以255.255.255.255为目的地址，向本<br>地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组</li>
<li>回环地址 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用<br>于对本机的测试，用的最多的是127.0.0.1</li>
</ol>
<h3 id="子网的作用？"><a href="#子网的作用？" class="headerlink" title="子网的作用？"></a>子网的作用？</h3><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部<br>分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类<br>地址的更多子网</p>
<h3 id="子网掩码的作用？"><a href="#子网掩码的作用？" class="headerlink" title="子网掩码的作用？"></a>子网掩码的作用？</h3><p>子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其<br>每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式<br>十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同<br>，即表明它们共属于同一子网中</p>
<h3 id="什么是超网？"><a href="#什么是超网？" class="headerlink" title="什么是超网？"></a>什么是超网？</h3><p>使用网络前缀和主机号，把这种通过使用网络前缀来减少路由表项的方式称为<br>路由聚合，也称为构成超网</p>
<h3 id="ARP-RARP协议是什么？"><a href="#ARP-RARP协议是什么？" class="headerlink" title="ARP/RARP协议是什么？"></a>ARP/RARP协议是什么？</h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址<br>获取物理地址的一个TCP/IP协议。ARP命令可用于查询本机ARP缓存中IP地址<br>和MAC地址的对应关系、添加或删除静态对应关系等。<br>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物<br>理地址转换为IP地址</p>
<h3 id="IP协议和ARP协议是什么？"><a href="#IP协议和ARP协议是什么？" class="headerlink" title="IP协议和ARP协议是什么？"></a>IP协议和ARP协议是什么？</h3><p>IP地址就是给互联网上的每一台主机的每一个接口分配一个在全世界范围内<br>是唯一的32位的标识符。<br>不管网络层使用什么协议，在实际的网络链路上传送数据帧时最终还是需<br>要使用硬件地址。ARP协议就是用来通过IP地址解析出MAC地址</p>
<h3 id="NAT协议是什么？"><a href="#NAT协议是什么？" class="headerlink" title="NAT协议是什么？"></a>NAT协议是什么？</h3><p>NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技<br>术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应<br>用于各种类型Internet接入方式和各种类型的网络中。NAT不仅完美地解决<br>了lP 地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏<br>并保护网络内部的计算机</p>
<h3 id="DHCP协议是什么？"><a href="#DHCP协议是什么？" class="headerlink" title="DHCP协议是什么？"></a>DHCP协议是什么？</h3><p>用户不再需要手动配置IP地址等信息。DHCP 配置的内容不仅是IP地址，还包<br>括子网掩码、网关IP地址</p>
<ol>
<li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口<br>68的UDP报文段中，放入具有广播IP 目的地址(255.255.255.255)和源IP地<br>址(0.0.0.0)的IP数据报中。该报文被广播到同一个子网的所有主机上。如果<br>客户端和DHCP 服务器不在同一个子网，就需要使用中继代理</li>
<li>DHCP 服务器收到请求报文之后，发送Offer 报文给客户端，该报文包<br>含了客户端所需要的信息。因为客户端可能收到多个DHCP服务器提供的信<br>息，因此客户端需要进行选择。DHCP 客户使用的UDP端口是68，而DHCP<br>服务器使用的UDP端口是67</li>
<li>如果客户端选择了某个DHCP 服务器提供的信息，那么就发送Request<br>报文给该DHCP 服务器</li>
<li>DHCP 服务器发送Ack 报文，表示客户端此时可以使用提供给它的信息</li>
</ol>
<h3 id="怎么理解WebSocket协议？"><a href="#怎么理解WebSocket协议？" class="headerlink" title="怎么理解WebSocket协议？"></a>怎么理解WebSocket协议？</h3><p>websocket是HTML5的一个新协议，它允许服务端向客户端传递信息，实现<br>浏览器和客户端全双工通信。服务器可以主动向客户端推送信息，客户端也<br>可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技<br>术的一种</p>
<h3 id="为什么使用WebSocket？"><a href="#为什么使用WebSocket？" class="headerlink" title="为什么使用WebSocket？"></a>为什么使用WebSocket？</h3><p>当我们在处理页面数据自动更新的时候，在使用js不断的请求服务器，查看<br>是否有新数据，如果有就获取到新数据，进行对页面信息的跟新，但是当页<br>面长时间没有更新数据时，这样就会存在资源浪费的情况，所以才会使用<br>WebSocket来解决</p>
<h3 id="WebSocket和Socket的区别是什么？"><a href="#WebSocket和Socket的区别是什么？" class="headerlink" title="WebSocket和Socket的区别是什么？"></a>WebSocket和Socket的区别是什么？</h3><p>Socket是应用层与TCP/IP协议通信的中间软件抽象层，它是一组接口。而<br>WebSocket则不同，它是一个完整的应用层协议，包含一套标准的API</p>
<h3 id="Http与WebSocket的区别？"><a href="#Http与WebSocket的区别？" class="headerlink" title="Http与WebSocket的区别？"></a>Http与WebSocket的区别？</h3><ol>
<li>http协议是短链接，因为请求之后，都会关闭连接，下次重新请求数据<br>，需要再次打开连接。WebSocket协议是一种长连接，只需要通过一次请求<br>来初始化链接，然后所有的请求和响应都是通过这个TCP 链接进行通信，<br>那么这就不用一次次加入cookie，也就是一个持久化的协议</li>
<li>WebSocket也借助了HTTP的握手，是HTTP的一个解决特定问题的补丁，<br>多了如下内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="输入一个URL，到打开网页的过程中发生了什么？"><a href="#输入一个URL，到打开网页的过程中发生了什么？" class="headerlink" title="输入一个URL，到打开网页的过程中发生了什么？"></a>输入一个URL，到打开网页的过程中发生了什么？</h4><p>总体来说分为以下几个过程</p>
<ol>
<li>DHCP 配置主机信息 如果最初没有IP地址等信息的话，那么就需要先<br>使用DHCP来获取。主机生成一个DHCP请求报文，并将这个报文放入具有目<br>的端口67和源端口68的UDP 报文段中，放入具有广播IP目的地址(255.</li>
<li>255.255)和源IP地址(0.0.0.0)的IP数据报中。DHCP服务器最后<br>就会把相关信息发送给主机</li>
<li>ARP解析MAC地址 DHCP过程只知道网关路由器的IP地址，为了获取网关<br>路由器的MAC地址，需要使用ARP协议</li>
<li>DNS解析 首先查找域名服务器获取相应域名的IP地址，首先以UDP数据<br>报的形式发送给本地域名服务器。主机向本地域名服务器的查询一般采用递<br>归查询，递归查询就是如果主机询问的本地域名服务器不知道被查询的IP<br>地址，那么本地域名服务器就会以DNS客户的身份器其他根域名服务器查询<br>，主机不会进行下一步查询。本地域名服务器向根域名服务器查询分为两种<br>方式，通常采用迭代查询：当根域名服务器收到本地域名服务器的请求时<br>会告诉本地域名服务器应该去哪一个域名服务器查询而不是帮助本地域名<br>服务器查询。本地服务器也可以采用递归查询，取决于最初查询请求报文<br>的设置是哪一种方式。为了提高DNS 查询效率在域名服务器和主机中都是<br>用了高速缓存。比如域名是 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 网址的解析是一个从右向<br>左的过程</li>
<li>HTTP协议建立在TCP协议之上，HTTP请求前，必须先与HTTP服务器<br>进行三次握手来建立连接</li>
<li>HTTP协议生成请求报文 生成针对目标Web服务器的HTTP请求报文，</li>
<li>HTTP协议对请求进行处理，比如返回相应的资源，HTTP响应报文</li>
<li>HTML页面的解析与渲染 抽取出Web页面内容，浏览器之后进行渲染，显<br>示Web页面</li>
</ol>
<h3 id="DNS什么情况使用UDP和TCP？"><a href="#DNS什么情况使用UDP和TCP？" class="headerlink" title="DNS什么情况使用UDP和TCP？"></a>DNS什么情况使用UDP和TCP？</h3><ol>
<li>UDP UDP速度更快，不需要三次握手。DNS 请求和响应通常都很小，一般<br>数据内容不会超过512字节。可以在应用层弥补UDP不可靠的缺点，自己完成<br>超时和重传处理。还有一个点是关于DNS负载均衡，事实上每次返回的IP 地<br>址并不一定都是一样的，资源是分布在许多的服务器，DNS会根据每台机器<br>的负载量该机器距离用户地理位置的距离来返回一个合适的IP</li>
<li>如果DNS响应超过512个字节那么使用UDP 就会将数据截断为512个字<br>节，多余的部分会抛弃，因为UDP没有字段来表示报文ID。所以当响应报<br>文的长度大于512个字节的时候就会使用TCP</li>
</ol>
<h3 id="HTTP是什么？"><a href="#HTTP是什么？" class="headerlink" title="HTTP是什么？"></a>HTTP是什么？</h3><p>HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎么<br>把文档传送给浏览器，它不断监听TCP的端口80。本身无连接也无状态。当建立<br>TCP连接的三报文握手的前两部分完成后，就把HTTP请求报文作为建立TCP连<br>接的三报文握手中的第三个报文数据</p>
<h3 id="请求报文和响应报文的区别？"><a href="#请求报文和响应报文的区别？" class="headerlink" title="请求报文和响应报文的区别？"></a>请求报文和响应报文的区别？</h3><ol>
<li>请求报文</li>
</ol>
<ul>
<li>请求行 请求方法、URL、协议版本</li>
<li>请求报头 为请求报文添加了一些附加信息，头部字段名和值</li>
<li>请求正文 可选部分，比如GET 请求就没有请求正文</li>
</ul>
<ol start="2">
<li>响应报文</li>
</ol>
<ul>
<li>状态行 协议版本、状态码以及描述</li>
<li>响应头部 响应报文添加了一些附加信息，头部字段名和值</li>
<li>响应正文 响应的内容主体</li>
</ul>
<h3 id="请求方法有哪些？"><a href="#请求方法有哪些？" class="headerlink" title="请求方法有哪些？"></a>请求方法有哪些？</h3><ol>
<li>OPTION 请求选项信息</li>
<li>GET 读取URL标志的信息</li>
<li>POST 添加信息</li>
<li>DELETE 删除URL资源</li>
</ol>
<h3 id="常见状态码的含义有哪些？"><a href="#常见状态码的含义有哪些？" class="headerlink" title="常见状态码的含义有哪些？"></a>常见状态码的含义有哪些？</h3><ol>
<li>1xx：表示请求已接收，正在处理</li>
</ol>
<ul>
<li>100 表明到目前为止都很正常，客户端可以继续发送请求或者忽略<br>这个响应</li>
</ul>
<ol start="2">
<li>2xx：成功 表示请求已被成功接收、理解、接受</li>
</ol>
<ul>
<li>200 OK 正在被正确处理</li>
<li>204 No Content 请求已经成功处理，但是返回的响应报文不包含实体的主<br>体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</li>
<li>206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返<br>回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功<br>的状态</li>
</ul>
<ol start="3">
<li>3xx：重定向–要完成请求必须进行更进一步的操作，虽然 HTTP 协议规定<br>301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数<br>浏览器都会在 301、302 和303 状态下的重定向把 POST方法改成GET方法</li>
</ol>
<ul>
<li>301 Moved Permanently 永久性重定向，资源分配性的URL</li>
<li>302 Found 临时性重定向，说明请求的资源还在，但暂时需要用另一个<br>URL 来访问</li>
<li>303 See Other 和 302 有着相同的功能，但是 303 明确要求客户端应<br>该采用 GET 方法获取资源</li>
<li>304 Not Modified 如果请求报文首部包含一些条件，例如： If-Match，<br>If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since<br>，允许访问但是不满足条件，则服务器会返回 304 状态码</li>
<li>307 Temporary Redirect 临时重定向，与 302 的含义类似，但是307<br>要求浏览器不会把重定向请求的改变</li>
</ul>
<ol start="4">
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
</ol>
<ul>
<li>400 Bad Request 请求报文中存在语法错误</li>
<li>401 Unauthorized 该状态码表示发送的请求需要有认证信息（BASIC<br>认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败</li>
<li>403 Forbidden 请求资源被服务器拒绝，实体部分返回原因描述</li>
<li>404 Not Found</li>
</ul>
<ol start="5">
<li>5xx：服务器端错误–服务器未能处理合法的请求</li>
</ol>
<ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误</li>
<li>501 Not Implemented ：表示客户端请求的功能还不支持</li>
<li>502 Bad Gateway ：通常是服务器作为网关或代理时返回的错误码，表<br>示服务器自身工作正常，访问后端服务器发生了错误</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维<br>护，现在无法处理请求</li>
</ul>
<h3 id="301和302状态码有什么区别？"><a href="#301和302状态码有什么区别？" class="headerlink" title="301和302状态码有什么区别？"></a>301和302状态码有什么区别？</h3><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的URL，<br>浏览器会自动重定向新的URL</p>
<ul>
<li>301是永久性重定向(Permanently Moved)，表示一个旧的网址所代表的<br>资源已经被永久地移除了，不能再访问了，并且搜索引擎在获取新的资源的<br>同时也将旧的网址转换为重定向之后的地址</li>
<li>302是临时重定向(Temporarily Moved)，这个重定向只是临时地从一个<br>旧的地址跳转到一个新的地址，旧的地址的资源还在，还可以继续访问，搜<br>索引擎会获取资源并保存旧的地址</li>
</ul>
<h3 id="http-常见字段有哪些？"><a href="#http-常见字段有哪些？" class="headerlink" title="http 常见字段有哪些？"></a>http 常见字段有哪些？</h3><ol>
<li>Host 客户端发送请求时，用来指定服务器的域名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br></pre></td></tr></table></figure></li>
<li>Content-Length 服务器在返回数据时，会有Content-Length 字段，表<br>明本次回应的数据长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本次服务器回应的数据长度是 1000 个字节</span><br><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure></li>
<li>Connection 最常用于客户端要求服务器使用TCP 持久连接，以便其他请<br>求复用，HTTP/1.1版本的默认连接都是持久连接，但为了兼容老版本的HTTP<br>，需要指定Connection 首部字段的值为 Keep-Alive<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></li>
<li>Content-Type 用于服务器回应时，告诉客户端，本次数据是什么格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送的是网页，而且编码是UTF-8</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure></li>
<li>Accept 客户端请求的时候，可以使用 Accept 字段声明自己可以接受<br>哪些数据格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端声明自己可以接受任何格式的数据</span><br><span class="line">Accept: *&#x2F;*</span><br></pre></td></tr></table></figure></li>
<li>Content-Encoding 说明数据的压缩方法。表示服务器返回的数据使用了<br>什么压缩格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">告知客户端需要用此方式解压</span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></li>
<li>Accept-Encoding 客户端在请求时，用Accept-Encoding 字段说明自<br>己可以接受哪些压缩方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a>GET和POST的区别？</h3><ol>
<li>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、<br>页面、图片视频等。而POST 方法则是相反操作，它向 URI 指定的资源提交<br>数据，数据就放在报文的body 里</li>
<li>参数位置 GET和POST的请求都能使用额外的参数，但是GET 的参数是<br>以查询字符串出现在URL 中，而POST 的参数存储在实体主体中。不能因<br>为POST参数存储在实体主体中就认为它的安全性更高，因为照样可以通<br>过一些抓包工具（Fiddler）查看</li>
<li>参数长度 GET方法的URL 长度有限度，POST 长度没有显示</li>
<li>参数编码 GET方法参数编码是ASCLL 码，POST 没有限制</li>
<li>TCP数据包 GET方法产生一个TCP数据包，把首部和数据一起发送，POST<br>方法产生两个TCP数据包，先发首部，服务器响应后再发数据</li>
<li>安全 安全的HTTP 方法不会改变服务器状态，也就是说它只是可读的，<br>GET 方法是安全的，而POST 却不是，因为POST 的目的是传送实体主体内<br>容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把<br>这个数据存储到数据库中，因此状态也就发生了改变</li>
<li>可缓存 如果要对响应进行缓存，需要满足以下条件</li>
</ol>
<ul>
<li>请求报文的HTTP 方法本身是可缓存的，包括GET 和HEAD，但是 PUT<br>和 DELETE 不可缓存，POST 在多数情况下不可缓存的</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301<br>, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存</li>
</ul>
<ol start="8">
<li>XMLHttpRequest XMLHttpRequest 是一个 API，它为客户端提供了在<br>客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的<br>简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会<br>打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用</li>
</ol>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再<br>发送 Data。但并不是所有浏览器会这么做，例如火狐就不会</li>
<li>而 GET 方法 Header 和 Data 会一起发送</li>
</ul>
<h3 id="安全方法和不安全方法有哪些？"><a href="#安全方法和不安全方法有哪些？" class="headerlink" title="安全方法和不安全方法有哪些？"></a>安全方法和不安全方法有哪些？</h3><p>在HTTP 协议里，所谓的安全是指请求方法不会破坏服务器上的资源</p>
<ol>
<li>安全的方法除了 GET 之外还有：HEAD、OPTIONS</li>
<li>不安全的方法除了 POST 之外还有 PUT、DELETE</li>
</ol>
<h3 id="幂等性了解吗？"><a href="#幂等性了解吗？" class="headerlink" title="幂等性了解吗？"></a>幂等性了解吗？</h3><p>幂等的HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，<br>服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计<br>用途除外）。所有的安全方法也都是幂等的。在正确实现的条件下，GET，<br>HEAD，PUT 和 DELETE 等方法都是幂等的，而POST 方法不是</p>
<h3 id="HTTP的特性有哪些？"><a href="#HTTP的特性有哪些？" class="headerlink" title="HTTP的特性有哪些？"></a>HTTP的特性有哪些？</h3><ol>
<li>简单 HTTP 基本的报文格式就是 header + body，头部信息也是<br>key-value 简单文本的形式，易于理解，降低了学习和使用的门槛</li>
<li>灵活和易于扩展 HTTP协议里的各类请求方法、URI/URL、状态码、头<br>字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充</li>
<li>应用广泛和跨平台</li>
<li>无状态</li>
</ol>
<ul>
<li>好处 因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记<br>录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外<br>提供服务</li>
<li>坏处 既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦</li>
</ul>
<ol start="5">
<li>明文传输 在传输过程中的信息，是可方便阅读的，很容易就能被窃取</li>
</ol>
<h3 id="谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？"><a href="#谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？" class="headerlink" title="谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？"></a>谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</h3><p>短连接：例如普通的web请求，在三次握手之后建立连接，发送数据包并得到<br>服务器返回的结果之后，通过客户端和服务端的四次握手进行关闭断开<br>长连接：区别于短连接，由于三次握手链接及四次握手断开，在请求频繁的情<br>况下，链接请求和断开请求的开销较大，影响效率。采用长连接方式，执行三<br>次握手链接后，不断开链接，保持客户端和服务端通信，直到服务器超时自动<br>断开链接，或者客户端主动断开链接。持久连接的特点是，只要任意一端没有<br>明确提出断开连接，则保持 TCP 连接状态<br>短连接：适用于网页浏览等数据刷新频度较低的场景<br>长连接：适用于客户端和服务端通信频繁的场景，例如聊天室，实时游戏等</p>
<h3 id="HTTP-1-1与HTTP-1-0的区别？"><a href="#HTTP-1-1与HTTP-1-0的区别？" class="headerlink" title="HTTP/1.1与HTTP/1.0的区别？"></a>HTTP/1.1与HTTP/1.0的区别？</h3><ol>
<li>缓存处理 在HTTP/1.0中主要使用header里的If-Modified=Since,<br>Expires来作为缓存判断的标准，HTTP/1.1则引入更多的缓存控制策略<br>例如Entity tag等</li>
<li>带宽优化及网络连接的使用 HTTP/1.0中客户端只是需要某个对象的<br>一部分，当服务器将整个对象传送过来，并且不支持断点续传功能，<br>HTTP/1.1在请求头中引入range头域，允许只请求资源的某个部分，<br>返回码是206</li>
<li>错误通知的管理 在HTTP/1.1中新增了24个错误状态响应码，如409<br>表示请求的资源与资源当前状态冲突，410表示服务器上的某个资源被<br>永久性删除</li>
<li>Host头处理 HTTP/1.0中认为每台服务器都绑定唯一的IP地址，所以<br>在URL中没有传递主机名，但是一个物理服务器上可以有多个虚拟主机，<br>共享一个IP地址，HTTP/1.1支持Host头域</li>
<li>长连接 HTTP/1.1支持长连接和请求的流水线处理，在一个TCP连接<br>上可以传送多个HTTP请求和响应。在HTTP/1.0中，默认使用的是短连接</li>
<li>管道网络传输 即可在同一个 TCP 连接里面，客户端可以发起多个<br>请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求<br>出去，可以减少整体的响应时间</li>
</ol>
<h3 id="HTTP-1-1的流水线技术是什么？"><a href="#HTTP-1-1的流水线技术是什么？" class="headerlink" title="HTTP/1.1的流水线技术是什么？"></a>HTTP/1.1的流水线技术是什么？</h3><p>客户在收到HTTP的响应报文之前就能够接着发送新的请求报文，于是一个接一<br>个的请求报文到达服务器后服务器就可连续发回响应报文，客户访问所有的对<br>象只需要花费一个RTT时间，不局限于传送同一个页面上链接的文档</p>
<h3 id="HTTP-2-0了解吗？"><a href="#HTTP-2-0了解吗？" class="headerlink" title="HTTP/2.0了解吗？"></a>HTTP/2.0了解吗？</h3><p>参考 <a href="https://segmentfault.com/a/1190000016656529" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016656529</a><br>HTTP/2是HTTP协议的第二个主要版本。HTTP/2主要基于SPDY协议。HTTP2.0<br>的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大<br>幅度提高了web性能。<br>SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层<br>协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩<br>短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数<br>。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。<br>HTTP1.x有以下几个主要缺点：</p>
<ol>
<li>HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用<br>的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因<br>此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟</li>
<li>单向请求，只能由客户端发起</li>
<li>请求报文与响应报文首部信息冗余量大</li>
<li>数据未压缩，导致数据的传输量大</li>
</ol>
<h3 id="HTTP-2-0优点有哪些？"><a href="#HTTP-2-0优点有哪些？" class="headerlink" title="HTTP/2.0优点有哪些？"></a>HTTP/2.0优点有哪些？</h3><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的</p>
<ol>
<li>新的二进制格式 HTTP/1.x 的解析是基于文本，基于文本协议的解析<br>存在天然缺陷，文本的表现形式由多样性，要做到健壮性考虑的场景必须<br>很多。二进制则不同，只认0和1的组合。基于这种考虑HTTP/2.0的协议解<br>析决定采用二进制格式，实现方便且健壮，头信息和数据体都是二进制<br>，并且统称为帧（frame）：头信息帧和数据帧。</li>
<li>多路复用 即连接共享，每一个request都是用做连接共享机制的，一个<br>request对应一个id，这样一个连接上可以有多个request，每个连接的<br>request可以随机混杂在一起，接受方可以根据request的id将request<br>再归属到各自不同的服务端请求中。不需要排队等待，也就不会再出现<br>队头阻塞问题，降低了延迟，大幅度提高了连接的利用率</li>
<li>header压缩 HTTP/1.x的header带有大量信息，如果你同时发出多个<br>请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分<br>。HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会<br>存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号<br>，这样就提高速度了</li>
<li>服务端推送 同SPDY一样，HTTP/2.0也具有server push功能，服务端<br>可以在客户端某个请求后，主动推送其他资源</li>
<li>数据流 HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数<br>据包，可能属于不同的回应。因此必须要对数据包做标记，指出它属于哪个<br>回应。每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数<br>据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为<br>奇数， 服务器发出的数据流编号为偶数</li>
</ol>
<h3 id="HTTP-3是什么？"><a href="#HTTP-3是什么？" class="headerlink" title="HTTP/3是什么？"></a>HTTP/3是什么？</h3><ol>
<li>HTTP/2 主要的问题在于，多个HTTP 请求在复用一个TCP 连接，下层的<br>TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会<br>触发TCP 的重传机制，这样在一个TCP 连接中的所有的HTTP 请求都必须等<br>待这个丢了的包被重传回来</li>
<li>HTTP/3 把HTTP 下层的TCP 协议改成了 UDP，UDP 发生是不管顺序，也<br>不管丢包的，所以不会出现HTTP/1.1 的队头阻塞和HTTP/2 的一个丢包全部<br>重传问题。</li>
<li>基于UDP 的QUIC 协议可以实现类似TCP 的可靠性传输</li>
<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是<br>TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互<br>合并成了 3 次，减少了交互次数</li>
</ol>
<h3 id="HTTPS-是什么？"><a href="#HTTPS-是什么？" class="headerlink" title="HTTPS 是什么？"></a>HTTPS 是什么？</h3><p>是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通<br>信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网<br>站服务器的身份认证，保护交换数据的隐私与完整性。S指的是SSL，即安全<br>套接字层</p>
<h4 id="HTTP和HTTPS有什么区别？HTTPS的S是什么意思？"><a href="#HTTP和HTTPS有什么区别？HTTPS的S是什么意思？" class="headerlink" title="HTTP和HTTPS有什么区别？HTTPS的S是什么意思？"></a>HTTP和HTTPS有什么区别？HTTPS的S是什么意思？</h4><ol>
<li>端口 HTTP的URL由“HTTP://”起始且默认使用端口80，而HTTPS的URL<br>由“https://”起始且默认使用端口443</li>
<li>安全性和资源消耗 HTTP明文传输，数据都是未加密的，安全性较差，<br>客户端和服务器端都无法验证对方的身份。HTTPS（SSL+HTTP）数据传输<br>过程是加密的，安全性较好。HTTPS是运行在SSL/TLS之上的HTTP协议，<br>SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称<br>加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说<br>，HTTP 安全性没有HTTPS 高，但是 HTTPS 比HTTP耗费更多服务器<br>资源</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报<br>文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手<br>过程，才可进入加密报文传输</li>
</ol>
<h3 id="混合加密如何实现？"><a href="#混合加密如何实现？" class="headerlink" title="混合加密如何实现？"></a>混合加密如何实现？</h3><p>HTTPS 采用的是对称加密和非对称加密结合的混合加密方式</p>
<ol>
<li>在通信建立前采用非对称加密的方式交换会话秘钥，后续就不再使用<br>非对称加密，非对称加密使用两个密钥：公钥和私钥，公钥可以任意分<br>发而私钥保密，解决了密钥交换问题但速度慢</li>
<li>在通信过程中全部使用对称加密的会话秘钥的方式加密明文数据，<br>只使用一个密钥，运算速度快，密钥必须保密</li>
</ol>
<h3 id="摘要算法是什么？"><a href="#摘要算法是什么？" class="headerlink" title="摘要算法是什么？"></a>摘要算法是什么？</h3><ol>
<li>摘要算法用来实现完整性，能够为数据生成独一无二的指纹，用于校验<br>数据的完整性，解决了篡改的风险</li>
<li>客户端在发送明文之前会通过摘要算法算出明文的指纹，发送的时候把指<br>纹 + 明文一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要<br>算法算出发送过来的明文，通过比较客户端携带的指纹和当前算出的指纹做<br>比较，若指纹相同，说明数据是完整的</li>
</ol>
<h3 id="证书是什么？有什么作用？"><a href="#证书是什么？有什么作用？" class="headerlink" title="证书是什么？有什么作用？"></a>证书是什么？有什么作用？</h3><p>SSL 证书是一种能够在服务器和浏览器之间的信息交换过程中实现通信安全的<br>工具，对发送和接受的数据进行加密保护。通过使用证书来对通信方进行认证<br>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方<br>都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA<br>在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分<br>配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起<br>。进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公<br>开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了</p>
<ol>
<li>提供身份验证</li>
<li>加密敏感信息</li>
<li>提高网站信任度</li>
<li>优化页面加载速度</li>
</ol>
<h3 id="Cookie的作用是什么？"><a href="#Cookie的作用是什么？" class="headerlink" title="Cookie的作用是什么？"></a>Cookie的作用是什么？</h3><p>HTTP是无状态的，但是网上购物时服务器必须记住用户的身份，可以在HTTP中<br>使用，万维网站点可以使用Cookie来跟踪用户，可以表示为在用户和服务器之<br>间传递的状态信息</p>
<h3 id="如何生成Cookie？"><a href="#如何生成Cookie？" class="headerlink" title="如何生成Cookie？"></a>如何生成Cookie？</h3><ol>
<li>当用户A浏览一个使用Cookie的网站时，该网站的服务器就会为A产生唯一<br>一个识别码，并以此作为索引在服务器的后端产生</li>
<li>给A的HTTP响应报文中添加一个叫做Set-cookie的首部行，这里首部字段<br>名就是Set-cookie，值就是赋予用户的识别码</li>
<li>A接收到响应之后浏览器就在它管理的特定Cookie文件中添加一行，其中<br>就包括这个服务器的主机名和Set-cookie后面给出的识别码，当A继续浏览<br>网站时每发送一个HTTP请求报文其浏览器就会从Cookie文件中取出这个网<br>站的识别码并放到HTTP请求报文的Cookie首部行中，于是网站就能够持续<br>跟踪这个用户的活动，所以可以用于告知服务端两个请求是否来自同一浏<br>览器</li>
</ol>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话<br>期内有效</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就<br>成为了持久性的 Cookie</li>
</ul>
<h3 id="Session的作用是什么？"><a href="#Session的作用是什么？" class="headerlink" title="Session的作用是什么？"></a>Session的作用是什么？</h3><ol>
<li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session</li>
<li>同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为<br>session对象的ID）</li>
<li>然后将该Cookie 发送至浏览器端。浏览器端发送第N（N&gt;1）次请求到服<br>务器端，浏览器端访问服务器端时携带该name为JSESSIONID的Cookie对象</li>
<li>服务器端根据name为JSESSIONID 的Cookie的value(sessionId)，去<br>查询Session 对象，从而区分不同用户</li>
</ol>
<h3 id="Session与Cookie的区别有哪些？"><a href="#Session与Cookie的区别有哪些？" class="headerlink" title="Session与Cookie的区别有哪些？"></a>Session与Cookie的区别有哪些？</h3><p>cookie和session都是用来跟踪浏览器用户身份的会话方式。不同之处如下</p>
<ol>
<li>存储位置 Cookie是客户端技术，数据保存在客户端，Session是服务端<br>会话技术，数据保存在服务器端</li>
<li>存储容量 Cookie一般小于等于4KB，Session无限制</li>
<li>跨域支持 Cookie支持跨域，Session不支持</li>
<li>作用 Cookie一般存储少量不太敏感的数据，Token授权机制，时间戳超时<br>机制，签名机制，拒绝重复调用</li>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的<br>数据，因此在考虑数据复杂性时首选 Session</li>
<li>相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写<br>入Cookie中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密</li>
<li>Cookie 一般用来保存用户信息，Session 的主要作用就是通过服务端记录<br>用户的状态</li>
</ol>
<h3 id="Cookie被禁用怎么办？"><a href="#Cookie被禁用怎么办？" class="headerlink" title="Cookie被禁用怎么办？"></a>Cookie被禁用怎么办？</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能<br>再将 Session ID存放到Cookie中，而是使用URL重写技术，将 Session ID<br>作为 URL 的参数进行传递</p>
<h3 id="Cookie-的属性有哪些？"><a href="#Cookie-的属性有哪些？" class="headerlink" title="Cookie 的属性有哪些？"></a>Cookie 的属性有哪些？</h3><ol>
<li>domain属性 指定可访问此cookie的域名 非顶级域名，如二级域名或者三<br>级域名，设置的cookie的domain 只能为顶级域名或者二级域名或者三级域名<br>本身，不能设置其他二级域名的cookie。要想cookie 在多个二级域名中共享<br>，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个<br>cookie的值了</li>
<li>path属性 指定该cookie的页面路径 比如domain是abc.com。path是<br>/test，那么只有/test路径下的页面可以读取此cookie，Cookie的路径<br>是在服务器创建Cookie时设置的，它的作用是决定浏览器访问服务器的<br>某个资源时，需要将浏览器端保存的那些Cookie归还给服务器</li>
</ol>
<h3 id="反向代理是什么？"><a href="#反向代理是什么？" class="headerlink" title="反向代理是什么？"></a>反向代理是什么？</h3><ol>
<li>反向代理方式是指以代理服务器来接收Internet 上的连接请求，然后将请<br>求转发给内部网络上的服务器 ，并将从服务器上得到的结果返回给Internet<br>上请求连接的客户端，此时代理服务器对外就表现为一个服务器</li>
<li>反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要<br>进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容<br>发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获<br>得的内容返回给客户端，就像这些内容原本就是它自己的一样</li>
</ol>
<h3 id="跨域产生的原因？"><a href="#跨域产生的原因？" class="headerlink" title="跨域产生的原因？"></a>跨域产生的原因？</h3><p>参考 <a href="https://www.jianshu.com/p/827b041be446" target="_blank" rel="noopener">https://www.jianshu.com/p/827b041be446</a><br>跨域是指从一个域名去请求另一个域名的资源，严格来说，只要域名，协议<br>，端口任何一个不同，就视为跨域。为了网络安全起见，浏览器设置了一个<br>同源策略，规定只有域名，端口，协议全部相同，就叫做同源。当页面在执<br>行一个脚本时，会检查访问的资源是否同源，如果不是，就会报错。可是在<br>实际开发中，经常会有跨域加载资源的需求，避免不了跨域请求，所以就<br>出现了跨域。<br>同源策略（Same Orgin Policy）是一种约定，它是浏览器核心也最基本<br>的安全功能，它会阻止一个域的js脚本和另外一个域的内容进行交互，如<br>果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源（即在<br>同一个域）就是两个页面具有相同的协议（protocol）、主机（host）<br>和端口号（port）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.baidu.com:8080&#x2F;index.html （http协议，www.baidu.com </span><br><span class="line">域名、8080 端口 ，只要这三个有一项不一样的都是跨域，这里不一一举例子）</span><br><span class="line">http:&#x2F;&#x2F;www.baidu.com:8080&#x2F;matsh.html（不跨域）</span><br><span class="line">http:&#x2F;&#x2F;www.baidu.com:8081&#x2F;matsh.html（端口不一样，跨域）</span><br><span class="line">注意：localhost 和127.0.0.1 虽然都指向本机，但也属于跨域</span><br></pre></td></tr></table></figure>
<p>同源策略限制的具体表现</p>
<ol>
<li>cookie、LocalStorage和Index DB 无法读取</li>
<li>Dom 无法获得</li>
<li>AJAX请求不能发送</li>
</ol>
<h3 id="Cookie如何跨域？"><a href="#Cookie如何跨域？" class="headerlink" title="Cookie如何跨域？"></a>Cookie如何跨域？</h3><p>正常的cookie只能在一个应用中共享，即一个cookie只能由创建它的应用获得</p>
<ol>
<li>可在同一应用服务器内共享方法 设置cookie.setPath(“/“)</li>
<li>跨域共享cookie的方法 设置cookie.setDomain(“.jszx.com”)</li>
<li>Nginx 反向代理来解决cookie 跨域问题，其实是通过“欺骗”浏览器来实现<br>的，通过nginx，我们可以将不同工程的cookie放到nginx域下，通过nginx反<br>向代理就可以取到不同工程写入的cookie</li>
</ol>
<h3 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h3><ol>
<li>JSONP – 原理就是利用了script标签，在标签外套了一层壳，利用标<br>签特性达到跨域加载资源的效果，JSONP由两部分组成，回调函数和数据，<br>缺点如下。会创建一个查询字符串参数 callback=? ，这个参数会加在请<br>求的URL后面。服务器端应当在JSON 数据前加上回调函数名，以便完成一<br>个有效的JSONP请求，意思就是远程服务端需要对返回的数据做下处理，<br>根据客户端提交的callback的参数，返回一个callback(json)的数据<br>，而客户端将会用script的方式处理返回数据，来对json数据做处理</li>
</ol>
<ul>
<li>只支持GET请求，不支持POST请求</li>
<li>不够安全。因为JSONP是从其他域中加载代码执行，如果其他域不安全，可<br>能会在响应中带有恶意代码</li>
<li>不容易确认请求是否失败</li>
</ul>
<ol start="2">
<li>CORS– 跨站资源共享，它是跨域的官方解决方案，升级版的JSONP。原<br>理是使用自定义的HTTP 头部让浏览器与服务器进行沟通，从而决定请求或<br>响应是应该成功还是失败。请求和响应都不包含cookie信息。<br>CORS需要浏览器和后端同时支持，浏览器会自动进行CORS通信，实现CORS<br>通信的关键是后端，只要后端实现了CORS，就实现了跨域，服务端设置<br>Access-Control-Allow-Origin 就可以开启CORS，该属性表示哪<br>些域名可以访问资源，如果设置通配符则表示所有网站都可以访问<br>资源</li>
<li>webSockets – 不受同源策略影响。原理是因为它不使用HTTP协议，而使<br>用一种自定义的协议，专门为快速传输小数据设计</li>
<li>Nginx代理服务器 – 代理跨域。反向代理跨域</li>
</ol>
<h3 id="了解对称加密算法和非对称加密算法的区别吗？"><a href="#了解对称加密算法和非对称加密算法的区别吗？" class="headerlink" title="了解对称加密算法和非对称加密算法的区别吗？"></a>了解对称加密算法和非对称加密算法的区别吗？</h3><ol>
<li>对称秘钥密码体制，即加密密钥与解密秘钥是使用相同的密码体制，<br>典型的对称加密算法有DES、AES等。DES 的保密性仅取决于对密钥的保<br>密，而算法是公开的。优点是加密解密快，缺点是无法安全将密钥传输<br>给通信方，因为加密与解密秘钥是同一个，要么事先约定好要么用信<br>使来传送</li>
<li>非对称密钥加密，又称公开密钥加密，加密和解密使用不同的密钥。<br>加密算法和解密算法都是公开的，加密秘钥也是公开的，而解密秘钥需<br>要保密。优点是可以更安全地将公开密钥传输给通信发送方，缺点是运<br>算速度慢。算法有RSA、DSA</li>
<li>在通信方面有很大不同 使用对称秘钥时由于双方使用相同的秘钥因此<br>在通信上可以进行一对一的双向保密通信，每一方即可发送密文也可解密<br>密文</li>
<li>在使用公开秘钥时，在通信信道上是多对一的单向保密密文，很多人<br>持有B的公钥，可以将自己的报文加密后发送给B，B能够用私钥进行解密<br>，当反过来不行。例如网购时很多顾客向同一个网站发送各自的信用卡信息</li>
</ol>
<h3 id="什么是数字签名？"><a href="#什么是数字签名？" class="headerlink" title="什么是数字签名？"></a>什么是数字签名？</h3><p>通过提供可鉴别的数字信息验证自身身份的一种方式。一套数字签名通常<br>定义两种互补的运算，一个用于签名，另一个用于验证。分别由发送者持<br>有能够代表自己身份的私钥 (私钥不可泄露)，由接受者持有与私钥对应<br>的公钥，能够在接受到来自发送者信息时用于验证其身份</p>
<ol>
<li>接受者能够核实发送者对报文的签名，也就是说接受者能够确信该报<br>文的确是发送者发送的，其他人无法伪造。这就是报文鉴别</li>
<li>接受者确信收到的数据和发送者发送的完全一样没有被修改，这就是<br>报文的完整性</li>
<li>发送者事后不能抵赖对报文的签名，这就是不可否认</li>
</ol>
<p>可以使用公钥算法或对称秘钥算法来实现，公钥算法更容易。为了进行签<br>名，A用私钥对报文进行解密运算，A 把经过解密运算得到的密文传送给<br>B，B为了核实签名就用A的公钥进行加密运算，还原明文。以上只是实现<br>数字签名，如果还要实现秘密通信，A可以用A的私钥解密运算，然后用<br>B的公钥进行加密运算，B用B的私钥进行解密运算，然后用A的公钥进行<br>加密运算核实签名</p>
<h3 id="HTTP采用的加密方式是怎样的？"><a href="#HTTP采用的加密方式是怎样的？" class="headerlink" title="HTTP采用的加密方式是怎样的？"></a>HTTP采用的加密方式是怎样的？</h3><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥Secret<br>Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我<br>们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采<br>用混合的加密机制，所有传输的内容都经过加密，加密采用对称加密，但<br>对称加密的密钥用服务器方的证书进行了非对称加密</p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key<br>，从而保证安全性</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证<br>效率</li>
</ul>
<p>运输层有两个广泛使用的安全协议</p>
<ul>
<li>安全套接字层SSL 作用在应用层的HTTP和运输层之间，在TCP之上建立一<br>个安全通道。SSL从SSL套接字接收应用层的数据，对数据进行加密，然后把<br>加密的数据送到TCP套接字，接收方从TCP套接字读取数据，解密后交给应<br>用层</li>
<li>运输层安全TLS SSL的升级版，为所有基于TCP的网络应用通过安全数据<br>传输服务</li>
</ul>
<h4 id="TLS握手过程是怎样？"><a href="#TLS握手过程是怎样？" class="headerlink" title="TLS握手过程是怎样？"></a>TLS握手过程是怎样？</h4><p>参考 <a href="https://zhuanlan.zhihu.com/p/37636276" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37636276</a></p>
<ol>
<li>协商加密算法 浏览器A向服务器B发送浏览器的SSL版本号和一些可选的<br>加密和压缩算法。服务器B发送给浏览器A自己支持的算法（如RSA）</li>
<li>服务器鉴别 服务器B向浏览器A发送包含RSA公钥的数字证书，A使用该<br>证书的认证机构CA公开发布的RSA公钥对该证书进行验证</li>
<li>会话秘钥计算 由A生成一个随机数，使用B的RSA公钥加密后发送给B。<br>双方根据协商的算法产生共享的对称会话秘钥</li>
<li>安全数据传输 双方用会话秘钥加密和解密它们之间传送的数据并验证<br>其完整性</li>
</ol>
<h3 id="代理和网关是什么？"><a href="#代理和网关是什么？" class="headerlink" title="代理和网关是什么？"></a>代理和网关是什么？</h3><ol>
<li>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端’中间人’<br>的角色，接收客户端发送的请求不改变请求的URI并转发给服务器，同时也接<br>收服务器返回的相应并转发客户端</li>
<li>缓存代理：代理转发响应时会预先将资源缓存在代理服务器上当代理再次<br>接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之<br>前缓存的资源作为响应返回</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工的代理类型</li>
<li>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时<br>，它就像自己拥有资源的源服务器一样对请求进行处理，其工作机制和代理<br>类似，而网关能使通信线路上的服务器提供非HTTP协议的服务</li>
</ol>
<h3 id="常见的攻击手段（XSS、CSRF）有哪些？"><a href="#常见的攻击手段（XSS、CSRF）有哪些？" class="headerlink" title="常见的攻击手段（XSS、CSRF）有哪些？"></a>常见的攻击手段（XSS、CSRF）有哪些？</h3><p>参考 <a href="https://blog.csdn.net/sinat_17775997/article/details/83377359" target="_blank" rel="noopener">https://blog.csdn.net/sinat_17775997/article/details/83377359</a></p>
<ol>
<li>拒绝服务Dos 攻击者向互联网上的某个服务器不停发送大量分组，使该<br>服务器无法提供正常服务，这种攻击称为拒绝服务。若从互联网上的成百上<br>千个网站几种攻击一个网站，则称为分布式拒绝服务DDos</li>
<li>XSS 跨站脚本攻击</li>
<li>CSRF 跨站请求伪造，攻击者盗用了你的身份，以你的名义发送恶意请求</li>
</ol>
<h3 id="XSS攻击过程？"><a href="#XSS攻击过程？" class="headerlink" title="XSS攻击过程？"></a>XSS攻击过程？</h3><ol>
<li>XSS 跨站脚本攻击，XSS 攻击是指攻击者在网站上注入恶意的客户端代码<br>，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览<br>器进行控制或者获取用户隐私数据的一种攻击方式。攻击者对客户端网页注入<br>的恶意脚本一般包括JavaScript，有时也会包含 HTML 和Flash 。有很多种<br>方式进行XSS攻击，但它们的共同点为：将一些隐私数据像cookie、session<br>发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机<br>器上进行一些恶意操作</li>
<li>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM</li>
<li>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻<br>击方式往往需要攻击者诱使用户点击一个恶意链接，可以注入注入能获取<br>用户隐私数据(如cookie)的脚本</li>
<li>存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数<br>据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性</li>
<li>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹<br>发生在客户端的攻击</li>
</ol>
<h3 id="如何防范XSS攻击？"><a href="#如何防范XSS攻击？" class="headerlink" title="如何防范XSS攻击？"></a>如何防范XSS攻击？</h3><ol>
<li>主流的浏览器内置了防范 XSS 的措施，例如CSP，是一个额外的安全层，<br>用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻<br>击等</li>
<li>HttpOnly 防止劫取 Cookie 浏览器将禁止页面的Javascript 访问带有<br>HttpOnly 属性的Cookie</li>
<li>对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML<br>标签白名单，在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包<br>含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式<br>也称为 XSS Filter</li>
</ol>
<h3 id="Cookie的类型？"><a href="#Cookie的类型？" class="headerlink" title="Cookie的类型？"></a>Cookie的类型？</h3><ol>
<li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie<br>，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话<br>期内有效，浏览器关闭之后它会被自动删除</li>
<li>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持<br>久性 Cookie可以指定一个特定的过期时间（Expires）或有效期（Max-Age）</li>
</ol>
<h3 id="CSRF攻击过程？"><a href="#CSRF攻击过程？" class="headerlink" title="CSRF攻击过程？"></a>CSRF攻击过程？</h3><p>跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。<br>CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害<br>者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并<br>未授权的情况下执行在权限保护之下的操作</p>
<ol>
<li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A</li>
<li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用<br>户登录网站A成功，可以正常发送请求到网站A</li>
<li>用户未退出网站A之前，在同一浏览器中，被诱导访问网站B</li>
<li>危险网站B有一个&lt;\img&gt;标签，这个img标签的src不指向图片，而是一个<br>http请求，这个请求让银行服务器从Alice转100到Bob账户上，由于Alice<br>已经登录，浏览器发请求时候会带上cookie骗取服务器信任得到响应<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;www.examplebank.com&#x2F;from&#x3D;Alice&amp;amount&#x3D;100&amp;to&#x3D;Bob&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li>浏览器在接收到这些攻击性代码后，根据网站B 的请求，在用户不知情<br>的情况下携带 Cookie 信息，向网站 A 发出请求。网站A 并不知道该请求<br>其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处<br>理该请求，导致来自网站 B 的恶意代码被执行</li>
<li>还有一种post攻击，危险网站伪造一个隐藏的表单，在onload事件中，<br>触发表单的提交事件</li>
</ol>
<h3 id="CSRF攻击如何防范？"><a href="#CSRF攻击如何防范？" class="headerlink" title="CSRF攻击如何防范？"></a>CSRF攻击如何防范？</h3><ol>
<li>禁止第三方网站带Cookies same-site属性:Strict,Lax<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(&#39;Set-Cookie: test&#x3D;12345; SameSite&#x3D;Lax&#39;)</span><br></pre></td></tr></table></figure></li>
<li>验证码 CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码<br>会强制用户必须与应用进行交互，才能完成最终请求,加入随机验证码来识别<br>请求是不是用户主动发起的</li>
<li>referer Check 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer<br>，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求<br>是否来自合法的”源”,如果黑客要对银行网站实施 CSRF 攻击，他只能在他<br>自己的网站构造请求</li>
<li>添加 token 验证 CSRF 攻击之所以能够成功，是因为攻击者可以完全伪<br>造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie中，因此攻<br>击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通<br>过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息<br>，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加<br>入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token。</li>
</ol>
<ul>
<li>对于GET 请求，token 将附在请求地址之后，这样URL 就变成<br><a href="http://url?csrftoken=tokenvalue" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue</a></li>
<li>对于 POST 请求来说，要在 form 的最后加上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;csrftoken&quot;value&#x3D;&quot;tokenvalue&quot;&#x2F;&gt;</span><br><span class="line">这样就把token以参数的形式加入请求</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="HTTPS的优缺点有哪些？"><a href="#HTTPS的优缺点有哪些？" class="headerlink" title="HTTPS的优缺点有哪些？"></a>HTTPS的优缺点有哪些？</h3><p>https不是一种新的协议，它是http+SSL(TLS)的结合体，SSL是一种独<br>立协议</p>
<ol>
<li>优点：相比于http，https可以提供更加优质保密的信息，保证了用户<br>数据的安全性，此外https 同时也一定程度上保护了服务端，使用恶意攻<br>击和伪装数据的成本大大提高</li>
<li>缺点：</li>
</ol>
<ul>
<li>第一https的技术门槛较高，多数个人或者私人网站难以支撑，CA机构颁<br>发的证书都是需要年费的，此外对接Https协议也需要额外的技术支持</li>
<li>目前来说大多数网站并不关心数据的安全性和保密性，其https最大的优<br>点对它来说并不适用</li>
<li>https加重了服务端的负担，相比于http其需要更多的资源来支撑，同时<br>也降低了用户的访问速度</li>
<li>目前来说Http网站仍然大规模使用，在浏览器侧也没有特别大的差别，很<br>多用户不关心的话根本不感知</li>
</ul>
<h3 id="http通信存在的问题"><a href="#http通信存在的问题" class="headerlink" title="http通信存在的问题"></a>http通信存在的问题</h3><ol>
<li>容易被监听 http通信都是明文</li>
<li>被伪装 无法保证通信双方是合法的，通信方可能是伪装的</li>
<li>被篡改 hacker中间篡改数据后，接收方并不知道数据已经被更改</li>
</ol>
<h3 id="HTTPS-怎么建立连接？"><a href="#HTTPS-怎么建立连接？" class="headerlink" title="HTTPS 怎么建立连接？"></a>HTTPS 怎么建立连接？</h3><ol>
<li>客户端发送请求到服务器端</li>
<li>服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在</li>
<li>客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用<br>公开密钥加密发送到服务器端</li>
<li>服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送<br>到客户端</li>
<li>客户端使用共享密钥解密数据</li>
<li>SSL加密建立</li>
</ol>
<h3 id="了解哪些加密算法？"><a href="#了解哪些加密算法？" class="headerlink" title="了解哪些加密算法？"></a>了解哪些加密算法？</h3><ol>
<li>对称加密算法 DES、3DES、AES</li>
<li>非对称算法 RSA、DSA</li>
<li>散列算法 不需要密钥 SHA-1、MD5</li>
<li>MD5 用的是 哈希函数，它的典型应用是对一段信息产生信息摘要，以防<br>止被篡改，无论是多长的输入，MD5都会输出长度为128bits 的一个串。(通<br>常用16进制表示为32个字符)，对于56位长度的密钥来说，如果用穷举法来<br>进行搜索的话，其运算次数为 2 ^ 56 次</li>
<li>SHA-1 消息摘要算法，比MD5的安全性更强，会产生一个160位的消息摘要</li>
<li>DES 加密算法是一种分组密码，以64位为分组对数据加密，它的密钥长<br>度是56位，加密解密用同一算法</li>
</ol>
<h3 id="https（问为什么要对称加密数据，而不用非对称加密数据呢）？"><a href="#https（问为什么要对称加密数据，而不用非对称加密数据呢）？" class="headerlink" title="https（问为什么要对称加密数据，而不用非对称加密数据呢）？"></a>https（问为什么要对称加密数据，而不用非对称加密数据呢）？</h3><ol>
<li>因为非对称加密加密解密算法效率较低，不适合客户端和服务器端这样高<br>频率的通信过程，在某些极端情况下，甚至能比非对称加密慢上1000倍</li>
<li>非对称加密的优势在于它可以很好帮助完成秘钥的交换，所以前期交换秘<br>钥必须使用非对称加密算法</li>
</ol>
<h3 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h3><ol>
<li>用户数据报协议UDP 是无连接的，尽最大可能交付，没有拥塞控制，面<br>向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部）<br>，支持一对一、一对多、多对一和多对多的交互通信</li>
<li>传输控制协议TCP 是面向连接的，提供可靠交付，有流量控制，拥塞控<br>制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，<br>把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的<br>（一对一）</li>
</ol>
<h3 id="UPD相对TCP优点和缺点？"><a href="#UPD相对TCP优点和缺点？" class="headerlink" title="UPD相对TCP优点和缺点？"></a>UPD相对TCP优点和缺点？</h3><ol>
<li>TCP优点 TCP的优点是可靠</li>
<li>TCP缺点 只能支持一对一的数据交互，占用的系统资源也高，有Dos攻击</li>
<li>UDP优点 快速，可以支持一对一，一对多，多对多的数据交互，UDP被攻<br>击者利用的漏洞少</li>
<li>UDP缺点 不可靠，不稳定，数据容易丢失</li>
</ol>
<h3 id="端口的作用？"><a href="#端口的作用？" class="headerlink" title="端口的作用？"></a>端口的作用？</h3><p>作用是对TCP/IP体系的应用进程进行统一的标志,使运行不同操作系统的计<br>算机的应用进程能够互相通信</p>
<h3 id="TCP首部字段有哪些？"><a href="#TCP首部字段有哪些？" class="headerlink" title="TCP首部字段有哪些？"></a>TCP首部字段有哪些？</h3><ul>
<li>seq:”sequance” 序列号</li>
<li>ack:”acknowledge” 确认号</li>
<li>SYN:”synchronize” 请求同步标志</li>
<li>ACK:”acknowledge” 确认标志”</li>
<li>FIN：”Finally” 结束标志</li>
</ul>
<h3 id="TCP三次握手的过程是怎样的（含状态转换，报文中的参数）？"><a href="#TCP三次握手的过程是怎样的（含状态转换，报文中的参数）？" class="headerlink" title="TCP三次握手的过程是怎样的（含状态转换，报文中的参数）？"></a>TCP三次握手的过程是怎样的（含状态转换，报文中的参数）？</h3><p>首先客户端与服务器都是处于CLOSED状态，接下来服务端创建传输控制块TCB<br>，准备接收客户进程的连接请求，这时服务器就进入LISTEN收听状态</p>
<ol>
<li>第一次握手：客户端发送第一个包，其中SYN标志位为1, ACK=0，发送顺<br>序号sequence=X(随机int)。客户端进入SYN发送状态，等待服务器确认。这<br>是一个连接请求报文，客户端进入SYN-SENT（同步已发送）状态</li>
<li>第二次握手：服务器收到这个包后发送第二个包，其中包SYN、ACK标志位<br>为1，发送顺序号seq=y(随机int)，接收顺序号ack=X+1，这是一个连接接<br>收报文，服务端进入SYN-RCVD（同步收到）状态</li>
<li>第三次握手：客户端收到服务器传来的包后，向服务器发送第三个包，<br>SYN=0，ACK=1，接收确认号ack=y+1,发送顺序号seq=x+1。此包发送完<br>毕，客户端ESTABLISHED（已建立连接）状态，服务端收到这个包后也<br>进入已建立连接状态</li>
</ol>
<h3 id="接收端为什么要传回SYN？"><a href="#接收端为什么要传回SYN？" class="headerlink" title="接收端为什么要传回SYN？"></a>接收端为什么要传回SYN？</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就<br>是你所发送的信号了。<br>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正<br>常的 TCP 网络连接时，客户机首先发出一个SYN消息，服务器使用SYN-ACK<br>应答表示接收到了这个消息，最后客户机再以ACK(Acknowledgement[汉译<br>：确认字符,在数据通信传输中，接收站发给发送站的一种传输控制字符。<br>它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务<br>器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递</p>
<h3 id="传了SYN-为啥还要传ACK？"><a href="#传了SYN-为啥还要传ACK？" class="headerlink" title="传了SYN,为啥还要传ACK？"></a>传了SYN,为啥还要传ACK？</h3><p>双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接<br>收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进<br>行验证</p>
<h3 id="为什么要三次握手而不是两次？"><a href="#为什么要三次握手而不是两次？" class="headerlink" title="为什么要三次握手而不是两次？"></a>为什么要三次握手而不是两次？</h3><p>注意为什么A最后还要发送一次确认，这是为了防止已失效的连接请求报文段<br>突然又传送到了B。假定A发出的第一个连接请求没有丢失而是因为延迟到了B<br>，这本是一个早已失效的报文段，但是B在接收到这个报文段后误认为是A又<br>发出的一个新的连接请求，于是向A发送确认请求建立连接，但是目前的A并<br>没有打算发送连接请求，所以不会理睬B的确认，当B认为这个连接已经建立<br>所以会一直等待A发来数据，B的很多资源白白浪费，而且容易被恶意攻击</p>
<h3 id="四次握手是什么情况？"><a href="#四次握手是什么情况？" class="headerlink" title="四次握手是什么情况？"></a>四次握手是什么情况？</h3><p>服务端发送给客户端的报文段可以拆分为两个报文段。可以先发送一个确认<br>报文段（ACK=1 ack=x+1），然后再发送一个同步报文段（SYN=1 seq=y）</p>
<h3 id="第三次握手失败了怎么办？"><a href="#第三次握手失败了怎么办？" class="headerlink" title="第三次握手失败了怎么办？"></a>第三次握手失败了怎么办？</h3><p>当第三次握手失败时，服务器并不会重传ack报文，而是直接发送RST报文段<br>，进入CLOSED状态。RST=1就表明TCP连接出现严重错误，此时必须释放连接<br>，这样做的目的是为了防止SYN洪泛攻击</p>
<h3 id="TCP四次挥手的过程是怎样的（含状态转换，报文中的参数）"><a href="#TCP四次挥手的过程是怎样的（含状态转换，报文中的参数）" class="headerlink" title="TCP四次挥手的过程是怎样的（含状态转换，报文中的参数）"></a>TCP四次挥手的过程是怎样的（含状态转换，报文中的参数）</h3><p>首先客户端和服务端都处于ESTABLISHED状态</p>
<ol>
<li>第一次挥手：主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号<br>seq为u，这个序号值就是前面已经发送的数据的最后一个字节的序号加1，这<br>是一个连接释放报文，进入FIN-WAIT-1（终止状态1）状态</li>
<li>第二次挥手：被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq<br>为v，接收顺序号ack为u+1，这时接收方就进入CLOSE-WAIT（关闭等待）状<br>态，这时TCP处于半关闭状态，发送方已经没有数据要发送了，接收方还可以<br>发送数据，发送方收到确认后进入FIN-WAIT-2（终止状态2）状态，等待接<br>收方发送连接释放报文</li>
<li>第三次挥手：发送连接释放报文，其中FIN标志位为1，发送顺序号seq为w<br>，接收顺序号ack为u+1，此时接收方进入LAST-ACK（最后确认）状态</li>
<li>第四次挥手：发送确认报文段，ACK置为1，发送需要是u+1，确认号是w+1<br>，发送方进入TIME-WAIT（时间等待）状态，这时TCP 连接还没有释放掉，必<br>须经过时间等待计时器设置的时间2MSL后，发送方才会进入CLOSED 状态，<br>MSL叫做最长报文段寿命</li>
</ol>
<h3 id="为什么挥手要四次，而握手只要三次？"><a href="#为什么挥手要四次，而握手只要三次？" class="headerlink" title="为什么挥手要四次，而握手只要三次？"></a>为什么挥手要四次，而握手只要三次？</h3><p>建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭<br>方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了<br>，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的</p>
<h3 id="为什么-TIME-WAIT-状态需要经过-2MSL-才能转换到-CLOSE-状态？"><a href="#为什么-TIME-WAIT-状态需要经过-2MSL-才能转换到-CLOSE-状态？" class="headerlink" title="为什么 TIME_WAIT 状态需要经过 2MSL 才能转换到 CLOSE 状态？"></a>为什么 TIME_WAIT 状态需要经过 2MSL 才能转换到 CLOSE 状态？</h3><p>为什么A在TIME-WAIT状态必须等待两个2MSL？第一是为了保证A发送的最后<br>一个报文段能够到达B，这个报文段可能丢失，如果处在LAST-ACK状态的B<br>收不到已发送的FIN+ACK报文段的确认就会超时重传这个报文段，A在2MSL<br>时间内能收到这个重传的报文段那么A就重传一次确认，重新启动2MSL计时<br>，最后A和B都能进入CLOSED状态，如果不等待2MSL的话就无法收到重传的<br>报文段，那么B就无法进入CLOSED状态。第二关闭链接一段时间后可能会在<br>相同的IP地址和端口建立新的连接，为了防止旧连接的重复分组在新连接<br>已经终止后再现。2MSL足以让所有分组都消失</p>
<h3 id="wait-time状态是哪个阶段？"><a href="#wait-time状态是哪个阶段？" class="headerlink" title="wait_time状态是哪个阶段？"></a>wait_time状态是哪个阶段？</h3><p>通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。客<br>户端主动关闭连接时，会发送最后一个ack后，然后会进入TIME_WAIT状态<br>，再停留2个MSL时间，进入CLOSED状态</p>
<h3 id="timewait一定只能在客户端吗？"><a href="#timewait一定只能在客户端吗？" class="headerlink" title="timewait一定只能在客户端吗？"></a>timewait一定只能在客户端吗？</h3><p>客户端和服务端都有可能</p>
<h3 id="怎么优化timewait过多？"><a href="#怎么优化timewait过多？" class="headerlink" title="怎么优化timewait过多？"></a>怎么优化timewait过多？</h3><ol>
<li>对于一个处理大量短连接的服务器，如果由服务器主动关闭客户端的连接<br>，将导致服务器存在大量的处于TIME_WAIT状态的socket，严重影响服务器<br>的处理能力，甚至耗尽可用的socket</li>
</ol>
<ul>
<li>高并发可以让服务器在短时间范围内同时占用大量端口</li>
<li>短连接表示“业务处理+传输数据的时间远远小于TIMEWAIT超时的时间”<br>的连接</li>
</ul>
<ol start="2">
<li>修改短连接为长连接方式</li>
<li>修改TIME_WAIT连接状态的上限值，超过此数量时，系统会立即清理出多<br>余的TIME_WAIT连接</li>
<li>开启重用机制 许将TIME-WAIT sockets重新用于新的TCP连接，重用<br>TIME_WAIT的条件是收到最后一个包后超过1s</li>
</ol>
<h3 id="timewait需要等待多少？"><a href="#timewait需要等待多少？" class="headerlink" title="timewait需要等待多少？"></a>timewait需要等待多少？</h3><p>2MSL。MSL叫做最长报文段寿命，经过2MSL时间，就可以使本连接持续的时间所<br>产生的所有报文段都从网络中消失</p>
<h3 id="SYN攻击了解么？"><a href="#SYN攻击了解么？" class="headerlink" title="SYN攻击了解么？"></a>SYN攻击了解么？</h3><ol>
<li>SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者<br>就不对其进行再确认，那这个TCP 连接就处于挂起状态，也就是所谓的半连<br>接状态，服务器收不到再确认的话，还会重复发送ACK 给攻击者。这样更加<br>会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP 连接，由<br>于每一个都没法完成三次握手，所以在服务器上，这些TCP 连接会因为挂<br>起状态而消耗CPU 和内存，最后服务器可能死机，就无法为正常用户提供<br>服务了，又称为DDoS攻击</li>
<li>直接攻击 攻击者用他们自己的没有经过伪装的IP地址快速地发送SYN数<br>据包，这种攻击非常容易抵御，用一个简单的防火墙规则阻止带有攻击者IP<br>地址的数据包就可以了</li>
<li>欺骗式攻击 攻击者还必须能够用有效的IP和TCP报文头去替换和重新生<br>成原始IP报文</li>
</ol>
<h3 id="怎么防范SYN攻击？"><a href="#怎么防范SYN攻击？" class="headerlink" title="怎么防范SYN攻击？"></a>怎么防范SYN攻击？</h3><ol>
<li>过滤网关防护 过滤网关主要指明防火墙，当然路由器也能成为过滤网<br>关。防火墙部署在不同网络之间，防范外来非法攻击和防止保密信息外泄<br>，它处于客户端和服务器之间，利用它来防护SYN攻击能起到很好的效果<br>。过滤网关防护主要包括超时设置，SYN网关和SYN代理三种</li>
<li>加固tcp/ip协议栈 防范SYN攻击的另一项主要技术是调整tcp/ip协<br>议栈，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN<br>cookies技术、增加最大半连接和缩短超时时间等</li>
<li>降低SYN timeout时间，使得主机尽快释放半连接的占用</li>
<li>采用SYN cookies设置，如果短时间内连续收到某个IP的重复SYN请求<br>，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文</li>
</ol>
<h3 id="TCP如何保证可靠传输？"><a href="#TCP如何保证可靠传输？" class="headerlink" title="TCP如何保证可靠传输？"></a>TCP如何保证可靠传输？</h3><ol>
<li>校验和 发送的数据包的二进制相加然后取反，目的是检测数据在传输过<br>程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确<br>认收到此报文段</li>
<li>确认应答+序列号 接收方收到报文就会确认（累积确认：对所有按序接收<br>的数据的确认）TCP给发送的每一个包进行编号，接收方对数据包进行排序，<br>把有序数据传送给应用层</li>
<li>超时重传 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到<br>这个报文段。如果不能及时收到一个确认，将重发这个报文段</li>
<li>流量控制 TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允<br>许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数<br>据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议<br>是可变大小的滑动窗口协议</li>
<li>拥塞控制 当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据<br>前比对接收方发过来的即时窗口，取小。慢启动、拥塞避免、拥塞发送、快速恢<br>复。丢弃重复数据</li>
<li>ARQ协议 也是为了实现可靠传输的，它的基本原理就是每发完一个分组<br>就停止发送，等待对方确认。在收到确认后再发下一个分组</li>
</ol>
<h3 id="TCP拥塞控制的过程（四个状态都要解释清楚）是什么样的？"><a href="#TCP拥塞控制的过程（四个状态都要解释清楚）是什么样的？" class="headerlink" title="TCP拥塞控制的过程（四个状态都要解释清楚）是什么样的？"></a>TCP拥塞控制的过程（四个状态都要解释清楚）是什么样的？</h3><p>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变<br>坏，这种情况就叫做网络拥塞。拥塞控制就是防止过多的数据注入网络中，前<br>提是网络能够承受现有的网络负荷，流量控制外网是点对点通信量的控制。有<br>四种算法</p>
<ul>
<li>慢开始 慢开始算法的思路是一开始不发送大量数据，由小到大逐渐增大发<br>送窗口，cwnd初始值为1，每经过一个传播轮次，cwnd加倍直到达到阈值</li>
<li>拥塞避免 达到阈值后使用拥塞避免算法，拥塞避免算法的思路是让拥塞<br>窗口cwnd缓慢增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd<br>加1，而不是加倍增长。当出现网络超时调整阈值为之前的一半，同时设<br>置拥塞窗口为1，进入慢开始阶段。如果发送方一连收到3个对同一个报<br>文段的重复确认，通过快重传算法知道这是丢失个别报文段，于是不<br>启用慢恢复而是快恢复</li>
<li>快重传 快速重传算法可以让发送方尽早知道发生了个别报文段的丢失，<br>要求接收方不要等待自己发送数据时才捎带确认，而是立即发送确认。如果<br>没有收到M3，那么就需要发送对M2的重复确认，发送方只要连续收到3个重<br>复确认就会立即进行重传</li>
<li>快恢复 将门限和拥塞窗口的值调整为当前的一半，并开始拥塞避免算法</li>
</ul>
<h3 id="TCP滑动窗口机制是什么？"><a href="#TCP滑动窗口机制是什么？" class="headerlink" title="TCP滑动窗口机制是什么？"></a>TCP滑动窗口机制是什么？</h3><ol>
<li>滑动窗口的作用是提供TCP 可靠性：对发送的数据进行确认以及流量控<br>制：窗口大小随链路变化</li>
<li>TCP中窗口大小是指tcp协议一次传输多少个数据。因为TCP 是一个面向<br>连接的可靠的传输协议，既然是可靠的就需要传输的数据进行确认</li>
<li>TCP窗口机制有两种，一种是固定窗口大小，另一种是滑动窗口。数据在<br>传输时，TCP会对所有数据进行编号，发送方在发送过程中始终保持着一个<br>窗口，只有落在发送窗口内的数据帧才允许被发送，同时接收方也始终保<br>持着一个接收窗口，只有落在窗口内的数据才会被接收。这样通过改变发<br>送窗口和接收窗口的大小就可以实现流量控制</li>
<li>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，<br>保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制<br>发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发<br>送方不能发送数据，保证流量传输不超过设备的负载能力</li>
</ol>
<h3 id="固定窗口机制？"><a href="#固定窗口机制？" class="headerlink" title="固定窗口机制？"></a>固定窗口机制？</h3><p>需要对每个数据包都进行一个确认</p>
<ol>
<li>如果说窗口过小，那么当传输比较大的数据的时候需要不停的对数据进行<br>确认，这个时候就会造成很大的延迟</li>
<li>如果说窗口的大小定义的过大。我们假设发送方一次发送100个数据。但是<br>接收方只能处理50个数据。这样每次都会只对这50个数据进行确认。发送方下<br>一次还是发送100个数据，但是接受方还是只能处理50个数据。这样就有不必<br>要的数据来拥塞我们的链路</li>
</ol>
<h3 id="滑动窗口大小机制？"><a href="#滑动窗口大小机制？" class="headerlink" title="滑动窗口大小机制？"></a>滑动窗口大小机制？</h3><p>窗口的大小并不是固定的而是根据我们之间的链路的带宽的大小、链路是否拥<br>护塞、接受方是否能处理这么多数据，三个元素共同决定。不需要对每个数据<br>包进行确认，而是可以进行累积确认</p>
<ol>
<li>第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的</li>
<li>窗口大小指的是可以发送数据包的最大数量。在实际使用中，它可以分为<br>两部分。第一部分表示数据包已经发送，但未得到确认应答包，第二部分表<br>示允许发送，但未发送的数据包。在进行数据包发送时，当发送了最大数量<br>的数据包（窗口大小数据包），有时不会同时收到这些数据包的确认应答<br>包，而是收到部分确认应答包</li>
<li>此时窗口就通过滑动的方式，向后移动，确保下一次发送仍然可以发送窗<br>口大小的数据包。这样的发送方式被称为滑动窗口机制</li>
</ol>
<h3 id="滑动窗口的优势？"><a href="#滑动窗口的优势？" class="headerlink" title="滑动窗口的优势？"></a>滑动窗口的优势？</h3><ol>
<li>允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每<br>发送每确认，因此该协议可以加速数据的传输</li>
<li>在接收窗口向前滑动时（与此同时也发送了确认），发送窗口也会同步向<br>前滑动，收发两端的窗口按照以上规律不断地向前滑动，可以动态调整窗口<br>大小</li>
</ol>
<h3 id="滑动窗口初始值是多少？"><a href="#滑动窗口初始值是多少？" class="headerlink" title="滑动窗口初始值是多少？"></a>滑动窗口初始值是多少？</h3><p>第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的</p>
<h3 id="发送缓存和接收缓存的区别？"><a href="#发送缓存和接收缓存的区别？" class="headerlink" title="发送缓存和接收缓存的区别？"></a>发送缓存和接收缓存的区别？</h3><ol>
<li>发送缓存用来暂时存放</li>
</ol>
<ul>
<li>发送应用程序传给发送方TCP准备发送的数据</li>
<li>TCP已发送但尚未收到确认的数据</li>
</ul>
<ol start="2">
<li>接收缓存用来暂时存放</li>
</ol>
<ul>
<li>按序到达的、但尚未被接受应用程序读取的数据</li>
<li>未按序到达的数据</li>
</ul>
<h3 id="拥塞窗口与流量窗口有什么区别？"><a href="#拥塞窗口与流量窗口有什么区别？" class="headerlink" title="拥塞窗口与流量窗口有什么区别？"></a>拥塞窗口与流量窗口有什么区别？</h3><p>滑动窗口位于传输层（区别于数据链路层的），拥塞控制更关注网络层</p>
<ol>
<li>滑动窗口 接受数据端使用的窗口大小，用来告知发送端接收端的缓存<br>大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的</li>
<li>拥塞窗口 防止过多的数据注入到网络中，这样可以使网络中的路由器或<br>链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络<br>负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与<br>降低网络传输性能有关的所有因素</li>
<li>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再<br>增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就<br>减小一些，以减少注入到网络中的分组数</li>
</ol>
<h3 id="ACK超时会怎么样？"><a href="#ACK超时会怎么样？" class="headerlink" title="ACK超时会怎么样？"></a>ACK超时会怎么样？</h3><ol>
<li>重新传送报文 发送一个数据之后，就开启一个定时器，若是在这个时间<br>内没有收到刚才发送数据的ACK确认报文（是通过确认序号的方式进行确认<br>，即刚才发送数据的序列号+1），则对该报文进行重传。如果一直失败，<br>满一定次数后就会放弃并发送一个复位信号</li>
<li>这个定时器的时间（RTO）相当关键，关系着网络资源是否被有效利用，<br>如果RTO设置过小，部分报文可能遇到网络拥堵或者延迟比较大的情形，这<br>样就会频繁重传，浪费带宽。如果RTO设置过大的话，发送端需要等待过长<br>时间才能发现数据丢失，影响网络的传输效率</li>
<li>当发送TCP收到窗口大小为0的确认时，就启动坚持计时器。当坚持计时<br>器期限到时，发送TCP就发送一个特殊的报文段，叫做探测报文</li>
<li>保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时<br>间的空闲，每当服务器收到客户的信息，就将计时器复位。通常设置为两小<br>时。若服务器过了两小时还没有收到客户的信息，他就发送探测报文段。若<br>发送了10个探测报文段（每一个75秒）还没有响应，就假定客户除了故障<br>，因而就终止了该连接</li>
</ol>
<h3 id="使用TCP的协议有哪些？"><a href="#使用TCP的协议有哪些？" class="headerlink" title="使用TCP的协议有哪些？"></a>使用TCP的协议有哪些？</h3><p>FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）<br>、POP3（和SMTP相对，用于接收邮件）、HTTP协议</p>
<h3 id="ARQ协议是什么？"><a href="#ARQ协议是什么？" class="headerlink" title="ARQ协议是什么？"></a>ARQ协议是什么？</h3><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层<br>和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠<br>服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收<br>到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<ol>
<li>停止等待ARQ协议 停止等待协议是为了实现可靠传输的，它的基本原理就<br>是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时<br>间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重<br>新发送，直到收到确认后再发下一个分组，在停止等待协议中，若接收方<br>收到重复分组，就丢弃该分组，但同时还要发送确认</li>
<li>连续ARQ协议 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗<br>口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。<br>接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到<br>这个分组为止的所有分组都已经正确收到了</li>
</ol>
<h3 id="数据包的合成是在哪里进行？"><a href="#数据包的合成是在哪里进行？" class="headerlink" title="数据包的合成是在哪里进行？"></a>数据包的合成是在哪里进行？</h3><p>在发送缓冲中进行</p>
<h3 id="开启Nagle的好处与坏处？"><a href="#开启Nagle的好处与坏处？" class="headerlink" title="开启Nagle的好处与坏处？"></a>开启Nagle的好处与坏处？</h3><ol>
<li>优点 避免网络中充斥着许多小数据块，降低网络负载，减少网络拥塞，提<br>高网络吞吐</li>
<li>缺点 客户端的延迟会增加，实时性降低，不适合延时要求尽量小的场景，<br>且对于大文件传输这种场景，会降低传输速度</li>
<li>大文件传输的情况下，因为文件数据移入输出缓存耗时很小，所以不用<br>nagle算法也会在装满缓存时才会发送数据，因此不仅不会增加数据包的网<br>络流量，反而无需等待ACK就可以传输，因此这种情况不使用nagle可以大<br>幅提高速度</li>
</ol>
<h3 id="什么是TCP粘包？"><a href="#什么是TCP粘包？" class="headerlink" title="什么是TCP粘包？"></a>什么是TCP粘包？</h3><p>发送方发送的若干数据，在接受方接受时这些数据粘在了一起（一包）。从接<br>收缓冲区来看，后一包数据的头紧接着前一包数据的尾。 这种现象被称作<br>TCP的粘包问题</p>
<h3 id="沾包的类型？"><a href="#沾包的类型？" class="headerlink" title="沾包的类型？"></a>沾包的类型？</h3><ol>
<li>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是<br>粘在一起的包有不完整的包</li>
<li>不是所有的粘包现象都需要处理，若传输的数据为不带结构的连续流数据<br>（如文件传输），则不必把粘连的包分开（简称分包）</li>
<li>在处理定长结构数据的粘包问题时，分包算法比较简单；在处理不定长结<br>构数据的粘包问题时，分包算法就比较复杂</li>
</ol>
<h3 id="TCP粘包产生的原因？"><a href="#TCP粘包产生的原因？" class="headerlink" title="TCP粘包产生的原因？"></a>TCP粘包产生的原因？</h3><p>粘包产生的原因可能由发送方造成，也可能由接收方造成</p>
<ol>
<li>发送方 发送端为了将多个发往接收端的包，更加高效的的发给接收端<br>，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的<br>数据，合并成一个数据量大的数据块，然后进行封包。而Nagle算法是造<br>成发送方出现沾包问题的主要原因</li>
<li>接收方 TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应<br>用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然<br>后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓<br>存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应<br>用程序就有可能读取到多个首尾相接粘到一起的包</li>
</ol>
<h3 id="TCP粘包如何解决？"><a href="#TCP粘包如何解决？" class="headerlink" title="TCP粘包如何解决？"></a>TCP粘包如何解决？</h3><ol>
<li>对于发送方：可以通过编程设置来关闭Nagle算法，使用TCP提供的强制<br>数据立即传送的操作指令push。但这样会降低发送效率，影响程序性能，所<br>以这个方法并不推荐使用</li>
<li>对于接受方：只能通过优化程序设计等措施保证接收方及时接收数据。但<br>这种方法只能减少粘包出现的可能性，并不能完全防止粘包问题的发生，所<br>以并不能算做成一个解决方案</li>
<li>应用层：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，<br>就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每<br>条数据的长度呢？<br>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易<br>行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符<br>和结束符发送长度：发送每条数据时，将数据的长度一并发送，例如规定<br>数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分<br>组的开始和结束位置</li>
<li>在数据包中添加长度的方式，即在数据包中的固定位置封装数据包的长度<br>信息，服务器接收到数据后，先是解析包长度，然后根据包长度截取数据包</li>
</ol>
<h3 id="UDP存在粘包问题吗？"><a href="#UDP存在粘包问题吗？" class="headerlink" title="UDP存在粘包问题吗？"></a>UDP存在粘包问题吗？</h3><ol>
<li>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了<br>基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界<br>的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，<br>接收端一次只能接受一条独立的消息）</li>
<li>UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条<br>独立的信息，所以不存在粘包问题</li>
</ol>
<h3 id="TCP拆包产生的原因和解法方法是什么？"><a href="#TCP拆包产生的原因和解法方法是什么？" class="headerlink" title="TCP拆包产生的原因和解法方法是什么？"></a>TCP拆包产生的原因和解法方法是什么？</h3><p>产生原因如下</p>
<ol>
<li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包</li>
<li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包</li>
</ol>
<h3 id="沾包和拆包如何解决？"><a href="#沾包和拆包如何解决？" class="headerlink" title="沾包和拆包如何解决？"></a>沾包和拆包如何解决？</h3><p>解决方法如下</p>
<ol>
<li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获<br>取消息头的时候解析出消息长度，然后向后读取该长度的内容</li>
<li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息，当消<br>息不够长时，空位补上固定字符，这样接收端每次接收缓冲区中读取固定长<br>度的数据就自然而然的把每个数据包拆分开来</li>
<li>设置消息边界，服务端从网络流中按消息边界分离出消息内容，一般使用\n</li>
<li>更为复杂的协议，车联网协议 808,809 协议</li>
</ol>
<h3 id="TCP和UDP的区别？各自的应用场景"><a href="#TCP和UDP的区别？各自的应用场景" class="headerlink" title="TCP和UDP的区别？各自的应用场景"></a>TCP和UDP的区别？各自的应用场景</h3><ol>
<li>TCP应用场景：效率要求相对低，但对准确性要求相对高的场景。因为<br>传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。文<br>件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录</li>
<li>UDP应用场景：效率要求相对高，对准确性要求相对低的场景。QQ聊天、<br>在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不<br>是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、<br>多播）</li>
</ol>
<h3 id="如何实现可靠的UDP？"><a href="#如何实现可靠的UDP？" class="headerlink" title="如何实现可靠的UDP？"></a>如何实现可靠的UDP？</h3><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以<br>参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层</p>
<ol>
<li>添加seq/ack机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要是用户超时重传</li>
<li>添加超时重传机制</li>
</ol>
<p>有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT</p>
<ol>
<li>RUDP RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制<br>及淡化服务器算法等</li>
<li>RTP RTP为数据提供了具有实时特征的端对端传送服务</li>
<li>UDT UDT的主要目的是支持高速广域网上的海量数据传输</li>
</ol>
<h3 id="URI和URL的区别是什么？"><a href="#URI和URL的区别是什么？" class="headerlink" title="URI和URL的区别是什么？"></a>URI和URL的区别是什么？</h3><ol>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标<br>识一个资源</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资<br>源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指<br>明了如何locate 这个资源</li>
<li>URI一般由三部组成</li>
</ol>
<ul>
<li>访问资源的命名机制</li>
<li>存放资源的主机名</li>
<li>资源自身的名称，由路径表示，着重强调于资源</li>
</ul>
<ol start="4">
<li>URL</li>
</ol>
<ul>
<li>协议(或称为服务方式)</li>
<li>存有该资源的主机IP地址(有时也包括端口号)</li>
<li>主机资源的具体地址。如目录和文件名等</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的<br>URI，它不仅唯一标识资源，而且还提供了定位该资源的信息</p>
<h3 id="四次挥手中客户端的-TIME-WAIT-的状态的意义是什么？"><a href="#四次挥手中客户端的-TIME-WAIT-的状态的意义是什么？" class="headerlink" title="四次挥手中客户端的 TIME-WAIT 的状态的意义是什么？"></a>四次挥手中客户端的 TIME-WAIT 的状态的意义是什么？</h3><ol>
<li>可靠地实现TCP全双工连接的终止 最终的ACK是由主动关闭连接的一端（<br>后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出<br>最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的<br>ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将<br>响应RST分节，B端收到后将此分节解释成一个错误，为了TCP打算执行必<br>要的工作以彻底终止某个连接两个方向上的数据流（即全双工关闭），<br>那么他必须要正确处理连接终止四个分节中任何一个分节丢失的情况</li>
<li>允许老的重复分节在网络中消逝 因为TIME_WAIT状态持续2MSL，就可以<br>保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中<br>消逝</li>
</ol>
<h3 id="为什么http一定要用TCP呢？"><a href="#为什么http一定要用TCP呢？" class="headerlink" title="为什么http一定要用TCP呢？"></a>为什么http一定要用TCP呢？</h3><ol>
<li>如果用UDP，网页源文件传输后可能出现错误，浏览器解析出错</li>
</ol>
<h3 id="长连接的好处？"><a href="#长连接的好处？" class="headerlink" title="长连接的好处？"></a>长连接的好处？</h3><ol>
<li>减少CPU及内存的使用，因为不需要经常的建立及关闭连接</li>
<li>减少网络的堵塞，因为减少了TCP请求，单个客户端不允许开启2个以上<br>的长连接，这个标准的目的是减少HTTP响应的时候，减少网络堵塞</li>
<li>减少后续请求的响应时间，因为此时不需要建立TCP，也不需要TCP握手<br>等过程</li>
<li>当发生错误时，可以在不关闭连接的情况下进行提示</li>
<li>缺点：可能会损害服务器的整体性能，如apache的长连接时间的长短，直<br>接影响到服务器的并发数</li>
</ol>
<h3 id="写一个简单的webserver？"><a href="#写一个简单的webserver？" class="headerlink" title="写一个简单的webserver？"></a>写一个简单的webserver？</h3><ol>
<li>服务器是属于被动的一方，当浏览器发起请求的时候，服务器才能和浏览<br>器通信，在此之前，服务器都处于一个等待监听的状态</li>
<li>实现服务器的第一步是建立一个 socket 连接，socket 套接字是对<br>TCP/UDP协议 的一个封装，socket()用于创建一个套接字，该套接字用<br>于监听某个端口</li>
<li>解析http请求 在bind()中套接字与端口绑定，随后通过listen()进行监<br>听，这时候就进入服务器程序的主循环，当有连接建立后，accpet()被调用<br>并返回一个新的套接字用于处理连接，这时派生一个子进程进行处理，子进<br>程中recv()从缓冲区读取数据交由相关函数处理</li>
<li>构造响应报文 拿到了请求报文并将其解析后，我们可以开始构造响应报文<br>的内容了，处理完毕后的结果通过send()发送出去，随后关闭用于处理的套<br>接字，子进程退出</li>
</ol>
<h3 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h3><p>socket是对TCP/IP协议的封装，它的出现只是使得程序员更方便地使用TCP<br>/IP协议栈而已。socket本身并不是协议，它是应用层与TCP/IP协议族通信<br>的中间软件抽象层，是一组调用接口（TCP/IP网络的API函数）</p>
<ol>
<li>服务端需要建立 socket 来监听指定的地址，然后等待客户端来连接。而<br>客户端则需要建立 socket 并与服务端的 socket 地址进行连接</li>
<li>调用这个网络库的一些API函数实现分布在不同主机的相关进程之间的数<br>据交换</li>
</ol>
<h3 id="什么是半关闭？什么是半打开？"><a href="#什么是半关闭？什么是半打开？" class="headerlink" title="什么是半关闭？什么是半打开？"></a>什么是半关闭？什么是半打开？</h3><ol>
<li>半关闭 当TCP链接中A向B发送FIN 请求关闭，另一端B回应ACK之后，并没<br>有立即发送FIN 给A，A方处于半关闭状态。此时A可以接收B发送的数据，但是<br>A已经不能再向B发送数据</li>
<li>半连接 如果A向B发起链接，B也按照正常情况响应了，但是A不进行三次握<br>手，这就是半连接。半连接攻击：半连接，会造成B分配的内存资源就一直这么<br>耗着，直到资源耗尽。（SYN攻击）</li>
<li>半打开 如果一方关闭或者异常关闭，而另一方并不知情，这样的链接称之<br>为半打开，如果需要发数据的话，这边收到之后 其实发现这个连接并不存在<br>了，就会回复RST包告知，这个时候就需要重新建立连接了</li>
</ol>
<h3 id="客户端的close-Wait是什么时候开始的？"><a href="#客户端的close-Wait是什么时候开始的？" class="headerlink" title="客户端的close-Wait是什么时候开始的？"></a>客户端的close-Wait是什么时候开始的？</h3><ol>
<li>主动关闭的一方发出FIN 包，被动关闭的一方响应ACK 包，此时被动关闭<br>的一方就进入了CLOSE_WAIT 状态。如果一切正常，稍后被动关闭的一方也会<br>发出FIN 包，然后迁移到LAST_ACK 状态</li>
<li>通常CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的<br>CLOSE_WAIT状态，那么就意味着被动关闭的一方没有及时发出FIN 包</li>
</ol>
<ul>
<li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不<br>会发出 FIN 包，从而导致 CLOSE_WAIT 累积</li>
<li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接timeout<br>，另一方却还在忙于耗时逻辑，就会导致 close 被延后</li>
</ul>
<h3 id="客户端接收到了服务器的close请求了，客户端不调用close，继续发包会怎么样？"><a href="#客户端接收到了服务器的close请求了，客户端不调用close，继续发包会怎么样？" class="headerlink" title="客户端接收到了服务器的close请求了，客户端不调用close，继续发包会怎么样？"></a>客户端接收到了服务器的close请求了，客户端不调用close，继续发包会怎么样？</h3><p>根据TCP协议的规定，认为它是一个异常终止连接，客户端将会收到一个RST<br>复位响应(而不是ACK响应)，如果客户端再次向服务端发送数据，系统将会<br>发送一个SIGPIPE信号给客户端进程，告诉客户端进程该连接已关闭，不要<br>再写了。系统给SIGPIPE信号的默认处理是直接终止收到该信号的进程，所<br>以此时客户端进程会被极不情愿地终止</p>
<h3 id="为什么挥手不可以三次？"><a href="#为什么挥手不可以三次？" class="headerlink" title="为什么挥手不可以三次？"></a>为什么挥手不可以三次？</h3><p>为什么是四次挥手，因为如果只进行了1、2次。由于TCP是全双工的，可以处于<br>Half-Close状态，此时就是处于Half-Close状态，客户端到服务器的通道已<br>经关闭，服务器到客户端的通道还没关闭，所以需要第三次和第四次来完全关<br>闭连接</p>
<h3 id="如何设计http2-0的头部压缩-说了哈夫曼编码或者字典树"><a href="#如何设计http2-0的头部压缩-说了哈夫曼编码或者字典树" class="headerlink" title="如何设计http2.0的头部压缩(说了哈夫曼编码或者字典树)"></a>如何设计http2.0的头部压缩(说了哈夫曼编码或者字典树)</h3><ol>
<li>hpack表 把经常使用的头部键值对进行表格化（可以理解为数据缓存），<br>使其可以通过索引进行数据关联。如果头部键值已经存在直接使用索引进行<br>传输，对方便可解析对应数据内容</li>
</ol>
<h3 id="描述一下TCP是怎么发送文件的？"><a href="#描述一下TCP是怎么发送文件的？" class="headerlink" title="描述一下TCP是怎么发送文件的？"></a>描述一下TCP是怎么发送文件的？</h3><ol>
<li>当你把要传送的数据传递给TCP后，TCP把文件按照MTU的大小分成一个个<br>包分成很多个数据包(这种数据包称为TCP分组)，每一个分组都包含有一个<br>序号</li>
<li>接着TCP分组被传递给IP层，IP层把这个TCP分组放在一个IP数据包的数<br>据部分。然后，这个IP数据包被传到目的主机</li>
</ol>
<h3 id="Chrome-为什么多进程而不是多线程？"><a href="#Chrome-为什么多进程而不是多线程？" class="headerlink" title="Chrome 为什么多进程而不是多线程？"></a>Chrome 为什么多进程而不是多线程？</h3><ol>
<li>Chromium里有三种进程——浏览器、渲染器和插件</li>
<li>有一种情况是多个页面使用同一进程，这就是同一站点</li>
<li>同一站点“定义为根域名加上协议，还包含了该根域名下的所有子域名<br>和不同的端口</li>
<li>Chrome 的默认策略是，每个标签对应一个渲染进程。但是如果从一个页<br>面打开了新页面，而新页面和当前页面属于同一个站点，那么新页面会复用<br>父页面的渲染进程</li>
<li>如果几个页面属于同一站点，那么他们将会被分配到同一个渲染进程中<br>，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同<br>一个渲染进程</li>
<li>因为在一个渲染进程中，他们就会共享 JS 的执行环境</li>
</ol>
<h3 id="TCP有了checksum还可能会造成数据错乱吗"><a href="#TCP有了checksum还可能会造成数据错乱吗" class="headerlink" title="TCP有了checksum还可能会造成数据错乱吗"></a>TCP有了checksum还可能会造成数据错乱吗</h3><p>有可能</p>
<ol>
<li>因为可能错误的数据凑成了正确的校验和。任何检测误差的方法都是有<br>他的极限的，错太多了就不行了</li>
<li>校验和本身传输的时候出错了</li>
</ol>
<h3 id="为什么初始化序列号要随机取，从0开始会出现什么问题？"><a href="#为什么初始化序列号要随机取，从0开始会出现什么问题？" class="headerlink" title="为什么初始化序列号要随机取，从0开始会出现什么问题？"></a>为什么初始化序列号要随机取，从0开始会出现什么问题？</h3><ol>
<li>假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然<br>后又不断地建立新的连接、传送报文段和释放连接，假定每一次建立连接时<br>，主机A都选择相同的、固定的初始序号，假定主机A发送出的某些TCP报文<br>段在网络中会滞留较长的时间，以致造成主机A超时重传这些TCP报文段，<br>假定有一些在网络中滞留时间较长的TCP报文段最后终于到达了主机B，但<br>这时传送该报文段的那个连接早已释放了．而在到达主机B时的TCP连接是<br>一条新的TCP连接，因此必须使得迟到的TCP报文段的序号不处在新的连接<br>中所使用的序号范围之中</li>
<li>如果TCP每次连接都使用固定ISN，黑客可以很方便模拟任何IP与server<br>建立连接，抓包只能发生在同一网络中，随机ISN能避免非同一网络的攻击</li>
</ol>
<h3 id="网页无法响应，分析原因？"><a href="#网页无法响应，分析原因？" class="headerlink" title="网页无法响应，分析原因？"></a>网页无法响应，分析原因？</h3><ol>
<li>DNS坏掉了，修改自己的IP地址为8.8.8.8试试</li>
<li>网络断了</li>
<li>服务器拒绝访问</li>
<li>请求或者响应在网络传输中途被劫走了</li>
</ol>
<h3 id="web-server实现了什么？"><a href="#web-server实现了什么？" class="headerlink" title="web server实现了什么？"></a>web server实现了什么？</h3><p>Web服务器可以解析(handles)HTTP协议。当Web服务器接收到一个HTTP请<br>求(request)，会返回一个HTTP响应(response)</p>
<h3 id="流量控制和拥塞控制有什么区别？"><a href="#流量控制和拥塞控制有什么区别？" class="headerlink" title="流量控制和拥塞控制有什么区别？"></a>流量控制和拥塞控制有什么区别？</h3><ol>
<li>流量控制解决的是发送方和接收方速率不匹配的问题，发送方发送过快接<br>收方就来不及接收和处理。采用的机制是滑动窗口的机制</li>
<li>拥塞控制解决的是避免网络资源被耗尽的问题，通过大家自律的采取避让<br>的措施，来避免网络有限资源被耗尽。当出现丢包时，控制发送的速率达到<br>降低网络负载的目的</li>
<li>流量控制是通过滑动窗口来实现的。 滑动窗口分为发送端窗口和接收端窗<br>口，窗口大小是接收端用来告诉发送端目前接收端能接收的最大字节数</li>
<li>拥塞控制是通过拥塞窗口来实现的。拥塞窗口指发送端在一个RTT内可以最<br>多发送的数据包数</li>
<li>滑动窗口是接收方的流量控制，拥塞控制是发送方的流量控制</li>
</ol>
<h3 id="https是用了哪些加密协议？"><a href="#https是用了哪些加密协议？" class="headerlink" title="https是用了哪些加密协议？"></a>https是用了哪些加密协议？</h3><ol>
<li>HTTPS采用的是TLS协议+SSL证书实现安全网站访问的</li>
<li>TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密<br>和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采<br>用协商的密钥对数据加密，基于散列函数验证信息的完整性</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NetWork/">NetWork</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/22/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>抢课项目总结</span></a></div><div class="next-post pull-right"><a href="/2021/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"><span>操作系统总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/01/08/计算机网络总结/';
  this.page.title = '计算机网络总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>