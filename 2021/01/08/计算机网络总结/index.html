<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机网络总结"><meta name="keywords" content="NetWork"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>计算机网络总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题总结"><span class="toc-number">2.</span> <span class="toc-text">面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI七层模型与TCP-IP四层模型"><span class="toc-number">2.1.</span> <span class="toc-text">OSI七层模型与TCP&#x2F;IP四层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要分层"><span class="toc-number">2.2.</span> <span class="toc-text">为什么要分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#各层的常见协议"><span class="toc-number">2.3.</span> <span class="toc-text">各层的常见协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-number">2.4.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用层"><span class="toc-number">2.5.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#应用层常见协议，对应的端口"><span class="toc-number">2.5.1.</span> <span class="toc-text">应用层常见协议，对应的端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入一个URL，到打开网页的过程中发生了什么。"><span class="toc-number">2.5.2.</span> <span class="toc-text">输入一个URL，到打开网页的过程中发生了什么。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-number">2.6.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常见状态码的含义"><span class="toc-number">2.6.1.</span> <span class="toc-text">常见状态码的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GET和POST的区别"><span class="toc-number">2.6.2.</span> <span class="toc-text">GET和POST的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1与HTTP-1-0的区别"><span class="toc-number">2.6.3.</span> <span class="toc-text">HTTP&#x2F;1.1与HTTP&#x2F;1.0的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1的流水线技术"><span class="toc-number">2.6.4.</span> <span class="toc-text">HTTP&#x2F;1.1的流水线技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2-0与HTTP-1-x的区别"><span class="toc-number">2.6.5.</span> <span class="toc-text">HTTP&#x2F;2.0与HTTP&#x2F;1.x的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session与Cookie的区别"><span class="toc-number">2.6.6.</span> <span class="toc-text">Session与Cookie的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#幂等性了解吗？"><span class="toc-number">2.6.7.</span> <span class="toc-text">幂等性了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跨域产生的原因？如何解决？"><span class="toc-number">2.6.8.</span> <span class="toc-text">跨域产生的原因？如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？"><span class="toc-number">2.6.9.</span> <span class="toc-text">谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS"><span class="toc-number">2.7.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP和HTTPS有什么区别？HTTPS的S是什么意思？"><span class="toc-number">2.7.1.</span> <span class="toc-text">HTTP和HTTPS有什么区别？HTTPS的S是什么意思？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#了解对称加密算法和非对称加密算法的区别吗？"><span class="toc-number">2.7.2.</span> <span class="toc-text">了解对称加密算法和非对称加密算法的区别吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS握手过程"><span class="toc-number">2.7.3.</span> <span class="toc-text">TLS握手过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#证书是什么？有什么作用？"><span class="toc-number">2.7.4.</span> <span class="toc-text">证书是什么？有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的攻击手段（XSS、CSRF）"><span class="toc-number">2.7.5.</span> <span class="toc-text">常见的攻击手段（XSS、CSRF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS的优缺点"><span class="toc-number">2.7.6.</span> <span class="toc-text">HTTPS的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP（非常重要！！！）"><span class="toc-number">2.8.</span> <span class="toc-text">TCP（非常重要！！！）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP三次握手的过程（含状态转换，报文中的参数）"><span class="toc-number">2.8.1.</span> <span class="toc-text">TCP三次握手的过程（含状态转换，报文中的参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要三次握手而不是两次？"><span class="toc-number">2.8.2.</span> <span class="toc-text">为什么要三次握手而不是两次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三次握手失败了怎么办？"><span class="toc-number">2.8.3.</span> <span class="toc-text">第三次握手失败了怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP四次挥手的过程（含状态转换，报文中的参数）"><span class="toc-number">2.8.4.</span> <span class="toc-text">TCP四次挥手的过程（含状态转换，报文中的参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么挥手要四次，而握手只要三次？"><span class="toc-number">2.8.5.</span> <span class="toc-text">为什么挥手要四次，而握手只要三次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么-TIME-WAIT-状态需要经过-2MSL-才能转换到-CLOSE-状态？"><span class="toc-number">2.8.6.</span> <span class="toc-text">为什么 TIME_WAIT 状态需要经过 2MSL 才能转换到 CLOSE 状态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SYN攻击了解么？怎么防范？"><span class="toc-number">2.8.7.</span> <span class="toc-text">SYN攻击了解么？怎么防范？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP如何保证可靠传输？"><span class="toc-number">2.8.8.</span> <span class="toc-text">TCP如何保证可靠传输？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP拥塞控制的过程。（四个状态都要解释清楚）"><span class="toc-number">2.8.9.</span> <span class="toc-text">TCP拥塞控制的过程。（四个状态都要解释清楚）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP滑动窗口机制"><span class="toc-number">2.8.10.</span> <span class="toc-text">TCP滑动窗口机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP粘包产生的原因和解决办法"><span class="toc-number">2.8.11.</span> <span class="toc-text">TCP粘包产生的原因和解决办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">2.9.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP和UDP的区别？各自的应用场景"><span class="toc-number">2.9.1.</span> <span class="toc-text">TCP和UDP的区别？各自的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何实现可靠的UDP？"><span class="toc-number">2.9.2.</span> <span class="toc-text">如何实现可靠的UDP？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络层"><span class="toc-number">2.10.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简单了解IP协议和ARP协议"><span class="toc-number">2.10.1.</span> <span class="toc-text">简单了解IP协议和ARP协议</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">计算机网络总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/01/08/计算机网络总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/maybe2030/p/4781555.html#_label3" target="_blank" rel="noopener">https://www.cnblogs.com/maybe2030/p/4781555.html#_label3</a></p>
<h2 id="面试题总结"><a href="#面试题总结" class="headerlink" title="面试题总结"></a>面试题总结</h2><h3 id="OSI七层模型与TCP-IP四层模型"><a href="#OSI七层模型与TCP-IP四层模型" class="headerlink" title="OSI七层模型与TCP/IP四层模型"></a>OSI七层模型与TCP/IP四层模型</h3><p>OSI七层模型由七个层次组成，分别是应用层、表示层、会话层、运输层、网<br>络层、数据链路层和物理层。TCP/IP五层模型分别由应用层、运输层、网际<br>层、网络接口层组成</p>
<h3 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h3><p>计算机网络是很复杂的，两个计算机必须高度协调工作才行。分层可以将<br>庞大而复杂的问题转化为若干较小的局部问题，这些较小的局部问题就<br>容易研究和处理，换句话说就是将各种特定的功能分隔开，分层结构使<br>各个层次的设计和测试相对独立，各层分别实现不同的功能，下层为上<br>层提供服务</p>
<h3 id="各层的常见协议"><a href="#各层的常见协议" class="headerlink" title="各层的常见协议"></a>各层的常见协议</h3><p>应用层：HTTP HTTPS FTP SMTP DNS<br>运输层：TCP UDP<br>网际层：IP<br>数据链路层：ARP PPP</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的<br>协议。服务器可以主动向客户端推送信息，客户端也可以主动向服务器<br>发送信息，是真正的双向平等对话，属于服务器推送技术的一种</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="应用层常见协议，对应的端口"><a href="#应用层常见协议，对应的端口" class="headerlink" title="应用层常见协议，对应的端口"></a>应用层常见协议，对应的端口</h4><ul>
<li>FTP 21</li>
<li>TFTP 69</li>
<li>TELNET</li>
<li>HTTP 80</li>
</ul>
<h4 id="输入一个URL，到打开网页的过程中发生了什么。"><a href="#输入一个URL，到打开网页的过程中发生了什么。" class="headerlink" title="输入一个URL，到打开网页的过程中发生了什么。"></a>输入一个URL，到打开网页的过程中发生了什么。</h4><p>参考 <a href="https://blog.csdn.net/zcw4237256/article/details/78461623" target="_blank" rel="noopener">https://blog.csdn.net/zcw4237256/article/details/78461623</a><br>总体来说分为以下几个过程: <img src="/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<ol>
<li>DNS解析 首先查找域名服务器获取相应域名的IP地址，首先以UDP数据<br>报的形式发送给本地域名服务器。主机向本地域名服务器的查询一般采用递<br>归查询，递归查询就是如果主机询问的本地域名服务器不知道被查询的IP<br>地址，那么本地域名服务器就会以DNS客户的身份器其他根域名服务器查询<br>，主机不会进行下一步查询。本地域名服务器向根域名服务器查询分为两种<br>方式，通常采用迭代查询：当根域名服务器收到本地域名服务器的请求时<br>会告诉本地域名服务器应该去哪一个域名服务器查询而不是帮助本地域名<br>服务器查询。本地服务器也可以采用递归查询，取决于最初查询请求报文<br>的设置是哪一种方式。为了提高DNS 查询效率在域名服务器和主机中都是<br>用了高速缓存。比如域名是 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 网址的解析是一个从右向<br>左的过程。注意DNS同时支持UDP和TCP，如果DNS响应超过512个字节那<br>么使用UDP就会将数据截断为512个字节，多余的部分会抛弃，因为UDP<br>没有字段来表示报文ID。所以当响应报文的长度大于512个字节的时候<br>就会使用TCP。为什么要使用UDP？<br>UDP速度更快，不需要三次握手。DNS请求和响应通常都很小，一般数据内容<br>不会超过512字节。可以在应用层弥补UDP不可靠的缺点，自己完成超时和重<br>传处理。还有一个点是关于DNS负载均衡，事实上每次返回的IP地址并不一<br>定都是一样的，资源是分布在许多的服务器，DNS会根据每台机器的负载量<br>该机器距离用户地理位置的距离来返回一个合适的IP</li>
<li>HTTP协议生成请求报文 生成针对目标Web服务器的HTTP请求报文，HTTP<br>请求报文由三部分组成：请求行，请求报头和请求正文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">请求行</span><br><span class="line">Method Request-URL HTTP-Version CRLF</span><br><span class="line">eg: GET index.html HTTP&#x2F;1.1</span><br><span class="line">请求报头</span><br><span class="line">请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息</span><br><span class="line">常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, </span><br><span class="line">Accept-Language, Content-Type, Authorization, Cookie, User-Agent等</span><br><span class="line">请求正文</span><br><span class="line">当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在</span><br><span class="line">请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通</span><br><span class="line">常采用Rest架构，请求的数据格式一般为json。这时就需要设置</span><br><span class="line">Content-Type: application&#x2F;json</span><br></pre></td></tr></table></figure></li>
<li>TCP协议将请求报文分割成报文段，进行可靠传输</li>
<li>IP协议进行分组转发</li>
<li>接收方TCP协议重组请求报文，按照序号以原来的顺序重组报文</li>
<li>HTTP协议对请求进行处理，比如返回相应的资源，HTTP响应报文也是<br>由三部分组成: 状态码, 响应报头和响应报文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</span><br><span class="line">响应报头</span><br><span class="line">常见的响应报头字段有: Server, Connection...</span><br><span class="line">响应报文</span><br><span class="line">服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分</span><br></pre></td></tr></table></figure></li>
<li>浏览器解析渲染页面</li>
</ol>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎么<br>把文档传送给浏览器，它不断监听TCP的端口80。本身无连接也无状态。当建立<br>TCP连接的三报文握手的前两部分完成后，就把HTTP请求报文作为建立TCP连<br>接的三报文握手中的第三个报文数据</p>
<h4 id="常见状态码的含义"><a href="#常见状态码的含义" class="headerlink" title="常见状态码的含义"></a>常见状态码的含义</h4><p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求<br>301 redirect: 301 代表永久性转移(Permanently Moved)<br>302 redirect: 302 代表暂时性转移(Temporarily Moved )</p>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><ol>
<li>参数位置 GET方法参数位置包含在URL，POST方法参数包含在请求主体</li>
<li>参数长度 GET方法的URL长度有限度，POST长度没有显示</li>
<li>参数编码 GET方法参数编码是ASCLL码，POST没有限制</li>
<li>TCP数据包 GET方法产生一个TCP数据包，把首部和数据一起发送，POST<br>方法产生两个TCP数据包，先发首部，服务器响应后再发数据  </li>
<li>功能 GET请求读取由URL所标志的信息，POST给服务器添加信息</li>
</ol>
<h4 id="HTTP-1-1与HTTP-1-0的区别"><a href="#HTTP-1-1与HTTP-1-0的区别" class="headerlink" title="HTTP/1.1与HTTP/1.0的区别"></a>HTTP/1.1与HTTP/1.0的区别</h4><ol>
<li>缓存处理 在HTTP/1.0中主要使用header里的If-Modified=Since,<br>Expires来作为缓存判断的标准，HTTP/1.1则引入更多的缓存控制策略<br>例如Entity tag等</li>
<li>带宽优化及网络连接的使用 HTTP/1.0中客户端只是需要某个对象的<br>一部分，当服务器将整个对象传送过来，并且不支持断点续传功能，<br>HTTP/1.1在请求头中引入range头域，允许只请求资源的某个部分，<br>返回码是206</li>
<li>错误通知的管理 在HTTP/1.1中新增了24个错误状态响应码，如409<br>表示请求的资源与资源当前状态冲突，410表示服务器上的某个资源被<br>永久性删除</li>
<li>Host头处理 HTTP/1.0中认为每台服务器都绑定唯一的IP地址，所以<br>在URL中没有传递主机名，但是一个物理服务器上可以有多个虚拟主机，<br>共享一个IP地址，HTTP/1.1支持Host头域</li>
<li>长连接 HTTP/1.1支持长连接和请求的流水线处理，在一个TCP连接<br>上可以传送多个HTTP请求和响应</li>
</ol>
<h4 id="HTTP-1-1的流水线技术"><a href="#HTTP-1-1的流水线技术" class="headerlink" title="HTTP/1.1的流水线技术"></a>HTTP/1.1的流水线技术</h4><p>客户在收到HTTP的响应报文之前就能够接着发送新的请求报文，于是一个接一<br>个的请求报文到达服务器后服务器就可连续发回响应报文，客户访问所有的对<br>象只需要花费一个RTT时间，不局限于传送同一个页面上链接的文档</p>
<h4 id="HTTP-2-0与HTTP-1-x的区别"><a href="#HTTP-2-0与HTTP-1-x的区别" class="headerlink" title="HTTP/2.0与HTTP/1.x的区别"></a>HTTP/2.0与HTTP/1.x的区别</h4><p>参考 <a href="https://segmentfault.com/a/1190000016656529" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016656529</a></p>
<ol>
<li>新的二进制格式 HTTP/1.x 的解析是基于文本，基于文本协议的解析<br>存在天然缺陷，文本的表现形式由多样性，要做到健壮性考虑的场景必须<br>很多。二进制则不同，只认0和1的组合。基于这种考虑HTTP/2.0的协议解<br>析决定采用二进制格式，实现方便且健壮</li>
<li>多路复用 即连接共享，每一个request都是用做连接共享机制的，一个<br>request对应一个id，这样一个连接上可以有多个request，每个连接的<br>request可以随机混杂在一起，接受方可以根据request的id将request<br>再归属到各自不同的服务端请求中</li>
<li>header压缩 HTTP/1.x的header带有大量信息，而且每次都要重复发<br>送，HTTP/2.0使用encoder减少需要传送的header大小</li>
<li>服务端推送 同SPDY一样，HTTP/2.0也具有server push功能</li>
</ol>
<p>HTTP/2（超文本传输协议第2版，最初命名为HTTP2.0），是HTTP协议的第二个<br>主要版本。HTTP/2是HTTP 协议自1999年HTTP1.1发布后的首个更新，主要基于<br>SPDY协议。HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字<br>段的情况下，大幅度提高了web性能。<br>SPDY是Speedy的昵音，意为“更快”。它是Google开发的基于TCP协议的应用层<br>协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩<br>短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数<br>。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。</p>
<h4 id="Session与Cookie的区别"><a href="#Session与Cookie的区别" class="headerlink" title="Session与Cookie的区别"></a>Session与Cookie的区别</h4><p>HTTP是无状态的，但是网上购物时服务器必须记住用户的身份，可以在HTTP中<br>使用，万维网站点可以使用Cookie来跟踪用户，可以表示为在用户和服务器之<br>间传递的状态信息。当用户A浏览一个使用Cookie的网站时，该网站的服务器<br>就会为A产生唯一一个识别码，并以此作为索引在服务器的后端数据库中产生<br>一个项目，接着在给A的HTTP响应报文中添加一个叫做Set-cookie的首部行<br>，这里首部字段名就是Set-cookie，值就是赋予用户的识别码，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: 31d3h432h4u23</span><br></pre></td></tr></table></figure>
<p>A接收到响应之后浏览器就在它管理的特定Cookie文件中添加一行，其中就包括<br>这个服务器的主机名和Set-cookie后面给出的识别码，当A继续浏览网站时每<br>发送一个HTTP请求报文其浏览器就会从Cookie文件中取出这个网站的识别码<br>并放到HTTP请求报文的Cookie首部行中，于是网站就能够持续跟踪这个用户<br>的活动。<br>浏览器端第一次发送请求到服务器端，服务器端创建一个 Session，同时会创<br>建一个特殊的Cookie（name为JSESSIONID的固定值，value 为session对象<br>的ID），然后将该Cookie 发送至浏览器端。浏览器端发送第N（N&gt;1）次请求<br>到服务器端,浏览器端访问服务器端时携带该name为JSESSIONID的Cookie对<br>象。服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查<br>询Session对象，从而区分不同用户。<br>cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
<ol>
<li>存储位置 Cookie是客户端技术，数据保存在客户端，Session是服务端<br>会话技术，数据保存在服务器端</li>
<li>存储容量 Cookie一般小于等于4KB，Session无限制</li>
<li>跨域支持 Cookie支持跨域，Session不支持</li>
<li>作用 Cookie一般存储少量不太敏感的数据，Token授权机制，时间戳超时<br>机制，签名机制，拒绝重复调用</li>
</ol>
<h4 id="幂等性了解吗？"><a href="#幂等性了解吗？" class="headerlink" title="幂等性了解吗？"></a>幂等性了解吗？</h4><p>参考 <a href="https://www.cnblogs.com/weidagang2046" target="_blank" rel="noopener">https://www.cnblogs.com/weidagang2046</a><br>参考 <a href="https://cloud.tencent.com/developer/ask/217917" target="_blank" rel="noopener">https://cloud.tencent.com/developer/ask/217917</a><br>幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致<br>的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，<br>用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时<br>钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，<br>用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中<br>，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应<br>客户端的时候也有可能出现网络中断或者异常等等。</p>
<h4 id="跨域产生的原因？如何解决？"><a href="#跨域产生的原因？如何解决？" class="headerlink" title="跨域产生的原因？如何解决？"></a>跨域产生的原因？如何解决？</h4><p>当一个请求url的协议、域名、端口三者之间的任意一个与当前页面url不同<br>即为跨域。同源策略（Same Orgin Policy）是一种约定，它是浏览器核<br>心也最基本的安全功能，它会阻止一个域的js脚本和另外一个域的内容进<br>行交互，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓<br>同源（即在同一个域）就是两个页面具有相同的协议（protocol）、主机<br>（host）和端口号（port）。<br>窗口之间JS跨域postMessage；简单的跨域请求jsonp即可，复杂的用cors<br>，开发环境下接口跨域用nginx反向代理或node中间件比较方便</p>
<h4 id="谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？"><a href="#谈下你对-HTTP-长连接和短连接的理解？分别应用于哪些场景？" class="headerlink" title="谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？"></a>谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</h4><p>短连接：例如普通的web请求，在三次握手之后建立连接，发送数据包并得到<br>服务器返回的结果之后，通过客户端和服务端的四次握手进行关闭断开。<br>长连接：区别于短连接，由于三次握手链接及四次握手断开，在请求频繁的情<br>况下，链接请求和断开请求的开销较大，影响效率。采用长连接方式，执行三<br>次握手链接后，不断开链接，保持客户端和服务端通信，直到服务器超时自动<br>断开链接，或者客户端主动断开链接。<br>短连接：适用于网页浏览等数据刷新频度较低的场景。<br>长连接：适用于客户端和服务端通信频繁的场景，例如聊天室，实时游戏等</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通<br>信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网<br>站服务器的身份认证，保护交换数据的隐私与完整性</p>
<h4 id="HTTP和HTTPS有什么区别？HTTPS的S是什么意思？"><a href="#HTTP和HTTPS有什么区别？HTTPS的S是什么意思？" class="headerlink" title="HTTP和HTTPS有什么区别？HTTPS的S是什么意思？"></a>HTTP和HTTPS有什么区别？HTTPS的S是什么意思？</h4><p>参考 <a href="https://www.runoob.com/w3cnote/http-vs-https.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/http-vs-https.html</a><br>HTTP明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP）数据传<br>输过程是加密的，安全性较好。s指的是SSL，即安全套接层</p>
<h4 id="了解对称加密算法和非对称加密算法的区别吗？"><a href="#了解对称加密算法和非对称加密算法的区别吗？" class="headerlink" title="了解对称加密算法和非对称加密算法的区别吗？"></a>了解对称加密算法和非对称加密算法的区别吗？</h4><p>对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据<br>发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后， 使<br>其变成复杂的加密密文发送出去。 收信方收到密文后，若想解读原文，则<br>需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其<br>恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方<br>都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道<br>加密密钥。<br>不对称加密算法使用两把完全不同但又是完全匹配的一对钥匙—公钥和私钥。<br>在使用不对称加密算法加密文件时，只有使用匹配的一对公钥和私钥，才能<br>完成对明文的加密和解密过程。加密明文时采用公钥加密，解密密文时使用<br>私钥才能完成，而且发信方（加密者）知道收信方的公钥，只有收信方（<br>解密者）才是唯一知道自己私钥的人</p>
<h4 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h4><p>参考 <a href="https://zhuanlan.zhihu.com/p/37636276" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37636276</a><br>TLS是一个信道建立和信道的表达方式，向下依托于TCP，向上对应用程序服<br>务。随着TLS的发展，DTLS也开始出现，就是同样的TLS逻辑被应用于UDP 业<br>务之上。由于客户端的网络千奇百怪，TCP需要普遍长连接的时候几乎就是不<br>靠谱的代名词，肯定是要断线重连机制的。如果处理的不好，还很容易形成<br>SYN攻击或者过多的耗费服务器资源。因此固定长连接的客户端业务，例如<br>游戏场景，大都倾向于使用UDP作为连接承载，在这种情况下，DTLS 就有<br>了很大的用武之地。UDP是一种基础协议，很多人选择了UDP 通常也并没有<br>明确原因，很多是基于不想去处理 TCP 那么多显而易见的麻烦的事情。但<br>是最后用了UDP之后，发现要做的事情甚至比TCP麻烦。但是UDP相对于TCP<br>的一个巨大的优势是UDP相当于四层的IP协议，在此之上可以构造更复杂<br>的取代TCP的协议，而不用改动内核代码。市场上确实是UDP也在大量的<br>使用。所以DTLS也仍然有市场</p>
<h4 id="证书是什么？有什么作用？"><a href="#证书是什么？有什么作用？" class="headerlink" title="证书是什么？有什么作用？"></a>证书是什么？有什么作用？</h4><p>SSL 证书是一种能够在服务器和浏览器之间的信息交换过程中实现通信安全的<br>工具,对发送和接受的数据进行加密保护。</p>
<ol>
<li>提供身份验证</li>
<li>加密敏感信息</li>
<li>提高网站信任度</li>
<li>优化页面加载速度</li>
</ol>
<h4 id="常见的攻击手段（XSS、CSRF）"><a href="#常见的攻击手段（XSS、CSRF）" class="headerlink" title="常见的攻击手段（XSS、CSRF）"></a>常见的攻击手段（XSS、CSRF）</h4><p>XSS 全称是Cross Site Scripting，为了与“CSS”区分开来，故简称XSS<br>，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者DOM中<br>注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击<br>的一种手段。<br>存在原因浏览器为了在安全和自由之间找到一个平衡点。支持了页面中的引<br>用第三方资源和 跨域资源共享（CORS），这样做带来了很多安全问题，其<br>中最典型的就是 XSS 攻击。Dos攻击，SQL注入攻击，OS命令注入攻击，<br>HTTP头部攻击，目录攻击，开放重定向攻击</p>
<h4 id="HTTPS的优缺点"><a href="#HTTPS的优缺点" class="headerlink" title="HTTPS的优缺点"></a>HTTPS的优缺点</h4><p>优点：相比于http，https可以提供更加优质保密的信息，保证了用户数据<br>的安全性，此外https同时也一定程度上保护了服务端，使用恶意攻击和伪<br>装数据的成本大大提高<br>缺点：第一https的技术门槛较高，多数个人或者私人网站难以支撑，CA机<br>构颁发的证书都是需要年费的，此外对接Https协议也需要额外的技术支持<br>，其二，目前来说大多数网站并不关心数据的安全性和保密性，其https最<br>大的优点对它来说并不适用；其三，https加重了服务端的负担，相比于<br>http其需要更多的资源来支撑，同时也降低了用户的访问速度；第四，<br>目前来说Http网站仍然大规模使用，在浏览器侧也没有特别大的差别，<br>很多用户不关心的话根本不感知</p>
<h3 id="TCP（非常重要！！！）"><a href="#TCP（非常重要！！！）" class="headerlink" title="TCP（非常重要！！！）"></a>TCP（非常重要！！！）</h3><h4 id="TCP三次握手的过程（含状态转换，报文中的参数）"><a href="#TCP三次握手的过程（含状态转换，报文中的参数）" class="headerlink" title="TCP三次握手的过程（含状态转换，报文中的参数）"></a>TCP三次握手的过程（含状态转换，报文中的参数）</h4><ol>
<li>第一次握手：客户端发送第一个包，其中SYN标志位为1, ACK=0，发送顺<br>序号sequence=X(随机int)。客户端进入SYN发送状态，等待服务器确认。</li>
<li>第二次握手：服务器收到这个包后发送第二个包，其中包SYN、ACK标志位<br>为1，发送顺序号seq=Y(随机int)，接收顺序号ACK=X+1，此时服务器进入<br>SYN接收状态。</li>
<li>第三次握手：客户端收到服务器传来的包后，向服务器发送第三个包，<br>SYN=0，ACK=1，接收顺序号ACK = Y+1,发送顺序号seq=X+1。此包发送完<br>毕，客户端和服务器进入ESTABLISHED建立成功状态，完成三次握手。</li>
</ol>
<h4 id="为什么要三次握手而不是两次？"><a href="#为什么要三次握手而不是两次？" class="headerlink" title="为什么要三次握手而不是两次？"></a>为什么要三次握手而不是两次？</h4><p>注意为什么A最后还要发送一次确认，这是为了防止已失效的连接请求报文段<br>突然又传送到了B。假定A发出的第一个连接请求没有丢失而是因为延迟到了B<br>，这本是一个早已失效的报文段，但是B在接收到这个报文段后误认为是A又<br>发出的一个新的连接请求，于是向A发送确认请求建立连接，但是目前的A并<br>没有打算发送连接请求，所以不会理睬B的确认，当B认为这个连接已经建立<br>所以会一直等待A发来数据，B的很多资源白白浪费吗，而且容易被恶意攻击</p>
<h4 id="第三次握手失败了怎么办？"><a href="#第三次握手失败了怎么办？" class="headerlink" title="第三次握手失败了怎么办？"></a>第三次握手失败了怎么办？</h4><p>当第三次握手失败时，服务器并不会重传ack报文，而是直接发送RST报文段<br>，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。</p>
<h4 id="TCP四次挥手的过程（含状态转换，报文中的参数）"><a href="#TCP四次挥手的过程（含状态转换，报文中的参数）" class="headerlink" title="TCP四次挥手的过程（含状态转换，报文中的参数）"></a>TCP四次挥手的过程（含状态转换，报文中的参数）</h4><ol>
<li>第一次挥手：主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号<br>seq为X</li>
<li>第二次挥手：被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq<br>为Z，接收顺序号ack为X+1</li>
<li>第三次挥手：被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序<br>号seq为Y，接收顺序号ack为X</li>
<li>第四次挥手：主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号<br>为Y。至此，完成四次挥手</li>
</ol>
<h4 id="为什么挥手要四次，而握手只要三次？"><a href="#为什么挥手要四次，而握手只要三次？" class="headerlink" title="为什么挥手要四次，而握手只要三次？"></a>为什么挥手要四次，而握手只要三次？</h4><p>建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭<br>方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了<br>，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的</p>
<h4 id="为什么-TIME-WAIT-状态需要经过-2MSL-才能转换到-CLOSE-状态？"><a href="#为什么-TIME-WAIT-状态需要经过-2MSL-才能转换到-CLOSE-状态？" class="headerlink" title="为什么 TIME_WAIT 状态需要经过 2MSL 才能转换到 CLOSE 状态？"></a>为什么 TIME_WAIT 状态需要经过 2MSL 才能转换到 CLOSE 状态？</h4><p>为什么A在TIME-WAIT状态必须等待两个2MSL？第一是为了保证A发送的最后<br>一个报文段能够到达B，这个报文段可能丢失，如果处在LAST-ACK状态的B<br>收不到已发送的FIN+ACK报文段的确认就会超时重传这个报文段，A在2MSL<br>时间内能收到这个重传的报文段那么A就重传一次确认，重新启动2MSL计时<br>，最后A和B都能进入CLOSED状态，如果不等待2MSL的话就无法收到重传的<br>报文段，那么B就无法进入CLOSED状态。第二关闭链接一段时间后可能会在<br>相同的IP地址和端口建立新的连接，为了防止旧连接的重复分组在新连接<br>已经终止后再现。2MSL足以让所有分组都消失</p>
<h4 id="SYN攻击了解么？怎么防范？"><a href="#SYN攻击了解么？怎么防范？" class="headerlink" title="SYN攻击了解么？怎么防范？"></a>SYN攻击了解么？怎么防范？</h4><p>syn其实就是在进行到第二次握手结束后，此时服务器不是已经发送了syn<br>消息和synack消息了吗，由于tcp3次握手机制，等待终端反馈synack 消<br>息，服务器得分配一定的资源等着终端。可是终端不但不回复synack给服<br>务器，反倒搞一大堆第一阶段的syn请求消息。这下服务器得腾出好多好<br>多资源给终端。这就是所谓的syn攻击，又称为ddos攻击。</p>
<ol>
<li>过滤网关防护 过滤网关主要指明防火墙，当然路由器也能成为过滤网<br>关。防火墙部署在不同网络之间，防范外来非法攻击和防止保密信息外泄<br>，它处于客户端和服务器之间，利用它来防护SYN攻击能起到很好的效果<br>。过滤网关防护主要包括超时设置，SYN网关和SYN代理三种</li>
<li>加固tcp/ip协议栈 防范SYN攻击的另一项主要技术是调整tcp/ip协<br>议栈，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN<br>cookies技术、增加最大半连接和缩短超时时间等</li>
</ol>
<h4 id="TCP如何保证可靠传输？"><a href="#TCP如何保证可靠传输？" class="headerlink" title="TCP如何保证可靠传输？"></a>TCP如何保证可靠传输？</h4><ol>
<li>校验和 发送的数据包的二进制相加然后取反，目的是检测数据在传输过<br>程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确<br>认收到此报文段</li>
<li>确认应答+序列号 接收方收到报文就会确认（累积确认：对所有按序接收<br>的数据的确认）TCP给发送的每一个包进行编号，接收方对数据包进行排序，<br>把有序数据传送给应用层</li>
<li>超时重传 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到<br>这个报文段。如果不能及时收到一个确认，将重发这个报文段</li>
<li>流量控制 TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允<br>许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数<br>据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议<br>是可变大小的滑动窗口协议</li>
<li>拥塞控制 当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据<br>前比对接收方发过来的即使窗口，取小。慢启动、拥塞避免、拥塞发送、快速恢<br>复。丢弃重复数据</li>
</ol>
<h4 id="TCP拥塞控制的过程。（四个状态都要解释清楚）"><a href="#TCP拥塞控制的过程。（四个状态都要解释清楚）" class="headerlink" title="TCP拥塞控制的过程。（四个状态都要解释清楚）"></a>TCP拥塞控制的过程。（四个状态都要解释清楚）</h4><p>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变<br>坏，这种情况就叫做网络拥塞。拥塞控制就是防止过多的数据注入网络中，前<br>提是网络能够承受现有的网络负荷，流量控制外网是点对点通信量的控制。有<br>四种算法</p>
<ul>
<li>慢开始 慢开始算法的思路是一开始不发送大量数据，由小到大逐渐增大发<br>送窗口</li>
<li>拥塞避免 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，每经过一个往<br>返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍增长</li>
<li>快重传 快速重传算法可以让发送方尽早知道发生了个别报文段的丢失</li>
<li>快恢复 将门限和拥塞窗口的值调整为当前的一半，并开始拥塞避免算法</li>
</ul>
<h4 id="TCP滑动窗口机制"><a href="#TCP滑动窗口机制" class="headerlink" title="TCP滑动窗口机制"></a>TCP滑动窗口机制</h4><p>滑动窗口的作用是提供TCP 可靠性：对发送的数据进行确认以及流量控制：窗<br>口大小随链路变化。TCP中窗口大小是指tcp协议一次传输多少个数据。因为TCP<br>是一个面向连接的可靠的传输协议，既然是可靠的就需要传输的数据进行确认。<br>TCP窗口机制有两种，一种是固定窗口大小，另一种是滑动窗口。数据在传输时<br>，TCP会对所有数据进行编号，发送方在发送过程中始终保持着一个窗口，只<br>有落在发送窗口内的数据帧才允许被发送，同时接收方也始终保持着一个接<br>收窗口，只有落在窗口内的数据才会被接收。这样通过改变发送窗口和接收<br>窗口的大小就可以实现流量控制。</p>
<h4 id="TCP粘包产生的原因和解决办法"><a href="#TCP粘包产生的原因和解决办法" class="headerlink" title="TCP粘包产生的原因和解决办法"></a>TCP粘包产生的原因和解决办法</h4><p>发送方发送的若干数据，在接受方接受时这些数据粘在了一起（一包）。从接收<br>缓冲区来看，后一包数据的头紧接着前一包数据的尾。 这种现象被称作TCP的粘<br>包问题。<br>粘包产生的原因：发送端为了将多个发往接收端的包，更加高效的的发给接收端<br>，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，<br>合并成一个数据量大的数据块，然后进行封包。而Nagle算法是造成发送方出现<br>沾宝问题的主要原因。TCP接收到数据包时，并不会马上交到应用层进行处理，<br>或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存<br>里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包<br>到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，<br>应用程序就有可能读取到多个首尾相接粘到一起的包。<br>解决方法：<br>对于发送方：可以通过编程设置来关闭Nagle算法，使用TCP提供的强制数据立即<br>传送的操作指令push。但这样会降低发送效率，影响程序性能，所以这个方法并<br>不推荐使用。<br>对于接受方：只能通过优化程序设计等措施保证接收方及时接收数据。但这种方法<br>只能减少粘包出现的可能性，并不能完全防止粘包问题的发生，所以并不能算做<br>成一个解决方案。<br>应用层：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该<br>循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长<br>度呢？<br>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，<br>但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符<br>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是<br>数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置<br>UDP是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的<br>信息，所以不存在粘包问题</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="TCP和UDP的区别？各自的应用场景"><a href="#TCP和UDP的区别？各自的应用场景" class="headerlink" title="TCP和UDP的区别？各自的应用场景"></a>TCP和UDP的区别？各自的应用场景</h4><p>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后<br>，不需要给出任何确认。TCP 则提供面向连接的服务。<br>TCP应用场景：效率要求相对低，但对准确性要求相对高的场景。因为传输中需<br>要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文<br>件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。<br>UDP应用场景：效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ<br>聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不<br>是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）</p>
<h4 id="如何实现可靠的UDP？"><a href="#如何实现可靠的UDP？" class="headerlink" title="如何实现可靠的UDP？"></a>如何实现可靠的UDP？</h4><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参<br>照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<ol>
<li>添加seq/ack机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>添加超时重传机制。</li>
</ol>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="简单了解IP协议和ARP协议"><a href="#简单了解IP协议和ARP协议" class="headerlink" title="简单了解IP协议和ARP协议"></a>简单了解IP协议和ARP协议</h4><p>IP地址就是给互联网上的每一台主机的每一个接口分配一个在全世界范围内<br>是唯一的32位的标识符。IP地址的编址经历了三个阶段</p>
<ol>
<li>分类的IP地址</li>
<li>子网的划分</li>
<li>构成超网</li>
</ol>
<p>不管网络层使用什么协议，在实际的网络链路上传送数据帧时最终还是需<br>要使用硬件地址。ARP协议就是用来通过IP地址解析出MAC地址</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NetWork/">NetWork</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/01/22/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>个人项目总结</span></a></div><div class="next-post pull-right"><a href="/2021/01/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"><span>操作系统总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/01/08/计算机网络总结/';
  this.page.title = '计算机网络总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>