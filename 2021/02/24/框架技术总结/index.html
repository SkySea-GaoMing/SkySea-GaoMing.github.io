<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="框架技术总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>框架技术总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">2.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是spring？"><span class="toc-number">2.1.</span> <span class="toc-text">什么是spring？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是POJO？"><span class="toc-number">2.2.</span> <span class="toc-text">什么是POJO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Spring框架的好处是什么？"><span class="toc-number">2.3.</span> <span class="toc-text">使用Spring框架的好处是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列举一些重要的Spring模块？"><span class="toc-number">2.4.</span> <span class="toc-text">列举一些重要的Spring模块？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Spring-IOC容器？"><span class="toc-number">2.5.</span> <span class="toc-text">什么是Spring IOC容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC的原理是什么？"><span class="toc-number">2.6.</span> <span class="toc-text">IOC的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC有什么好处？"><span class="toc-number">2.7.</span> <span class="toc-text">IOC有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean的创建方式有哪些？"><span class="toc-number">2.8.</span> <span class="toc-text">Bean的创建方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring容器创建对象的时机分几种？"><span class="toc-number">2.9.</span> <span class="toc-text">Spring容器创建对象的时机分几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释Spring支持哪几种bean的作用域？"><span class="toc-number">2.10.</span> <span class="toc-text">解释Spring支持哪几种bean的作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean的生命周期？"><span class="toc-number">2.11.</span> <span class="toc-text">Spring Bean的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory和ApplicationContext有什么区别？"><span class="toc-number">2.12.</span> <span class="toc-text">BeanFactory和ApplicationContext有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是依赖注入？"><span class="toc-number">2.13.</span> <span class="toc-text">什么是依赖注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有哪些不同类型的IOC（依赖注入）方式？"><span class="toc-number">2.14.</span> <span class="toc-text">有哪些不同类型的IOC（依赖注入）方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP的原理是什么？"><span class="toc-number">2.15.</span> <span class="toc-text">AOP的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用AOP？"><span class="toc-number">2.16.</span> <span class="toc-text">为什么使用AOP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切入点与切面的区别？"><span class="toc-number">2.17.</span> <span class="toc-text">切入点与切面的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式有哪些？"><span class="toc-number">2.18.</span> <span class="toc-text">代理模式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代理的缺点？"><span class="toc-number">2.19.</span> <span class="toc-text">静态代理的缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理是如何实现的？"><span class="toc-number">2.20.</span> <span class="toc-text">动态代理是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理Class对象和代理对象的区别？"><span class="toc-number">2.21.</span> <span class="toc-text">代理Class对象和代理对象的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理的缺点是什么？"><span class="toc-number">2.22.</span> <span class="toc-text">动态代理的缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP如何实现？"><span class="toc-number">2.23.</span> <span class="toc-text">AOP如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP和AspectJ-AOP有什么区别？"><span class="toc-number">2.24.</span> <span class="toc-text">Spring AOP和AspectJ AOP有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP的通知类型？"><span class="toc-number">2.25.</span> <span class="toc-text">AOP的通知类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring框架中用到了哪些设计模式？"><span class="toc-number">2.26.</span> <span class="toc-text">Spring框架中用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Spring-beans？"><span class="toc-number">2.27.</span> <span class="toc-text">什么是Spring beans？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你怎样定义类的作用域？"><span class="toc-number">2.28.</span> <span class="toc-text">你怎样定义类的作用域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个Spring-Bean定义包含什么？"><span class="toc-number">2.29.</span> <span class="toc-text">一个Spring Bean定义包含什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何给Spring容器提供配置元数据？"><span class="toc-number">2.30.</span> <span class="toc-text">如何给Spring容器提供配置元数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哪些是重要的bean生命周期方法？你能重载它们吗？"><span class="toc-number">2.31.</span> <span class="toc-text">哪些是重要的bean生命周期方法？你能重载它们吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是bean的自动装配？"><span class="toc-number">2.32.</span> <span class="toc-text">什么是bean的自动装配？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有哪几种自动装配方式？"><span class="toc-number">2.33.</span> <span class="toc-text">有哪几种自动装配方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是基于Java的Spring注解配置"><span class="toc-number">2.34.</span> <span class="toc-text">什么是基于Java的Spring注解配置?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Component的作用？"><span class="toc-number">2.35.</span> <span class="toc-text">@Component的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Component和-Bean的区别是什么？"><span class="toc-number">2.36.</span> <span class="toc-text">@Component和@Bean的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource的作用？"><span class="toc-number">2.37.</span> <span class="toc-text">@Resource的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired的作用？"><span class="toc-number">2.38.</span> <span class="toc-text">@Autowired的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Qualifier的作用？"><span class="toc-number">2.39.</span> <span class="toc-text">@Qualifier的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring事务管理的方式有几种？"><span class="toc-number">2.40.</span> <span class="toc-text">Spring事务管理的方式有几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种事务管理方式的优劣？"><span class="toc-number">2.41.</span> <span class="toc-text">两种事务管理方式的优劣？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事务管理器的接口？"><span class="toc-number">2.42.</span> <span class="toc-text">什么是事务管理器的接口？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PlatformTransactionManager接口是什么？"><span class="toc-number">2.43.</span> <span class="toc-text">PlatformTransactionManager接口是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TransactionStatus是什么？"><span class="toc-number">2.44.</span> <span class="toc-text">TransactionStatus是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TransactionDefinition是什么？"><span class="toc-number">2.45.</span> <span class="toc-text">TransactionDefinition是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事务的传播行为？"><span class="toc-number">2.46.</span> <span class="toc-text">什么是事务的传播行为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是隔离级别？"><span class="toc-number">2.47.</span> <span class="toc-text">什么是隔离级别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是只读？"><span class="toc-number">2.48.</span> <span class="toc-text">什么是只读？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事务超时？"><span class="toc-number">2.49.</span> <span class="toc-text">什么是事务超时？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是回滚规则？"><span class="toc-number">2.50.</span> <span class="toc-text">什么是回滚规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring声明式事务如何配置？"><span class="toc-number">2.51.</span> <span class="toc-text">Spring声明式事务如何配置？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC"><span class="toc-number">3.</span> <span class="toc-text">SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是SpringMVC？"><span class="toc-number">3.1.</span> <span class="toc-text">什么是SpringMVC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC三个字母分别代表什么意思？"><span class="toc-number">3.2.</span> <span class="toc-text">MVC三个字母分别代表什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC工作原理是什么？"><span class="toc-number">3.3.</span> <span class="toc-text">SpringMVC工作原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Controller的作用？"><span class="toc-number">3.4.</span> <span class="toc-text">@Controller的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequestMapping"><span class="toc-number">3.5.</span> <span class="toc-text">@RequestMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PathVariable的作用？"><span class="toc-number">3.6.</span> <span class="toc-text">@PathVariable的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequestParam的作用？"><span class="toc-number">3.7.</span> <span class="toc-text">@RequestParam的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResponseBody的作用？"><span class="toc-number">3.8.</span> <span class="toc-text">@ResponseBody的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequestBody的作用？"><span class="toc-number">3.9.</span> <span class="toc-text">@RequestBody的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC中拦截器如何使用？"><span class="toc-number">3.10.</span> <span class="toc-text">SpringMVC中拦截器如何使用？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">框架技术总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/02/24/框架技术总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.nowcoder.com&#x2F;discuss&#x2F;5683?type&#x3D;all&amp;order&#x3D;time&amp;pos&#x3D;&amp;page&#x3D;1&amp;channel</span><br><span class="line">&#x3D;-1&amp;source_id&#x3D;search_all_nctrack</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;yanggb&#x2F;p&#x2F;11004887.html</span><br><span class="line">https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;20794107</span><br></pre></td></tr></table></figure>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="什么是spring？"><a href="#什么是spring？" class="headerlink" title="什么是spring？"></a>什么是spring？</h3><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但<br>是有些扩展是针对构建J2EE平台的web 应用。它是很多模块的集合，使用这些模块<br>可以很方便地协助我们进行开发。Spring 框架目标是简化Java企业级应用开发，<br>并通过POJO为基础的编程模型促进良好的编程习惯。Spring的核心是控制反转<br>（IoC）和面向切面（AOP）</p>
<h3 id="什么是POJO？"><a href="#什么是POJO？" class="headerlink" title="什么是POJO？"></a>什么是POJO？</h3><p>plain ordinary java object：简单无规则java对象，传统意义的java对象，最<br>基本的Java Bean只有属性加上属性的get和set方法，也就是实体类</p>
<h3 id="使用Spring框架的好处是什么？"><a href="#使用Spring框架的好处是什么？" class="headerlink" title="使用Spring框架的好处是什么？"></a>使用Spring框架的好处是什么？</h3><ol>
<li>轻量：Spring 是轻量的，基本的版本大约2MB</li>
<li>方便解耦，简化开发：通过Spring提供的IoC容器，我们可以将对象之间的依<br>赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，<br>用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以<br>更专注于上层的应用</li>
<li>面向切面的编程(AOP)：通过Spring提供的AOP功能，方便进行面向切面的编程<br>，许多不容易用传统OOP实现的功能可以通过AOP轻松应付</li>
<li>MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品</li>
<li>声明式事务的支持：在Spring中，我们可以从单调烦闷的事务管理代码中解脱<br>出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，<br>Hibernate or JDO抛出的）转化为一致的unchecked 异常</li>
<li>方便程序的测试：可以用非容器依赖的编程方式进行几乎所有的测试工作，<br>在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对<br>Junit4支持，可以通过注解方便的测试Spring程序</li>
<li>容器：Spring包含并管理应用对象的配置和生命周期，在这个意义上它<br>是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型<br>（prototype），你的bean可以创建一个单独的实例或者每次需要时都生<br>成一个新的实例——以及它们是如何相互关联的</li>
</ol>
<h3 id="列举一些重要的Spring模块？"><a href="#列举一些重要的Spring模块？" class="headerlink" title="列举一些重要的Spring模块？"></a>列举一些重要的Spring模块？</h3><ol>
<li>Spring Core：基础，可以说Spring其他所有的功能都依赖于该类库。主要提供IOC<br>和DI功能</li>
<li>Spring Aspects：该模块为与AspectJ的集成提供支持</li>
<li>Spring AOP：提供面向切面的编程实现</li>
<li>Spring JDBC：Java数据库连接</li>
<li>Spring JMS：Java消息服务。</li>
<li>Spring ORM：用于支持Hibernate等ORM工具</li>
<li>Spring Web：为创建Web应用程序提供支持</li>
<li>Spring Test：提供了对JUnit和TestNG测试的支持</li>
</ol>
<h3 id="什么是Spring-IOC容器？"><a href="#什么是Spring-IOC容器？" class="headerlink" title="什么是Spring IOC容器？"></a>什么是Spring IOC容器？</h3><p>Spring IOC负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象<br>，所有的类的创建、销毁都由spring来控制，spring管理这些对象的整个生命周期</p>
<h3 id="IOC的原理是什么？"><a href="#IOC的原理是什么？" class="headerlink" title="IOC的原理是什么？"></a>IOC的原理是什么？</h3><p>IOC（Inversion Of Controll，控制反转，也叫依赖注入）是一种设计思想，就是<br>将原本在程序中手动创建对象的控制权，交由给Spring框架来管理。IOC 在其他语言<br>中也有应用，并非Spring特有。IOC容器是Spring用来实现IOC的载体，IOC 容器实<br>际上就是一个Map(key,value)，Map 中存放的是各种对象。将对象之间的相互依赖<br>关系交给IOC 容器来管理，并由IOC容器完成对象的注入。这样可以很大程度上简化<br>应用的开发，把应用从复杂的依赖关系中解放出来。IOC容器就像是一个工厂一样，<br>当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑<br>对象是如何被创建出来的</p>
<h3 id="IOC有什么好处？"><a href="#IOC有什么好处？" class="headerlink" title="IOC有什么好处？"></a>IOC有什么好处？</h3><ol>
<li>在实际项目中一个Service类可能由几百甚至上千个类作为它的底层，假如我们<br>需要实例化这个Service，可能要每次都搞清楚这个Service所有底层类的构造函<br>数，这可能会把人逼疯。如果利用IOC的话，你只需要配置好，然后在需要的地方<br>引用就行了，大大增加了项目的可维护性且降低了开发难度</li>
<li>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再<br>需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC<br>容器支持加载服务时的饿汉式初始化和懒加载</li>
</ol>
<h3 id="Bean的创建方式有哪些？"><a href="#Bean的创建方式有哪些？" class="headerlink" title="Bean的创建方式有哪些？"></a>Bean的创建方式有哪些？</h3><ol>
<li>利用默认的构造方法 在applicationContext.xml文件中配置id和class<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloIoc"</span> <span class="attr">class</span>=<span class="string">"com.ys.ioc.HelloIoc"</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloIoc"</span> <span class="attr">class</span>=<span class="string">"com.ys.ioc.HelloIoc"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"fd"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
使用有参数构造器进行定义，使用此中方式，可以使用<constructor-arg>标签<br>指定构造器参数值，其中index表示位置，value表示常量值，也可以指定引用，<br>指定引用使用ref来引用另一个Bean定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、启动 spring 容器</span></span><br><span class="line">ApplicationContext context =<span class="keyword">new</span> ClassPathXmlApplicationContext</span><br><span class="line">(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//2、从 spring 容器中取出数据</span></span><br><span class="line">HelloIoc IOC = (HelloIoc) context.getBean(<span class="string">"helloIoc"</span>);</span><br></pre></td></tr></table></figure></constructor-arg></li>
<li>利用静态工厂方法 使用这种方式除了指定必须的class属性，还要指定<br>factory-method属性来指定实例化Bean的方法，而且使用静态工厂方法也<br>允许指定方法参数，spring IoC容器将调用此属性指定的方法来获取Bean<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstances"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">class</span>=<span class="string">"com.ys.ioc.HelloStaticFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
spring容器只负责调用静态工厂方法，而这个静态工厂方法内部实现由程序<br>员完成<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloStaticFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloStaticFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloStaticFactory constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HelloIoc <span class="title">getInstances</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloIoc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObjectStaticFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        HelloIoc staticFactory =</span><br><span class="line">                (HelloIoc) context.getBean(<span class="string">"helloStaticFactory"</span>);</span><br><span class="line">        staticFactory.sayHello();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>利用实例工厂方法 使用这种方式不能指定class属性，此时必须使用<br>factory-bean属性来指定工厂Bean，factory-method属性指定实例化<br>Bean的方法，而且使用实例工厂方法允许指定方法参数，方式和使用构<br>造器方式一样<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"com.ys.ioc.HelloInstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instance"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> </span></span><br><span class="line"><span class="tag">    	<span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloInstanceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloInstanceFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例工厂方法构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用实例工厂方法创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloIoc <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloIoc instanceIoc = <span class="keyword">new</span> HelloIoc();</span><br><span class="line">        <span class="keyword">return</span> instanceIoc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createObjectInstanceFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        HelloIoc staticFactory =</span><br><span class="line">                (HelloIoc) context.getBean(<span class="string">"instance"</span>);</span><br><span class="line">        staticFactory.sayHello();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>利用setter方式 这种方式，只要写上对应的set、get方法，然后再<br>bean.xml文件中利用property注入值即可<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span> <span class="attr">scope</span>=<span class="string">"singleton/prototype"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">包名+类名</span>&gt;</span> </span><br><span class="line">		<span class="comment">&lt;!-- 类的属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"fsd"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Spring容器创建对象的时机分几种？"><a href="#Spring容器创建对象的时机分几种？" class="headerlink" title="Spring容器创建对象的时机分几种？"></a>Spring容器创建对象的时机分几种？</h3><p>分为两种</p>
<ol>
<li>默认情况下，启动spring容器便创建对象</li>
<li>在spring的配置文件bean中有一个属性 lazy-init=”default/true/false”</li>
</ol>
<ul>
<li>如果lazy-init为”default/false”在启动spring容器时创建对象（默认情况）</li>
<li>如果lazy-init为”true”,在context.getBean时才要创建对象</li>
</ul>
<h3 id="解释Spring支持哪几种bean的作用域？"><a href="#解释Spring支持哪几种bean的作用域？" class="headerlink" title="解释Spring支持哪几种bean的作用域？"></a>解释Spring支持哪几种bean的作用域？</h3><p>在单例模式下，启动 spring 容器，便会创建对象，在多例模式下，启动容器<br>并不会创建对象，获得 bean 的时候才会创建对象</p>
<ol>
<li>singleton : bean在每个Spring ioc容器中只有一个实例</li>
<li>prototype：一个bean的定义可以有多个实例</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的<br>Spring ApplicationContext情形下有效</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用<br>域仅在基于web的Spring ApplicationContext情形下有效</li>
<li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实<br>例。该作用域仅在基于web的Spring ApplicationContext情形下有效</li>
</ol>
<h3 id="Spring-Bean的生命周期？"><a href="#Spring-Bean的生命周期？" class="headerlink" title="Spring Bean的生命周期？"></a>Spring Bean的生命周期？</h3><p><a href="https://www.jianshu.com/p/1dec08d290c1" target="_blank" rel="noopener">https://www.jianshu.com/p/1dec08d290c1</a><br><a href="https://www.zhihu.com/question/38597960" target="_blank" rel="noopener">https://www.zhihu.com/question/38597960</a><br><a href="https://www.cnblogs.com/yanggb/p/11004887.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanggb/p/11004887.html</a><br>Bean的生命周期可以分为四个阶段</p>
<ol>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ol>
<ol>
<li>实例化bean 对于BeanFactory容器，当客户向容器请求一个尚未初始化<br>的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器<br>就会调用createBean进行实例化。对于ApplicationContext容器，当容器<br>启动结束后，便实例化所有的bean。实例化对象被包装在BeanWrapper对象<br>中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设<br>置属性</li>
<li>设置对象属性（依赖注入）Spring根据BeanDefinition中的信息进行<br>依赖注入</li>
<li>注入Aware接口 Spring会检测该对象是否实现了xxxAware接口，并将相<br>关的xxxAware实例注入给bean</li>
<li>BeanPostProcessor 当经过上述几个步骤后，bean对象已经被正确构造<br>，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过<br>BeanPostProcessor接口实现，有两个函数</li>
</ol>
<ul>
<li>postProcessBeforeInitialzation(Object bean, String beanName)<br>当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处<br>理。 这个函数会先于InitialzationBean执行，因此称为前置处理。 所有<br>Aware接口的注入就是在这一步完成的</li>
<li>postProcessAfterInitialzation(Object bean, String beanName)<br>当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处<br>理。 这个函数会在InitialzationBean完成后执行，因此称为后置处理</li>
</ul>
<ol start="5">
<li>InitializingBean与init-method 当BeanPostProcessor的前置处理<br>完成后就会进入本阶段。InitializingBean接口只有一个函数：<br>afterPropertiesSet()</li>
<li>DisposableBean和destroy-method 当spring容器关闭的时候执行<br>destroy方法，当scope为”prototype”时，调用close()方法时是不会<br>调用 destroy 方法的<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"springLifeCycle"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">class</span>=<span class="string">"com.ys.ioc.SpringLifeCycle"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h3><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以<br>当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<ol>
<li>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义<br>，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期<br>，维护bean之间的依赖关系</li>
<li>ApplicationContext接口作为BeanFactory的派生，除了提供<br>BeanFactory所具有的功能外，还提供了更完整的框架功能</li>
<li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某<br>个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就<br>不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入<br>，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常</li>
<li>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。<br>这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利<br>于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单<br>实例Bean，通过预载入单实例bean，确保当你需要的时候，你就不用等待<br>，因为它们已经创建好了</li>
</ol>
<h3 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h3><p>spring动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency<br>Injection，依赖注入）来实现的。spring就是通过反射来实现注入的。简单来说什<br>么是依赖注入，就是给属性赋值（包括基本数据类型和引用数据类型）</p>
<h3 id="有哪些不同类型的IOC（依赖注入）方式？"><a href="#有哪些不同类型的IOC（依赖注入）方式？" class="headerlink" title="有哪些不同类型的IOC（依赖注入）方式？"></a>有哪些不同类型的IOC（依赖注入）方式？</h3><ol>
<li>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该<br>类有一系列参数，每个参数代表一个对其他类的依赖</li>
<li>Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static<br>工厂，方法实例化bean之后，调用该bean的setter方法，即实现了基于setter<br>的依赖注入。底层通过反射实现</li>
</ol>
<h3 id="AOP的原理是什么？"><a href="#AOP的原理是什么？" class="headerlink" title="AOP的原理是什么？"></a>AOP的原理是什么？</h3><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，<br>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封<br>装起来，并将其命名为”Aspect”，即切面。便于减少系统的重复代码，降低模块间<br>的耦合度，并有利于未来的可扩展性和可维护性</p>
<h3 id="为什么使用AOP？"><a href="#为什么使用AOP？" class="headerlink" title="为什么使用AOP？"></a>为什么使用AOP？</h3><p>比如有几个方法含有一些相同代码，如果把这些代码抽成一个方法，这就是面<br>向对象编程，如果这个方法改名字那么所有引用这个方法的地方都要改名字，<br>如果这个方法因为逻辑要改变位置那么所有引用这个方法的地方都要进行修<br>改。以上问题可以用AOP解决。根据以上如果许多方法需要使用这个抽取的方<br>法，不需要写在那些方法中，直接切入那些方法中，如果修改抽取方法的名<br>字或位置时不需要修改，因为这些方法并没有引用</p>
<h3 id="切入点与切面的区别？"><a href="#切入点与切面的区别？" class="headerlink" title="切入点与切面的区别？"></a>切入点与切面的区别？</h3><p>切入点定义抽取方法在哪个位置执行，切面就是抽取方法切到切入点</p>
<h3 id="代理模式有哪些？"><a href="#代理模式有哪些？" class="headerlink" title="代理模式有哪些？"></a>代理模式有哪些？</h3><p>分为静态代理和动态代理。</p>
<ol>
<li>静态代理 为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类<br>相同的接口（假设都有），在创建代理对象时，通过构造器塞入一个目标对象，然<br>后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是<br>说，代理对象=增强代码 +目标对象（原对象）。有了代理对象后，就不用原对象<br>了，静态代理没有修改原对象的代码。静态代理的缺点是程序员要手动为每一个<br>目标类编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。<br>所以，现在努力方向是：如何少写或者不写代理类，却能完成代理功能？</li>
<li>动态代理 要创建一个实例，最关键的就是得到对应的Class对象。能否不写代理<br>类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。代理类和目标<br>类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结<br>构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，<br>代理对象只需专注于增强代码的编写。接口拥有代理对象和目标对象共同的类信息<br>。所以我们可以从接口那得到理应由代理类提供的信息。但是接口是无法创建对象的</li>
</ol>
<h3 id="静态代理的缺点？"><a href="#静态代理的缺点？" class="headerlink" title="静态代理的缺点？"></a>静态代理的缺点？</h3><ol>
<li>代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必<br>要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了</li>
<li>如果接口增加一个方法，比如 UserService 增加修改 updateUser(）方法，<br>则除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代<br>码维护的复杂度</li>
</ol>
<h3 id="动态代理是如何实现的？"><a href="#动态代理是如何实现的？" class="headerlink" title="动态代理是如何实现的？"></a>动态代理是如何实现的？</h3><p>java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类<br>，这两个类相互配合，入口是 Proxy。Proxy 有个静态方法： getProxyClass(<br>ClassLoader,interfaces)，只要你给它传入类加载器和一组接口，它就给你返<br>回代理Class对象。用通俗的话说，getProxyClass()这个方法，会从你传入的接<br>口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有<br>构造器，是可以创建对象的。所以一旦我们明确接口，完全可以通过接口的Class<br>对象，创建一个代理Class，通过代理Class即可创建代理对象 <img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/3.jpg" alt><br>根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代<br>理对象的方法，最终都会调用InvocationHandler的invoke()方法 <img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/1.jpg" alt><br>根据代理Class的构造器创建对象时，需要传入InvocationHandler。通过构造器<br>传入一个引用，那么必然有个成员变量去接收。代理对象的内部确实有个成员变量<br>invocationHandler，而且代理对象的每个方法内部都会调用handler.invoke()<br>。InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直<br>接 <img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/2.jpg" alt><br>上图动态代理部分在invocationHandler的invoke()方法中并没有写目标对象。<br>因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手<br>动new <img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/4.jpg" alt><br>但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来<br>改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		CalculatorImpl target = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">    <span class="comment">//传入目标对象 目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span></span><br><span class="line">		Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">		calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Object target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span></span><br><span class="line">		Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader()</span><br><span class="line">			, target.getClass().getInterfaces());</span><br><span class="line">		Constructor constructor = proxyClazz.getConstructor(InvocationHandler.</span><br><span class="line">			<span class="class"><span class="keyword">class</span>)</span>;</span><br><span class="line">		Object proxy = constructor.newInstance(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				System.out.println(method.getName() + <span class="string">"方法开始执行..."</span>);</span><br><span class="line">				Object result = method.invoke(target, args);</span><br><span class="line">				System.out.println(result);</span><br><span class="line">				System.out.println(method.getName() + <span class="string">"方法执行结束..."</span>);</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你把实例传进来，<br>getProxy()都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类<br>，直接创建了代理对象。不过实际编程中，一般不用getProxyClass()，而是<br>使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代<br>理实例，连中间得到代理Class对象的过程都帮你隐藏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		CalculatorImpl target = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">		Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">		calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Object target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Object proxy = Proxy.newProxyInstance(</span><br><span class="line">				target.getClass().getClassLoader(),<span class="comment">/*类加载器*/</span></span><br><span class="line">				target.getClass().getInterfaces(),<span class="comment">//让代理对象和目标对象实现相同接口</span></span><br><span class="line">				<span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">					<span class="comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[]</span></span></span><br><span class="line"><span class="function"><span class="params">						args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">						System.out.println(method.getName() + <span class="string">"方法开始执行..."</span>);</span><br><span class="line">						Object result = method.invoke(target, args);</span><br><span class="line">						System.out.println(result);</span><br><span class="line">						System.out.println(method.getName() + <span class="string">"方法执行结束..."</span>);</span><br><span class="line">						<span class="keyword">return</span> result;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/5.jpg" alt></p>
<h3 id="代理Class对象和代理对象的区别？"><a href="#代理Class对象和代理对象的区别？" class="headerlink" title="代理Class对象和代理对象的区别？"></a>代理Class对象和代理对象的区别？</h3><p>代理Class对象是Class类型，代理Class其实就是附有构造器的接口Class，一样<br>的类结构信息，却能创建实例。而代理对象可以赋值给接口类型，只要实现该接口<br>就是该类型，代理对象的本质就是：和目标对象实现相同接口的实例。代理Class<br>可以叫任何名字，只要它实现某个接口，就能成为该接口类型</p>
<h3 id="动态代理的缺点是什么？"><a href="#动态代理的缺点是什么？" class="headerlink" title="动态代理的缺点是什么？"></a>动态代理的缺点是什么？</h3><p>动态代理生成的代理对象，最终都可以用接口接收，和目标对象一起形成了多态，<br>可以随意切换展示不同的功能。但是切换的同时，只能使用该接口定义的方法 <img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/6.jpg" alt></p>
<h3 id="AOP如何实现？"><a href="#AOP如何实现？" class="headerlink" title="AOP如何实现？"></a>AOP如何实现？</h3><p>Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring<br>AOP就会使用JDK 动态代理去创建代理对象，而对于没有实现接口的对象，就无法<br>使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//目标类</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="comment">//切面类（这里指事务类）</span></span><br><span class="line">    <span class="keyword">private</span> MyTransaction transaction;</span><br><span class="line">    <span class="comment">//通过构造器赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectInterceptor</span><span class="params">(Object target,MyTransaction transaction)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        <span class="keyword">this</span>.transaction.before();</span><br><span class="line">        <span class="comment">//调用目标类方法</span></span><br><span class="line">        method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="keyword">this</span>.transaction.after();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标类</span></span><br><span class="line">        Object target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">//事务类</span></span><br><span class="line">        MyTransaction transaction = <span class="keyword">new</span> MyTransaction();</span><br><span class="line">        ObjectInterceptor proxyObject = <span class="keyword">new</span> ObjectInterceptor(target, </span><br><span class="line">        	transaction);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 三个参数的含义：</span></span><br><span class="line"><span class="comment">         * 1、目标类的类加载器</span></span><br><span class="line"><span class="comment">         * 2、目标类所有实现的接口</span></span><br><span class="line"><span class="comment">         * 3、拦截器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        UserService userService = (UserService) Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), proxyObject);</span><br><span class="line">        userService.addUser(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring-AOP和AspectJ-AOP有什么区别？"><a href="#Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="Spring AOP和AspectJ AOP有什么区别？"></a>Spring AOP和AspectJ AOP有什么区别？</h3><ol>
<li>AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语<br>法，也可以说 AspectJ 是一个基于 Java 语言的 AOP 框架。通常我们在使用<br>Spring AOP 的时候，都会导入 AspectJ 的相关 jar 包</li>
<li>Spring AOP是属于运行时增强，而AspectJ是编译时增强。SpringAOP基于<br>代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。<br>Spring AOP已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整<br>的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对<br>来说更简单。如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多<br>的话，最好选择AspectJ，它比SpringAOP快很多</li>
</ol>
<h3 id="AOP的通知类型？"><a href="#AOP的通知类型？" class="headerlink" title="AOP的通知类型？"></a>AOP的通知类型？</h3><ol>
<li>前置通知<br>在切入点add方法执行之前插入的通知</li>
<li>后置通知<br>在切入点add方法执行之后插入的通知</li>
<li>异常通知<br>在切入点add方法抛出异常时插入的通知</li>
<li>环绕通知<br>可以贯穿切入点add方法执行的通知</li>
<li>最终通知<br>当切入点add方法执行完毕插入的通知（不论正常还是异常）</li>
</ol>
<h3 id="Spring框架中用到了哪些设计模式？"><a href="#Spring框架中用到了哪些设计模式？" class="headerlink" title="Spring框架中用到了哪些设计模式？"></a>Spring框架中用到了哪些设计模式？</h3><ol>
<li>工厂设计模式：Spring使用工厂模式通过BeanFactory和ApplicationContext<br>创建bean对象</li>
<li>代理设计模式：Spring AOP功能的实现</li>
<li>单例设计模式：Spring中的bean默认都是单例的</li>
<li>模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template<br>结尾的对数据库操作的类，它们就使用到了模板模式</li>
<li>包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问<br>中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切<br>换不同的数据源</li>
<li>观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用</li>
<li>适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式、<br>Spring MVC中也是用到了适配器模式适配Controller</li>
</ol>
<h3 id="什么是Spring-beans？"><a href="#什么是Spring-beans？" class="headerlink" title="什么是Spring beans？"></a>什么是Spring beans？</h3><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC<br>容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如以<br>XML文件中&lt;\bean/&gt; 的形式定义</p>
<h3 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h3><p>bean中还有一个属性是scope，默认是singleton，表示这个类是单例类，也就是<br>说不管从容器中拿出多少个student，实际上拿出的是同一个student。如果指定<br>为prototype则说明会创建多例对象，这个scope就是定义类的作用域</p>
<h3 id="一个Spring-Bean定义包含什么？"><a href="#一个Spring-Bean定义包含什么？" class="headerlink" title="一个Spring Bean定义包含什么？"></a>一个Spring Bean定义包含什么？</h3><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean<br>，它的生命周期详情及它的依赖</p>
<h3 id="如何给Spring容器提供配置元数据？"><a href="#如何给Spring容器提供配置元数据？" class="headerlink" title="如何给Spring容器提供配置元数据？"></a>如何给Spring容器提供配置元数据？</h3><ol>
<li>XML配置文件</li>
<li>基于注解的配置</li>
<li>基于java的配置</li>
</ol>
<h3 id="哪些是重要的bean生命周期方法？你能重载它们吗？"><a href="#哪些是重要的bean生命周期方法？你能重载它们吗？" class="headerlink" title="哪些是重要的bean生命周期方法？你能重载它们吗？"></a>哪些是重要的bean生命周期方法？你能重载它们吗？</h3><p>有两个重要的bean 生命周期方法，第一个是setup ，它是在容器加载bean<br>的时候被调用。第二个方法是 teardown它是在容器卸载类的时候被调用</p>
<h3 id="什么是bean的自动装配？"><a href="#什么是bean的自动装配？" class="headerlink" title="什么是bean的自动装配？"></a>什么是bean的自动装配？</h3><p>约定优于配置，不需要在bean中配置，能够自动找到引用，自动装配可以减少<br>代码量但是降低可读性</p>
<h3 id="有哪几种自动装配方式？"><a href="#有哪几种自动装配方式？" class="headerlink" title="有哪几种自动装配方式？"></a>有哪几种自动装配方式？</h3><ol>
<li>no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配</li>
<li>byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的<br>autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性<br>具有相同名字的bean</li>
<li>byType：通过参数类型自动装配，Spring容器在配置文件中发现bean的<br>autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具<br>有相同类型的bean。如果有多个bean符合条件，则抛出错误</li>
<li>constructor：这个方式类似于byType，但是要提供给构造器参数，如<br>果没有确定的带参数的构造器参数类型，将会抛出异常</li>
</ol>
<h3 id="什么是基于Java的Spring注解配置"><a href="#什么是基于Java的Spring注解配置" class="headerlink" title="什么是基于Java的Spring注解配置?"></a>什么是基于Java的Spring注解配置?</h3><p>通过注解的形式将bean以及相应的属性值放入ioc容器进行大部分Spring配<br>置而非通过XML文件。以@Configuration 注解为例，它用来标记类可以当<br>做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，<br>表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文</p>
<h3 id="Component的作用？"><a href="#Component的作用？" class="headerlink" title="@Component的作用？"></a>@Component的作用？</h3><p>添加Component后就不需要在配置文件中配置bean，容器中引入注解扫描器<br>Component可以细化为以下三个注解</p>
<ul>
<li>Repository 代表该类属于Dao层</li>
<li>Service 代表该类属于Service层</li>
<li>Controller 代表该类属于Controller层</li>
</ul>
<h3 id="Component和-Bean的区别是什么？"><a href="#Component和-Bean的区别是什么？" class="headerlink" title="@Component和@Bean的区别是什么？"></a>@Component和@Bean的区别是什么？</h3><ol>
<li>作用对象不同。@Component注解作用于类，而@Bean注解作用于方法</li>
<li>@Component注解通常是通过类路径扫描来自动侦测以及自动装配到Spring<br>容器中（我们可以使用@ComponentScan注解定义要扫描的路径）。@Bean注解<br>通常是在标有该注解的方法中定义产生这个bean，告诉Spring这是某个类的<br>实例，当我需要用它的时候还给我</li>
<li>@Bean注解比@Component注解的自定义性更强，而且很多地方只能通过<br>@Bean注解来注册bean。比如当引用第三方库的类需要装配到Spring容器的<br>时候，就只能通过@Bean注解来实现</li>
</ol>
<h3 id="Resource的作用？"><a href="#Resource的作用？" class="headerlink" title="@Resource的作用？"></a>@Resource的作用？</h3><p>它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过<br>@Resource的使用来消除set get方法。如果有name属性，就会按照id进行匹<br>配，如果没有name属性，默认会按照属性的名称进行匹配，如果属性名称不<br>匹配则会按照class类型进行匹配</p>
<h3 id="Autowired的作用？"><a href="#Autowired的作用？" class="headerlink" title="@Autowired的作用？"></a>@Autowired的作用？</h3><p>这个注解跟Resource很像，按照类型来进行装配。如果接口的实现类只有一个<br>，那么相当于Student student=new Studentimpl()，如果Student实现类<br>有多个，则会按照属性名称进行匹配。如果查询的结果为空，那么会抛出异常<br>。解决方法是使用required=false</p>
<h3 id="Qualifier的作用？"><a href="#Qualifier的作用？" class="headerlink" title="@Qualifier的作用？"></a>@Qualifier的作用？</h3><p>这个注解跟Autowired配合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于Resource</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="keyword">private</span> Student student;</span><br></pre></td></tr></table></figure>

<h3 id="Spring事务管理的方式有几种？"><a href="#Spring事务管理的方式有几种？" class="headerlink" title="Spring事务管理的方式有几种？"></a>Spring事务管理的方式有几种？</h3><p>Spring支持两种类型的事务管理：</p>
<ol>
<li>编程式事务管理：所谓编程式事务指的是通过编码方式实现事务，允许用<br>户在代码中精确定义事务的边界。即类似于JDBC编程实现事务管理。管理使用<br>TransactionTemplate或者直接使用底层的PlatformTransactionManager<br>。对于编程式事务管理，spring推荐使用TransactionTemplate</li>
<li>声明式事务管理：管理建立在AOP之上的。其本质是对方法前后进行拦截，<br>然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据<br>执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方<br>式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在<br>配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方<br>式)，便可以将事务规则应用到业务逻辑中</li>
</ol>
<h3 id="两种事务管理方式的优劣？"><a href="#两种事务管理方式的优劣？" class="headerlink" title="两种事务管理方式的优劣？"></a>两种事务管理方式的优劣？</h3><ol>
<li>编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式<br>事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影<br>响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注<br>解的方式，便可以将事务规则应用到业务逻辑中</li>
<li>显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入<br>式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编<br>程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式<br>事务管理的配置</li>
</ol>
<h3 id="什么是事务管理器的接口？"><a href="#什么是事务管理器的接口？" class="headerlink" title="什么是事务管理器的接口？"></a>什么是事务管理器的接口？</h3><p>org.springframework.transaction.PlatformTransactionManager是Spring<br>事务管理器的接口。Spring并不直接管理事务，通过这个接口，Spring为各个平台<br>如JDBC、Hibernate等都提供了对应的事务管理器，也就是将事务管理的职责委托<br>给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现 <img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/7.jpg" alt></p>
<h3 id="PlatformTransactionManager接口是什么？"><a href="#PlatformTransactionManager接口是什么？" class="headerlink" title="PlatformTransactionManager接口是什么？"></a>PlatformTransactionManager接口是什么？</h3><p>该接口下有三个方法</p>
<ol>
<li>TransactionStatus getTransaction(TransactionDefinition definition)<br>，事务管理器通过TransactionDefinition，获得“事务状态”，从而管理事务</li>
<li>void commit(TransactionStatus status)  根据状态提交</li>
<li>void rollback(TransactionStatus status) 根据状态回滚</li>
</ol>
<p>也就是说Spring事务管理的为不同的事务API提供一致的编程模型，具体的事务管<br>理机制由对应各个平台去实现，比如JDBC平台管理事务</p>
<h3 id="TransactionStatus是什么？"><a href="#TransactionStatus是什么？" class="headerlink" title="TransactionStatus是什么？"></a>TransactionStatus是什么？</h3><p>getTransaction返回的是TransactionStatus对象，然后程序根据返回的对象<br>来获取事务状态，然后进行相应的操作。这个接口描述的是一些处理事务提供简<br>单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应<br>的事务状态 <img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/9.jpg" alt></p>
<h3 id="TransactionDefinition是什么？"><a href="#TransactionDefinition是什么？" class="headerlink" title="TransactionDefinition是什么？"></a>TransactionDefinition是什么？</h3><p>这个类就定义了一些基本的事务属性。事务属性可以理解成事务的一些基本配置<br>，描述了事务策略如何应用到方法上。事务属性包含了5个方面</p>
<ol>
<li>传播行为</li>
<li>隔离规则</li>
<li>回滚规则</li>
<li>事务超时</li>
<li>是否只读</li>
</ol>
<p>TransactionDefinition接口方法如下 <img src="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/10.jpg" alt></p>
<h3 id="什么是事务的传播行为？"><a href="#什么是事务的传播行为？" class="headerlink" title="什么是事务的传播行为？"></a>什么是事务的传播行为？</h3><p>事务的传播性一般用在事务嵌套的场景，比如一个事务方法里面调用了另外一<br>个事务方法，那么两个方法是各自作为独立的方法提交还是内层的事务合并到<br>外层的事务一起提交，这就是需要事务传播机制的配置来确定怎么样执行。<br>Spring定义了如下七中传播行为</p>
<ol>
<li>PROPAGATION_REQUIRED ：required 必须。Spring默认的传播机制，能<br>满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块<br>提交，一块回滚。如果外层没有事务，新建一个事务执行</li>
<li>PROPAGATION_SUPPORT：support 支持。如果外层有事务，则加入外层事<br>务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务</li>
<li>PROPAGATION_MANDATORY：mandatory 强制。与NEVER相反，如果外层没<br>有事务，则抛出异常</li>
<li>PROPAGATION_REQUIRES_NEW ：requires_new 必须新的。该事务传播机<br>制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，<br>恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可</li>
<li>PROPAGATION_NOT_SUPPORTED ：not_supporte 不支持。该传播机制不支<br>持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论<br>是否异常都不会回滚当前的代码</li>
<li>PROPAGATION_NEVER ：never 从不。该传播机制不支持外层事务，即如果<br>外层有事务就抛出异常</li>
<li>PROPAGATION_NESTED ：nested 嵌套。该传播机制的特点是可以保存状态<br>保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自<br>回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的</li>
</ol>
<h3 id="什么是隔离级别？"><a href="#什么是隔离级别？" class="headerlink" title="什么是隔离级别？"></a>什么是隔离级别？</h3><p>事务的隔离级别定义一个事务可能受其他并发务活动活动影响的程度，可以把事<br>务的隔离级别想象为这个事务对于事物处理数据的自私程度。在一个典型的应用<br>程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。<br>在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全<br>隔离会影响性能，因为隔离经常涉及到锁定在数据库中的记录（甚至有时是锁<br>表）。完全隔离要求事务相互等待来完成工作，会阻碍并发。因此，可以根据<br>业务场景选择不同的隔离级别</p>
<ol>
<li>ISOLATION_DEFAULT：使用后端数据库默认的隔离级别</li>
<li>ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数<br>据变更，可能会导致脏读、幻读或不可重复读</li>
<li>ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻<br>止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除<br>非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能<br>发生</li>
<li>ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从ACID的隔离级别，<br>确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是<br>通过完全锁定事务相关的数据库表来实现的</li>
</ol>
<p>上面定义的隔离级别，在 Spring 的 TransactionDefinition.class 中也<br>分别用常量 -1,0,1,2,4,8表示</p>
<h3 id="什么是只读？"><a href="#什么是只读？" class="headerlink" title="什么是只读？"></a>什么是只读？</h3><p>这是事务的第三个特性，如果一个事务只对数据库执行读操作，那么该数据库就<br>可能利用那个事务的只读特性，采取某些优化措施。通过把一个事务声明为只读<br>，可以给后端数据库一个机会来应用那些它认为合适的优化措施。由于只读的优<br>化措施是在一个事务启动时由后端数据库实施的，因此只有对于那些具有可能<br>启动一个新事务的传播行为的方法来说，将事务声明为只读才有意义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROPAGATION_REQUIRES_NEW</span><br><span class="line">PROPAGATION_REQUIRED</span><br><span class="line">ROPAGATION_NESTED</span><br></pre></td></tr></table></figure>

<h3 id="什么是事务超时？"><a href="#什么是事务超时？" class="headerlink" title="什么是事务超时？"></a>什么是事务超时？</h3><p>为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后<br>端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是<br>事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚<br>，而不是一直等待其结束。由于超时时钟在一个事务启动的时候开始的，因此<br>，只有对于那些具有可能启动一个新事务的传播行为的方法来说，声明事务<br>超时才有意义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROPAGATION_REQUIRES_NEW</span><br><span class="line">PROPAGATION_REQUIRED</span><br><span class="line">ROPAGATION_NESTED</span><br></pre></td></tr></table></figure>

<h3 id="什么是回滚规则？"><a href="#什么是回滚规则？" class="headerlink" title="什么是回滚规则？"></a>什么是回滚规则？</h3><p>在默认设置下，事务只在出现运行时异常（runtime exception）时回滚，而<br>在出现受检查异常（checked exception）时不回滚（这一行为和EJB中的回<br>滚行为是一致的）。不过，可以声明在出现特定受检查异常时像运行时异常一<br>样回滚。同样，也可以声明一个事务在出现特定的异常时不回滚，即使特定的<br>异常是运行时异常</p>
<h3 id="Spring声明式事务如何配置？"><a href="#Spring声明式事务如何配置？" class="headerlink" title="Spring声明式事务如何配置？"></a>Spring声明式事务如何配置？</h3><p>在目标类或者方法添加注解@Transactional。如果在类上添加，则说明类中的<br>所有方法都添加事务，如果在方法上添加，则只有该方法具有事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation=Propagation.REQUIRED , isolation = Isolation.DEFAULT)</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"accountDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String outer, String inner, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        accountDao.out(outer, money);</span><br><span class="line">        <span class="comment">//int i = 1/0;</span></span><br><span class="line">        accountDao.in(inner, money);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>只读：@Transactional(readOnly=true) 该属性用于设置当前事务是否<br>为只读事务，设置为true表示只读，false则表示可读写，默认值为false</li>
<li>事务的超时性：@Transactional(timeout=30)</li>
<li>回滚：该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常<br>数组中的异常时，则进行事务回滚</li>
</ol>
<ul>
<li>指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)</li>
<li>指定多个异常类：@Transactional(rollbackFor={RuntimeException.class<br>, Exception.class})</li>
</ul>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="什么是SpringMVC？"><a href="#什么是SpringMVC？" class="headerlink" title="什么是SpringMVC？"></a>什么是SpringMVC？</h3><p>SpringMVC 是类似于Struts2 的一个MVC 框架，在实际开发中，接收浏览器的<br>请求响应，对数据进行处理，然后返回页面进行显示</p>
<h3 id="MVC三个字母分别代表什么意思？"><a href="#MVC三个字母分别代表什么意思？" class="headerlink" title="MVC三个字母分别代表什么意思？"></a>MVC三个字母分别代表什么意思？</h3><ol>
<li>M 代表 模型（Model）模型就是数据，就是 dao,bean</li>
<li>V 代表 视图（View） 就是网页, JSP，用来展示模型中的数据</li>
<li>C 代表 控制器（controller) 控控制器的作用就是把不同的数据(Model)，<br>显示在不同的视图(View)上，Servlet 扮演的就是这样的角色</li>
</ol>
<h3 id="SpringMVC工作原理是什么？"><a href="#SpringMVC工作原理是什么？" class="headerlink" title="SpringMVC工作原理是什么？"></a>SpringMVC工作原理是什么？</h3><ul>
<li>客户端发送请求到 DispatcherServlet</li>
<li>DispatcherServlet查询handlerMapping找到处理请求的Controller</li>
<li>Controller 调用业务逻辑后，返回ModelAndView</li>
<li>DispatcherServlet 查询 ModelAndView，找到指定视图</li>
<li>视图将结果返回到客户端</li>
</ul>
<h3 id="Controller的作用？"><a href="#Controller的作用？" class="headerlink" title="@Controller的作用？"></a>@Controller的作用？</h3><p>请求的URL到我们这里所编写的Handler类的某个方法进行一些业务逻辑处理。<br>使用@Controller注解表示这个类是一个Handler</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>注解括号里面的表示访问的URL，也可以放在类上面,页面跳转时默认是请求转<br>发。RequestMapping中可以写多个属性,method中指定拦截什么类型的请求<br>，params指定请求必须有指定的name，并且必须有zs值，age可以没有，不<br>能有height参数，约定headers请求头信息，必须符合要求的头信息才可以<br>接收 </p>
<ul>
<li>RequestMethod.GET</li>
<li>RequestMethod.POST</li>
<li>RequestMethod.DELETE</li>
<li>RequestMethod.PUT</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"Spring/**/Mvc/*/Han"</span>,method=<span class="string">"RequestMethod.POST"</span>,</span><br><span class="line">	params=&#123;<span class="string">"name=zs"</span>,<span class="string">"age!=23"</span>，<span class="string">"!height"</span>&#125;,headers=&#123;</span><br><span class="line">			<span class="string">"Accept=text....."</span>,<span class="string">"Accept-Encoding.."</span></span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="PathVariable的作用？"><a href="#PathVariable的作用？" class="headerlink" title="@PathVariable的作用？"></a>@PathVariable的作用？</h3><p>获取动态参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Controller</span> <span class="comment">//使类变为控制器</span></span><br><span class="line"><span class="comment">//SpringMvcHan/welcome/abc</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"Spring"</span>) <span class="comment">//映射路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcHandler</span></span>&#123; </span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"welcome/&#123;name&#125;"</span>) </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestParam的作用？"><a href="#RequestParam的作用？" class="headerlink" title="@RequestParam的作用？"></a>@RequestParam的作用？</h3><p>该注解有三个变量：value、required、defaultvalue</p>
<ul>
<li>value ：指定 name 属性的名称是什么，value 属性都可以默认不写</li>
<li>required ：是否必须要有该参数，可以设置为【true】或者【false】</li>
<li>defaultvalue ：设置默认值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">//使类变为控制器</span></span><br><span class="line">	<span class="comment">//SpringMvcHan/welcome/name=fd</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"Spring"</span>) <span class="comment">//映射路径</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvcHandler</span></span>&#123; </span><br><span class="line">		<span class="meta">@RequestMapping</span>(<span class="string">"/welcome"</span>) </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ResponseBody的作用？"><a href="#ResponseBody的作用？" class="headerlink" title="@ResponseBody的作用？"></a>@ResponseBody的作用？</h3><p>把后台pojo转换json对象，返回到页面</p>
<h3 id="RequestBody的作用？"><a href="#RequestBody的作用？" class="headerlink" title="@RequestBody的作用？"></a>@RequestBody的作用？</h3><p>接受前台json数据，把json数据自动封装pojo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">requestJson</span><span class="params">(@RequestBody User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> user;<span class="comment">//由于@ResponseBody注解，将user转成json格式返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SpringMVC中拦截器如何使用？"><a href="#SpringMVC中拦截器如何使用？" class="headerlink" title="SpringMVC中拦截器如何使用？"></a>SpringMVC中拦截器如何使用？</h3><ol>
<li>定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。</li>
</ol>
<ul>
<li>preHandle ：进入 Handler方法之前执行，用于身份认证、身份授权，<br>比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不<br>再向下执行</li>
<li>postHandle：进入Handler方法之后，返回modelAndView之前执行，应用<br>场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视<br>图，也可以在这里统一指定视图</li>
<li>afterCompletion：执行Handler完成执行此方法，应用场景：统一异常<br>处理，统一日志处理</li>
</ul>
<ol start="2">
<li>拦截器配置：</li>
</ol>
<ul>
<li>针对HandlerMapping配置(不推荐)：springMVC拦截器针对HandlerMapping<br>进行拦截设置，如果在某个HandlerMapping配置拦截，经过该HandlerMapping<br>映射成功的handler最终使用该 拦截器。(一般不推荐使用)</li>
<li>类似全局的拦截器：springmvc配置类似全局的拦截器，springmvc框架将配<br>置的类似全局的拦截器注入到每个HandlerMapping中</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>设计模式总结</span></a></div><div class="next-post pull-right"><a href="/2021/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span>机器学习</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/02/24/框架技术总结/';
  this.page.title = '框架技术总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>