<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="设计模式总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>设计模式总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象六大原则"><span class="toc-number">2.</span> <span class="toc-text">面向对象六大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单一职责"><span class="toc-number">2.1.</span> <span class="toc-text">单一职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#里氏替换原则"><span class="toc-number">2.2.</span> <span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖倒置原则"><span class="toc-number">2.3.</span> <span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口隔离原则"><span class="toc-number">2.4.</span> <span class="toc-text">接口隔离原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迪米特法则（最少知道原则）"><span class="toc-number">2.5.</span> <span class="toc-text">迪米特法则（最少知道原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开闭原则"><span class="toc-number">2.6.</span> <span class="toc-text">开闭原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-number">3.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">3.1.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之饿汉模式"><span class="toc-number">3.1.1.</span> <span class="toc-text">单例模式之饿汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之懒汉模式"><span class="toc-number">3.1.2.</span> <span class="toc-text">单例模式之懒汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之懒汉模式（线程安全）"><span class="toc-number">3.1.3.</span> <span class="toc-text">单例模式之懒汉模式（线程安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之懒汉模式–双重校验锁"><span class="toc-number">3.1.4.</span> <span class="toc-text">单例模式之懒汉模式–双重校验锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之静态内部类"><span class="toc-number">3.1.5.</span> <span class="toc-text">单例模式之静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之枚举实现"><span class="toc-number">3.1.6.</span> <span class="toc-text">单例模式之枚举实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂方法模式"><span class="toc-number">3.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象工厂模式"><span class="toc-number">3.3.</span> <span class="toc-text">抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建造者模式"><span class="toc-number">3.4.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型模式"><span class="toc-number">3.5.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式"><span class="toc-number">3.6.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桥接模式"><span class="toc-number">3.7.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合模式"><span class="toc-number">3.8.</span> <span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰模式"><span class="toc-number">3.9.</span> <span class="toc-text">装饰模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式"><span class="toc-number">3.10.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#亨元模式"><span class="toc-number">3.11.</span> <span class="toc-text">亨元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#责任链模式"><span class="toc-number">3.12.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令模式"><span class="toc-number">3.13.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释器模式"><span class="toc-number">3.14.</span> <span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器设计模式"><span class="toc-number">3.15.</span> <span class="toc-text">迭代器设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中介者模式"><span class="toc-number">3.16.</span> <span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#备忘录模式"><span class="toc-number">3.17.</span> <span class="toc-text">备忘录模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#观察者模式"><span class="toc-number">3.18.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态模式"><span class="toc-number">3.19.</span> <span class="toc-text">状态模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#策略模式"><span class="toc-number">3.20.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板方法设计模式"><span class="toc-number">3.21.</span> <span class="toc-text">模板方法设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问者模式"><span class="toc-number">3.22.</span> <span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空对象模式"><span class="toc-number">3.23.</span> <span class="toc-text">空对象模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#责任链模式-1"><span class="toc-number">3.24.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委托的设计思想"><span class="toc-number">3.25.</span> <span class="toc-text">委托的设计思想</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">设计模式总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/02/25/设计模式总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/pony1223/p/7608955.html" target="_blank" rel="noopener">https://www.cnblogs.com/pony1223/p/7608955.html</a><br><a href="http://www.cyc2018.xyz" target="_blank" rel="noopener">http://www.cyc2018.xyz</a></p>
<h2 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h2><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>例如要实现逻辑和界面的分离，一个类只负责一项职责</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>子类可以扩展父类的功能，但不能改变父类原有的功能</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少</p>
<h3 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h3><p>就是一个类对自己依赖的类知道的越少越好。对于被依赖的类来说，无论逻辑多么<br>复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外<br>泄漏任何信息</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>对扩展开放，对修改关闭</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>24种设计模式可以分为三类 <img src="/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<ol>
<li>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程</li>
<li>结构型模式：把类或对象结合在一起形成一个更大的结构</li>
<li>行为型模式：类和对象如何交互，及划分责任和算法</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>某个类只能有一个实例，提供一个全局的访问点。有三个特点</p>
<ol>
<li>单例类只能有一个实例</li>
<li>单例类必须自己创建自己的实例</li>
<li>单例类必须提供外界获取这个实例的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化，因为外界不能创建这个类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之饿汉模式"><a href="#单例模式之饿汉模式" class="headerlink" title="单例模式之饿汉模式"></a>单例模式之饿汉模式</h4><p>线程不安全问题主要是由于Instance被实例化多次，采取直接实例化Instance<br>的方式就不会产生线程不安全问题。不过在类装载的时候就进行了实例化，有可<br>能这个实例化过程很长，那么就会加大类装载的时间,直接实例化的方式也丢失<br>了延迟实例化带来的节约资源的好处，没有达到lazy-loading的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之懒汉模式"><a href="#单例模式之懒汉模式" class="headerlink" title="单例模式之懒汉模式"></a>单例模式之懒汉模式</h4><p>这种方法达到了lazy-loading 的效果，即我们在第一次需要得到这个单例的时<br>候，才回去创建它的实例，以后再需要就可以不用创建，直接获取了。但是这种<br>设计在多线程的情况下是不安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之懒汉模式（线程安全）"><a href="#单例模式之懒汉模式（线程安全）" class="headerlink" title="单例模式之懒汉模式（线程安全）"></a>单例模式之懒汉模式（线程安全）</h4><p>采用同步代码块来达到线程安全。这会让线程阻塞时间过长，因此该方法有性能<br>问题，不推荐使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之懒汉模式–双重校验锁"><a href="#单例模式之懒汉模式–双重校验锁" class="headerlink" title="单例模式之懒汉模式–双重校验锁"></a>单例模式之懒汉模式–双重校验锁</h4><p>上面的例子我们可以看到，synchronized其实将方法内部的所有语句都已经<br>包括了，每一个进来的线程都要单独进入同步代码块，判断实例是否存在，<br>这就造成了性能的浪费。那么我们可以想到，其实在第一次已经创建了实例<br>的情况下，后面再获取实例的时候，可以不进入这个同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式线程安全--双重锁校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个变量有两步</p>
<ol>
<li>申请一块内存，调用构造方法进行初始化</li>
<li>分配一个指针指向该内存</li>
</ol>
<p>根据编译器的优化可能会调整指令的顺序，也就是存在这样一种情况：先开辟<br>一块内存，然后分配一个指针指向该内存，最后调用构造方法进行初始化。<br>那么针对单例模式的设计，就会存在这样一个问题：线程A开始创建Singleton<br>的实例，此时线程 B已经调用了getInstance的（）方法，首先判断instance<br>是否为null。而我们上面说的那种模型，A已经把instance指向了那块内存，只<br>是还没来得及调用构造方法进行初始化，因此B检测到instance不为null，于<br>是直接把instance返回了。所以应该使用volatile修饰instance</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>我们知道在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器<br>的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中<br>修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷<br>贝，造成数据的不一致。<br>volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成<br>员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内<br>存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值</p>
<h4 id="单例模式之静态内部类"><a href="#单例模式之静态内部类" class="headerlink" title="单例模式之静态内部类"></a>单例模式之静态内部类</h4><p>当Singleton类被加载时，静态内部类InnerSingleton没有被加载进内存。只<br>有当调用getInstance()方法从而触发Inner.instance时Inner 才会被加载<br>，此时初始化instance实例，并且JVM能确保instance只被实例化一次。这种<br>方式不仅具有延迟初始化的好处，而且由JVM提供了对线程安全的支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> InnerSingleton instance = <span class="keyword">new</span> InnerSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(InnerSingleton.getInstance()==</span><br><span class="line">        InnerSingleton.getInstance());<span class="comment">//true</span></span><br><span class="line">        System.out.println(InnerSingleton.getInstance().equals(</span><br><span class="line">        InnerSingleton.getInstance()));<span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之枚举实现"><a href="#单例模式之枚举实现" class="headerlink" title="单例模式之枚举实现"></a>单例模式之枚举实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例模式的应用可以分为两类：资源共享和方便资源互相通信</p>
<ol>
<li>windows 系统的回收站，我们能在任何盘符删除数据，但是最后都是到了<br>回收站中</li>
<li>网站的计数器，不过不采用单例模式，很难实现同步</li>
<li>数据库连接池，可以节省打开或关闭数据库连接所引起的效率损耗，用单例模<br>式来维护，可以大大降低这种损耗</li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂模式是用来创建对象的一种最常用的设计模式。是用工厂方法代替new操作<br>的一种模式。我们不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中<br>，那么这个函数就可以被视为一个工厂<br>Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需<br>要明确指定具体类。抽象工厂模式创建的是对象家族，也就是很多对象而不是一个<br>对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是<br>用于创建一个对象，这和抽象工厂模式有很大不同</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>封装一个复杂对象的构建过程，并可以按步骤构造。建造者模式将复杂产品的构建<br>过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的<br>控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得<br>相同的创建过程能够创建不同的产品。StringBuilder的实现就用到该模式</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。在我们应<br>用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果<br>这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们<br>需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模<br>式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Prototype <span class="title">myClone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype</span><span class="params">(String filed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Prototype <span class="title">myClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototype(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的方法接口转换成客户希望的另外一个接口。在我们的应用程序中我<br>们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们<br>可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所<br>谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可<br>以让原本两个不兼容的接口能够无缝完成对接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> INputStreamReader(inputStream);</span><br></pre></td></tr></table></figure>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>将抽象部分和它的实现部分分离，使它们都可以独立的变化</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>将对象组合成树形结构以表示“”部分-整体“”的层次结构</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>动态的给对象添加新的功能，一种动态地往一个类中添加新的行为的设计<br>、模式。就功能而言，装饰器模式相比生成子类更为灵活，这样可以给某<br>个对象而不是整个类添加一些功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(inputStream));</span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一个代理以便控制这个对象的访问</p>
<h3 id="亨元模式"><a href="#亨元模式" class="headerlink" title="亨元模式"></a>亨元模式</h3><p>通过共享技术来有效的支持大量细粒度的对象</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系<br>。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>将命令请求封装为一个对象，使得可以用不同的请求来进行参数化</p>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器</p>
<h3 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h3><p>一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。<br>Collection接口在元素遍历的设计上采用迭代器的设计模式。迭代器给我们<br>提供了统一的接口来遍历实现了迭代器接口的类的对象，实现了遍历集合方<br>法的复用，减少我们的代码量</p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>用一个中介对象来封装一系列的对象交互</p>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>在不破坏封装的前提下，保持对象的内部状态</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>对象间的一对多的依赖关系</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>允许一个对象在其对象内部状态改变时改变它的行为</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列算法，把他们封装起来，并且使它们可以相互替换</p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>定义一个算法结构，而将一些步骤延迟到子类实现。<br>在父类中声明一些必要的抽象方法，同时父类通过这些抽象方法来实现一些<br>实例方法，而这些个抽象方法通过继承来交给子类实现，子类根据自己的特<br>性来自定义实现这些抽象方法，以达到最好的执行效率。利用多态性来达到<br>不同的子类有不同的行为的同时也保证了整个框架具有良好的扩展性。比如<br>抽象类AbstractCollection中的contains remove等方法都用到了迭代<br>器，这些实例方法都依赖于两个抽象方法iterator和size</p>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>在不改变数据结构的前提下，增加作用于一组对象元素的新功能</p>
<h3 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h3><p>使用什么都不做的空对象来代替NULL。一个方法返回 NULL，意味着方法的调<br>用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码<br>。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，<br>那么就有可能抛出空指针异常</p>
<h3 id="责任链模式-1"><a href="#责任链模式-1" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会</p>
<h3 id="委托的设计思想"><a href="#委托的设计思想" class="headerlink" title="委托的设计思想"></a>委托的设计思想</h3><p>SubList类中并没有重新创建一个列表List，而是创建一个字段指向源列表<br>对象，并且将起始下标（fromIndex）作为偏移量，而之后对子列表元素的<br>相关操作都是通过调用源列表的相关方法并且算上偏移量（offset）来实<br>现的</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/15/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>高并发项目学习</span></a></div><div class="next-post pull-right"><a href="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"><span>常见工具总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/02/25/设计模式总结/';
  this.page.title = '设计模式总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>