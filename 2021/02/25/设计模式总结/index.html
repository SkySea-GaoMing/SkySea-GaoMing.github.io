<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="设计模式总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>设计模式总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象六大原则"><span class="toc-number">2.</span> <span class="toc-text">面向对象六大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单一职责"><span class="toc-number">2.1.</span> <span class="toc-text">单一职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#里氏替换原则"><span class="toc-number">2.2.</span> <span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖倒置原则"><span class="toc-number">2.3.</span> <span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口隔离原则"><span class="toc-number">2.4.</span> <span class="toc-text">接口隔离原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迪米特法则（最少知道原则）"><span class="toc-number">2.5.</span> <span class="toc-text">迪米特法则（最少知道原则）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开闭原则"><span class="toc-number">2.6.</span> <span class="toc-text">开闭原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-number">3.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">3.1.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之饿汉模式"><span class="toc-number">3.1.1.</span> <span class="toc-text">单例模式之饿汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之懒汉模式"><span class="toc-number">3.1.2.</span> <span class="toc-text">单例模式之懒汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之懒汉模式（线程安全）"><span class="toc-number">3.1.3.</span> <span class="toc-text">单例模式之懒汉模式（线程安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之懒汉模式–双重校验锁"><span class="toc-number">3.1.4.</span> <span class="toc-text">单例模式之懒汉模式–双重校验锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之静态内部类"><span class="toc-number">3.1.5.</span> <span class="toc-text">单例模式之静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式之枚举实现"><span class="toc-number">3.1.6.</span> <span class="toc-text">单例模式之枚举实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂方法模式"><span class="toc-number">3.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象工厂模式"><span class="toc-number">3.3.</span> <span class="toc-text">抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建造者模式"><span class="toc-number">3.4.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型模式"><span class="toc-number">3.5.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式"><span class="toc-number">3.6.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桥接模式"><span class="toc-number">3.7.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合模式"><span class="toc-number">3.8.</span> <span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰模式"><span class="toc-number">3.9.</span> <span class="toc-text">装饰模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式"><span class="toc-number">3.10.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#亨元模式"><span class="toc-number">3.11.</span> <span class="toc-text">亨元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#责任链模式"><span class="toc-number">3.12.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令模式"><span class="toc-number">3.13.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释器模式"><span class="toc-number">3.14.</span> <span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器设计模式"><span class="toc-number">3.15.</span> <span class="toc-text">迭代器设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中介者模式"><span class="toc-number">3.16.</span> <span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#备忘录模式"><span class="toc-number">3.17.</span> <span class="toc-text">备忘录模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#观察者模式"><span class="toc-number">3.18.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态模式"><span class="toc-number">3.19.</span> <span class="toc-text">状态模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#策略模式"><span class="toc-number">3.20.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板方法设计模式"><span class="toc-number">3.21.</span> <span class="toc-text">模板方法设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问者模式"><span class="toc-number">3.22.</span> <span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空对象模式"><span class="toc-number">3.23.</span> <span class="toc-text">空对象模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#责任链模式-1"><span class="toc-number">3.24.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委托的设计思想"><span class="toc-number">3.25.</span> <span class="toc-text">委托的设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式-1"><span class="toc-number">3.26.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态代理"><span class="toc-number">3.26.1.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态代理"><span class="toc-number">3.26.2.</span> <span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理和静态代理的区别"><span class="toc-number">3.27.</span> <span class="toc-text">动态代理和静态代理的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-动态代理的步骤"><span class="toc-number">3.28.</span> <span class="toc-text">JDK 动态代理的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代理和动态代理的区别？"><span class="toc-number">3.29.</span> <span class="toc-text">静态代理和动态代理的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代理和动态代理的优缺点？"><span class="toc-number">3.30.</span> <span class="toc-text">静态代理和动态代理的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理Class对象和代理对象的区别？"><span class="toc-number">3.31.</span> <span class="toc-text">代理Class对象和代理对象的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理的原理？"><span class="toc-number">3.32.</span> <span class="toc-text">动态代理的原理？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">设计模式总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/02/25/设计模式总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/pony1223/p/7608955.html" target="_blank" rel="noopener">https://www.cnblogs.com/pony1223/p/7608955.html</a><br><a href="http://www.cyc2018.xyz" target="_blank" rel="noopener">http://www.cyc2018.xyz</a></p>
<h2 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h2><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>例如要实现逻辑和界面的分离，一个类只负责一项职责</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>子类可以扩展父类的功能，但不能改变父类原有的功能</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少</p>
<h3 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h3><p>就是一个类对自己依赖的类知道的越少越好。对于被依赖的类来说，无论逻辑多么<br>复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外<br>泄漏任何信息</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>对扩展开放，对修改关闭</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>24种设计模式可以分为三类 <img src="/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/1.jpg" alt></p>
<ol>
<li>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程</li>
<li>结构型模式：把类或对象结合在一起形成一个更大的结构</li>
<li>行为型模式：类和对象如何交互，及划分责任和算法</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>某个类只能有一个实例，提供一个全局的访问点。有三个特点</p>
<ol>
<li>单例类只能有一个实例</li>
<li>单例类必须自己创建自己的实例</li>
<li>单例类必须提供外界获取这个实例的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化，因为外界不能创建这个类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之饿汉模式"><a href="#单例模式之饿汉模式" class="headerlink" title="单例模式之饿汉模式"></a>单例模式之饿汉模式</h4><p>线程不安全问题主要是由于Instance被实例化多次，采取直接实例化Instance<br>的方式就不会产生线程不安全问题。不过在类装载的时候就进行了实例化，有可<br>能这个实例化过程很长，那么就会加大类装载的时间,直接实例化的方式也丢失<br>了延迟实例化带来的节约资源的好处，没有达到lazy-loading的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之懒汉模式"><a href="#单例模式之懒汉模式" class="headerlink" title="单例模式之懒汉模式"></a>单例模式之懒汉模式</h4><p>这种方法达到了lazy-loading 的效果，即我们在第一次需要得到这个单例的时<br>候，才回去创建它的实例，以后再需要就可以不用创建，直接获取了。但是这种<br>设计在多线程的情况下是不安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之懒汉模式（线程安全）"><a href="#单例模式之懒汉模式（线程安全）" class="headerlink" title="单例模式之懒汉模式（线程安全）"></a>单例模式之懒汉模式（线程安全）</h4><p>采用同步代码块来达到线程安全。这会让线程阻塞时间过长，因此该方法有性能<br>问题，不推荐使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之懒汉模式–双重校验锁"><a href="#单例模式之懒汉模式–双重校验锁" class="headerlink" title="单例模式之懒汉模式–双重校验锁"></a>单例模式之懒汉模式–双重校验锁</h4><p>上面的例子我们可以看到，synchronized其实将方法内部的所有语句都已经<br>包括了，每一个进来的线程都要单独进入同步代码块，判断实例是否存在，<br>这就造成了性能的浪费。那么我们可以想到，其实在第一次已经创建了实例<br>的情况下，后面再获取实例的时候，可以不进入这个同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉模式线程安全--双重锁校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类的内部自己创建实例的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//提供get 方法以供外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个变量有两步</p>
<ol>
<li>申请一块内存，调用构造方法进行初始化</li>
<li>分配一个指针指向该内存</li>
</ol>
<p>根据编译器的优化可能会调整指令的顺序，也就是存在这样一种情况：先开辟<br>一块内存，然后分配一个指针指向该内存，最后调用构造方法进行初始化。<br>那么针对单例模式的设计，就会存在这样一个问题：线程A开始创建Singleton<br>的实例，此时线程 B已经调用了getInstance的（）方法，首先判断instance<br>是否为null。而我们上面说的那种模型，A已经把instance指向了那块内存，只<br>是还没来得及调用构造方法进行初始化，因此B检测到instance不为null，于<br>是直接把instance返回了。所以应该使用volatile修饰instance</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>我们知道在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器<br>的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中<br>修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷<br>贝，造成数据的不一致。<br>volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成<br>员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内<br>存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值</p>
<h4 id="单例模式之静态内部类"><a href="#单例模式之静态内部类" class="headerlink" title="单例模式之静态内部类"></a>单例模式之静态内部类</h4><p>当Singleton类被加载时，静态内部类InnerSingleton没有被加载进内存。只<br>有当调用getInstance()方法从而触发Inner.instance时Inner 才会被加载<br>，此时初始化instance实例，并且JVM能确保instance只被实例化一次。这种<br>方式不仅具有延迟初始化的好处，而且由JVM提供了对线程安全的支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> InnerSingleton instance = <span class="keyword">new</span> InnerSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(InnerSingleton.getInstance()==</span><br><span class="line">        InnerSingleton.getInstance());<span class="comment">//true</span></span><br><span class="line">        System.out.println(InnerSingleton.getInstance().equals(</span><br><span class="line">        InnerSingleton.getInstance()));<span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式之枚举实现"><a href="#单例模式之枚举实现" class="headerlink" title="单例模式之枚举实现"></a>单例模式之枚举实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例模式的应用可以分为两类：资源共享和方便资源互相通信</p>
<ol>
<li>windows 系统的回收站，我们能在任何盘符删除数据，但是最后都是到了<br>回收站中</li>
<li>网站的计数器，不过不采用单例模式，很难实现同步</li>
<li>数据库连接池，可以节省打开或关闭数据库连接所引起的效率损耗，用单例模<br>式来维护，可以大大降低这种损耗</li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂模式是用来创建对象的一种最常用的设计模式。是用工厂方法代替new操作<br>的一种模式。我们不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中<br>，那么这个函数就可以被视为一个工厂<br>Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需<br>要明确指定具体类。抽象工厂模式创建的是对象家族，也就是很多对象而不是一个<br>对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是<br>用于创建一个对象，这和抽象工厂模式有很大不同</p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>封装一个复杂对象的构建过程，并可以按步骤构造。建造者模式将复杂产品的构建<br>过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的<br>控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得<br>相同的创建过程能够创建不同的产品。StringBuilder的实现就用到该模式</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。在我们应<br>用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果<br>这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们<br>需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模<br>式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Prototype <span class="title">myClone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype</span><span class="params">(String filed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Prototype <span class="title">myClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototype(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的方法接口转换成客户希望的另外一个接口。在我们的应用程序中我<br>们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们<br>可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所<br>谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可<br>以让原本两个不兼容的接口能够无缝完成对接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> INputStreamReader(inputStream);</span><br></pre></td></tr></table></figure>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>将抽象部分和它的实现部分分离，使它们都可以独立的变化</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>将对象组合成树形结构以表示“”部分-整体“”的层次结构</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>动态的给对象添加新的功能，一种动态地往一个类中添加新的行为的设计<br>、模式。就功能而言，装饰器模式相比生成子类更为灵活，这样可以给某<br>个对象而不是整个类添加一些功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(inputStream));</span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一个代理以便控制这个对象的访问</p>
<h3 id="亨元模式"><a href="#亨元模式" class="headerlink" title="亨元模式"></a>亨元模式</h3><p>通过共享技术来有效的支持大量细粒度的对象</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系<br>。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>将命令请求封装为一个对象，使得可以用不同的请求来进行参数化</p>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器</p>
<h3 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h3><p>一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。<br>Collection接口在元素遍历的设计上采用迭代器的设计模式。迭代器给我们<br>提供了统一的接口来遍历实现了迭代器接口的类的对象，实现了遍历集合方<br>法的复用，减少我们的代码量</p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>用一个中介对象来封装一系列的对象交互</p>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>在不破坏封装的前提下，保持对象的内部状态</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>对象间的一对多的依赖关系</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>允许一个对象在其对象内部状态改变时改变它的行为</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列算法，把他们封装起来，并且使它们可以相互替换</p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>定义一个算法结构，而将一些步骤延迟到子类实现。<br>在父类中声明一些必要的抽象方法，同时父类通过这些抽象方法来实现一些<br>实例方法，而这些个抽象方法通过继承来交给子类实现，子类根据自己的特<br>性来自定义实现这些抽象方法，以达到最好的执行效率。利用多态性来达到<br>不同的子类有不同的行为的同时也保证了整个框架具有良好的扩展性。比如<br>抽象类AbstractCollection中的contains remove等方法都用到了迭代<br>器，这些实例方法都依赖于两个抽象方法iterator和size</p>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>在不改变数据结构的前提下，增加作用于一组对象元素的新功能</p>
<h3 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h3><p>使用什么都不做的空对象来代替NULL。一个方法返回 NULL，意味着方法的调<br>用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码<br>。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，<br>那么就有可能抛出空指针异常</p>
<h3 id="责任链模式-1"><a href="#责任链模式-1" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会</p>
<h3 id="委托的设计思想"><a href="#委托的设计思想" class="headerlink" title="委托的设计思想"></a>委托的设计思想</h3><p>SubList类中并没有重新创建一个列表List，而是创建一个字段指向源列表<br>对象，并且将起始下标（fromIndex）作为偏移量，而之后对子列表元素的<br>相关操作都是通过调用源列表的相关方法并且算上偏移量（offset）来实<br>现的</p>
<h3 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h3><p>我们使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的<br>前提下，提供额外的功能操作，扩展目标对象的功能。代理模式的主要作用是扩<br>展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自<br>定义的操作</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>首先得有一个接口，通用的接口是代理模式实现的基础</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span>   </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要有一个真正的实现这个接口的类，和一个只是实现接口的代理类。<br>代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能<br>的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或<br>者是共同继承某个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span>   </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">  </span>&#123;   </span><br><span class="line">    System.out.println( <span class="string">"call doSomething()"</span> );   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  Subject subimpl = <span class="keyword">new</span> RealSubject();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  	 ...</span><br><span class="line">     subimpl.doSomething();</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到静态代理的代理对象和被代理对象在代理之前就已经确定，它们都实现<br>相同的接口或继承相同的抽象类</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在动态代理中，我们可以让程序在运行的时候自动在内存中创建一个实现该接口<br>的代理，而不需要去定义这个类。这就是它被称为动态的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span>   </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span>   </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">  </span>&#123;   </span><br><span class="line">    System.out.println( <span class="string">"call doSomething()"</span> );   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写代理类，需要实现InvocationHandler 接口，重写invoke() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object tar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定委托对象，并返回代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object tar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tar = tar;</span><br><span class="line">        <span class="comment">//绑定该类实现的所有接口，取得代理类 </span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(tar.getClass().getClassLoader(),</span><br><span class="line">                                      tar.getClass().getInterfaces(),</span><br><span class="line">                                      <span class="keyword">this</span>);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy , Method method , Object[] args)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//这里就可以进行所谓的AOP编程了</span></span><br><span class="line">        <span class="comment">//在调用具体函数方法前，执行功能处理</span></span><br><span class="line">        result = method.invoke(tar,args);</span><br><span class="line">        <span class="comment">//在调用具体函数方法后，执行功能处理</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           ProxyHandler proxy = <span class="keyword">new</span> ProxyHandler();</span><br><span class="line">           <span class="comment">//绑定该类实现的所有接口</span></span><br><span class="line">           Subject sub = (Subject) proxy.bind(<span class="keyword">new</span> RealSubject());</span><br><span class="line">           sub.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Proxy 的静态方法newProxyInstance 才会动态创建代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">    InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>loader 自然是类加载器</li>
<li>interfaces 代码要用来代理的接口</li>
<li>h 一个InvocationHandler 对象</li>
</ol>
<p>InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有<br>一个与之关联的InvocationHandler 实现类，如果代理的方法被调用，那<br>么代理便会通知和转发给内部的InvocationHandler 实现类，由它决定处<br>理。InvocationHandler 内部只是一个 invoke() 方法，正是这个方法决<br>定了怎么样处理代理传递过来的方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>proxy 代理对象</li>
<li>method 代理对象调用的方法</li>
<li>args 调用的方法中的参数</li>
</ol>
<p>因为Proxy 动态产生的代理会调用InvocationHandler 实现类，所以该类是<br>实际执行者</p>
<h3 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h3><ol>
<li>静态代理的代理对象和被代理对象在代理之前就已经确定，它们都实现相同<br>的接口或继承相同的抽象类。静态代理模式一般由业务实现类和业务代理类组成<br>，业务实现类里面实现主要的业务逻辑，业务代理类负责在业务方法调用的前<br>后作一些你需要的处理，以实现业务逻辑与业务方法外的功能解耦，减少了对<br>业务方法的入侵。静态代理又可细分：基于继承的方式和基于聚合的方式实现</li>
<li>静态代理模式的代理类，只是实现了特定类的代理，代理类对象的方法越多<br>，你就得写越多的重复的代码。动态代理就可以动态的生成代理类，实现对不同<br>类下的不同方法的代理</li>
<li>JDK 动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用业务<br>方法前调用InvocationHandler 处理。代理类必须实现 InvocationHandler<br>接口，并且JDK 动态代理只能代理实现了接口的类</li>
</ol>
<h3 id="JDK-动态代理的步骤"><a href="#JDK-动态代理的步骤" class="headerlink" title="JDK 动态代理的步骤"></a>JDK 动态代理的步骤</h3><ol>
<li>编写需要被代理的类和接口</li>
<li>编写代理类，需要实现InvocationHandler 接口，重写invoke() 方法</li>
<li>使用Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[]<br>interfaces, InvocationHandler h)动态创建代理类对象，通过代理类<br>对象调用业务方法</li>
</ol>
<h3 id="静态代理和动态代理的区别？"><a href="#静态代理和动态代理的区别？" class="headerlink" title="静态代理和动态代理的区别？"></a>静态代理和动态代理的区别？</h3><ol>
<li>静态代理 为现有的每一个类都编写一个对应的代理类，并且让它实现和<br>目标类相同的接口（假设都有），在创建代理对象时，通过构造器塞入一个<br>目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前<br>后打印日志。也就是说，代理对象=增强代码 +目标对象（原对象）。有了代<br>理对象后，就不用原对象了，静态代理没有修改原对象的代码</li>
<li>动态代理 要创建一个实例，最关键的就是得到对应的Class对象。不写代<br>理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。代理<br>类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证<br>代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都<br>可以转移到目标对象身上，代理对象只需专注于增强代码的编写。接口拥<br>有代理对象和目标对象共同的类信息。所以我们可以从接口那得到理应由<br>代理类提供的信息。但是接口是无法创建对象的</li>
</ol>
<h3 id="静态代理和动态代理的优缺点？"><a href="#静态代理和动态代理的优缺点？" class="headerlink" title="静态代理和动态代理的优缺点？"></a>静态代理和动态代理的优缺点？</h3><ol>
<li>静态代理</li>
</ol>
<ul>
<li>缺点 静态代理的缺点是程序员要手动为每一个目标类编写对应的代理类。<br>如果当前系统已经有成百上千个类，工作量太大了</li>
<li>如果接口增加一个方法，比如 UserService 增加修改 updateUser()<br>方法，则除了所有实现类需要实现这个方法外，所有代理类也需要实现此<br>方法。增加了代码维护的复杂度</li>
</ul>
<ol start="2">
<li>动态代理</li>
</ol>
<ul>
<li>缺点 动态代理生成的代理对象，最终都可以用接口接收，和目标对象一<br>起形成了多态，可以随意切换展示不同的功能。但是切换的同时，只能使<br>用该接口定义的方法</li>
</ul>
<h3 id="代理Class对象和代理对象的区别？"><a href="#代理Class对象和代理对象的区别？" class="headerlink" title="代理Class对象和代理对象的区别？"></a>代理Class对象和代理对象的区别？</h3><p>代理Class对象是Class类型，代理Class其实就是附有构造器的接口Class，一样<br>的类结构信息，却能创建实例。而代理对象可以赋值给接口类型，只要实现该接口<br>就是该类型，代理对象的本质就是：和目标对象实现相同接口的实例。代理Class<br>可以叫任何名字，只要它实现某个接口，就能成为该接口类型</p>
<h3 id="动态代理的原理？"><a href="#动态代理的原理？" class="headerlink" title="动态代理的原理？"></a>动态代理的原理？</h3><p>InvocationHandler 接口和Proxy 类。这两个类相互配合，入口是Proxy</p>
<ol>
<li>Proxy 有个静态方法：getProxyClass(ClassLoader,interfaces)<br>，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象</li>
<li>getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结<br>构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创<br>建对象的</li>
<li>一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理<br>Class，通过代理Class即可创建代理对象</li>
<li>根据代理Class的构造器创建对象时，需要传入 InvocationHandler。<br>代理对象的内部确实有个成员变量invocationHandler，每次调用代理对<br>象的方法，最终都会调用InvocationHandler的invoke()<br>方法</li>
<li>InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代<br>理这么直接</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/15/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>高并发项目学习</span></a></div><div class="next-post pull-right"><a href="/2021/02/24/%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"><span>常见框架总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/02/25/设计模式总结/';
  this.page.title = '设计模式总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>