<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JAVA集合总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>JAVA集合总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-number">1.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器设计模式"><span class="toc-number">1.1.</span> <span class="toc-text">迭代器设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板方法设计模式"><span class="toc-number">1.2.</span> <span class="toc-text">模板方法设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委托的设计思想"><span class="toc-number">1.3.</span> <span class="toc-text">委托的设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">1.4.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#饿汉式"><span class="toc-number">1.5.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒汉式"><span class="toc-number">1.6.</span> <span class="toc-text">懒汉式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java集合"><span class="toc-number">2.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Java的集合？使用集合有什么好处？"><span class="toc-number">2.1.</span> <span class="toc-text">什么是Java的集合？使用集合有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的集合类有哪些？"><span class="toc-number">2.2.</span> <span class="toc-text">常用的集合类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List，Set，Map三者的区别？"><span class="toc-number">2.3.</span> <span class="toc-text">List，Set，Map三者的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterable接口是什么？"><span class="toc-number">2.4.</span> <span class="toc-text">Iterable接口是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterable接口的作用是什么？"><span class="toc-number">2.5.</span> <span class="toc-text">Iterable接口的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator怎么使用？有什么特点？"><span class="toc-number">2.6.</span> <span class="toc-text">Iterator怎么使用？有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator的作用是什么？"><span class="toc-number">2.7.</span> <span class="toc-text">Iterator的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator和foreach遍历集合的区别？"><span class="toc-number">2.8.</span> <span class="toc-text">Iterator和foreach遍历集合的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是快速失败（fast-fail）机制？"><span class="toc-number">2.9.</span> <span class="toc-text">什么是快速失败（fast-fail）机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator和ListIterator有什么区别？"><span class="toc-number">2.10.</span> <span class="toc-text">Iterator和ListIterator有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么确保一个集合不能被修改？"><span class="toc-number">2.11.</span> <span class="toc-text">怎么确保一个集合不能被修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合框架底层数据结构是什么？"><span class="toc-number">2.12.</span> <span class="toc-text">集合框架底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见接口和类的作用是什么？"><span class="toc-number">2.13.</span> <span class="toc-text">常见接口和类的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历一个List有哪些不同的方式？"><span class="toc-number">2.14.</span> <span class="toc-text">遍历一个List有哪些不同的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList继承和实现的接口有哪些？"><span class="toc-number">2.15.</span> <span class="toc-text">ArrayList继承和实现的接口有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList是什么？底层数据结构是什么？"><span class="toc-number">2.16.</span> <span class="toc-text">ArrayList是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList与LinkedList的区别？"><span class="toc-number">2.17.</span> <span class="toc-text">ArrayList与LinkedList的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList与LinkedList的应用场景？"><span class="toc-number">2.18.</span> <span class="toc-text">ArrayList与LinkedList的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList的扩容机制是什么样的？"><span class="toc-number">2.19.</span> <span class="toc-text">ArrayList的扩容机制是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList的add方法具体是如何实现的？"><span class="toc-number">2.20.</span> <span class="toc-text">ArrayList的add方法具体是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ensureExplicitCapacity具体如何实现？"><span class="toc-number">2.21.</span> <span class="toc-text">ensureExplicitCapacity具体如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩容方法grow是如何实现的？"><span class="toc-number">2.22.</span> <span class="toc-text">扩容方法grow是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hugeCapcity的具体实现？"><span class="toc-number">2.23.</span> <span class="toc-text">hugeCapcity的具体实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简要说说ArrayList的扩容机制"><span class="toc-number">2.24.</span> <span class="toc-text">简要说说ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么情况下modCount会增加"><span class="toc-number">2.25.</span> <span class="toc-text">什么情况下modCount会增加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList按照索引增加和减少是什么样的？"><span class="toc-number">2.26.</span> <span class="toc-text">ArrayList按照索引增加和减少是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList⽤来做队列合适么？"><span class="toc-number">2.27.</span> <span class="toc-text">ArrayList⽤来做队列合适么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList的遍历和LinkedList遍历性能⽐较如何？"><span class="toc-number">2.28.</span> <span class="toc-text">ArrayList的遍历和LinkedList遍历性能⽐较如何？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList的优缺点有哪些？"><span class="toc-number">2.29.</span> <span class="toc-text">ArrayList的优缺点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现数组和List之间的转换？"><span class="toc-number">2.30.</span> <span class="toc-text">如何实现数组和List之间的转换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么ArrayList的elementData加上transient修饰？"><span class="toc-number">2.31.</span> <span class="toc-text">为什么ArrayList的elementData加上transient修饰？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList是什么？底层数据结构是什么？"><span class="toc-number">2.32.</span> <span class="toc-text">LinkedList是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue有什么作用？"><span class="toc-number">2.33.</span> <span class="toc-text">Queue有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deque有什么作用？"><span class="toc-number">2.34.</span> <span class="toc-text">Deque有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList用什么保存元素？"><span class="toc-number">2.35.</span> <span class="toc-text">LinkedList用什么保存元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList如何实现插入？"><span class="toc-number">2.36.</span> <span class="toc-text">LinkedList如何实现插入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入和删除是否受元素位置的影响？"><span class="toc-number">2.37.</span> <span class="toc-text">插入和删除是否受元素位置的影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector是什么？底层数据结构是什么？"><span class="toc-number">2.38.</span> <span class="toc-text">Vector是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-和-Vector-的区别是什么？"><span class="toc-number">2.39.</span> <span class="toc-text">ArrayList 和 Vector 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程场景下如何使用-ArrayList？"><span class="toc-number">2.40.</span> <span class="toc-text">多线程场景下如何使用 ArrayList？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack是什么？底层数据结构是什么？"><span class="toc-number">2.41.</span> <span class="toc-text">Stack是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList、LinkedList、Vector和Stack的区别"><span class="toc-number">2.42.</span> <span class="toc-text">ArrayList、LinkedList、Vector和Stack的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">2.43.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#容量阈值threshold有什么用"><span class="toc-number">2.43.1.</span> <span class="toc-text">容量阈值threshold有什么用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap的底层数据结构是什么？"><span class="toc-number">2.43.2.</span> <span class="toc-text">HashMap的底层数据结构是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树"><span class="toc-number">2.43.3.</span> <span class="toc-text">为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不用红黑树，用二叉查找树可以么"><span class="toc-number">2.43.4.</span> <span class="toc-text">不用红黑树，用二叉查找树可以么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#当链表转为红黑树后，什么时候退化为链表"><span class="toc-number">2.43.5.</span> <span class="toc-text">当链表转为红黑树后，什么时候退化为链表?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么链表改为红黑树的阈值是-8"><span class="toc-number">2.43.6.</span> <span class="toc-text">为什么链表改为红黑树的阈值是 8?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认加载因子是多少？为什么是0-75，不是0-6或者0-8？"><span class="toc-number">2.43.7.</span> <span class="toc-text">默认加载因子是多少？为什么是0.75，不是0.6或者0.8？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap中key的存储索引是怎么计算的？"><span class="toc-number">2.43.8.</span> <span class="toc-text">HashMap中key的存储索引是怎么计算的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8为什么要hashcode异或其右移十六位的值？"><span class="toc-number">2.43.9.</span> <span class="toc-text">JDK1.8为什么要hashcode异或其右移十六位的值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么-hash-值要与length-1相与？"><span class="toc-number">2.43.10.</span> <span class="toc-text">为什么 hash 值要与length-1相与？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap数组的长度为什么是-2-的幂次方？"><span class="toc-number">2.43.11.</span> <span class="toc-text">HashMap数组的长度为什么是 2 的幂次方？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-的put方法流程？"><span class="toc-number">2.43.12.</span> <span class="toc-text">HashMap 的put方法流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-7-和1-8-的put方法区别是什么？"><span class="toc-number">2.43.13.</span> <span class="toc-text">JDK1.7 和1.8 的put方法区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-的扩容方式？"><span class="toc-number">2.43.14.</span> <span class="toc-text">HashMap 的扩容方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩容在JDK1-8中有什么不一样？"><span class="toc-number">2.43.15.</span> <span class="toc-text">扩容在JDK1.8中有什么不一样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#还知道哪些hash算法？"><span class="toc-number">2.43.16.</span> <span class="toc-text">还知道哪些hash算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key-可以为-Null-吗"><span class="toc-number">2.43.17.</span> <span class="toc-text">key 可以为 Null 吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一般用什么作为HashMap的key"><span class="toc-number">2.43.18.</span> <span class="toc-text">一般用什么作为HashMap的key?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用可变类当-HashMap-的-key-有什么问题"><span class="toc-number">2.43.19.</span> <span class="toc-text">用可变类当 HashMap 的 key 有什么问题?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">2.44.</span> <span class="toc-text">TreeMap</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">57</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JAVA集合总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/02/16/JAVA集合总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h3><p>Collection接口在元素遍历的设计上采用迭代器的设计模式。迭代器给我们<br>提供了统一的接口来遍历实现了迭代器接口的类的对象，实现了遍历集合方<br>法的复用，减少我们的代码量</p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>在父类中声明一些必要的抽象方法，同时父类通过这些抽象方法来实现一些<br>实例方法，而这些个抽象方法通过继承来交给子类实现，子类根据自己的特<br>性来自定义实现这些抽象方法，以达到最好的执行效率。利用多态性来达到<br>不同的子类有不同的行为的同时也保证了整个框架具有良好的扩展性。比如<br>抽象类AbstractCollection中的contains remove等方法都用到了迭代<br>器，这些实例方法都依赖于两个抽象方法iterator和size</p>
<h3 id="委托的设计思想"><a href="#委托的设计思想" class="headerlink" title="委托的设计思想"></a>委托的设计思想</h3><p>SubList类中并没有重新创建一个列表List，而是创建一个字段指向源列表<br>对象，并且将起始下标（fromIndex）作为偏移量，而之后对子列表元素的<br>相关操作都是通过调用源列表的相关方法并且算上偏移量（offset）来实<br>现的</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="什么是Java的集合？使用集合有什么好处？"><a href="#什么是Java的集合？使用集合有什么好处？" class="headerlink" title="什么是Java的集合？使用集合有什么好处？"></a>什么是Java的集合？使用集合有什么好处？</h3><p>Java 的集合也称为容器，是用来存放数据的容器，不过注意，集合存放的<br>只能是引用数据类型的数据，也就是一个个的对象（如果存入基本数据类型<br>的数据，会自动装箱成包装类）。集合的好处如下</p>
<ol>
<li>集合的长度是可变的</li>
<li>集合可以存放不同类型的对象</li>
<li>使用集合之后，可以像操作基本数据类型那样来操作对象</li>
<li>集合为我们提供了多种数据结构和操作的API，选用合适的集合，能够提<br>程序性能和开发效率</li>
</ol>
<h3 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h3><p>Map接口和Collection接口是所有集合框架的父接口</p>
<ul>
<li>Collection接口的子接口包括：Set接口、List接口和Queue接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、LinkedHashMap<br>、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
<h3 id="List，Set，Map三者的区别？"><a href="#List，Set，Map三者的区别？" class="headerlink" title="List，Set，Map三者的区别？"></a>List，Set，Map三者的区别？</h3><ol>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可<br>以重复，可以插入多个null元素，元素都有索引。常用的实现类有ArrayList<br>、LinkedList 和 Vector</li>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元<br>素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是<br>HashSet、LinkedHashSet 以及 TreeSet</li>
<li>Map：是一个键值对集合，存储键、值和之间的映射。 Key无序唯一，value<br>不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元<br>素时，只要给出键对象，就会返回对应的值对象</li>
</ol>
<h3 id="Iterable接口是什么？"><a href="#Iterable接口是什么？" class="headerlink" title="Iterable接口是什么？"></a>Iterable接口是什么？</h3><p>Iterable接口实际上是JAVA集合中最顶级的接口，Collection接口直接继承<br>了这个接口，所以Collection的子接口List和Set间接继承它。Map没有直接<br>继承这个接口，但是可以通过Map的KeySet来遍历Map</p>
<h3 id="Iterable接口的作用是什么？"><a href="#Iterable接口的作用是什么？" class="headerlink" title="Iterable接口的作用是什么？"></a>Iterable接口的作用是什么？</h3><p>作用：Iterable接口有一个产生迭代器Iterator 的方法，其作用就是提供了<br>统一的方法接口来方便我们遍历容器，foreach 的实现原理是编译器帮我们将<br>遍历直接转换成了对集合iterator.next()的调用（可以使用foreach进行遍<br>历集合都实现了Iterable接口），所以如果自定义类实现了Iterable接口并<br>且实现了该接口中iterator()方法的具体定义，则可以通过foreach语法来<br>遍历自定义的类。对于List接口来说，它是可以产生一个ListIterator对象<br>的，而这个接口也是继承于Iterator接口，提供了向前访问和向后访问两种<br>方式。</p>
<h3 id="Iterator怎么使用？有什么特点？"><a href="#Iterator怎么使用？有什么特点？" class="headerlink" title="Iterator怎么使用？有什么特点？"></a>Iterator怎么使用？有什么特点？</h3><p>这个接口有三个方法。如果类本身也实现了Iterator接口，那么iterator方<br>法可直接返回this，注意在使用foreach之后需要重置迭代器位置，也证明<br>了foreach确实是通过迭代器实现的</p>
<ol>
<li>next()：返回序列中的下一个元素</li>
<li>hasNext()：检查序列中是否还有元素</li>
<li>使用remove()：将迭代器新返回的元素删除</li>
</ol>
<h3 id="Iterator的作用是什么？"><a href="#Iterator的作用是什么？" class="headerlink" title="Iterator的作用是什么？"></a>Iterator的作用是什么？</h3><p>迭代器给我们提供了统一的接口来遍历实现了迭代器接口的类的对象，实现了<br>遍历集合方法的复用，减少我们的代码量</p>
<h3 id="Iterator和foreach遍历集合的区别？"><a href="#Iterator和foreach遍历集合的区别？" class="headerlink" title="Iterator和foreach遍历集合的区别？"></a>Iterator和foreach遍历集合的区别？</h3><p>foreach的实现原理是编译器将遍历直接转换成了对集合iterator.next()<br>的调用（可以使用foreach进行遍历集合都实现了Iterable接口），所以如<br>果自定义类实现了Iterable接口并且实现了该接口中iterator()方法的具<br>体定义，则可以通过foreach语法来遍历自定义的类。区别如下</p>
<ol>
<li>foreach 不可以在遍历的过程中删除元素，不然会出现并发修改异常<br>（ConcurrentModificationException）,这是因为当使用 foreach(<br>for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历<br>该 list，但同时该 list 正在被 Iterator.remove() 修改。Java一<br>般不允许一个线程在遍历 Collection 时另一个线程修改它</li>
<li>使用iterator遍历时可以通过iterator.remove()删除元素</li>
</ol>
<h3 id="什么是快速失败（fast-fail）机制？"><a href="#什么是快速失败（fast-fail）机制？" class="headerlink" title="什么是快速失败（fast-fail）机制？"></a>什么是快速失败（fast-fail）机制？</h3><p>foreach 不可以在遍历的过程中删除元素就是因为快速失败机制。快速失<br>败是Java集合的一种错误检测机制，当多个线程对集合进行结构上的改变<br>的操作时，有可能会产生fail-fast。<br>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历<br>集合A中的元素，在某个时候，线程2修改了集合A的结构（是结构上面的<br>修改，而不是简单的修改集合元素的内容），那么这个时候程序就可能<br>会抛出ConcurrentModificationException异常，从而产生快速失败。<br>而迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个<br>modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount<br>的值。当迭代器使用hashNext()/next()遍历下一个元素之前，都会检<br>测modCount变量是否为expectedModCount值，是的话就返回遍历，否<br>则抛出异常，终止遍历。<br>解决方法如下</p>
<ol>
<li>在遍历过程中，所有涉及到改变modCount值的地方全部加上synchronized</li>
<li>使用 JUC 中的线程安全类来替代，比如使用 CopyOnWriteArrayList<br>来替代 ArrayList ，使用ConcurrentHashMap 来替代 HashMap </li>
</ol>
<h3 id="Iterator和ListIterator有什么区别？"><a href="#Iterator和ListIterator有什么区别？" class="headerlink" title="Iterator和ListIterator有什么区别？"></a>Iterator和ListIterator有什么区别？</h3><ol>
<li>Iterator可以遍历Set和List集合，而ListIterator只能遍历List</li>
<li>Iterator只能单向遍历，而ListIterator可以双向遍历（向前/后遍历）</li>
<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，<br>比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置</li>
</ol>
<h3 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c)方法<br>来创建一个只读集合，这样改变集合的任何操作都会抛出<br>UnsupportedOperationException 异常</p>
<h3 id="集合框架底层数据结构是什么？"><a href="#集合框架底层数据结构是什么？" class="headerlink" title="集合框架底层数据结构是什么？"></a>集合框架底层数据结构是什么？</h3><ol>
<li>List</li>
</ol>
<ul>
<li>Arraylist： Object数组</li>
<li>Vector： Object数组</li>
<li>LinkedList： 双向循环链表</li>
</ul>
<ol start="2">
<li>Set</li>
</ol>
<ul>
<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap<br>来保存元素</li>
<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是<br>通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap<br>其内部是基于 Hashmap 实现一样，不过还是有一点点区别的</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li>
</ul>
<ol start="3">
<li>Map</li>
</ol>
<ul>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap<br>的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）<br>.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值<br>（默认为8）时，将链表转化为红黑树，以减少搜索时间</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层<br>仍然是基于拉链式散列结构即由数组和链表和红黑树组成。LinkedHashMap<br>在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键<br>值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关<br>逻辑</li>
<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是<br>主要为了解决哈希冲突而存在的</li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="常见接口和类的作用是什么？"><a href="#常见接口和类的作用是什么？" class="headerlink" title="常见接口和类的作用是什么？"></a>常见接口和类的作用是什么？</h3><ol>
<li>Collection 接口提供了线性类型和集合类型的集合的通用接口方法<br>，比如add remove contain等方法</li>
<li>List 新增排序方法sort(Comparator&lt;? super E&gt; c)，并且增加<br>了按照下标添加、修改和删除元素的方法</li>
<li>Set 没有新增任何方法，集合有三个特性：无序、有限、无重复</li>
<li>Map map 即为映射，其提供了两种不同类型的数据对象进行相互关联的<br>能力，也就是键值对。Map中通过Map.Entry 接口来描述这种类型的元素，<br>Entry接口代表一个key-value对（键值对）形成的数据结构，即为映射元<br>素。这个接口中有获取键和值的方法，在Map(HashMap、 LinkedHashMap)<br>中正是通过实现了这个接口的类对象来储存键值对的信息。Map 中添加键<br>值对和通过 key获取键值对的方法，还有一个entrySet方法返回一个包<br>含了所有键值对对象的集合类型对象</li>
<li>AbstractCollection Collection有一个名为AbstractCollection<br>的抽象类，而List接口和Set接口下的具体类都直接/间接的继承了这个抽<br>象类。<br>作用：该类提供了Collection接口的骨架实现，以最小化实现该接口所需<br>代价要实现不可修改的集合，开发者只需要继承这个类并实现iterator()<br>方法和size()方法，即返回一个迭代器（实现了hasNext和next 方法）<br>用于遍历集合和一个表示集合元素个数的值。<br>为了实现可修改的集合，开发者必须另外重写该类的add方法（否则抛出<br>UnsupportedOperationException 异常），迭代器方法返回的迭代器<br>还必须实现其remove方法。使用到了模板方法设计模式</li>
<li>AbstractList的作用<br>它继承了AbstractCollection，同时也是ArrayList等具体集合类的父类。<br>作用：该类提供了List接口的骨架实现，以最大限度地减少实现由 “随机访<br>问”数据存储（如数组）所支持的接口所需的工作量。对于顺序访问数据（如<br>链接列表），应该优先使用AbstractSequentialList类。<br>如果要实现一个不可修改的列表，程序员只需要扩展这个类并为 get(int)<br>和 size() 方法提供实现。<br>要实现一个可修改的列表，程序员必须另外重写 set(int, E) 方法。如果列<br>表是可变大小，程序员必须另外重写add(int E) 和remove(int) 方法，即<br>当前类并没有实现获取随机访问集合和修改集合元素信息的方法。<br>与其他抽象集合实现不同，这个类已经实现了 iterator() 方法，子类可以<br>不必提供迭代器实现，对于某些方法，如果子类允许更有效的实现，设计者<br>鼓励子类可以重写这些方法中的任何一个</li>
<li>SubList的作用<br>表示一个列表的子列表，表示范围：源列表下标范围 [fromIndex, toIndex)<br>并没有新建一个列表对象，还是利用源列表来进行相关操作，创建一个字段指<br>向源列表对象，并且将起始下标（fromIndex）作为偏移量，而之后对子列表<br>元素的相关操作都是通过调用源列表的相关方法并且算上偏移量（offset）<br>来实现的（委托的设计思想）</li>
</ol>
<h3 id="遍历一个List有哪些不同的方式？"><a href="#遍历一个List有哪些不同的方式？" class="headerlink" title="遍历一个List有哪些不同的方式？"></a>遍历一个List有哪些不同的方式？</h3><ol>
<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每<br>一个位置的元素，当读取到最后一个元素后停止</li>
<li>迭代器遍历，Iterator。Iterator是面向对象的一个设计模式，目的是屏蔽<br>不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了<br>Iterator 模式</li>
<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用<br>时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只<br>能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换</li>
</ol>
<h3 id="ArrayList继承和实现的接口有哪些？"><a href="#ArrayList继承和实现的接口有哪些？" class="headerlink" title="ArrayList继承和实现的接口有哪些？"></a>ArrayList继承和实现的接口有哪些？</h3><p>ArrayList类继承于AbstractList抽象类，ArrayList类还实现Serializable<br>、RandomAccess、Cloneable 接口。其中 Serializable 接口是用于将对象序<br>列化以储存在文件中或者通过流的形式在网络中传输的接口，RandomAccess接<br>口是一个没有声明任何方法的空接口，cloneable接口是一个对象复写Object<br>类中clone()方法必须实现的接口</p>
<h3 id="ArrayList是什么？底层数据结构是什么？"><a href="#ArrayList是什么？底层数据结构是什么？" class="headerlink" title="ArrayList是什么？底层数据结构是什么？"></a>ArrayList是什么？底层数据结构是什么？</h3><p>ArrayList就是有序的动态数组列表，主要⽤来装载数据，只能装载包装类，<br>它的主要底层实现是数组Object[] elementData</p>
<h3 id="ArrayList与LinkedList的区别？"><a href="#ArrayList与LinkedList的区别？" class="headerlink" title="ArrayList与LinkedList的区别？"></a>ArrayList与LinkedList的区别？</h3><ol>
<li>数据结构实现 ArrayList 是动态数组的数据结构实现，而LinkedList<br>是双向链表的数据结构实现</li>
<li>随机访问效率 ArrayList比LinkedList在随机访问的时候效率要高，因为<br>LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找</li>
<li>增加和删除效率 在非首尾的增加和删除操作，LinkedList要比ArrayList<br>效率要高，因为ArrayList增删操作要影响数组内的其他数据的下标</li>
<li>内存空间占用 LinkedList 比 ArrayList 更占内存，因为 LinkedList<br>的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后<br>一个元素</li>
<li>线程安全 ArrayList和LinkedList都是不同步的，也就是不保证线程安全</li>
</ol>
<h3 id="ArrayList与LinkedList的应用场景？"><a href="#ArrayList与LinkedList的应用场景？" class="headerlink" title="ArrayList与LinkedList的应用场景？"></a>ArrayList与LinkedList的应用场景？</h3><p>在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作<br>较多时，更推荐使用 LinkedList。如果需要线程安全的就是可以使用Vector，<br>CopyOrWriteArrayList</p>
<h3 id="ArrayList的扩容机制是什么样的？"><a href="#ArrayList的扩容机制是什么样的？" class="headerlink" title="ArrayList的扩容机制是什么样的？"></a>ArrayList的扩容机制是什么样的？</h3><ol>
<li>JDK1.7 相当于设计模式中的饿汉式，第一次创建无参构造器时就创建一个<br>初始容量为10的数组，否则就根据参数创建指定长度的数组</li>
<li>JDK1.8 相当于设计模式中的懒汉式，ArrayList可以通过构造⽅法在初始<br>化的时候指定底层数组的⼤⼩。 通过⽆参构造⽅法的⽅式ArrayList()初始化<br>，则赋值底层数组 Object[] elementData 为⼀个默认的空数组 Object[]<br>DEFAULTCAPACITY_EMPTY_ELEMENTDATA ={}，所以数组容量为0，注意只有<br>真正对数据进⾏添加add时，如果当前数组就是那个默认空数组，才分配默认<br>DEFAULT_CAPACITY = 10的初始容量</li>
</ol>
<h3 id="ArrayList的add方法具体是如何实现的？"><a href="#ArrayList的add方法具体是如何实现的？" class="headerlink" title="ArrayList的add方法具体是如何实现的？"></a>ArrayList的add方法具体是如何实现的？</h3><p>add方法的思路：add添加一个元素时进入ensureCapacityInternal(int)方<br>法，首先判断elementData是不是默认的空数组，如果是那么minCapacity就<br>赋值为初始容量10，否则直接使用当前元素个数加1的值进入下一个判断方法<br>。判断方法结束以后就在数组末尾添加元素</p>
<h3 id="ensureExplicitCapacity具体如何实现？"><a href="#ensureExplicitCapacity具体如何实现？" class="headerlink" title="ensureExplicitCapacity具体如何实现？"></a>ensureExplicitCapacity具体如何实现？</h3><p>首先modeCount会1，表示列表元素结构进行了更改。然后比较minCapicaty和<br>数组长度的大小关系，如果已经大于数组长度那么就会调用扩容方法grow</p>
<h3 id="扩容方法grow是如何实现的？"><a href="#扩容方法grow是如何实现的？" class="headerlink" title="扩容方法grow是如何实现的？"></a>扩容方法grow是如何实现的？</h3><p>grow方法的实现思路如下，首先获得一个原数组1.5倍长的长度 newCapacity<br>，如果minCapacity小于这个1.5倍的长度那么这个1.5倍的长度就是新长度，<br>否则新长度就是指定的容量，这个容量可能是10或者元素个数加1。<br>接下来还要判断这个新长度是否溢出，与Integer.MAX_VALUE - 8进行比较<br>，如果大于就调用hugeCapacity(minCapacity)，这里调用的参数是min是<br>因为newCapacity比minCapacity大，但是minCapacity不一定超</p>
<h3 id="hugeCapcity的具体实现？"><a href="#hugeCapcity的具体实现？" class="headerlink" title="hugeCapcity的具体实现？"></a>hugeCapcity的具体实现？</h3><p>在hugeCapacity中判断minCapacity如果已经超出最大整数的限制那么就<br>直接抛出异常，如果还没有还有一次判断，如果minCapacity还没有大于<br>最大整数减8，那么就直接赋值为最大整数减8，如果已经大于最大整数减<br>8那么就直接赋值为最大整数<br>获取新长度之后回到gorw方法，然后就开始将原数组扩容为新数组，调用<br>Arrays.copyOf方法，将原数组中的值拷贝到新数组中</p>
<h3 id="简要说说ArrayList的扩容机制"><a href="#简要说说ArrayList的扩容机制" class="headerlink" title="简要说说ArrayList的扩容机制"></a>简要说说ArrayList的扩容机制</h3><p>总结一句话：先判断元素数组是否需要扩容 ⇒ 确定扩容后的容量（第一次<br>将容量调整为默认容量（10），之后 以1.5 倍数进行扩容）⇒ 判断扩容<br>后容量是否溢出 ⇒ 进行数组扩容并复制原数组元素到新数组中</p>
<h3 id="什么情况下modCount会增加"><a href="#什么情况下modCount会增加" class="headerlink" title="什么情况下modCount会增加"></a>什么情况下modCount会增加</h3><p>add和remove方法修改数组会增加modCount，set方法不会增加modcount<br>，modCountb表是结构上面的修改，而不是简单的修改集合元素的内容</p>
<h3 id="ArrayList按照索引增加和减少是什么样的？"><a href="#ArrayList按照索引增加和减少是什么样的？" class="headerlink" title="ArrayList按照索引增加和减少是什么样的？"></a>ArrayList按照索引增加和减少是什么样的？</h3><p>ArrayList有指定index（索引下标）新增，也有尾部新增，但是都有校验长<br>度的判断ensureCapacityInternal，就是说如果⻓度不够，是需要扩容的。<br>在扩容的时候，1.7是取余，1.8是位运算，右移⼀位，其实就是除以2这个<br>操作</p>
<h3 id="ArrayList⽤来做队列合适么？"><a href="#ArrayList⽤来做队列合适么？" class="headerlink" title="ArrayList⽤来做队列合适么？"></a>ArrayList⽤来做队列合适么？</h3><p>队列⼀般是FIFO（先⼊先出）的，如果⽤ArrayList做队列，就需要在数组尾<br>部追加数据，数组头部删除数组，反过来也可以。但是⽆论如何总会有⼀个操<br>作会涉及到数组的数据搬迁，这个是⽐较耗费性能的。<br>结论：ArrayList不适合做队列</p>
<h3 id="ArrayList的遍历和LinkedList遍历性能⽐较如何？"><a href="#ArrayList的遍历和LinkedList遍历性能⽐较如何？" class="headerlink" title="ArrayList的遍历和LinkedList遍历性能⽐较如何？"></a>ArrayList的遍历和LinkedList遍历性能⽐较如何？</h3><p>ArrayList要比LinkedList快得多，ArrayList遍历最大的优势在于内存的<br>连续性，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内<br>存的性能开销</p>
<h3 id="ArrayList的优缺点有哪些？"><a href="#ArrayList的优缺点有哪些？" class="headerlink" title="ArrayList的优缺点有哪些？"></a>ArrayList的优缺点有哪些？</h3><p>ArrayList的优点如下</p>
<ul>
<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了<br>RandomAccess 接口，因此查找的时候非常快</li>
<li>ArrayList 在顺序添加一个元素的时候非常方便</li>
</ul>
<p>ArrayList的缺点如下</p>
<ul>
<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那<br>么就会比较耗费性能</li>
<li>插入元素的时候，也需要做一次元素复制操作，缺点同上</li>
</ul>
<h3 id="如何实现数组和List之间的转换？"><a href="#如何实现数组和List之间的转换？" class="headerlink" title="如何实现数组和List之间的转换？"></a>如何实现数组和List之间的转换？</h3><ul>
<li>数组转 List：使用 Arrays.asList(array) 进行转换</li>
<li>List 转数组：使用 List 自带的 toArray() 方法</li>
</ul>
<h3 id="为什么ArrayList的elementData加上transient修饰？"><a href="#为什么ArrayList的elementData加上transient修饰？" class="headerlink" title="为什么ArrayList的elementData加上transient修饰？"></a>为什么ArrayList的elementData加上transient修饰？</h3><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。<br>transient的作用是不希望elementData数组被序列化，重写了writeObject<br>实现。每次序列化时，先调用defaultWriteObject()方法序列化ArrayList<br>中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素<br>，这样既加快了序列化的速度，又减小了序列化之后的文件大小</p>
<h3 id="LinkedList是什么？底层数据结构是什么？"><a href="#LinkedList是什么？底层数据结构是什么？" class="headerlink" title="LinkedList是什么？底层数据结构是什么？"></a>LinkedList是什么？底层数据结构是什么？</h3><p>底层使用的是双向链表数据结构，可以作为队列/双端队列使用。LinkedList<br>类继承了AbstractSequentialList抽象类，同时实现了List、Queue、Deque<br> 、Cloneable、Serializable接口。Queue接口声明了队列的相关方法</p>
<h3 id="Queue有什么作用？"><a href="#Queue有什么作用？" class="headerlink" title="Queue有什么作用？"></a>Queue有什么作用？</h3><p>这个接口声明一个队列的相关操作。<br>add添加一个元素到队列尾部，offer添加一个元素到队列尾部，remove移除<br>头部元素如果队列为空抛出异常，poll也是移除头部元素如果队列为空返回<br>null，element取出头部元素，如果队列为空抛出异常，peek也是取出头部<br>元素当队列为空时返回null</p>
<h3 id="Deque有什么作用？"><a href="#Deque有什么作用？" class="headerlink" title="Deque有什么作用？"></a>Deque有什么作用？</h3><p>这个接口声明了双端队列的相关操作。<br>addFirst添加元素到双端队列的头部，addLast添加元素到双端队列的尾部，<br>以上两个如果有容量限制添加失败会抛出异常。offerFirst添加元素到双端<br>队列头部，offerLast添加元素到双端队列尾部，以上两个添加失败false。<br>removeFirst removeLast poolFirst pollLast getFirst getLast<br>peekFirst peekLast</p>
<h3 id="LinkedList用什么保存元素？"><a href="#LinkedList用什么保存元素？" class="headerlink" title="LinkedList用什么保存元素？"></a>LinkedList用什么保存元素？</h3><p>LinkedList有一个用来表示元素节点的类Node，有前驱和后继指针字段。<br>LinkedList没有扩容机制，添加元素时只需要插入链表尾即可。但是每个<br>节点除了保存元素值外还要保存前驱和后继指针，消耗额外的内存空间。<br>有一个first和last指针分别指向头结点和尾节点</p>
<h3 id="LinkedList如何实现插入？"><a href="#LinkedList如何实现插入？" class="headerlink" title="LinkedList如何实现插入？"></a>LinkedList如何实现插入？</h3><p>add方法默认是将元素插入到链表尾部。如果使用add(int index,E e)来<br>添加元素的话首先判断越界以及是否是直接插入在尾部，否则就会先找到<br>节点的位置，这里是调用node方法找到节点位置，思路是如果index不大<br>于链表长度的1/2就正向遍历，否则就反向遍历，这种设计能够最小化减<br>少循环的次数。注意索引是从0开始，找到这个节点后还要获取该节点的<br>前驱节点，注意插入的意思是新节点要插入到index这个位置，所以新<br>节点的后继节点就是找到的这个节点</p>
<h3 id="插入和删除是否受元素位置的影响？"><a href="#插入和删除是否受元素位置的影响？" class="headerlink" title="插入和删除是否受元素位置的影响？"></a>插入和删除是否受元素位置的影响？</h3><ol>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置<br>的影响。 比如：执行add(E e)方法的时候， ArrayList会默认在将指定的元<br>素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位<br>置i插入和删除元素的话（add(int index, E element)）时间复杂度就为<br>O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)<br>个元素都要执行向后位/向前移一位的操作。</li>
<li>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位<br>置的影响，都是近似O(1)而数组为近似O(n)</li>
</ol>
<h3 id="Vector是什么？底层数据结构是什么？"><a href="#Vector是什么？底层数据结构是什么？" class="headerlink" title="Vector是什么？底层数据结构是什么？"></a>Vector是什么？底层数据结构是什么？</h3><p>Vecctor类和ArrayList继承的类和实现的接口都一样，也是有序的动态数据<br>列表，Vector可以指定每次扩容的增量，如果不指定默认每次扩容2倍。默认<br>的数组长度也是10。Vector类的所有方法都是同步的。</p>
<h3 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h3><ol>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安<br>全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只<br>不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</li>
</ol>
<h3 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h3><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections<br>的 synchronizedList 方法将其转换成线程安全的容器后再使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">"aaa"</span>);</span><br><span class="line">synchronizedList.add(<span class="string">"bbb"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stack是什么？底层数据结构是什么？"><a href="#Stack是什么？底层数据结构是什么？" class="headerlink" title="Stack是什么？底层数据结构是什么？"></a>Stack是什么？底层数据结构是什么？</h3><p>Stack继承了Vector类，也是线程安全的。<br>作用：提供了栈的实现。push pop peek都是线程安全的方法，add本质是在<br>链表尾部添加元素，pop本质是在链表尾部移除元素，peek本质是在链表尾<br>部取出元素</p>
<h3 id="ArrayList、LinkedList、Vector和Stack的区别"><a href="#ArrayList、LinkedList、Vector和Stack的区别" class="headerlink" title="ArrayList、LinkedList、Vector和Stack的区别"></a>ArrayList、LinkedList、Vector和Stack的区别</h3><ul>
<li>ArrayList：内部采用数组保存元素，初始默认容量为 10，之后添加元素时<br>，如果数组容量不足，则以1.5倍扩容数组，溢出时抛出OutOfMemeryError<br>异常。扩容操作即为新建一个更大的数组并将原数组中的元素拷贝到新数组中<br>。在元素较多时扩容操作开销较大，如果一开始可以确定最大需要的容量，那<br>么建议使用另一个构造方法来创建指定初始容量的ArrayList以提高效率。因<br>为采用的数组储存元素，所以插入和删除元素操作较慢（时间复杂度为O(N)<br>）。ArrayList为非线程安全的类</li>
<li>LinkedList ：内部采用双向链表来储存元素，每添加一个元素就新建一个<br>Node 并添加到对应的位置，就没有所谓的扩容机制，同时实现了 Deque 接<br>口，可以作为队列 / 双端队列使用。插入元素、移除元素效率较高（时间复<br>杂度为 O(1)），但是随机访问元素效率较低（时间复杂度为 O(N)）。<br>LinkedList 非线程安全</li>
<li>Vector ：和 ArrayList 相似，内部采用数组保存元素，默认容量为 10。创<br>建时如果指定了 capacityIncrement 参数，那么每次扩容时数组容量增加<br>capacityIncrement ，否则扩容时数组容量变为原来的 2 倍。Vector 线程<br>安全</li>
<li>Stack ：继承于Vector类，提供了数据结构中栈的相关操作方法，线程安全</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ol>
<li>AbstractMap的作用<br>这个抽象类提供了Map的骨架实现，以最小化实现Map接口功能所需的要求。<br>如果要实现一个不可更改的map对象，开发者只需要继承这个类并实现entrySet<br>方法，返回一个包含当前 Map 对象中所有键值对的集合。通常，这个集合应该<br>基于AbstractSet类来实现，并且不应该支持添加和删除元素的方法，其迭代<br>器不应该支持移除元素的方法。<br>如果要实现可更改的 map 对象，开发者必须重写 put 方法，并且通过<br>entrySet().iterator() 方法返回的迭代器必须实现移除元素的方法</li>
<li>SortedMap的作用<br>实现这个接口的容器应该要按某个规则对容器内的元素进行排序，并且可以通<br>过这个接口提供的方法获取容器特定的一些元素。但是接口本身不干预容器的<br>排序规则，具体的排序方式由容器自己决定。Map 接口中的具体类 TreeMap<br>就是一个实现了 SortedMap 接口的类</li>
</ol>
<p>HashMap默认的初始化容量是16，并且容量必须是2的次幂，最大容量是2^30。<br>默认的负载因子是0.75，用于计算出下一次扩容时的容量阈值</p>
<ol start="3">
<li>HashMap用哪个类保存键值对<br>在HashMap中通过一个名为Node的静态内部类来实现Map.Entry接口并实现接<br>口中的方法。Node类中有 hash键的哈希值 key value next用于指向下一个<br>Node用于处理冲突。</li>
<li>HashMap的数据结构<br>HashMap是通过一个Node类型的数据table保存所有键值对，长度必须是2的<br>幂次方。有一个Set类型的集合entrySet保存所有键值对</li>
<li>HashMap的构造方法<br>能够自定义初始容量和负载因子，如果初始容量大于最大容量1073741824那么<br>就设置为最大容量1073741824，负载因子不能小于0 或者是一个非数，注意</li>
<li>0/0.0不会抛异常但是每次的结果不同，然后就会通过tableSizeFor方法<br>进行扩容。<br>tableSizeFor方法中对当前cap指定的容量进行操作，返回第一个大于等于<br>cap的2的次幂值，具体实现就是把n的二进制数中最左边的那一位1之后的0<br>全变为1，如果n是正常的再加上1，那么一定就是2的次幂。一开始赋值时n<br>要减1是因为防止本来就是一个2的次幂再扩大两倍。<br>到目前为止还没有为table分配内存空间，有一个构造参数也是Map时会调用<br>putMapEntries进行存入对象，这个方法中有一个resize和putVal方法，<br>那么真正存入键值对应该就是这个putVal方法。<br>在putVal方法中首先就判断table是否为null，如果为null就通过resize<br>方法申请空间并调整table的容量，先不管空间具体是如何创建的。首先看<br>一下如何存键值对</li>
<li>HashMap中key的存储索引是怎么计算的？<br>键的话一般情况是通过key%length来实现，但是HashMap的源码中通过<br>(n-1)&amp;hash 来获取键，也就是说为什么可以用&amp;运算符来模拟%操作。<br>HashMap的容量必须是2的次幂，所以其容量n转换成二进制中必然只有<br>一位是1，那么n-1，就是将最左边的那一位1变为0，并且将其右边的0<br>变成1，再将得到的值和hash通过&amp;按位相与，这样的话得到的结果必<br>然不会大于 n-1，即通过位运算达到了 % 操作的目的，还减小了CPU<br>资源的消耗（位操作速度一般的操作符快多了）</li>
<li>put的流程<br>已经得到了键以后，如果数组所在索引位置元素为null就直接赋值，如<br>果已经有元素了，如果插入的键值对和冲突的键等价先记录冲突的元素<br>之后再赋值，如果不等价就判断Node是否是TreeNode类型，如果是的<br>话说明这个链表已经转化为了红黑树，就直接插入树中，否则就遍历<br>整个链表，如果键等价也跟之前一样记录，否则就直接插入链表末尾<br>，插入末尾的话还要判断整个链表的长度是否大于等于8，如果超过<br>就树化。到此再根据之前是否有key等价更新value。<br>如果插入键值对后元素数目大于重新分配HashMap容量的阀值，那么再次<br>分配HashMap容量</li>
<li>HashMap扩容如何实现<br>首先得到旧数组的长度oldCap，如果数组一开始就是空的话长度就是0，<br>如果oldCap大于等于默认最大长度的话那么阈值就设置为最大整数并直<br>接返回，如果oldCap不小于默认容量16并且*2小于默认最大容量那么<br>新的阈值就是旧阈值的2倍。如果当前HashMap容量为0但是阈值不为0，<br>这种情况是因为调用了带有初始容量的构造参数，刚刚已经说了构造<br>方法中并没有进行扩容，所以容量依然是0但是阈值不是0，所以新的<br>数组长度就是阈值。如果阈值也为0说明调用的是默认的构造参数这时<br>就分配默认的初始容量为16，阈值为12。<br>以上完成后还有一种特殊情况就是新的阈值为0，说明调用了带有负载<br>因子的构造参数但是这个负载因子可能有问题，所以使用默认的负载<br>因子计算新的阈值</li>
</ol>
<p>容量（默认为 16，如果自定义初始容量，那么会处理成最小的不小于<br>指定的容量的2的次幂数，注意HashMap的容量一定会是 2 的次幂数）<br>扩容机制（每次扩容变成上一次容量的 2 倍，如果当前元素数目达到<br>扩容阀值（负载因子 * 当前 HashMap 总容量），进行扩容）<br>负载因子（默认 0.75 ）<br>最大容量（Integer.MAX_VALUE - 8）<br>可以指定的最小容量（1（2^0））</p>
<h4 id="容量阈值threshold有什么用"><a href="#容量阈值threshold有什么用" class="headerlink" title="容量阈值threshold有什么用"></a>容量阈值threshold有什么用</h4><p>假设当前设置的HashMap对象的容量为默认容量即16，那么当前的threshold<br>值为16 * 0.75 = 12。当元素个数大于12时就会进行扩容，这里没有在达到<br>16的时候扩容，确实浪费了一部分内存空间，目的是为了减少元素冲突，当<br>容量越大的时候，key计算出的hashCode选择也越多，冲突的可能性越小，<br>而HashMap的主要任务就是保证在尽可能低的时间复杂度O(1)下查询和增删<br>元素，从这个角度牺牲内存是值得的</p>
<h4 id="HashMap的底层数据结构是什么？"><a href="#HashMap的底层数据结构是什么？" class="headerlink" title="HashMap的底层数据结构是什么？"></a>HashMap的底层数据结构是什么？</h4><ul>
<li>在JDK1.7中，由“数组+链表”组成，数组是HashMap的主体，链表则是主要为<br>了解决哈希冲突而存在的</li>
<li>在JDK1.8中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响HashMap<br>的性能，红黑树搜索时间复杂度是O(logn)，而链表是糟糕的O(n)。因此，JDK1.8<br>对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进<br>行转换：当链表长度超过 8 且数据总量大于等于 64 才会转红黑树。将链表转换<br>成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，<br>而不是转换为红黑树，以减少搜索时间</li>
</ul>
<h4 id="为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树"><a href="#为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树" class="headerlink" title="为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?"></a>为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</h4><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元<br>素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于<br>8 个的时候，红黑树搜索时间复杂度是O(logn)，而链表是O(n)，此时需要红黑树<br>来加快查询速度，但是新增节点的效率变慢了。因此，如果一开始就用红黑树结构<br>，元素太少，新增效率又比较慢，无疑这是浪费性能的</p>
<h4 id="不用红黑树，用二叉查找树可以么"><a href="#不用红黑树，用二叉查找树可以么" class="headerlink" title="不用红黑树，用二叉查找树可以么?"></a>不用红黑树，用二叉查找树可以么?</h4><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构<br>一样了，造成很深的问题），遍历查找会非常慢</p>
<h4 id="当链表转为红黑树后，什么时候退化为链表"><a href="#当链表转为红黑树后，什么时候退化为链表" class="headerlink" title="当链表转为红黑树后，什么时候退化为链表?"></a>当链表转为红黑树后，什么时候退化为链表?</h4><p>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下<br>，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成<br>链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁<br>的发生树转链表、链表转树，效率会很低。</p>
<h4 id="为什么链表改为红黑树的阈值是-8"><a href="#为什么链表改为红黑树的阈值是-8" class="headerlink" title="为什么链表改为红黑树的阈值是 8?"></a>为什么链表改为红黑树的阈值是 8?</h4><p>是因为泊松分布，理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的<br>频率遵循泊松分布，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照<br>表，可以看到链表中元素个数为8时的概率已经非常小，再多的就更少了，所以原<br>作者在选择链表元素个数时选择了8，是根据概率统计而选择的</p>
<h4 id="默认加载因子是多少？为什么是0-75，不是0-6或者0-8？"><a href="#默认加载因子是多少？为什么是0-75，不是0-6或者0-8？" class="headerlink" title="默认加载因子是多少？为什么是0.75，不是0.6或者0.8？"></a>默认加载因子是多少？为什么是0.75，不是0.6或者0.8？</h4><p>我们在创建 HashMap 对象的时候可以自己定义这个负载因子，但是我们很难去准<br>确的找到一个最适用我们程序中的负载因子，如果太小，那么会浪费太多的内存空<br>间，如果太大，又可能会在插入元素时产生较多冲突，提高了插入和查询操作的时<br>间复杂度。<br>Node[] table 的初始化长度length(默认值是16)，Load factor为负载因子(<br>默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold =<br>length * Loadfactor。也就是说，在数组定义好长度之后，负载因子越大，所<br>能容纳的键值对个数越多。<br>默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不<br>要修改，除非在时间和空间比较特殊的情况下 ：</p>
<ul>
<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值</li>
<li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor<br>的值，这个值可以大于1<br>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较<br>高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包<br>括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，<br>并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，<br>rehash操作将不会发生</li>
</ul>
<h4 id="HashMap中key的存储索引是怎么计算的？"><a href="#HashMap中key的存储索引是怎么计算的？" class="headerlink" title="HashMap中key的存储索引是怎么计算的？"></a>HashMap中key的存储索引是怎么计算的？</h4><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后<br>通过hash&amp;（length-1）计算得到存储的位置。这里的 Hash 算法本质上就是三<br>步：取key的 hashCode值、根据 hashcode 计算出hash值、通过取模计算下标</p>
<h4 id="JDK1-8为什么要hashcode异或其右移十六位的值？"><a href="#JDK1-8为什么要hashcode异或其右移十六位的值？" class="headerlink" title="JDK1.8为什么要hashcode异或其右移十六位的值？"></a>JDK1.8为什么要hashcode异或其右移十六位的值？</h4><p>因为在JDK 1.7 中扰动了4次，计算 hash 值的性能会稍差一点点。 从速度、功效<br>、质量来考虑，JDK1.8 优化了高位运算的算法，通过hashCode()的高16位异或低<br>16位实现：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)。这么做可以在数组 table 的<br>length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不<br>会有太大的开销</p>
<h4 id="为什么-hash-值要与length-1相与？"><a href="#为什么-hash-值要与length-1相与？" class="headerlink" title="为什么 hash 值要与length-1相与？"></a>为什么 hash 值要与length-1相与？</h4><p>把hash值对数组长度取模运算，模运算的消耗很大，没有位运算快。当length总是<br>2的n次方时，h&amp; (length-1) 运算等价于对length取模，也就是 h%length，但<br>是&amp;比%具有更高的效率</p>
<h4 id="HashMap数组的长度为什么是-2-的幂次方？"><a href="#HashMap数组的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap数组的长度为什么是 2 的幂次方？"></a>HashMap数组的长度为什么是 2 的幂次方？</h4><p>这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外，2的N<br>次幂有助于减少碰撞的几率。如果 length 为2的幂次方，则 length-1 转化为<br>二进制必定是11111……的形式，在与h的二进制与操作效率会非常的快，而且空<br>间不浪费</p>
<h4 id="HashMap-的put方法流程？"><a href="#HashMap-的put方法流程？" class="headerlink" title="HashMap 的put方法流程？"></a>HashMap 的put方法流程？</h4><p>简要流程如下：</p>
<ol>
<li>首先根据key的值计算hash值，找到该元素在数组中存储的下标</li>
<li>如果数组是空的，则调用 resize 进行初始化</li>
<li>如果没有哈希冲突直接放在对应的数组下标里</li>
<li>如果冲突了，且 key 已经存在，就覆盖掉 value</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上</li>
<li>如果冲突后是链表，判断该链表是否大于8 ，如果大于8并且数组容量小于64<br>，就进行扩容</li>
<li>如果链表长度大于 8 并且数组的容量大于等于 64，则将这个结构转换为红黑树</li>
<li>否则，链表插入键值对，若 key 存在，就覆盖掉 value</li>
</ol>
<h4 id="JDK1-7-和1-8-的put方法区别是什么？"><a href="#JDK1-7-和1-8-的put方法区别是什么？" class="headerlink" title="JDK1.7 和1.8 的put方法区别是什么？"></a>JDK1.7 和1.8 的put方法区别是什么？</h4><p>解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定<br>条件，链表会转换为红黑树。链表插入元素时，JDK1.7 使用头插法插入元素，<br>在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环。因此<br>，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，就不会<br>出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是线程不安全的</p>
<h4 id="HashMap-的扩容方式？"><a href="#HashMap-的扩容方式？" class="headerlink" title="HashMap 的扩容方式？"></a>HashMap 的扩容方式？</h4><p>Hashmap 在容量超过负载因子所定义的容量之后，就会扩容。Java里的数组是<br>无法自动扩容的，方法是将Hashmap 的大小扩大为原来数组的两倍，并将原来<br>的对象放入新的数组中</p>
<h4 id="扩容在JDK1-8中有什么不一样？"><a href="#扩容在JDK1-8中有什么不一样？" class="headerlink" title="扩容在JDK1.8中有什么不一样？"></a>扩容在JDK1.8中有什么不一样？</h4><p>JDK1.8做了两处优化：resize 之后，元素的位置在原来的位置，或者原来的<br>位置 +oldCap (原来哈希表的长度）。不需要像 JDK1.7 的实现那样重新计<br>算hash ，只需要看看原来的 hash值新增的那个bit是1还是0就好了，是0<br>的话索引没变，是1的话索引变成“原索引 + oldCap ”。这个设计非常的巧<br>妙，省去了重新计算 hash 值的时间</p>
<h4 id="还知道哪些hash算法？"><a href="#还知道哪些hash算法？" class="headerlink" title="还知道哪些hash算法？"></a>还知道哪些hash算法？</h4><p>Hash函数是指把一个大范围映射到一个小范围，目的往往是为了节省空间，使得<br>数据容易保存。 比较出名的有MurmurHash、MD4、MD5等等</p>
<h4 id="key-可以为-Null-吗"><a href="#key-可以为-Null-吗" class="headerlink" title="key 可以为 Null 吗?"></a>key 可以为 Null 吗?</h4><p>可以，key 为 Null 的时候，hash算法最后的值以0来计算，也就是放在数组<br>的第一个位置</p>
<h4 id="一般用什么作为HashMap的key"><a href="#一般用什么作为HashMap的key" class="headerlink" title="一般用什么作为HashMap的key?"></a>一般用什么作为HashMap的key?</h4><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且String<br>最为常用。因为字符串是不可变的，所以在它创建的时候 hashcode 就被<br>缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的<br>原因。因为获取对象的时候要用到 equals() 和 hashCode() 方法，那<br>么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写<br>了 hashCode() 以及 equals() 方法</p>
<h4 id="用可变类当-HashMap-的-key-有什么问题"><a href="#用可变类当-HashMap-的-key-有什么问题" class="headerlink" title="用可变类当 HashMap 的 key 有什么问题?"></a>用可变类当 HashMap 的 key 有什么问题?</h4><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为<br>常用。因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不<br>需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。因为获取对象<br>的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个<br>方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals()<br>方法</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>底层数据结构是红黑树，TreeMap本身继承自AbstractMap抽象类，实现了<br>NavigableMap 接口，这个 NavigableMap 接口实际上是继承了SortedMap<br>接口，并声明了几个额外的方法</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>机器学习</span></a></div><div class="next-post pull-right"><a href="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><span>JAVA基础总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/02/16/JAVA集合总结/';
  this.page.title = 'JAVA集合总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>