<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JAVA集合总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>JAVA集合总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java集合"><span class="toc-number">2.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的集合"><span class="toc-number">2.1.</span> <span class="toc-text">Java的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List，Set，Map的区别"><span class="toc-number">2.2.</span> <span class="toc-text">List，Set，Map的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的集合类"><span class="toc-number">2.3.</span> <span class="toc-text">常用的集合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterable接口是什么？"><span class="toc-number">2.4.</span> <span class="toc-text">Iterable接口是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator是什么？有什么特点？"><span class="toc-number">2.5.</span> <span class="toc-text">Iterator是什么？有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator和foreach遍历集合的区别？"><span class="toc-number">2.6.</span> <span class="toc-text">Iterator和foreach遍历集合的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach的实现原理是什么？"><span class="toc-number">2.7.</span> <span class="toc-text">foreach的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator和ListIterator有什么区别？"><span class="toc-number">2.8.</span> <span class="toc-text">Iterator和ListIterator有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是快速失败（fast-fail）机制？"><span class="toc-number">2.9.</span> <span class="toc-text">什么是快速失败（fast-fail）机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何防止快速失败？"><span class="toc-number">2.10.</span> <span class="toc-text">如何防止快速失败？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是安全失败机制？"><span class="toc-number">2.11.</span> <span class="toc-text">什么是安全失败机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么情况下modCount会增加？"><span class="toc-number">2.12.</span> <span class="toc-text">什么情况下modCount会增加？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么确保一个集合不能被修改？"><span class="toc-number">2.13.</span> <span class="toc-text">怎么确保一个集合不能被修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays-asList-使用"><span class="toc-number">2.14.</span> <span class="toc-text">Arrays.asList()使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-toArray-方法使用"><span class="toc-number">2.15.</span> <span class="toc-text">Collection.toArray()方法使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合框架底层数据结构总结"><span class="toc-number">2.16.</span> <span class="toc-text">集合框架底层数据结构总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合类别是什么？"><span class="toc-number">2.17.</span> <span class="toc-text">集合类别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性集合类有哪些？"><span class="toc-number">3.</span> <span class="toc-text">线性集合类有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">3.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList继承和实现的接口有哪些？"><span class="toc-number">3.1.1.</span> <span class="toc-text">ArrayList继承和实现的接口有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList是什么？底层数据结构是什么？"><span class="toc-number">3.1.2.</span> <span class="toc-text">ArrayList是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList的扩容机制是什么样的？"><span class="toc-number">3.1.3.</span> <span class="toc-text">ArrayList的扩容机制是什么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList的add方法具体是如何实现的？"><span class="toc-number">3.1.4.</span> <span class="toc-text">ArrayList的add方法具体是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一句话概括ArrayList的扩容机制？"><span class="toc-number">3.1.5.</span> <span class="toc-text">一句话概括ArrayList的扩容机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList按照索引增加和减少是什么样的？"><span class="toc-number">3.1.6.</span> <span class="toc-text">ArrayList按照索引增加和减少是什么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList⽤来做队列合适么？"><span class="toc-number">3.1.7.</span> <span class="toc-text">ArrayList⽤来做队列合适么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList的优缺点有哪些？"><span class="toc-number">3.1.8.</span> <span class="toc-text">ArrayList的优缺点有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何实现数组和List之间的转换？"><span class="toc-number">3.1.9.</span> <span class="toc-text">如何实现数组和List之间的转换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么ArrayList的elementData加上transient修饰？"><span class="toc-number">3.1.10.</span> <span class="toc-text">为什么ArrayList的elementData加上transient修饰？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArryList是线程不安全的？为什么？"><span class="toc-number">3.1.11.</span> <span class="toc-text">ArryList是线程不安全的？为什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">3.2.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList是什么？底层数据结构是什么？"><span class="toc-number">3.2.1.</span> <span class="toc-text">LinkedList是什么？底层数据结构是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList和ArrayList在尾部插入数据效率？"><span class="toc-number">3.3.</span> <span class="toc-text">LinkedList和ArrayList在尾部插入数据效率？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue有什么作用？"><span class="toc-number">3.3.1.</span> <span class="toc-text">Queue有什么作用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deque有什么作用？"><span class="toc-number">3.4.</span> <span class="toc-text">Deque有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList用什么保存元素？"><span class="toc-number">3.5.</span> <span class="toc-text">LinkedList用什么保存元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList如何实现插入？"><span class="toc-number">3.6.</span> <span class="toc-text">LinkedList如何实现插入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList和LinkedList"><span class="toc-number">3.7.</span> <span class="toc-text">ArrayList和LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList的遍历和LinkedList遍历性能⽐较如何？"><span class="toc-number">3.7.1.</span> <span class="toc-text">ArrayList的遍历和LinkedList遍历性能⽐较如何？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList与LinkedList的应用场景？"><span class="toc-number">3.7.2.</span> <span class="toc-text">ArrayList与LinkedList的应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList与LinkedList的区别？"><span class="toc-number">3.7.3.</span> <span class="toc-text">ArrayList与LinkedList的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入和删除是否受元素位置的影响？"><span class="toc-number">3.7.4.</span> <span class="toc-text">插入和删除是否受元素位置的影响？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-number">3.8.</span> <span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector是什么？底层数据结构是什么？"><span class="toc-number">3.8.1.</span> <span class="toc-text">Vector是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-和-Vector-的区别是什么？"><span class="toc-number">3.8.2.</span> <span class="toc-text">ArrayList 和 Vector 的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack"><span class="toc-number">3.9.</span> <span class="toc-text">Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Stack是什么？底层数据结构是什么？"><span class="toc-number">3.9.1.</span> <span class="toc-text">Stack是什么？底层数据结构是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历一个List有哪些不同的方式？"><span class="toc-number">3.10.</span> <span class="toc-text">遍历一个List有哪些不同的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程场景下如何使用-ArrayList？"><span class="toc-number">3.11.</span> <span class="toc-text">多线程场景下如何使用 ArrayList？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射集合类有哪些？"><span class="toc-number">4.</span> <span class="toc-text">映射集合类有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">4.1.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap用哪个类保存键值对？"><span class="toc-number">4.1.1.</span> <span class="toc-text">HashMap用哪个类保存键值对？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap的loadFactor和threshold两个字段有什么用？"><span class="toc-number">4.1.2.</span> <span class="toc-text">HashMap的loadFactor和threshold两个字段有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么元素个数达到threshold就进行扩容？"><span class="toc-number">4.1.3.</span> <span class="toc-text">为什么元素个数达到threshold就进行扩容？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认负载因子为什么是0-75？"><span class="toc-number">4.1.4.</span> <span class="toc-text">默认负载因子为什么是0.75？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap的最大容量是多少？"><span class="toc-number">4.1.5.</span> <span class="toc-text">HashMap的最大容量是多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap的底层数据结构是什么？"><span class="toc-number">4.1.6.</span> <span class="toc-text">HashMap的底层数据结构是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap在JDK1-8的构造方法具体内容是什么？"><span class="toc-number">4.1.7.</span> <span class="toc-text">HashMap在JDK1.8的构造方法具体内容是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Float-isNaN有什么作用？"><span class="toc-number">4.1.8.</span> <span class="toc-text">Float.isNaN有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tableSizeFor方法的作用是什么？"><span class="toc-number">4.1.9.</span> <span class="toc-text">tableSizeFor方法的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap中key的存储索引是怎么计算的？"><span class="toc-number">4.1.10.</span> <span class="toc-text">HashMap中key的存储索引是怎么计算的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap在JDK1-7和1-8中的hash函数如何实现的？"><span class="toc-number">4.1.11.</span> <span class="toc-text">HashMap在JDK1.7和1.8中的hash函数如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8为什么要hashcode异或其右移十六位的值"><span class="toc-number">4.1.12.</span> <span class="toc-text">JDK1.8为什么要hashcode异或其右移十六位的值?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap数组的长度为什么是2-的幂次方？"><span class="toc-number">4.1.13.</span> <span class="toc-text">HashMap数组的长度为什么是2 的幂次方？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么在两个版本都是hash值与length-1相与？"><span class="toc-number">4.1.14.</span> <span class="toc-text">为什么在两个版本都是hash值与length-1相与？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap在JDK7之前是如何实现的？"><span class="toc-number">4.1.15.</span> <span class="toc-text">HashMap在JDK7之前是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8中put中的冲突有哪两种情况？"><span class="toc-number">4.1.16.</span> <span class="toc-text">JDK1.8中put中的冲突有哪两种情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是哈希？"><span class="toc-number">4.1.17.</span> <span class="toc-text">什么是哈希？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是哈希冲突？"><span class="toc-number">4.1.18.</span> <span class="toc-text">什么是哈希冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap在JDK1-8如何实现？"><span class="toc-number">4.1.19.</span> <span class="toc-text">HashMap在JDK1.8如何实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap的put方法简要流程？"><span class="toc-number">4.1.20.</span> <span class="toc-text">HashMap的put方法简要流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize方法的作用是什么？"><span class="toc-number">4.1.21.</span> <span class="toc-text">resize方法的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩容在JDK1-8中有什么不一样？"><span class="toc-number">4.1.22.</span> <span class="toc-text">扩容在JDK1.8中有什么不一样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在JDK1-7的时候是先扩容后插入，JDK1-8先插入后扩容？"><span class="toc-number">4.1.23.</span> <span class="toc-text">在JDK1.7的时候是先扩容后插入，JDK1.8先插入后扩容？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap将旧数组复制到新数组的过程是怎样的？"><span class="toc-number">4.1.24.</span> <span class="toc-text">HashMap将旧数组复制到新数组的过程是怎样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap中如何通过键获取相应的值？"><span class="toc-number">4.1.25.</span> <span class="toc-text">HashMap中如何通过键获取相应的值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap中如何通过键删除相应的值？"><span class="toc-number">4.1.26.</span> <span class="toc-text">HashMap中如何通过键删除相应的值？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-为什么是红黑树不是平衡二叉树？"><span class="toc-number">4.2.</span> <span class="toc-text">HashMap 为什么是红黑树不是平衡二叉树？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EntrySet类的作用是什么？"><span class="toc-number">4.2.1.</span> <span class="toc-text">EntrySet类的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EntryIterator类的作用是什么？"><span class="toc-number">4.2.2.</span> <span class="toc-text">EntryIterator类的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap中元素的遍历顺序和元素的插入顺序有关系吗？"><span class="toc-number">4.2.3.</span> <span class="toc-text">HashMap中元素的遍历顺序和元素的插入顺序有关系吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap的重要属性是什么？"><span class="toc-number">4.2.4.</span> <span class="toc-text">HashMap的重要属性是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不直接用红黑树？而选择先用链表，再转红黑树？"><span class="toc-number">4.2.5.</span> <span class="toc-text">不直接用红黑树？而选择先用链表，再转红黑树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不用红黑树，用二叉查找树可以么？"><span class="toc-number">4.2.6.</span> <span class="toc-text">不用红黑树，用二叉查找树可以么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#当链表转为红黑树后，什么时候退化为链表？"><span class="toc-number">4.2.7.</span> <span class="toc-text">当链表转为红黑树后，什么时候退化为链表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么链表改为红黑树的阈值是8，而不是7或20？"><span class="toc-number">4.2.8.</span> <span class="toc-text">为什么链表改为红黑树的阈值是8，而不是7或20？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap中key的存储索引是怎么计算的？-1"><span class="toc-number">4.2.9.</span> <span class="toc-text">HashMap中key的存储索引是怎么计算的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8为什么要hashcode异或其右移十六位的值？"><span class="toc-number">4.2.10.</span> <span class="toc-text">JDK1.8为什么要hashcode异或其右移十六位的值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么-hash-值要与length-1相与？"><span class="toc-number">4.2.11.</span> <span class="toc-text">为什么 hash 值要与length-1相与？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#还知道哪些hash算法？"><span class="toc-number">4.2.12.</span> <span class="toc-text">还知道哪些hash算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key-可以为-Null-吗？"><span class="toc-number">4.2.13.</span> <span class="toc-text">key 可以为 Null 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一般用什么作为HashMap的key？"><span class="toc-number">4.2.14.</span> <span class="toc-text">一般用什么作为HashMap的key？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用可变类当HashMap-的key-有什么问题"><span class="toc-number">4.2.15.</span> <span class="toc-text">用可变类当HashMap 的key 有什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap扩容时候的死循环问题？"><span class="toc-number">4.2.16.</span> <span class="toc-text">HashMap扩容时候的死循环问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程的put可能导致元素的丢失？"><span class="toc-number">4.2.17.</span> <span class="toc-text">多线程的put可能导致元素的丢失？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put和get并发时，可能导致get为null？"><span class="toc-number">4.2.18.</span> <span class="toc-text">put和get并发时，可能导致get为null？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决HashMap-线程不安全的问题？"><span class="toc-number">4.3.</span> <span class="toc-text">如何解决HashMap 线程不安全的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">4.4.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Segment是什么？"><span class="toc-number">4.4.1.</span> <span class="toc-text">Segment是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashEntry是什么？"><span class="toc-number">4.4.2.</span> <span class="toc-text">HashEntry是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现原理？"><span class="toc-number">4.4.3.</span> <span class="toc-text">实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8-中为什么使用synchronized替换ReentrantLock？"><span class="toc-number">4.4.4.</span> <span class="toc-text">JDK1.8 中为什么使用synchronized替换ReentrantLock？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个版本put-方法执行逻辑是什么？"><span class="toc-number">4.4.5.</span> <span class="toc-text">两个版本put 方法执行逻辑是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两个版本get-方法的执行逻辑是什么？"><span class="toc-number">4.4.6.</span> <span class="toc-text">两个版本get 方法的执行逻辑是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-方法是否要加锁？"><span class="toc-number">4.4.7.</span> <span class="toc-text">get 方法是否要加锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-方法不需要加锁与volatile-修饰的哈希桶数组有关吗？"><span class="toc-number">4.4.8.</span> <span class="toc-text">get 方法不需要加锁与volatile 修饰的哈希桶数组有关吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-不支持key-或者value-为null？"><span class="toc-number">4.4.9.</span> <span class="toc-text">ConcurrentHashMap 不支持key 或者value 为null？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-的并发度是什么？"><span class="toc-number">4.4.10.</span> <span class="toc-text">ConcurrentHashMap 的并发度是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-迭代器是强一致性还是弱一致性？"><span class="toc-number">4.4.11.</span> <span class="toc-text">ConcurrentHashMap 迭代器是强一致性还是弱一致性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap能完全替代Hashtable吗？"><span class="toc-number">4.4.12.</span> <span class="toc-text">ConcurrentHashMap能完全替代Hashtable吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#size操作？"><span class="toc-number">4.4.13.</span> <span class="toc-text">size操作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程下安全的操作map还有其他方法吗？"><span class="toc-number">4.4.14.</span> <span class="toc-text">多线程下安全的操作map还有其他方法吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap是如何遍历键值对的？"><span class="toc-number">4.5.</span> <span class="toc-text">HashMap是如何遍历键值对的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">4.6.</span> <span class="toc-text">TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap的comparator属性有什么用？"><span class="toc-number">4.6.1.</span> <span class="toc-text">TreeMap的comparator属性有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap是用什么数据结构来描述键值对？"><span class="toc-number">4.6.2.</span> <span class="toc-text">TreeMap是用什么数据结构来描述键值对？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap的特点是什么？"><span class="toc-number">4.7.</span> <span class="toc-text">TreeMap的特点是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap是否可以指定元素的值进行排序？"><span class="toc-number">4.7.1.</span> <span class="toc-text">TreeMap是否可以指定元素的值进行排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap和TreeMap-如何选用？"><span class="toc-number">4.7.2.</span> <span class="toc-text">HashMap和TreeMap 如何选用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap的底层实现原理是什么？"><span class="toc-number">4.8.</span> <span class="toc-text">LinkedHashMap的底层实现原理是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap如何保存键值对？"><span class="toc-number">4.8.1.</span> <span class="toc-text">LinkedHashMap如何保存键值对？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap相较于父类HashMap重写了什么内容？"><span class="toc-number">4.8.2.</span> <span class="toc-text">LinkedHashMap相较于父类HashMap重写了什么内容？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？"><span class="toc-number">4.8.3.</span> <span class="toc-text">LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap是如何遍历元素的？"><span class="toc-number">4.8.4.</span> <span class="toc-text">LinkedHashMap是如何遍历元素的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap的属性accessOrder有什么作用？"><span class="toc-number">4.8.5.</span> <span class="toc-text">LinkedHashMap的属性accessOrder有什么作用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap如何重写afterNodeInsertion？"><span class="toc-number">4.9.</span> <span class="toc-text">LinkedHashMap如何重写afterNodeInsertion？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeEldestEntry的作用是什么？"><span class="toc-number">4.10.</span> <span class="toc-text">removeEldestEntry的作用是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">4.10.1.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何通过LinkedHashMap实现LRU？"><span class="toc-number">4.10.2.</span> <span class="toc-text">如何通过LinkedHashMap实现LRU？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakHashMap"><span class="toc-number">4.11.</span> <span class="toc-text">WeakHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashTable"><span class="toc-number">4.12.</span> <span class="toc-text">HashTable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashtable的底层实现原理？有什么特点？"><span class="toc-number">4.12.1.</span> <span class="toc-text">Hashtable的底层实现原理？有什么特点？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakHashMap-1"><span class="toc-number">4.13.</span> <span class="toc-text">WeakHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IdentifyHashMap"><span class="toc-number">4.14.</span> <span class="toc-text">IdentifyHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一般集合类有哪些？"><span class="toc-number">5.</span> <span class="toc-text">一般集合类有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet的底层实现原理？"><span class="toc-number">5.1.</span> <span class="toc-text">HashSet的底层实现原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet和HashMap的区别？"><span class="toc-number">5.1.1.</span> <span class="toc-text">HashSet和HashMap的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet的底层实现原理？"><span class="toc-number">5.2.</span> <span class="toc-text">TreeSet的底层实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet的底层实现原理？"><span class="toc-number">5.3.</span> <span class="toc-text">LinkedHashSet的底层实现原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何实现安全的Set集合？"><span class="toc-number">5.3.1.</span> <span class="toc-text">如何实现安全的Set集合？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#comparable-和-comparator的区别？"><span class="toc-number">5.4.</span> <span class="toc-text">comparable 和 comparator的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection-和Collections-有什么区别？"><span class="toc-number">5.4.1.</span> <span class="toc-text">Collection 和Collections 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap-和TreeSet-在排序时如何比较元素？"><span class="toc-number">5.4.2.</span> <span class="toc-text">TreeMap 和TreeSet 在排序时如何比较元素？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collections-工具类中的sort-方法如何比较元素？"><span class="toc-number">5.4.3.</span> <span class="toc-text">Collections 工具类中的sort() 方法如何比较元素？</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">85</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JAVA集合总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/02/16/JAVA集合总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nowcoder.com/discuss/593247" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/593247</a><br><a href="https://www.nowcoder.com/discuss/589336" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/589336</a><br><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">https://blog.csdn.net/qq_36520235/article/details/82417949</a><br><a href="https://thinkwon.blog.csdn.net/article/details/104588551" target="_blank" rel="noopener">https://thinkwon.blog.csdn.net/article/details/104588551</a><br><a href="https://blog.csdn.net/Hacker_ZhiDian/article/details/85270407" target="_blank" rel="noopener">https://blog.csdn.net/Hacker_ZhiDian/article/details/85270407</a></p>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="Java的集合"><a href="#Java的集合" class="headerlink" title="Java的集合"></a>Java的集合</h3><p>Java 的集合也称为容器，是用来存放数据的容器，集合存放的只能是引用数<br>据类型的数据，也就是对象（如果存入基本数据类型的数据，会自动装箱成<br>包装类）。集合的好处如下</p>
<ol>
<li>集合的长度是可变的</li>
<li>集合可以存放不同类型的对象</li>
<li>Java 为每个基本数据类型都提供了一个包装类，这样我们就可以像操作对<br>象那样来操作基本数据类型</li>
<li>集合为我们提供了多种数据结构和操作的API，选用合适的集合，能够提<br>程序性能和开发效率</li>
</ol>
<h3 id="List，Set，Map的区别"><a href="#List，Set，Map的区别" class="headerlink" title="List，Set，Map的区别"></a>List，Set，Map的区别</h3><ol>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可<br>以重复，可以插入多个null元素，元素都有索引</li>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元<br>素，只允许存入一个null元素，必须保证元素唯一性</li>
<li>Map：是一个键值对集合，存储键、值和之间的映射。Key无序唯一，value<br>不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索<br>元素时，只要给出键对象，就会返回对应的值对象</li>
</ol>
<h3 id="常用的集合类"><a href="#常用的集合类" class="headerlink" title="常用的集合类"></a>常用的集合类</h3><p>在Java 中除了以Map 结尾的类之外，其他类都实现了Collection 接口</p>
<ol>
<li>Collection接口的子接口包括 Set接口、List接口，提供了线性类型和<br>一般集合类型的集合的通用接口方法，比如add remove contain等方法</li>
</ol>
<ul>
<li>Set接口的实现类主要有 HashSet、TreeSet、LinkedHashSet等，没有新<br>增任何方法，集合有三个特性：无序、有限、无重复</li>
<li>List接口的实现类主要有 ArrayList、LinkedList、Stack以及Vector等<br>。新增排序方法sort(Comparator c)，并且增加了按照下标添加、修改和删<br>除元素的方法</li>
</ul>
<ol start="2">
<li>Map接口的实现类有 HashMap、TreeMap、Hashtable、LinkedHashMap、<br>ConcurrentHashMap。其提供了两种不同类型的数据对象进行相互关联的能<br>力，也就是键值对。Map 中通过Map.Entry 接口来描述这种类型的元素，<br>Entry 接口代表一个key-value对（键值对）形成的数据结构，即为映射<br>元素。这个接口中有获取键和值的方法，在 Map(HashMap)正是通过实现<br>了这个接口的类对象来储存键值对的信息。Map 中添加键值对和通过key<br>获取键值对的方法，还有一个entrySet 方法返回一个包含了所有键值<br>对对象的集合类型对象</li>
</ol>
<h3 id="Iterable接口是什么？"><a href="#Iterable接口是什么？" class="headerlink" title="Iterable接口是什么？"></a>Iterable接口是什么？</h3><p>Iterable 接口实际上是Java 集合中最顶级的接口，Collection接口直接继承<br>了这个接口。Map没有直接继承这个接口，但是可以通过Map的KeySet来遍历Map<br>。Iterable接口有一个产生迭代器Iterator 的方法，其作用就是提供了统一的<br>方法接口来方便我们遍历容器。对List接口，它是可以产生一个ListIterator<br>对象，而这个接口也是继承于Iterator接口，提供了向前访问和向后访问两种<br>方式</p>
<h3 id="Iterator是什么？有什么特点？"><a href="#Iterator是什么？有什么特点？" class="headerlink" title="Iterator是什么？有什么特点？"></a>Iterator是什么？有什么特点？</h3><p>Iterator是一个迭代器，迭代器是一种模式，它可以使得对于序列类型的数据<br>结构的遍历行为与被遍历的对象分离，作用是迭代器给我们提供了统一的接口<br>来遍历实现了迭代器接口的类的对象，实现了遍历集合方法的复用，减少我们<br>的代码量。<br>这个接口有三个方法。如果类本身也实现了Iterator 接口，那么iterator方<br>法可直接返回this，注意在使用foreach之后需要重置迭代器位置，也证明<br>了foreach确实是通过迭代器实现的</p>
<ol>
<li>next()：返回序列中的下一个元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lastRet是返回值的索引，一开始是-1</span></span><br><span class="line">checkForComodification();</span><br><span class="line">i=cursor;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=size)</span><br><span class="line">	<span class="keyword">throw</span> ..;</span><br><span class="line">...</span><br><span class="line">cursor=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> elementData[lastRet=i];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>hasNext()：检查序列中是否还有元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cursor是一个游标，初始值是0，表示第几次</span></span><br><span class="line"><span class="keyword">return</span> cursor!=size;</span><br></pre></td></tr></table></figure></li>
<li>使用remove()：将迭代器新返回的元素删除<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">           checkForComodification();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">               cursor = lastRet;</span><br><span class="line">               lastRet = -<span class="number">1</span>;</span><br><span class="line">               <span class="comment">//注意这里更新</span></span><br><span class="line">               expectedModCount = modCount;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//集合类自身也有删除方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       modCount++;</span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Iterator和foreach遍历集合的区别？"><a href="#Iterator和foreach遍历集合的区别？" class="headerlink" title="Iterator和foreach遍历集合的区别？"></a>Iterator和foreach遍历集合的区别？</h3><ol>
<li>Iterator 和 foreach 都可以遍历集合</li>
<li>foreach 不可以在遍历的过程中删除元素，不然会出现并发修改异常，<br>其实是基于快速失败机制</li>
<li>使用 Iterator遍历集合时，可以删除集合中的元素，这里的删除集合<br>是指可以用Iterator来删除集合元素而不是集合本身的删除方法</li>
</ol>
<h3 id="foreach的实现原理是什么？"><a href="#foreach的实现原理是什么？" class="headerlink" title="foreach的实现原理是什么？"></a>foreach的实现原理是什么？</h3><p>foreach的实现原理是编译器将遍历直接转换成了对集合iterator.next()<br>的调用（可以使用foreach进行遍历集合都实现了Iterable接口），所以如<br>果自定义类实现了Iterable接口并且实现了该接口中iterator()方法的具<br>体定义，则可以通过foreach语法来遍历自定义的类。区别如下</p>
<ol>
<li>foreach 不可以在遍历的过程中使用集合的删除方法删除元素，在获取<br>iterator时会将expectedModCount初始化为记录版本变量的modCount，<br>当通过iterator的remove方法删除时，本质也是通过调用集合的删除方法<br>，但是删除时候会更新expectedModCount，而直接使用集合的删除方法不<br>会更新expectedModCount，所以下一次删除或遍历时就会抛出异常</li>
<li>而迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个<br>modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount<br>的值。当迭代器使用 remove()/next() 遍历下一个元素之前，都会检测<br>modCount变量是否为expectedModCount值，是的话就返回遍历，否则抛<br>出异常，终止遍历。</li>
</ol>
<h3 id="Iterator和ListIterator有什么区别？"><a href="#Iterator和ListIterator有什么区别？" class="headerlink" title="Iterator和ListIterator有什么区别？"></a>Iterator和ListIterator有什么区别？</h3><ol>
<li>Iterator可以遍历Set和List集合，而ListIterator只能遍历List</li>
<li>Iterator只能单向遍历，而ListIterator可以双向遍历（向前/后遍历）</li>
<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，<br>比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置</li>
</ol>
<h3 id="什么是快速失败（fast-fail）机制？"><a href="#什么是快速失败（fast-fail）机制？" class="headerlink" title="什么是快速失败（fast-fail）机制？"></a>什么是快速失败（fast-fail）机制？</h3><p>快速失败是Java集合的一种错误检测机制，在多线程和单线程环境下都有可<br>能出现快速失败。</p>
<ol>
<li>使用迭代器遍历，在遍历过程中，刻意在某一步迭代中remove一个元素</li>
<li>当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast<br>。比如一个线程对集合进行迭代，另一个线程对集合进行删除元素的操作</li>
</ol>
<h3 id="如何防止快速失败？"><a href="#如何防止快速失败？" class="headerlink" title="如何防止快速失败？"></a>如何防止快速失败？</h3><ol>
<li>在单线程的遍历过程中，如果要进行remove操作，调用迭代器的remove<br>方法而不是集合类的remove方法</li>
<li>使用JUC 中的线程安全类来替代，比如使用 CopyOnWriteArrayList来<br>替代ArrayList，使用ConcurrentHashMap 来替代HashMap 。concurrent<br>包下的容器都是安全失败的，可以在多线程下并发使用和并发修改。安全失<br>败方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList等</li>
</ol>
<h3 id="什么是安全失败机制？"><a href="#什么是安全失败机制？" class="headerlink" title="什么是安全失败机制？"></a>什么是安全失败机制？</h3><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是<br>先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷<br>贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到<br>，所以不会触发ConcurrentModificationException</p>
<h3 id="什么情况下modCount会增加？"><a href="#什么情况下modCount会增加？" class="headerlink" title="什么情况下modCount会增加？"></a>什么情况下modCount会增加？</h3><p>add和remove方法修改数组会增加modCount，set方法不会增加modcount<br>，modCountb表示结构上面的修改，而不是简单的修改集合元素的内容</p>
<h3 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h3><ol>
<li>可以使 Collections.unmodifiableCollection(Collection c)方法<br>来创建一个只读集合，因为它不是将原本的比如list集合对象增加了限制不<br>能修改，而是将原本的集合的值copy了一份，定义为了一个新的集合这样改<br>变集合的任何操作都会抛出UnsupportedOperationException 异常</li>
<li>使用Arrays.asList创建的集合 通过Arrays.asList方法创建了一个集<br>合，但不是我们传统中使用的ArrayList集合，两者继承同一个父类，但是<br>内部却又不同的实现，Arrays.asList 创建的ArrayList中没有重写其父<br>类AbstractList的add、remove 方法，所以不持支新增和删除。如果强行<br>调用，虽然不会出现编译错误，调用的是父类的该方法，则会报出<br>UnsupportedOperationException异常</li>
</ol>
<h3 id="Arrays-asList-使用"><a href="#Arrays-asList-使用" class="headerlink" title="Arrays.asList()使用"></a>Arrays.asList()使用</h3><p>可以使用它将一个数组转换为一个List集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</span><br></pre></td></tr></table></figure>
<p>传递的数组必须是对象数组，而不是基本类型。因为Arrays.asList()是泛型<br>方法，传入的对象必须是对象数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span>[] array = (<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>Stream可以实现转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="Collection-toArray-方法使用"><a href="#Collection-toArray-方法使用" class="headerlink" title="Collection.toArray()方法使用"></a>Collection.toArray()方法使用</h3><p>该方法是一个泛型方法，如果toArray方法中没有传递任何参数的话返回的是<br>Object类型数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> String[]&#123;</span><br><span class="line">    <span class="string">"dog"</span>, <span class="string">"lazy"</span>, <span class="string">"a"</span>, <span class="string">"over"</span>, <span class="string">"jumps"</span>, <span class="string">"fox"</span>, <span class="string">"brown"</span>, <span class="string">"quick"</span>, <span class="string">"A"</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s=list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><ol>
<li>List</li>
</ol>
<ul>
<li>Arraylist：Object[]数组</li>
<li>Vector：Object[]数组</li>
<li>LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<ol start="2">
<li>Set</li>
</ol>
<ul>
<li>HashSet（无序，唯一）:基于HashMap 实现的，底层采用HashMap来保存元素</li>
<li>LinkedHashSet：LinkedHashSet 是HashSet 的子类，并且其内部是通过<br>LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部<br>是基于 HashMap 实现一样，不过还是有一点点区别的</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<ol start="3">
<li>Map</li>
</ol>
<h3 id="集合类别是什么？"><a href="#集合类别是什么？" class="headerlink" title="集合类别是什么？"></a>集合类别是什么？</h3><p>分为三类</p>
<ol>
<li>线性集合类</li>
<li>映射集合类</li>
<li>一般集合类</li>
</ol>
<h2 id="线性集合类有哪些？"><a href="#线性集合类有哪些？" class="headerlink" title="线性集合类有哪些？"></a>线性集合类有哪些？</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 内部通过数组保存元素，默认初始容量为10 ，之后以1.5倍进行扩<br>容。每次扩容时新建一个新的数组，然后将原数组中的元素复制到新数组中（直<br>接复制引用），之后将原数组中的元素清除，数组引用指向新的数组。插入元素<br>和删除元素时间复杂度都是O(n)，获取元素的时间复杂度为O(1)，ArrayList<br>是非线程安全的类</p>
<h4 id="ArrayList继承和实现的接口有哪些？"><a href="#ArrayList继承和实现的接口有哪些？" class="headerlink" title="ArrayList继承和实现的接口有哪些？"></a>ArrayList继承和实现的接口有哪些？</h4><p>ArrayList类继承于AbstractList抽象类，ArrayList类还实现Serializable<br>、RandomAccess、Cloneable 接口。其中 Serializable 接口是用于将对象序<br>列化以储存在文件中或者通过流的形式在网络中传输的接口，RandomAccess 接<br>口是一个没有声明任何方法的空接口，标识该类支持快速随机访问。cloneable<br>接口是一个对象复写Object类中clone()方法必须实现的接口</p>
<h4 id="ArrayList是什么？底层数据结构是什么？"><a href="#ArrayList是什么？底层数据结构是什么？" class="headerlink" title="ArrayList是什么？底层数据结构是什么？"></a>ArrayList是什么？底层数据结构是什么？</h4><p>ArrayList就是有序的动态数组列表，主要⽤来装载数据，它的主要底层实现是<br>数组Object[] elementData</p>
<h4 id="ArrayList的扩容机制是什么样的？"><a href="#ArrayList的扩容机制是什么样的？" class="headerlink" title="ArrayList的扩容机制是什么样的？"></a>ArrayList的扩容机制是什么样的？</h4><ol>
<li>JDK1.7 相当于设计模式中的饿汉式，第一次创建无参构造器时就创建一个<br>初始容量为10的数组，否则就根据参数创建指定长度的数组</li>
<li>JDK1.8 相当于设计模式中的懒汉式，ArrayList可以通过构造⽅法在初始<br>化的时候指定底层数组的⼤⼩。 通过⽆参构造⽅法的⽅式ArrayList()初始化<br>，则赋值底层数组 Object[] elementData 为⼀个默认的空数组 Object[]<br>所以数组容量为0，只有真正对数据进⾏添加add时，如果当前数组就是那个<br>默认空数组，才分配默认为10的初始容量</li>
<li>在扩容的时候，1.6是取余，1.7和1.8是位运算，右移⼀位，其实就是除以<br>2这个操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="ArrayList的add方法具体是如何实现的？"><a href="#ArrayList的add方法具体是如何实现的？" class="headerlink" title="ArrayList的add方法具体是如何实现的？"></a>ArrayList的add方法具体是如何实现的？</h4><ol>
<li>add方法思路：add添加一个元素时首先判断elementData 是不是默认的<br>空数组，如果是那么当前设定容量就赋值为初始容量10，否则直接使用当前<br>元素个数加1的值作为当前容量进入下一个判断方法。判断方法结束以后就<br>在数组末尾添加元素</li>
<li>判断方法：首先modeCount会1，表示列表元素结构进行了更改。然后比<br>较当前设定容量与数组长度的大小关系。如果已经大于数组长度那么就会调<br>用扩容方法grow</li>
<li>grow方法：首先获得一个原数组1.5倍长的长度设定为新长度，如果设定<br>容量小于这个1.5倍的新长度那么这个新长度就是数组扩容后的长度。否则数<br>组扩容后的长度就是一开始设定的长度。接下来还要判断这个新长度是否溢<br>出，与Integer.MAX_VALUE-8进行比较，如果大于就调用调整容量的方法</li>
<li>调整容量的方法：判断设定容量是否超过最大整数的限制，如果超过就<br>直接抛出异常表示没有判断获取型数组。如果没有超过限制则将设定容量赋<br>值为最大整数-8，如果已经大于最大整数-8则直接赋值为最大整数，获取<br>新长度后将原数组扩容为新数组，调用Arrays.copyOf方法将原数组的值<br>拷贝到新数组。这里使用设定容量进行判断而不是1.5倍的长度进行判断是<br>因为设定容量可能并没有超过限制</li>
</ol>
<h4 id="一句话概括ArrayList的扩容机制？"><a href="#一句话概括ArrayList的扩容机制？" class="headerlink" title="一句话概括ArrayList的扩容机制？"></a>一句话概括ArrayList的扩容机制？</h4><ol>
<li>先判断元素数组是否需要扩容</li>
<li>确定扩容后的容量（第一次将容量调整为默认容量(10)，之后以1.5倍<br>数进行扩容）</li>
<li>判断扩容后容量是否溢出</li>
<li>进行数组扩容并复制原数组元素到新数组中</li>
</ol>
<h4 id="ArrayList按照索引增加和减少是什么样的？"><a href="#ArrayList按照索引增加和减少是什么样的？" class="headerlink" title="ArrayList按照索引增加和减少是什么样的？"></a>ArrayList按照索引增加和减少是什么样的？</h4><p>ArrayList有指定index（索引下标）新增，也有尾部新增，但是都有校验长<br>度的判断过程，就是说如果⻓度不够，是需要扩容的</p>
<h4 id="ArrayList⽤来做队列合适么？"><a href="#ArrayList⽤来做队列合适么？" class="headerlink" title="ArrayList⽤来做队列合适么？"></a>ArrayList⽤来做队列合适么？</h4><p>ArrayList不适合做队列。队列⼀般是FIFO（先⼊先出）的，如果⽤ArrayList<br>做队列，就需要在数组尾部追加数据，数组头部删除数组，反过来也可以。但是<br>⽆论如何总会有⼀个操作会涉及到数组的数据搬迁，这个是⽐较耗费性能的</p>
<h4 id="ArrayList的优缺点有哪些？"><a href="#ArrayList的优缺点有哪些？" class="headerlink" title="ArrayList的优缺点有哪些？"></a>ArrayList的优缺点有哪些？</h4><p>ArrayList的优点如下</p>
<ul>
<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了<br>RandomAccess 接口，因此查找的时候非常快</li>
<li>ArrayList 在顺序添加一个元素的时候非常方便</li>
</ul>
<p>ArrayList的缺点如下</p>
<ul>
<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那<br>么就会比较耗费性能</li>
<li>插入元素的时候，也需要做一次元素复制操作，缺点同上</li>
</ul>
<h4 id="如何实现数组和List之间的转换？"><a href="#如何实现数组和List之间的转换？" class="headerlink" title="如何实现数组和List之间的转换？"></a>如何实现数组和List之间的转换？</h4><ol>
<li>数组转 List：使用 Arrays.asList(array) 进行转换</li>
<li>List 转数组：使用 List 自带的 toArray() 方法</li>
</ol>
<h4 id="为什么ArrayList的elementData加上transient修饰？"><a href="#为什么ArrayList的elementData加上transient修饰？" class="headerlink" title="为什么ArrayList的elementData加上transient修饰？"></a>为什么ArrayList的elementData加上transient修饰？</h4><p>ArrayList 实现了Serializable 接口，这意味着ArrayList支持序列化。<br>transient的作用是默认elementData数组不序列化，重写了writeObject<br>实现。每次序列化时先调用defaultWriteObject()方法序列化ArrayList<br>中的非transient 元素，然后遍历elementData，只序列化已存入的元素<br>，这样既加快了序列化的速度，又减小了序列化之后的文件大小</p>
<h4 id="ArryList是线程不安全的？为什么？"><a href="#ArryList是线程不安全的？为什么？" class="headerlink" title="ArryList是线程不安全的？为什么？"></a>ArryList是线程不安全的？为什么？</h4><p>ArrayList 是线程不安全的，因为ArrayList 里的方法没有加锁，也没有<br>使用其他保证线程安全的措施，当多个线程来对ArrayList 进行操作时，<br>就会出现并发修改异常</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 内部以双向链表的结构来保存元素，每一个元素都是一个双向链表<br>节点。每次来一个元素，就新建一个链表节点并将这个节点插入当前的双向链表<br>尾部，时间复杂度为 O(1)。删除元素的时候也是通过要删除元素的值来找到对<br>应的链表节点，之后将这个链表节点从双向链表中移除，寻找链表节点的时间<br>复杂度为O(n)，删除节点的时间复杂度为 O(1)，因此整个删除节点的时间复<br>杂度为O(n)。因为LinkedList 实现了Deque 接口，因此也可以将其作为队<br>列/双端队列使用。LinkedList 也是非线程安全的类</p>
<h4 id="LinkedList是什么？底层数据结构是什么？"><a href="#LinkedList是什么？底层数据结构是什么？" class="headerlink" title="LinkedList是什么？底层数据结构是什么？"></a>LinkedList是什么？底层数据结构是什么？</h4><p>底层使用的是双向链表数据结构，可以作为队列/双端队列使用。LinkedList<br>实现了List、Queue、Deque、Cloneable、Serializable接口</p>
<h3 id="LinkedList和ArrayList在尾部插入数据效率？"><a href="#LinkedList和ArrayList在尾部插入数据效率？" class="headerlink" title="LinkedList和ArrayList在尾部插入数据效率？"></a>LinkedList和ArrayList在尾部插入数据效率？</h3><ol>
<li>当输入的数据一直是小于千万级别的时候，大部分是Linked效率高，应该<br>是当出现ArrayList扩容的时候，会效率降低，所以ArrayList的效益比较低<br>。而当数据量大于千万级别的时候，就会出现ArrayList的效率比较高了</li>
<li>LinkedList每次增加的时候，会new 一个Node对象来存新增加的元素，<br>所以当数据量小的时候，这个时间并不明显，而ArrayList需要扩容，所以<br>LinkedList的效率就会比较高，其中如果ArrayList出现不需要扩容的时<br>候，那么ArrayList的效率应该是比LinkedList高的，当数据量很大的时<br>候，new对象的时间大于扩容的时间，那么就会出现ArrayList的效率比<br>Linkedlist高了</li>
</ol>
<h4 id="Queue有什么作用？"><a href="#Queue有什么作用？" class="headerlink" title="Queue有什么作用？"></a>Queue有什么作用？</h4><p>这个接口声明一个队列的相关操作</p>
<ol>
<li>add添加一个元素到队列尾部，offer添加一个元素到队列尾部</li>
<li>remove移除头部元素如果队列为空抛出异常，poll也是移除头部元素如果<br>队列为空返回null</li>
<li>element取出头部元素，如果队列为空抛出异常，peek也是取出头部元素<br>当队列为空时返回null</li>
</ol>
<h3 id="Deque有什么作用？"><a href="#Deque有什么作用？" class="headerlink" title="Deque有什么作用？"></a>Deque有什么作用？</h3><p>这个接口声明了双端队列的相关操作</p>
<ol>
<li>addFirst添加元素到双端队列的头部，addLast添加元素到双端队列的尾<br>部，以上两个如果有容量限制添加失败会抛出异常。offerFirst添加元素到<br>双端队列头部</li>
<li>offerLast添加元素到双端队列尾部，以上两个添加失败false</li>
<li>removeFirst removeLast </li>
<li>poolFirst pollLast </li>
<li>getFirst getLast</li>
<li>peekFirst peekLast</li>
</ol>
<h3 id="LinkedList用什么保存元素？"><a href="#LinkedList用什么保存元素？" class="headerlink" title="LinkedList用什么保存元素？"></a>LinkedList用什么保存元素？</h3><p>LinkedList有一个用来表示元素节点的类Node，有前驱和后继指针字段。<br>LinkedList没有扩容机制，添加元素时只需要插入链表尾即可。但是每个<br>节点除了保存元素值外还要保存前驱和后继指针，消耗额外的内存空间。<br>有一个first和last指针分别指向头结点和尾节点</p>
<h3 id="LinkedList如何实现插入？"><a href="#LinkedList如何实现插入？" class="headerlink" title="LinkedList如何实现插入？"></a>LinkedList如何实现插入？</h3><p>add方法默认是将元素插入到链表尾部。如果使用add(int index,E e)来<br>添加元素的话首先判断越界以及是否是直接插入在尾部，否则就会先找到<br>节点的位置，这里是调用node方法找到节点位置，思路是如果index不大<br>于链表长度的1/2就正向遍历，否则就反向遍历，这种设计能够最小化减<br>少循环的次数。注意索引是从0开始，找到这个节点后还要获取该节点的<br>前驱节点，注意插入的意思是新节点要插入到index这个位置，所以新<br>节点的后继节点就是找到的这个节点</p>
<h3 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h3><h4 id="ArrayList的遍历和LinkedList遍历性能⽐较如何？"><a href="#ArrayList的遍历和LinkedList遍历性能⽐较如何？" class="headerlink" title="ArrayList的遍历和LinkedList遍历性能⽐较如何？"></a>ArrayList的遍历和LinkedList遍历性能⽐较如何？</h4><p>ArrayList要比LinkedList快得多，ArrayList遍历最大的优势在于内存的<br>连续性，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内<br>存的性能开销</p>
<h4 id="ArrayList与LinkedList的应用场景？"><a href="#ArrayList与LinkedList的应用场景？" class="headerlink" title="ArrayList与LinkedList的应用场景？"></a>ArrayList与LinkedList的应用场景？</h4><p>在需要频繁读取集合中的元素时，更推荐使用ArrayList，而在插入和删除<br>操作较多时，更推荐使用 LinkedList。如果需要线程安全的就是可以使用<br>Vector，CopyOnWriteArrayList</p>
<h4 id="ArrayList与LinkedList的区别？"><a href="#ArrayList与LinkedList的区别？" class="headerlink" title="ArrayList与LinkedList的区别？"></a>ArrayList与LinkedList的区别？</h4><ol>
<li>数据结构实现 ArrayList 是动态数组的数据结构实现，而LinkedList<br>是双向链表的数据结构实现</li>
<li>随机访问效率 ArrayList比LinkedList在随机访问的时候效率要高，因为<br>LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找</li>
<li>增加和删除效率 在非首尾的增加和删除操作，LinkedList要比ArrayList<br>效率要高，因为ArrayList增删操作要影响数组内的其他数据的下标</li>
<li>内存空间占用LinkedList 比ArrayList 更占内存，因为LinkedList的<br>节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后<br>一个元素</li>
<li>线程安全 ArrayList和LinkedList都是不同步的，也就是不保证线程安全</li>
</ol>
<h4 id="插入和删除是否受元素位置的影响？"><a href="#插入和删除是否受元素位置的影响？" class="headerlink" title="插入和删除是否受元素位置的影响？"></a>插入和删除是否受元素位置的影响？</h4><ol>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置<br>的影响。 比如：执行add(E e)方法的时候，ArrayList 会默认在将指定的元<br>素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位<br>置i插入和删除元素的话（add(int index, E element)）时间复杂度就为<br>O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)<br>个元素都要执行向后位/向前移一位的操作</li>
<li>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位<br>置的影响，都是近似O(1)而数组为近似O(n)</li>
</ol>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector和ArrayList类似，内部都是采用数组来保存元素，而其与ArrayList最<br>大的区别在于Vecotr是线程安全的类。因此如果需要用线程安全的线性结构，可<br>以采用Vecotor</p>
<h4 id="Vector是什么？底层数据结构是什么？"><a href="#Vector是什么？底层数据结构是什么？" class="headerlink" title="Vector是什么？底层数据结构是什么？"></a>Vector是什么？底层数据结构是什么？</h4><p>Vecctor类和ArrayList继承的类和实现的接口都一样，也是有序的动态数据<br>列表，Vector可以指定每次扩容的增量，如果不指定默认每次扩容2倍。默认<br>无参构造器设定的数组长度是10。Vector类的所有方法都是同步的</p>
<h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><ol>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安<br>全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只<br>不过在Vector 扩容每次会增加1倍，而ArrayList 只会增加50%</li>
</ol>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>该类继承自Vector，因此也是线程安全的类，其提供了“栈”这种数据结构的一<br>些操作元素 API，入栈、出栈、取栈顶元素等</p>
<h4 id="Stack是什么？底层数据结构是什么？"><a href="#Stack是什么？底层数据结构是什么？" class="headerlink" title="Stack是什么？底层数据结构是什么？"></a>Stack是什么？底层数据结构是什么？</h4><p>Stack继承了Vector类，也是线程安全的，提供了栈的实现。<br>push pop peek都是线程安全的方法，push 本质是在链表尾部添加元素，pop<br>本质是在链表尾部移除元素，peek本质是在链表尾部取出元素</p>
<h3 id="遍历一个List有哪些不同的方式？"><a href="#遍历一个List有哪些不同的方式？" class="headerlink" title="遍历一个List有哪些不同的方式？"></a>遍历一个List有哪些不同的方式？</h3><ol>
<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每<br>一个位置的元素，当读取到最后一个元素后停止</li>
<li>迭代器遍历，Iterator。Iterator是面向对象的一个设计模式，目的是屏蔽<br>不同数据集合的特点，统一遍历集合的接口</li>
<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用<br>时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错，缺点是只<br>能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换</li>
</ol>
<h3 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h3><ol>
<li>Vector类替代</li>
<li>ArrayList不是线程安全的，如果遇到多线程场景，可以通过Collections<br>的synchronizedList 方法将其转换成线程安全的容器后再使用。核心就是<br>arrayList 的add() 的外面套了一层 synchronized 锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure></li>
<li>JUC中的CopyOnWriteArrayList（写时复制）是java.util.concurrent<br>包里的类，是个线程安全的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =<span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
CopyOnWriteArrayList 的思想是写时复制</li>
</ol>
<ul>
<li>写时复制：我们要向一个文件中添加新数据时，先将原来文件拷贝一份，<br>然后在这个拷贝文件上进行添加，而此时如果有别人读取数据，还是从原文<br>件读取，添加数据完成后，再用这个拷贝文件替换掉原来的文件。这样做的<br>好处是，读写分离，写的是拷贝文件，读的是原文件，可以支持多线程并<br>发读取，而不需要加锁。其中的 setArray方法中的array是用volatile<br>修饰的，可以保证可见性。其中add操作依然是要加锁的</li>
</ul>
<p>缺点如下<br>在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写<br>少的应用场景。不适合内存敏感以及对实时性要求很高的场景</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两<br>倍左右</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未<br>同步到读数组中。只能保证数据的最终一致性，不能保证数据的实时一致性。</li>
</ul>
<h2 id="映射集合类有哪些？"><a href="#映射集合类有哪些？" class="headerlink" title="映射集合类有哪些？"></a>映射集合类有哪些？</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap提供了一种高效的两种数据之间的映射能力。内部提供了一个table数<br>组，数组元素为自定义的实现了Map.Entry 接口的对象。Map.Entry就描述了<br>一个完整的键值对对象。通过键的hash 值来决定当前键值对元素所在的数组<br>下标。其默认的初始元素容量为 16，扩容因子默认为0.75，当容量达到当前<br>最大容量* 扩容因子的值时进行扩容。 每次扩容的时候容量翻倍。这样保证<br>每次进行键值对进行hash时可以通过位运算来代替取余操作（防止得到的数<br>组下标越界）提高效率。当出现 hash 值冲突的时候，先采用链地址法处理<br>（使用单链表将冲突的元素连接），当某个冲突链表的长度大于8 并且数组<br>长度大于等于64时，将其树化（转换为红黑树，加快查找速度）。HashMap<br> 是非线程安全的类</p>
<h4 id="HashMap用哪个类保存键值对？"><a href="#HashMap用哪个类保存键值对？" class="headerlink" title="HashMap用哪个类保存键值对？"></a>HashMap用哪个类保存键值对？</h4><p>在HashMap中通过一个名为Node的静态内部类来实现Map.Entry接口并实现接<br>口中的方法。Node类中有键的哈希值、key、value、next指针用于指向下一个<br>Node（用于处理冲突）</p>
<h4 id="HashMap的loadFactor和threshold两个字段有什么用？"><a href="#HashMap的loadFactor和threshold两个字段有什么用？" class="headerlink" title="HashMap的loadFactor和threshold两个字段有什么用？"></a>HashMap的loadFactor和threshold两个字段有什么用？</h4><ol>
<li>loadFactor 意为负载因子，这个值用于计算出下一次需要对HashMap进<br>行扩容时HashMap中包含的最大元素（即键值对）数</li>
<li>threshold 意为容纳键值对的最大值</li>
</ol>
<p>Node[] table的初始化长度length(默认值是16)，Load factor为负载因<br>子(默认值是0.75)，threshold 是 HashMap 所能容纳键值对的最大值。<br>threshold = length * Load factor。也就是说，在数组定义好长度之<br>后，负载因子越大，所能容纳的键值对个数越多。如果键值对的数量超出<br>threshold就会扩容</p>
<h4 id="为什么元素个数达到threshold就进行扩容？"><a href="#为什么元素个数达到threshold就进行扩容？" class="headerlink" title="为什么元素个数达到threshold就进行扩容？"></a>为什么元素个数达到threshold就进行扩容？</h4><p>这样做确实会浪费一部分内存，但是主要目的是为了减少元素冲突。当当前的<br>HashMap 容量越大的时候，给元素的 key 计算出来的 hashCode 的选择也<br>就越多，这样就越不容易产生冲突。而 HashMap 的任务其实主要是致力于保<br>证在尽可能低的时间复杂度O(1) 中插入和查询元素。所以从这个角度上来说<br>牺牲一点内存是值得的</p>
<h4 id="默认负载因子为什么是0-75？"><a href="#默认负载因子为什么是0-75？" class="headerlink" title="默认负载因子为什么是0.75？"></a>默认负载因子为什么是0.75？</h4><p>0.75是对空间和时间效率的一个平衡选择</p>
<ul>
<li>如果内存空间很多而又对时间效率要求高，可以降低负载因子Loadfactor<br>的值</li>
<li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子<br>loadFactor的值，这个值可以大于1</li>
</ul>
<p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较<br>高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包<br>括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，<br>并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，<br>rehash操作将不会发生</p>
<h4 id="HashMap的最大容量是多少？"><a href="#HashMap的最大容量是多少？" class="headerlink" title="HashMap的最大容量是多少？"></a>HashMap的最大容量是多少？</h4><p>最大容量MAXIMUM_CAPACITY是1073741824，2*MAXIMUM_CAPACITY-1就是<br>最大整数，最大容量也就是最大整数+1的一半</p>
<h4 id="HashMap的底层数据结构是什么？"><a href="#HashMap的底层数据结构是什么？" class="headerlink" title="HashMap的底层数据结构是什么？"></a>HashMap的底层数据结构是什么？</h4><ol>
<li>jdk7及jdk7之前，底层是用数组+链表 来实现的</li>
<li>jdk8及jdk8之后，底层是用数组+链表+红黑树来实现的，HashMap是通过<br>一个Node类型的数组table保存所有键值对，数组长度必须是2的幂次方。有<br>一个Set类型的集合entrySet保存所有键值对</li>
</ol>
<h4 id="HashMap在JDK1-8的构造方法具体内容是什么？"><a href="#HashMap在JDK1-8的构造方法具体内容是什么？" class="headerlink" title="HashMap在JDK1.8的构造方法具体内容是什么？"></a>HashMap在JDK1.8的构造方法具体内容是什么？</h4><ol>
<li>自定义初始容量和负载因子，如果初始容量大于最大容量那么就设置为最<br>大容量，负载因子不能小于0 或者是一个非数，注意0.0/0.0 不会抛异常但<br>是每次的结果不同，然后就会通过tableSizeFor方法得到下一次要进行扩容<br>时 HashMap对象包含的元素数目，赋值给threshold</li>
<li>自定义初始化容量，默认负载因子是0.75</li>
<li>无参构造函数 默认容量是16，默认负载因子0.75</li>
<li>参数是一个Map对象 默认负载因子是0.75，并且把该对象的所有所有键<br>值对通过putMapEntries方法传入</li>
</ol>
<h4 id="Float-isNaN有什么作用？"><a href="#Float-isNaN有什么作用？" class="headerlink" title="Float.isNaN有什么作用？"></a>Float.isNaN有什么作用？</h4><p>为了判断出一个值是否为 “非数字” 值，“非数字”值指的是类似于0.0/0.0<br>得到的值。在Java 中，小数除以 0 不会抛出 ArithmeticException异常<br>，但是每次0.0 / 0.0 得到的结果都是不同的值（对象）</p>
<h4 id="tableSizeFor方法的作用是什么？"><a href="#tableSizeFor方法的作用是什么？" class="headerlink" title="tableSizeFor方法的作用是什么？"></a>tableSizeFor方法的作用是什么？</h4><p>tableSizeFor方法中对当前cap指定的容量进行操作，返回第一个大于等于<br>cap的2的次幂值，具体实现就是把n的二进制数中最左边的那一位1之后的0<br>全变为1，如果n是正常的再加上1，那么一定就是2的次幂。一开始赋值时n<br>要减1是因为防止本来就是一个2的次幂再扩大两倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = cap - <span class="number">1</span> = <span class="number">5</span></span><br><span class="line"><span class="comment">//n 的二进制：000..00(29个0) 101，之后省略前导零</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span> = (<span class="number">101</span>) | (<span class="number">010</span>) = <span class="number">111</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span> = (<span class="number">111</span>) | (<span class="number">001</span>) = <span class="number">111</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span> = (<span class="number">0</span>) | (<span class="number">111</span>) = <span class="number">111</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span> = (<span class="number">0</span>) | (<span class="number">111</span>) = <span class="number">111</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span> = (<span class="number">0</span>) | (<span class="number">111</span>) = <span class="number">111</span></span><br></pre></td></tr></table></figure>

<h4 id="HashMap中key的存储索引是怎么计算的？"><a href="#HashMap中key的存储索引是怎么计算的？" class="headerlink" title="HashMap中key的存储索引是怎么计算的？"></a>HashMap中key的存储索引是怎么计算的？</h4><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值<br>，最后通过hash&amp;(length-1)计算得到存储的位置</p>
<h4 id="HashMap在JDK1-7和1-8中的hash函数如何实现的？"><a href="#HashMap在JDK1-7和1-8中的hash函数如何实现的？" class="headerlink" title="HashMap在JDK1.7和1.8中的hash函数如何实现的？"></a>HashMap在JDK1.7和1.8中的hash函数如何实现的？</h4><p>首先取key的hashCode值、根据hashcode计算出hash值。JDK1.7和1.8的<br>不同之处在于根据hashcode计算出hash值</p>
<ol>
<li>JDK1.7 扰动9次，先是右移20位和右移12位异或取得的值又右移7位<br>与右移4位异或，为了让每一位都参与位运算，让相近的数最后通过hash<br>能分散开并减少碰撞，采用多次位移和异或，多一次与key的hashCode<br>异或，也是为了尽量减少碰撞</li>
<li>JDK1.8 hashCode值与其右移16位的值进行异或操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="number">0</span> : (h = key.hashCode()) ^ h &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="JDK1-8为什么要hashcode异或其右移十六位的值"><a href="#JDK1-8为什么要hashcode异或其右移十六位的值" class="headerlink" title="JDK1.8为什么要hashcode异或其右移十六位的值?"></a>JDK1.8为什么要hashcode异或其右移十六位的值?</h4><ol>
<li>因为在JDK1.7 中扰动用了9次扰动处理=4次位运算+5次异或，计算<br>hash 值的性能会稍差一点点</li>
<li>从速度、功效、质量来考虑，JDK1.8 优化了高位运算的算法，只用了2<br>次扰动处理=1次位运算+1次异或。通过hashCode()的高16位异或低16位，<br>这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit<br>都参与到Hash的计算，同时不会有太大的开销</li>
</ol>
<h4 id="HashMap数组的长度为什么是2-的幂次方？"><a href="#HashMap数组的长度为什么是2-的幂次方？" class="headerlink" title="HashMap数组的长度为什么是2 的幂次方？"></a>HashMap数组的长度为什么是2 的幂次方？</h4><p>这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外<br>，2的N次幂有助于减少碰撞的几率。如果length为2的幂次方，则length<br>-1转化为二进制必定是11111……的形式，在与h的二进制与操作效率会非<br>常的快，而且空间不浪费，每一个位置都有可能存放数据</p>
<h4 id="为什么在两个版本都是hash值与length-1相与？"><a href="#为什么在两个版本都是hash值与length-1相与？" class="headerlink" title="为什么在两个版本都是hash值与length-1相与？"></a>为什么在两个版本都是hash值与length-1相与？</h4><ol>
<li>把hash值对数组长度取模运算，模运算的消耗很大，没有位运算快</li>
<li>HashMap 的数组长度必须是2的次幂，所以其容量n转换成二进制中必<br>然只有一位是1，那么n-1，就是将最左边的那一位1变为0，并且将其右边<br>的0变成1，再将得到的值和hash通过&amp;按位相与，这样的话得到的结果必<br>然不会大于n-1。位操作速度一般的操作符快</li>
</ol>
<h4 id="HashMap在JDK7之前是如何实现的？"><a href="#HashMap在JDK7之前是如何实现的？" class="headerlink" title="HashMap在JDK7之前是如何实现的？"></a>HashMap在JDK7之前是如何实现的？</h4><ol>
<li>jdk7及jdk7之前，底层是用 数组+链表 来实现的</li>
<li>new HashMap()之后，底层不会直接创建数组，而是第一次put才创建</li>
<li>put 数据时(put(key,value))，如果是第一次put 会创建一个长度为<br>16的数组(Entry[] table)，会先调用key 所在类的hashCode 方法计算<br>出此 key 的哈希值，再将此哈希值经过处理计算后，得到该数据在数组<br>table上的位置</li>
<li>然后分情况判断是否存储</li>
</ol>
<ul>
<li>情况一 位置为空，直接在该位置上存储put的数据</li>
<li>情况二 位置不为空，说明存在一条链表，如果要put数据的key的哈希值<br>与链表上的数据的key的哈希值不一样，则将数据放在此位置上，也就是链<br>表头部</li>
<li>情况三 位置不为空，如果要put数据的key的哈希值与链表上的数据的key<br>的哈希值一样，继续调用key的equals方法进行比较，如果一样那么覆盖这<br>个值，否则插入链表头部</li>
</ul>
<ol start="5">
<li>当存储的数据超出临界值，且要存放数据的位置非空时，则扩容，扩容为<br>原来容量的2倍。 临界值 = 当前容量 x 填充因子</li>
</ol>
<h4 id="JDK1-8中put中的冲突有哪两种情况？"><a href="#JDK1-8中put中的冲突有哪两种情况？" class="headerlink" title="JDK1.8中put中的冲突有哪两种情况？"></a>JDK1.8中put中的冲突有哪两种情况？</h4><p>这里的冲突是指两个键值对元素的 “键” 的 hashCode 相同</p>
<ol>
<li>要插入的键值对的 “键” 和冲突的键值对的 “键” 等价（两个引用指向<br>一个对象或者两个引用指向的对象的 equals 方法返回 true）。此时记录<br>这个键值对，到后面更新一下它的值即可</li>
<li>要插入的键值对的 “键” 和冲突的键值对的 “键” 不等价（两个引用指<br>向的对象的 equals 方法返回 false）。这种情况下就需要进行特殊处理<br>（链化或者树化节点）</li>
</ol>
<h4 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h4><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的<br>输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）<br>，这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间<br>，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定<br>输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘<br>要的函数</p>
<h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们<br>就把它叫做碰撞（哈希碰撞）</p>
<h4 id="HashMap在JDK1-8如何实现？"><a href="#HashMap在JDK1-8如何实现？" class="headerlink" title="HashMap在JDK1.8如何实现？"></a>HashMap在JDK1.8如何实现？</h4><ol>
<li>new HashMap() 之后，底层并不会直接创建数组。而是等put 数据时才<br>会创建数组</li>
<li>put 数据时，如果是第一次向这个集合中put 数据，如果是的话就通过<br>resize 方法申请空间并调整table的容量，会先创建一个长度为16的一维<br>数组(Node[] table)，然后存储数据</li>
<li>存储数据的过程和jdk7 及之前基本一样，即先计算哈希值，然后根据，<br>最后通过hash&amp;(length-1) 计算得到存储的位置</li>
<li>找到位置后分为四种情况判断</li>
</ol>
<ul>
<li>情况一 位置为空，直接在该位置上存储put的数据</li>
<li>情况二 位置不为空，如果要put数据的key的哈希值与位置上的数据的key<br>的哈希值一样并且继续调用key的equals方法进行比较也一样，那么先记录<br>冲突的元素到后面更新。既然是更新那么modCount不会改变</li>
<li>情况二 位置不为空，并且哈希值不一样，那么判断节点是否是TreeNode<br>类型，如果是的话说明这条链表已经被树化，那么直接将这个节点插入到<br>红黑树中，返回一个TreeNode对象。如果为null 说明这是更新操作那么<br>不会更新modCount</li>
<li>情况三 位置不为空，并且与该位置的key不等价，那么判断该节点是链表<br>类型的节点，那么遍历链表如果存在等价的key则记录这个链表位置</li>
<li>情况四 位置不为空，并且与该位置的key不等价，那么遍历完整个链表都<br>没有等价的key，这时把节点插入到链表尾部。然后判断链表长度是否大于8<br>以及数组长度是否大于等于64，如果满足这两个条件就将链表树化，否则<br>就扩容数组</li>
</ul>
<ol start="5">
<li>之前如果判断是更新操作那么不会更改modCount，而是直接return 旧<br>的值，如果不是更新操作那么modCount+1，如果插入一个键值对后大于阈<br>值，那么会调用resize方法重新分配数组的长度</li>
</ol>
<h4 id="HashMap的put方法简要流程？"><a href="#HashMap的put方法简要流程？" class="headerlink" title="HashMap的put方法简要流程？"></a>HashMap的put方法简要流程？</h4><p>简要流程如下：</p>
<ol>
<li>首先根据key的值计算hash值，找到该元素在数组中存储的下标</li>
<li>如果数组是空的，则调用resize 进行初始化</li>
<li>如果没有哈希冲突直接放在对应的数组下标里</li>
<li>如果冲突了，且key 已经存在，就覆盖掉value</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上</li>
<li>如果冲突后是链表，判断该链表是否大于8 ，如果大于8并且数组容量小于64<br>，就进行扩容</li>
<li>如果链表长度大于8并且数组的容量大于等于64，则将这个结构转换为红黑树</li>
<li>否则，链表插入键值对，若 key 存在，就覆盖掉 value</li>
</ol>
<h4 id="resize方法的作用是什么？"><a href="#resize方法的作用是什么？" class="headerlink" title="resize方法的作用是什么？"></a>resize方法的作用是什么？</h4><p>这个方法是真正给HashMap扩容的方法</p>
<ol>
<li>首先判断数组长度是否大于0，如果大于0分为两种情况。第一种情况就是<br>数组长度已经大于HashMap 指定的最大容量，那么这个时候数组的长度就不<br>能再增大了，但是阈值threshold 变为最大整数。第二种情况就是如果当前<br>HashMap 容量不小于默认容量16并且其*2 小于允许的最大容量，那么将<br>HashMap长度变成原来的两倍，并且容量分配阀值*2</li>
<li>如果当前HashMap的容量为0，并且容量分配阀值大于0。之前解析构造方<br>法时已经说明了，当调用传入指定初始容量的构造方法时，数组依然没有扩<br>容，所以长度为0，但是阈值threshold设置为大于等于初始容量的2的次幂<br>，所以这时数组的长度就扩容为阈值的大小</li>
<li>HashMap的长度和容量分配阀值都为0。说明这个时候调用的是默认的无参<br>构造器，那么HashMap的容量就设置为16，阈值就是12</li>
<li>如果新分配的阈值newThr为0，说明调用了有初始容量和指定负载因子的<br>构造器或有初始容量的构造器，这两个构造器刚刚只把初始容量设置为阈值<br>大小，没有设置新阈值的大小，通过刚刚的代码可以看到只设置了newCap<br>还没有设置newThr。直接使用loadFactor字段计算出新的容量分配阈值</li>
<li>到此HashMap的新长度和阈值都已经获取，接下来为table申请内存空间</li>
</ol>
<h4 id="扩容在JDK1-8中有什么不一样？"><a href="#扩容在JDK1-8中有什么不一样？" class="headerlink" title="扩容在JDK1.8中有什么不一样？"></a>扩容在JDK1.8中有什么不一样？</h4><p>有两处优化</p>
<ol>
<li>resize 之后，元素的位置在原来的位置，或者原来的位置+oldCap（原<br>来哈希表的长度）。不需要像 JDK1.7 的实现那样重新计算hash ，只需要<br>看看原来的 hash 值新增参与运算的那个bit是1还是0就好了，是0的话索<br>引没变，是1的话索引变成“原索引 + oldCap ”。这个设计非常的巧妙，<br>省去了重新计算 hash 值的时间</li>
<li>JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的<br>数组索引位置相同，则链表元素会倒置（头插法），容易出现逆序且环形链<br>表死循环问题。JDK1.8 不会倒置，使用尾插法</li>
</ol>
<h4 id="在JDK1-7的时候是先扩容后插入，JDK1-8先插入后扩容？"><a href="#在JDK1-7的时候是先扩容后插入，JDK1-8先插入后扩容？" class="headerlink" title="在JDK1.7的时候是先扩容后插入，JDK1.8先插入后扩容？"></a>在JDK1.7的时候是先扩容后插入，JDK1.8先插入后扩容？</h4><ol>
<li>JDK1.7 先进行扩容后进行插入的，当前数据存储的数量大小必须大于<br>等于阈值以及当前加入的数据是否发生了hash冲突这两个条件都满足那么<br>就会扩容，但是如果不发生Hash冲突的话，说明当前桶是空的（后面并没<br>有挂有链表），那就等到下一次发生Hash冲突的时候在进行扩容。但是当<br>如果以后都没有发生hash冲突产生，那么就不会进行扩容了，减少了一<br>次无用扩容，也减少了内存的使用</li>
<li>JDK1.8 先插入后进行扩容，当最新的数据存储的数量大于阈值的时候<br>就会扩容</li>
</ol>
<h4 id="HashMap将旧数组复制到新数组的过程是怎样的？"><a href="#HashMap将旧数组复制到新数组的过程是怎样的？" class="headerlink" title="HashMap将旧数组复制到新数组的过程是怎样的？"></a>HashMap将旧数组复制到新数组的过程是怎样的？</h4><p>如果旧数组不为null的话还要把之前数组的元素复制到新数组，复制过程如下</p>
<ol>
<li>如果原数组元素引用不为null，并且这个元素没有next节点，证明没有<br>元素和它产生冲突，那么直接复制到新数组，注意这个索引位置有变化，<br>用新长度-1与hash值进行按位与操作。注意如果是TreeNode类型的节点<br>也有next，因为TreeNode继承了Node类</li>
<li>如果有冲突，并且节点类型是TreeNode类型，会调用split方法，处理<br>树中元素的重排</li>
<li>如果有冲突，并且节点类型是链表节点类型，元素的位置在原来的位置，<br>或者原来的位置+oldCap ，如果有些节点还在相同的位置那么这条链表的相<br>对顺序也不会改变</li>
</ol>
<h4 id="HashMap中如何通过键获取相应的值？"><a href="#HashMap中如何通过键获取相应的值？" class="headerlink" title="HashMap中如何通过键获取相应的值？"></a>HashMap中如何通过键获取相应的值？</h4><ol>
<li>首先判断数组table是否为null，如果为null说明根本没有这个键值对，<br>直接返回null</li>
<li>如果数组table不为null，key的hash值与length-1向与的结果得到索<br>引，如果数组中相应索引位置第一个键值对与要查询的键等价那么直接返回<br>第一个键值对</li>
<li>如果不等价的话，根据这个节点是树类型节点还是链表类型节点在相应<br>数据结构中查找等价的键</li>
</ol>
<h4 id="HashMap中如何通过键删除相应的值？"><a href="#HashMap中如何通过键删除相应的值？" class="headerlink" title="HashMap中如何通过键删除相应的值？"></a>HashMap中如何通过键删除相应的值？</h4><p>remove方法中通过参数key删除相应键值对，本质是调用removeNode方法</p>
<ol>
<li>首先判断数组table是否为null，如果为null说明根本没有这个键值对，<br>直接返回null</li>
<li>如果数组table不为null，那么就要根据索引位置取得要删除的节点</li>
<li>如果要删除的是树类型节点，那么直接从红黑树中移除</li>
<li>如果要删除的是链表类型节点，如果删除的是头结点那么直接将数组下<br>标赋给下一个节点，如果不是头结点那么删除时注意上一个节点的next要改</li>
</ol>
<h3 id="HashMap-为什么是红黑树不是平衡二叉树？"><a href="#HashMap-为什么是红黑树不是平衡二叉树？" class="headerlink" title="HashMap 为什么是红黑树不是平衡二叉树？"></a>HashMap 为什么是红黑树不是平衡二叉树？</h3><ol>
<li>在CurrentHashMap中是加锁了的，实际上是读写锁，如果写冲突就会等待<br>，如果插入时间过长必然等待时间更长，而红黑树相对AVL树他的插入更快</li>
<li>插入和删除方面，AVL树速度较慢，需要更高的旋转次数才能在修改时正确<br>地重新平衡数据结构</li>
<li>AVL树比红黑树保持更加严格的平衡，在AVL树中查找通常更快，但这是以<br>更多旋转操作导致更慢的插入和删除为代价的</li>
</ol>
<h4 id="EntrySet类的作用是什么？"><a href="#EntrySet类的作用是什么？" class="headerlink" title="EntrySet类的作用是什么？"></a>EntrySet类的作用是什么？</h4><p>EntrySet 类是 HashMap 的一个内部类，而 HashMap 的 entrySet方<br>法中返回的也是一个 EntrySet 对象，也就是说我们通过 entrySet方<br>法得到的其实是一个 EntrySet 对象，我们对 Set 进行遍历时是通过<br>其提供的迭代器进行的，能够返回一个EntryIterator迭代器</p>
<h4 id="EntryIterator类的作用是什么？"><a href="#EntryIterator类的作用是什么？" class="headerlink" title="EntryIterator类的作用是什么？"></a>EntryIterator类的作用是什么？</h4><p>EntryIterator就是一个实现了Itreator接口的迭代器，通过next方法<br>遍历HashMap中所有的元素。在构造方法中初始化next引用为table数组<br>中第一个不为null的元素，然后开始按照数组的顺序遍历。如果当前位<br>置有一个链表，那么会从头节点到尾节点的顺序遍历。我通过阅读源码<br>发现如果是一个红黑树的话，链表树化的过程中next节点没有变化</p>
<h4 id="HashMap中元素的遍历顺序和元素的插入顺序有关系吗？"><a href="#HashMap中元素的遍历顺序和元素的插入顺序有关系吗？" class="headerlink" title="HashMap中元素的遍历顺序和元素的插入顺序有关系吗？"></a>HashMap中元素的遍历顺序和元素的插入顺序有关系吗？</h4><p>没有任何关系，因为插入元素时主要依据的是元素的键的 hashCode 值，而<br>每个元素的键的 hashCode 没有什么规则（根据键所属的类的实现而定），<br>所以我们并不能试图按照插入元素的顺序来取出元素。如果需要使得取出的<br>元素顺序是按照插入元素的先后顺序排序的话，使用LinkedHashMap</p>
<h4 id="HashMap的重要属性是什么？"><a href="#HashMap的重要属性是什么？" class="headerlink" title="HashMap的重要属性是什么？"></a>HashMap的重要属性是什么？</h4><ol>
<li>容量（默认为 16，如果自定义初始容量，那么会处理成最小的不小于指<br>定的容量的2 的次幂数，注意HashMap 的长度一定会是2的次幂数）</li>
<li>扩容机制（每次扩容变成上一次容量的 2 倍，如果当前元素数目达到扩<br>容阀值（负载因子 * 当前 HashMap 总容量），进行扩容）</li>
<li>负载因子（默认 0.75 ）</li>
<li>最大容量(Integer.MAX_VALUE - 8)，可以指定的最小容量(1(2^0))</li>
</ol>
<h4 id="不直接用红黑树？而选择先用链表，再转红黑树？"><a href="#不直接用红黑树？而选择先用链表，再转红黑树？" class="headerlink" title="不直接用红黑树？而选择先用链表，再转红黑树？"></a>不直接用红黑树？而选择先用链表，再转红黑树？</h4><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。<br>当元素小于8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当<br>元素大于8 个的时候，红黑树搜索时间复杂度是O(logn)，而链表是O(n)，<br>此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。因此，如果<br>一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性<br>能的</p>
<h4 id="不用红黑树，用二叉查找树可以么？"><a href="#不用红黑树，用二叉查找树可以么？" class="headerlink" title="不用红黑树，用二叉查找树可以么？"></a>不用红黑树，用二叉查找树可以么？</h4><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链<br>表结构一样了，造成很深的问题），遍历查找会非常慢</p>
<h4 id="当链表转为红黑树后，什么时候退化为链表？"><a href="#当链表转为红黑树后，什么时候退化为链表？" class="headerlink" title="当链表转为红黑树后，什么时候退化为链表？"></a>当链表转为红黑树后，什么时候退化为链表？</h4><p>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设<br>一下，如果设计成链表个数达到8则链表转换成树结构，链表个数小于8则树结<br>构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘<br>徊，就会频繁的发生树转链表、链表转树，效率会很低</p>
<h4 id="为什么链表改为红黑树的阈值是8，而不是7或20？"><a href="#为什么链表改为红黑树的阈值是8，而不是7或20？" class="headerlink" title="为什么链表改为红黑树的阈值是8，而不是7或20？"></a>为什么链表改为红黑树的阈值是8，而不是7或20？</h4><ol>
<li>由于treenodes的大小大约是常规节点的两倍，因此我们仅在容器包含<br>足够的节点以保证使用时才使用它们，当它们变得太小（由于移除或调整<br>大小）时，它们会被转换回普通的node节点，容器中节点分布在hash 桶<br>中的频率遵循泊松分布，桶的长度超过8的概率非常非常小。所以作者应<br>该是根据概率统计而选择了8作为阀值</li>
</ol>
<h4 id="HashMap中key的存储索引是怎么计算的？-1"><a href="#HashMap中key的存储索引是怎么计算的？-1" class="headerlink" title="HashMap中key的存储索引是怎么计算的？"></a>HashMap中key的存储索引是怎么计算的？</h4><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后<br>通过hash&amp;（length-1）计算得到存储的位置。这里的 Hash 算法本质上就是三<br>步：取key的 hashCode值、根据 hashcode 计算出hash值、通过取模计算下标</p>
<h4 id="JDK1-8为什么要hashcode异或其右移十六位的值？"><a href="#JDK1-8为什么要hashcode异或其右移十六位的值？" class="headerlink" title="JDK1.8为什么要hashcode异或其右移十六位的值？"></a>JDK1.8为什么要hashcode异或其右移十六位的值？</h4><p>因为在JDK 1.7 中扰动了4次，计算 hash 值的性能会稍差一点点。 从速度、功效<br>、质量来考虑，JDK1.8 优化了高位运算的算法，通过hashCode()的高16位异或低<br>16位实现：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)。这么做可以在数组 table 的<br>length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不<br>会有太大的开销</p>
<h4 id="为什么-hash-值要与length-1相与？"><a href="#为什么-hash-值要与length-1相与？" class="headerlink" title="为什么 hash 值要与length-1相与？"></a>为什么 hash 值要与length-1相与？</h4><p>把hash值对数组长度取模运算，模运算的消耗很大，没有位运算快。当length总是<br>2的n次方时，h&amp; (length-1) 运算等价于对length取模，也就是 h%length，但<br>是&amp;比%具有更高的效率</p>
<h4 id="还知道哪些hash算法？"><a href="#还知道哪些hash算法？" class="headerlink" title="还知道哪些hash算法？"></a>还知道哪些hash算法？</h4><p>Hash函数是指把一个大范围映射到一个小范围，目的往往是为了节省空间，使得<br>数据容易保存。 比较出名的有MurmurHash、MD4、MD5等等</p>
<h4 id="key-可以为-Null-吗？"><a href="#key-可以为-Null-吗？" class="headerlink" title="key 可以为 Null 吗？"></a>key 可以为 Null 吗？</h4><p>可以，key 为 Null 的时候，hash算法最后的值以0来计算，也就是放在数组<br>的第一个位置</p>
<h4 id="一般用什么作为HashMap的key？"><a href="#一般用什么作为HashMap的key？" class="headerlink" title="一般用什么作为HashMap的key？"></a>一般用什么作为HashMap的key？</h4><p>一般用Integer、String 这种不可变类当HashMap 当key，而且String<br>最为常用。因为字符串是不可变的，所以在它创建的时候hashcode 就被<br>缓存了，不需要重新计算。这就是HashMap 中的键往往都使用字符串的<br>原因。因为获取对象的时候要用到equals() 和hashCode() 方法，那<br>么键对象正确的重写这两个方法是非常重要的，这些类已经很规范的<br>重写了hashCode() 以及equals() 方法</p>
<h4 id="用可变类当HashMap-的key-有什么问题"><a href="#用可变类当HashMap-的key-有什么问题" class="headerlink" title="用可变类当HashMap 的key 有什么问题?"></a>用可变类当HashMap 的key 有什么问题?</h4><p>一般用Integer、String 这种不可变类当HashMap 当key，而且String 最为<br>常用。因为字符串是不可变的，所以在它创建的时候hashcode 就被缓存了，<br>不需要重新计算。这就是HashMap 中的键往往都使用字符串的原因。因为获取<br>对象的时候要用到equals() 和hashCode() 方法，那么键对象正确的重写<br>这两个方法是非常重要的，这些类已经很规范的重写了 hashCode() 以及<br>equals()方法</p>
<h4 id="HashMap扩容时候的死循环问题？"><a href="#HashMap扩容时候的死循环问题？" class="headerlink" title="HashMap扩容时候的死循环问题？"></a>HashMap扩容时候的死循环问题？</h4><ol>
<li>HashMap 1.7 插入数据时，使用的是头插法，并发下扩容时的Rehash，会<br>出现死循环问题，可能导致链表成环</li>
<li>而HashMap 1.8 插入数据时，改成了尾插法，解决了扩容时的死循环问题</li>
</ol>
<h4 id="多线程的put可能导致元素的丢失？"><a href="#多线程的put可能导致元素的丢失？" class="headerlink" title="多线程的put可能导致元素的丢失？"></a>多线程的put可能导致元素的丢失？</h4><p>多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前<br>一个key 被后一个key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和JDK<br>1.8 中都存在</p>
<ol>
<li>假设线程1和线程2同时执行put，并且都冲突在同一个位置，异常就发生<br>当两个线程都找到数组位置的时候，假设线程1先new Node放在这个位置然<br>后切换，线程2此时也new Node就会覆盖这个线程1的Node</li>
</ol>
<h4 id="put和get并发时，可能导致get为null？"><a href="#put和get并发时，可能导致get为null？" class="headerlink" title="put和get并发时，可能导致get为null？"></a>put和get并发时，可能导致get为null？</h4><ol>
<li>线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此<br>时执行get，有可能导致这个问题。此问题在JDK 1.7和JDK 1.8 中都存在。</li>
<li>线程1用新计算的容量new 了一个新的hash表，将新创建的空hash表赋值<br>给实例变量table，但是还没有进行值的拷贝，此时线程2执行get，就会get<br>出null</li>
</ol>
<h3 id="如何解决HashMap-线程不安全的问题？"><a href="#如何解决HashMap-线程不安全的问题？" class="headerlink" title="如何解决HashMap 线程不安全的问题？"></a>如何解决HashMap 线程不安全的问题？</h3><ol>
<li>Hashtable类替代</li>
<li>Collections 工具类转换，synchronizedMap 方法来得到一个保证<br>线程安全的Map，这是一个静态的方法，返回一个线程安全的 Map，这个<br>方法只是对参数中的 Map对象进行了一下包装，返回了一个新的Map对象<br>，将参数中的Map 对象的相关操作方法都通过使用 synchronized 关键<br>字修饰的方法包装了一下，但是具体的操作流程还是和原来的Map对象一<br>样</li>
<li>JUC 中的ConcurrentHashMap 替代</li>
</ol>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>用ConcurrentHashMap 替代HashMap，可以解决线程安全的问题，但是<br>ConcurrentHashMap 也是有jdk1.7 和jdk1.8 的区别。</p>
<ol>
<li>数据结构 jdk1.7 采用Segment分段锁方式。jdk1.8 采用数组+链表<br>和红黑树实现</li>
<li>保证线程安全机制 jdk1.7 采用Segment分段锁方式保证线程安全，<br>其中Segment 继承自ReentrantLock，jdk1.8采用CAS和synchronized<br>来保证线程安全</li>
<li>锁的粒度 jdk1.7 将数据分成一段一段的存储，然后每一段数据单独<br>一个锁，所以当一个线程占用一个锁访问其中的一段数据时，其他段的数<br>据可以被其他线程访问，包含一个Segment数组，数组中的每个Segment<br>都包含一个HashEntry 数组，每个HashEntry 是一个链表结构的元素。<br>jdk1.8 锁的锁更细粒度了，synchronized 只锁定当前链表或红黑树<br>的首节点，只要hash不冲突，就不会有线程安全问题，效率大幅提升</li>
<li>链表转化为红黑树 定位节点的 hash 算法简化会带来弊端，hash<br>冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时<br>，会将链表转化为红黑树进行存储</li>
<li>查询时间复杂度 从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红<br>黑树O(logN)</li>
</ol>
<h4 id="Segment是什么？"><a href="#Segment是什么？" class="headerlink" title="Segment是什么？"></a>Segment是什么？</h4><p>Segment是ConcurrentHashMap 的一个静态内部类，保存一个HashEntry数<br>组，继承了ReentrantLock，所以Segment是一种可重入锁，扮演锁的角色。<br>Segment 默认为16，也就是并发度为16</p>
<h4 id="HashEntry是什么？"><a href="#HashEntry是什么？" class="headerlink" title="HashEntry是什么？"></a>HashEntry是什么？</h4><p>保存key 和value 以及一个指向下一个节点的引用，用volatile 修饰了<br>HashEntry 的数据 value 和 下一个节点 next，保证了多线程环境下<br>数据获取时的可见性</p>
<h4 id="实现原理？"><a href="#实现原理？" class="headerlink" title="实现原理？"></a>实现原理？</h4><ol>
<li>JDK1.7 JDK1.7 中的 ConcurrentHashMap 是由 Segment 数组结构和<br>HashEntry 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小<br>数组（Segment），每个小数组有n 个HashEntry 组成。将数据分为一段一<br>段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数<br>据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。</li>
<li>JDK1.8 JDK1.8 中的ConcurrentHashMap 选择了与HashMap相同的Node<br>数组+链表+红黑树结构，在锁的实现上，抛弃了原有的Segment 分段锁，采<br>用CAS + synchronized实现更加细粒度的锁。将锁的级别控制在了更细粒度<br>的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根<br>节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度</li>
</ol>
<h4 id="JDK1-8-中为什么使用synchronized替换ReentrantLock？"><a href="#JDK1-8-中为什么使用synchronized替换ReentrantLock？" class="headerlink" title="JDK1.8 中为什么使用synchronized替换ReentrantLock？"></a>JDK1.8 中为什么使用synchronized替换ReentrantLock？</h4><ol>
<li>在JDK1.6 中，对synchronized 锁的实现引入了大量的优化，并且<br>synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt;<br>重量级锁一步步转换</li>
<li>减少内存开销。假设使用可重入锁来获得同步支持，那么每个节点都需<br>要通过继承AQS 来获得同步支持。但并不是每个节点都需要获得同步支持<br>的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨<br>大内存浪费</li>
</ol>
<h4 id="两个版本put-方法执行逻辑是什么？"><a href="#两个版本put-方法执行逻辑是什么？" class="headerlink" title="两个版本put 方法执行逻辑是什么？"></a>两个版本put 方法执行逻辑是什么？</h4><ol>
<li>JDK1.7 先定位到相应的Segment，然后再进行put 操作。首先会尝试<br>获取锁，如果获取失败肯定就有其他线程存在竞争，则利用<br>scanAndLockForPut() 自旋获取锁</li>
<li>JDK1.8 分为4步</li>
</ol>
<ul>
<li>第一步 根据key 计算出hash 值</li>
<li>第二步 判断是否需要进行初始化</li>
<li>第三步 定位到Node，拿到首节点 f，判断首节点f。如果f为null那么<br>就采用CAS的方式尝试添加，如果为f.hash=MOVED=-1 ，说明其他线程<br>在扩容，参与一起扩容。如果都不满足，synchronized 锁住f 节点，<br>判断是链表还是红黑树，遍历插入</li>
<li>第四步 当在链表长度达到8 的时候，数组扩容或者将链表转换为红黑树</li>
</ul>
<h4 id="两个版本get-方法的执行逻辑是什么？"><a href="#两个版本get-方法的执行逻辑是什么？" class="headerlink" title="两个版本get 方法的执行逻辑是什么？"></a>两个版本get 方法的执行逻辑是什么？</h4><ol>
<li>JDK1.7 根据key 计算出hash 值定位到具体的Segment，再根据hash<br>值获取定位HashEntry 对象，并对HashEntry 对象进行链表遍历，找到<br>对应元素。由于 HashEntry 涉及到的共享变量都使用volatile 修饰，<br>volatile 可以保证内存可见性，所以每次获取时都是最新值</li>
<li>JDK1.8 可以分为4步</li>
</ol>
<ul>
<li>第一步 根据key 计算出hash 值，判断数组是否为空</li>
<li>第二步 如果是首节点，就直接返回</li>
<li>第三步 如果是红黑树结构，就从红黑树里面查询</li>
<li>第四步 如果是链表结构，循环遍历判断</li>
</ul>
<h4 id="get-方法是否要加锁？"><a href="#get-方法是否要加锁？" class="headerlink" title="get 方法是否要加锁？"></a>get 方法是否要加锁？</h4><p>get 方法不需要加锁。因为Node 的元素value 和指针next 是用volatile<br>修饰的，在多线程环境下线程A修改节点的value 或者新增节点的时候是对<br>线程B可见的。这也是它比其他并发集合比如 Hashtable、用Collections<br>.synchronizedMap()包装的 HashMap 效率高的原因之一</p>
<h4 id="get-方法不需要加锁与volatile-修饰的哈希桶数组有关吗？"><a href="#get-方法不需要加锁与volatile-修饰的哈希桶数组有关吗？" class="headerlink" title="get 方法不需要加锁与volatile 修饰的哈希桶数组有关吗？"></a>get 方法不需要加锁与volatile 修饰的哈希桶数组有关吗？</h4><p>没有关系，哈希桶数组table用volatile 修饰主要是保证在数组扩容的时<br>候保证可见性</p>
<h4 id="ConcurrentHashMap-不支持key-或者value-为null？"><a href="#ConcurrentHashMap-不支持key-或者value-为null？" class="headerlink" title="ConcurrentHashMap 不支持key 或者value 为null？"></a>ConcurrentHashMap 不支持key 或者value 为null？</h4><p>先来说value 为什么不能为null。因为 ConcurrentHashMap 是用于多线程<br>的，如果ConcurrentHashMap.get(key)得到了null ，这就无法判断，是<br>映射的value是null ，还是没有找到对应的key而为null ，就有了二义性<br>。而用于单线程状态的HashMap 却可以用containsKey(key) 去判断到底<br>是否包含了这个null。二义性是指</p>
<ol>
<li>这个key从来没有在map中映射过。</li>
<li>这个key的value在设置的时候，就是null</li>
</ol>
<h4 id="ConcurrentHashMap-的并发度是什么？"><a href="#ConcurrentHashMap-的并发度是什么？" class="headerlink" title="ConcurrentHashMap 的并发度是什么？"></a>ConcurrentHashMap 的并发度是什么？</h4><ol>
<li>并发度可以理解为程序运行时能够同时更新ConccurentHashMap 且不产<br>生锁竞争的最大线程数。在JDK1.7中，实际上就是ConcurrentHashMap中的<br>分段锁个数，即Segment[]的数组长度，默认是16，这个值可以在构造函数<br>中设置</li>
<li>如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最<br>小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并<br>发度是32</li>
<li>如果并发度设置的过小，会带来严重的锁竞争问题，如果并发度设置的过<br>大，原本位于同一个Segment内的访问会扩散到不同Segment中，CPU cache<br>命中率会下降，从而引起程序性能下降</li>
<li>在JDK1.8中，已经摒弃了Segment的概念，选择了Node数组+链表+红黑树<br>结构，并发度大小依赖于数组的大小</li>
</ol>
<h4 id="ConcurrentHashMap-迭代器是强一致性还是弱一致性？"><a href="#ConcurrentHashMap-迭代器是强一致性还是弱一致性？" class="headerlink" title="ConcurrentHashMap 迭代器是强一致性还是弱一致性？"></a>ConcurrentHashMap 迭代器是强一致性还是弱一致性？</h4><p>与HashMap 迭代器是强一致性不同，ConcurrentHashMap迭代器是弱一致性。<br>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，<br>但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分<br>，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发<br>现并反映出来，这就是弱一致性。这样迭代器线程可以使用原来老的数据，而<br>写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连<br>续性和扩展性，是性能提升的关键，无法保证读取到的数据是原集合中最新<br>的数据，即迭代器进行遍历的是拷贝的集合，在遍历期间原集合发生的修改<br>，迭代器是检测不到的</p>
<h4 id="ConcurrentHashMap能完全替代Hashtable吗？"><a href="#ConcurrentHashMap能完全替代Hashtable吗？" class="headerlink" title="ConcurrentHashMap能完全替代Hashtable吗？"></a>ConcurrentHashMap能完全替代Hashtable吗？</h4><p>不能</p>
<ol>
<li>线程安全 ConcurrentHashMap 和 Hashtable 都是线程安全的</li>
<li>底层数据结构 ConcurrentHashMap 的底层数据结构： jdk1.7 是用分<br>段数组+链表实现，jdk1.8 是用数组+链表+红黑树实现，红黑树可以保证查<br>找效率，Hashtable 底层数据结构是用 数组+链表 实现</li>
<li>保证线程安全的方式 ConcurrentHashMap jdk1.7 是用分段锁的方式保<br>证线程安全，jdk1.8 是用synchronized和CAS 保证线程安全，Hashtable<br>是用全表锁来保证线程安全（既一个Hashtable 只用一把锁），这种的方式<br>的效率非常低</li>
<li>一致性 ConcurrentHashMap 的迭起器是弱一致性的，而Hashtable 的<br>迭代器是强一致性的。弱一致性是指当数据更新后，后续对该数据的读取操<br>作可能得到更新后的值，也可能是更改前的值。强一致性是指当更新操作完<br>成之后，在任何时刻所有的用户或者进程查询到的都是最近一次成功更新<br>的数据。强一致性是程度最高一致性要求，也是最难实现的</li>
</ol>
<h4 id="size操作？"><a href="#size操作？" class="headerlink" title="size操作？"></a>size操作？</h4><ol>
<li>JDK1.7 每个Segment 维护了一个count 变量来统计该Segment 中的键<br>值对个数，在执行size 操作时，需要遍历所有Segment 然后把count 累计<br>起来。 在执行size 操作时先尝试不加锁，如果连续两次不加锁操作得到的<br>结果一致，那么可以认为这个结果是正确的。尝试次数为3 ，如果尝试的次<br>数超过3次，就需要对每个Segment 加锁</li>
<li>JDK1.8 不需要加锁，数组的每个位置都有一个元素数量值</li>
</ol>
<h4 id="多线程下安全的操作map还有其他方法吗？"><a href="#多线程下安全的操作map还有其他方法吗？" class="headerlink" title="多线程下安全的操作map还有其他方法吗？"></a>多线程下安全的操作map还有其他方法吗？</h4><p>还可以使用Collections.synchronizedMap方法，对方法进行加同步锁。本<br>质也是对 HashMap 进行全表锁。在竞争激烈的多线程环境下性能依然也非常<br>差，不推荐使用</p>
<h3 id="HashMap是如何遍历键值对的？"><a href="#HashMap是如何遍历键值对的？" class="headerlink" title="HashMap是如何遍历键值对的？"></a>HashMap是如何遍历键值对的？</h3><p>有三种遍历方式</p>
<ol>
<li>通过 entrySet() 方法得到 HashMap 的键值对集合，再通过集合提供<br>的迭代器来遍历元素，这个遍历过程其实就是顺序遍历HashMap中的table<br>数组</li>
<li>通过 keySet() 方法得到HashMap 的所有键值对中 “键” 的集合，然后<br>通过 get()方法得到值来遍历元素</li>
<li>通过 forEach方法来实现HashMap中的元素遍历（JDK1.8以上支持），<br>本质也是通过遍历HashMap中的table数组</li>
</ol>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>同 HashMap 一样，TreeMap也是提供了一种数据之间的的映射能力，但是这<br>里并没有用高效来形容它，是因为同 HashMap 相比，它的效率还是略低，因<br>为其还提供对键排序的功能，我们在遍历 TreeMap 的时候，元素的遍历顺序<br>已经是根据某种规则排序后的序列，为了达成这种功能，其内部借助了一种平<br>衡二叉树（红黑树）的数据结构来实现。当我们在插入新的元素的时候，其依<br>据定义的排序规则来找到合适的位置进行插入。所以其插入元素的过程是来一<br>个插一个，所以在 TreeMap 中并没有初始容量和扩容的概念。而插入、删除、<br>查询等操作的时间复杂度为 O(logn)。n为树中的节点总数，即为元素总数</p>
<h4 id="TreeMap的comparator属性有什么用？"><a href="#TreeMap的comparator属性有什么用？" class="headerlink" title="TreeMap的comparator属性有什么用？"></a>TreeMap的comparator属性有什么用？</h4><p>TreeMap 的实现原理是红黑树，即为一种二叉搜索树，comparator的任务就<br>是为了判断出两个节点的大小关系的。Comparator是提供了一个泛型参数的<br>接口，需要实现compare方法，比较传入的两个参数的大小关系</p>
<h4 id="TreeMap是用什么数据结构来描述键值对？"><a href="#TreeMap是用什么数据结构来描述键值对？" class="headerlink" title="TreeMap是用什么数据结构来描述键值对？"></a>TreeMap是用什么数据结构来描述键值对？</h4><p>用一个Entry类来实现键值对，这个Entry实现了Map.Entry接口，包含key<br>value、左子节点和右子节点和父节点，以及表示颜色的boolean值</p>
<h3 id="TreeMap的特点是什么？"><a href="#TreeMap的特点是什么？" class="headerlink" title="TreeMap的特点是什么？"></a>TreeMap的特点是什么？</h3><p>TreeMap 最大的特点是能根据插入的键值对的键来对键值对元素节点进行<br>排序，而当我们遍历TreeMap 对象的时候取得的元素顺序是按照某个规则<br>来进行排序的，具体规则我们可以在创建TreeMap 对象的实现传入一个<br>Comparator 对象的参数来进行指定。注意如果没有指定 TreeMap 的<br>Comparator对象，那么需要保证TreeMap储存的键值对元素的 “键”<br>是实现了Comparable 接口，否则会报类型转换异常</p>
<h4 id="TreeMap是否可以指定元素的值进行排序？"><a href="#TreeMap是否可以指定元素的值进行排序？" class="headerlink" title="TreeMap是否可以指定元素的值进行排序？"></a>TreeMap是否可以指定元素的值进行排序？</h4><p>我们已经知道 TreeMap 默认会依据键值对元素的键来对元素进行排序。我<br>们也可以通过自定义的 Comparator 接口对象来指定其对键的排序方式，<br>也可以通过指定对元素的值的排序方式来对元素进行排序。<br>可以利用TreeMap会利用键来对键值对元素进行排序的特点，来自定义一个<br>“键的包装类”来作为新的键，我们就叫它 KeyWrap吧，这个KeyWrap内部<br>有两个引用，分别指向原本的 Key 和 Value两个属性，我们使得这个类<br>实现Comparable接口，并且重写其 compareTo方法，这个方法直接调用<br>Value 的 compareTo 方法作为返回值。同时，因为 TreeMap 本身需要<br>用到 Key的equals 方法来进行键的等价比较，因此我们实现这两个方法<br>并且调用对应键的方法来作为返回值</p>
<h4 id="HashMap和TreeMap-如何选用？"><a href="#HashMap和TreeMap-如何选用？" class="headerlink" title="HashMap和TreeMap 如何选用？"></a>HashMap和TreeMap 如何选用？</h4><ol>
<li>在需要大量插入、删除和查找元素这种操作的，选择HashMap ，因为底<br>层使用数据+链表+红黑树实现，对于插入、删除、查找的性能都不错，但是<br>HashMap的结果是没有排序的</li>
<li>在需要对集合排序的时候，选择TreeMap，TreeMap 基于红黑树实现，<br>TreeMap 的映射根据键的自然顺序进行排序，或者根据创建映射时提供的<br>Comparator 进行排序，具体取决于使用的构造方法</li>
</ol>
<h3 id="LinkedHashMap的底层实现原理是什么？"><a href="#LinkedHashMap的底层实现原理是什么？" class="headerlink" title="LinkedHashMap的底层实现原理是什么？"></a>LinkedHashMap的底层实现原理是什么？</h3><p>LinkedHashMap内部通过双向链表来维持元素顺序，同时继承于HashMap<br>，元素的遍历顺序和插入顺序相同。有一个链表头和链表尾节点</p>
<h4 id="LinkedHashMap如何保存键值对？"><a href="#LinkedHashMap如何保存键值对？" class="headerlink" title="LinkedHashMap如何保存键值对？"></a>LinkedHashMap如何保存键值对？</h4><p>使用内部类Entry保存键值对，继承于 HashMap.Node，每个节点都有一<br>个前驱和后继节点</p>
<h4 id="LinkedHashMap相较于父类HashMap重写了什么内容？"><a href="#LinkedHashMap相较于父类HashMap重写了什么内容？" class="headerlink" title="LinkedHashMap相较于父类HashMap重写了什么内容？"></a>LinkedHashMap相较于父类HashMap重写了什么内容？</h4><p>put 和 remove 方法都没有在LinkedHashMap 中提供，但是我们在使用<br>LinkedHashMap的时候都是直接使用这些方法来操作元素，HashMap中提<br>供了3个方法供LinkedHashMap 重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function">Node&lt;K, V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K, V&gt; e)</span></span></span><br><span class="line"><span class="function">TreeNode&lt;K, V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K, V&gt; next)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？"><a href="#LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？" class="headerlink" title="LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？"></a>LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？</h4><p>在 HashMap 的 putVal（HashMap 的 put 方法中会调用）方法中还会调<br>用newNode和newTreeNode 方法。</p>
<ol>
<li>newNode 这个方法新建的是LinkedHashMap 提供的表示双向链表节<br>点的类对象，之后调用了linkNodeLast方法来连接这个新建的链表元素<br>，也就是将新建的节点连接到链表尾部</li>
<li>afterNodeRemoval remove 方法中最后会调用afterNodeRemoval<br>(node)方法，既然移除了一个元素，自然要把这个元素从链表中移除</li>
</ol>
<h4 id="LinkedHashMap是如何遍历元素的？"><a href="#LinkedHashMap是如何遍历元素的？" class="headerlink" title="LinkedHashMap是如何遍历元素的？"></a>LinkedHashMap是如何遍历元素的？</h4><p>和其他Map一样，LinkedHashMap也是通过迭代器(Iterator)来遍历元<br>素的，有两种方式遍历元素。这两个迭代器对象都调用了nextNode方法<br>，实际就是根据已经有的双向链表的来顺序遍历元素</p>
<ol>
<li>通过keySet 得到键的集合，可以返回一个LinkedKeyIterator迭<br>代器</li>
<li>通过entrySet 得到键值对的集合，返回一个LinkedEntryIterator<br>迭代器</li>
</ol>
<h4 id="LinkedHashMap的属性accessOrder有什么作用？"><a href="#LinkedHashMap的属性accessOrder有什么作用？" class="headerlink" title="LinkedHashMap的属性accessOrder有什么作用？"></a>LinkedHashMap的属性accessOrder有什么作用？</h4><p>表示链表元素排序依据：按访问顺序排序(true)，按插入顺序排序(false)<br>，比如一开始插入了很多元素，第一次遍历的时候完全按照插入的顺序进行<br>遍历，第二次遍历时，如果中间访问了一些元素，那么这些元素就会放在后<br>面，也就是说accessOrder为true时会将已经访问的元素放到链表末尾，<br>这里已经访问包括get和put</p>
<ol>
<li>afterNodeAccess() 当一个节点被访问时，如果accessOrder为true，<br>则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一<br>个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，<br>那么链表首部就是最近最久未使用的节点</li>
<li>afterNodeInsertion() 这个方法在插入元素之后（putVal之中会调<br>用，即在元素插入完成之后会调用），并且传递的参数evict值为true，<br>这里面将removeEldestEntry 方法的返回值作为一个条件判断</li>
</ol>
<h3 id="LinkedHashMap如何重写afterNodeInsertion？"><a href="#LinkedHashMap如何重写afterNodeInsertion？" class="headerlink" title="LinkedHashMap如何重写afterNodeInsertion？"></a>LinkedHashMap如何重写afterNodeInsertion？</h3><p>这个方法在插入元素之后（putVal 之中会调用，即在元素插入完成之后会<br>调用），并且传递的参数 evict值为true，这里面将removeEldestEntry<br>方法的返回值作为一个条件判断。这个方法直接返回了 false ，并且它是<br>protected 修饰的，因此可以被子类重写，假设我们自定义一个子类并且<br>将这个方法重写返回 true 的话，在上面的代码中就会调用（当链表头结<br>点不为null时）将新添加的节点移除，这样的话LinkedHashMap 就是一<br>个没有任何元素的空链表。这个方法移除链表最老的节点（因为采用尾插<br>法建立双向链表，因此头结点是最老的节点）</p>
<h3 id="removeEldestEntry的作用是什么？"><a href="#removeEldestEntry的作用是什么？" class="headerlink" title="removeEldestEntry的作用是什么？"></a>removeEldestEntry的作用是什么？</h3><p>根据removeEldestEntry的介绍来看，主要是用于当LinkedHashMap作为<br>缓存映射时，可以节省内存而设计的。其实我们熟悉的LRU缓存算法就可以<br>通过LinkedHashMap中提供的accessOrder和removeEldestEntry方法来<br>实现，我们知道LRU 算法的缓存的思想是每次有新元素加入时，淘汰最近<br>最少被使用的元素。其核心思想是 如果数据最近被访问过，那么将来被访<br>问的几率也更高。也就是说每当元素被访问时，LRU就将该元素移至缓存队<br>列顶部，而每次如果需要淘汰元素时，LRU将缓存队列底部的元素淘汰。而<br>在LinkedHashMap中，我们可以通过accessOrder属性来控制将每次访问<br>的元素移至链表尾部，通过removeEldestEntry方法来控制是否移除链表<br>头部节点，只是将链表尾部看成了 LRU 中缓存队列的顶部，将链表头部<br>看成了 LRU 中缓存队列的底部</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>HashMap 在遍历时的元素顺序和插入时的元素顺序是不一定相同的，那么有时<br>候我们可能有这种需求，即使得遍历时的元素顺序和插入时一致，此时我们就<br>可以考虑使用LinkedHashMap，因为 LinkedHashMap 是继承于HashMap 的<br>，只不过为了维护元素顺序和插入时的保持一致，LinkedHashMap在HashMap<br>节点的基础上增加了指向前驱和后继节点的引用，也就是通过双向链表来维护<br>元素的顺序。而同时留有一些扩展方法，一些缓存算法（LRU）就可以通过<br>LinkedHashMap 来轻松实现</p>
<h4 id="如何通过LinkedHashMap实现LRU？"><a href="#如何通过LinkedHashMap实现LRU？" class="headerlink" title="如何通过LinkedHashMap实现LRU？"></a>如何通过LinkedHashMap实现LRU？</h4><ol>
<li>重写removeEldestEntry方法 如果容量超过最大值就返回true，表示可以<br>进行操作最久未使用节点</li>
<li>调用构造器时第三个参数accessOrder 设置为true</li>
</ol>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>WeakHashMap 的Entry 继承自WeakReference，被WeakReference 关联的<br>对象在下一次垃圾回收时会被回收。WeakHashMap 主要用来实现缓存，通过<br>使用WeakHashMap 来引用缓存对象，由JVM 对这部分缓存进行回收。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>和 HashMap 类似，不过其是线程安全的类，其实也就是在每个操作元素的方法<br>前加入synchronized关键字修饰，效率不高，我们完全有更好的方法来代替这<br>个，同时具体的扩容机制和HashMap 也略有不同：默认初始容量为11，扩容因<br>子为0.75，每次扩容后的容量变为之前容量的2倍+1。这个类已经被标为遗留类<br>，即不被推荐使用。键和值都不能为null</p>
<h4 id="Hashtable的底层实现原理？有什么特点？"><a href="#Hashtable的底层实现原理？有什么特点？" class="headerlink" title="Hashtable的底层实现原理？有什么特点？"></a>Hashtable的底层实现原理？有什么特点？</h4><p>这个类类似于 HashMap，不过它相对于HashMap而言其中的相关操作元素<br>的方法名前多用了一个synchronized关键字修饰，也就是说这个类是多<br>线程安全的。默认初始容量为11，扩容因子为 0.75，每次扩容后的容量<br>变为之前容量的 2 倍 + 1</p>
<h3 id="WeakHashMap-1"><a href="#WeakHashMap-1" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>由于弱引用的出现，使得 WeakHashMap 可以做到保证其所引用的元素不会导致<br>OutofMemoryError 异常。同HashMap 一样，WeakHashMap 内部也是通过数组<br>来储存元素的，WeakHashMap 默认的初始容量是 16，最大容量为 1 &lt;&lt; 30，<br>默认扩容因子为 0.75，可以指定初始容量，但是处理过后的初始容量一定是2<br>的次幂，好处是可以通过 &amp; 运算来代替 % 运算提高效率；每次扩容时容量翻<br>倍。节点（Entry）之间利用单项链表之间来处理 hash 值冲突</p>
<h3 id="IdentifyHashMap"><a href="#IdentifyHashMap" class="headerlink" title="IdentifyHashMap"></a>IdentifyHashMap</h3><p>之前介绍的Map 都是通过具体元素的 key 的 equals 方法来判断元素等价，<br>而这个Map 中则是通过最原始的方法（Object 的equals 方法）来判断，即<br>如果两个对象不是同一个对象，即使其内部属性值相同，那么也被当做不等价<br>。其内部通过一个Object 类型的数组来储存元素，即键值都用这个数组储存<br>，键所在的下标是偶数（0、2、4…），值所在的下标是对应的键下标+1。同时<br>，存入元素也按照相同的规则。如果 当前元素个数 * 3 &gt; table.length<br>（包括了键和值）。那么进行扩容，扩容是数组容量翻倍。table 数组的最<br>大容量是 1 &lt;&lt; 30，默认初始容量为32</p>
<h2 id="一般集合类有哪些？"><a href="#一般集合类有哪些？" class="headerlink" title="一般集合类有哪些？"></a>一般集合类有哪些？</h2><h3 id="HashSet的底层实现原理？"><a href="#HashSet的底层实现原理？" class="headerlink" title="HashSet的底层实现原理？"></a>HashSet的底层实现原理？</h3><p>这个类用来尽量保证以 O(1) 的时间复杂度来添加/判断元素存在/移除元<br>素等。所有对元素的相关操作都交给了其内部的一个HashMap 对象处理，<br>而添加进HashSet中的元素其实都是作为“键”储存在了这个HashMap对象<br>中</p>
<h4 id="HashSet和HashMap的区别？"><a href="#HashSet和HashMap的区别？" class="headerlink" title="HashSet和HashMap的区别？"></a>HashSet和HashMap的区别？</h4><ol>
<li>HashMap是实现了Map接口，存储的是键值对，HashSet是实现了Set接<br>口，只存储对象。前者调用put 方法添加键值对，后者通过add方法添加元<br>素，add方法的本质是调用put方法，值是一个不可更改的object</li>
<li>HashMap使用键来计算哈希值，HashSet是使用成员对象来计算哈希值</li>
<li>HashMap 比HashSet 快，前者使用了唯一的键来获取对象，当取对象<br>时，HashMap 可以直接通过hash 计算得到的键来获取对象。HashSet 判<br>断对象是否存在时调用的是 contains 方法，本质其实是调用HashMap<br>的containsKey方法，这个方法本质也是通过hash 计算得到的值。以上<br>来看实际没有差距，都必须计算哈希码，快是因为HashMap的键的性质-<br>它通常是一个简单的String或者数字，而 String 和Integer 的计算<br>哈希码的速度比整个对象的默认哈希码计算要快得多。也就是说如果<br>HashMap的键与存储在HashSet中的键是相同的对象，则性能将没有<br>真正的区别。区别在于HashMap的键是哪种对象</li>
<li>HashSet 的底层其实是基于HashMap 实现的，大部分方法都是直接调<br>用HashMap中的方法，除少数方法比如clone readObject writeObject</li>
</ol>
<h3 id="TreeSet的底层实现原理？"><a href="#TreeSet的底层实现原理？" class="headerlink" title="TreeSet的底层实现原理？"></a>TreeSet的底层实现原理？</h3><p>这个类可以使得添加进入 Set 集合中的元素按照某种规则来排序，而和<br>HashSet类似，其内部也是借助了一个TreeMap类型的对象来实现相关的<br>操作，底层结构是红黑树，查找的时间复杂度是O(log(N))</p>
<h3 id="LinkedHashSet的底层实现原理？"><a href="#LinkedHashSet的底层实现原理？" class="headerlink" title="LinkedHashSet的底层实现原理？"></a>LinkedHashSet的底层实现原理？</h3><p>就像 HashMap 和 LinkedHashMap 的关系一样，LinkedHashSet 是继承<br>了 HashSet 的，这个类的作用时保证遍历元素得到的元素序列的顺序和插<br>入元素的先后顺序一样。而其中没有重写任何操作元素的方法，底层使用了<br>一个双向链表</p>
<h4 id="如何实现安全的Set集合？"><a href="#如何实现安全的Set集合？" class="headerlink" title="如何实现安全的Set集合？"></a>如何实现安全的Set集合？</h4><ol>
<li>Set 集合内部都是通过对应的Map 实现的，那么我们自定义一个Set 集<br>合类，内部用一个线程安全的Map 来实现，比如使用ConcurrentHashMap</li>
<li>在集合工具类Collections 中已经提供了一些方法来创造一些线程安全<br>的集合，这里面有一些以synchronized 开头的方法名，接受的参数也是有<br>List、Map、Set 等集合</li>
</ol>
<h3 id="comparable-和-comparator的区别？"><a href="#comparable-和-comparator的区别？" class="headerlink" title="comparable 和 comparator的区别？"></a>comparable 和 comparator的区别？</h3><ol>
<li>comparable接口实际上是出自java.lang包，它有一个compareTo(Object<br>obj)方法用来排序</li>
<li>comparator接口实际上是出自java.util包，它有一个compare(Object<br>obj1, Object obj2)方法用来排序</li>
</ol>
<h4 id="Collection-和Collections-有什么区别？"><a href="#Collection-和Collections-有什么区别？" class="headerlink" title="Collection 和Collections 有什么区别？"></a>Collection 和Collections 有什么区别？</h4><ol>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）<br>它提供了对集合对象进行基本操作的通用接口方法。Collection接口在<br>Java 类库中有很多具体的实现。Collection接口的意义是为各种具体<br>的集合提供了最大化的统一操作方式，其直接继承接口有List与Set</li>
<li>Collections则是集合类的一个工具类，其中提供了一系列静态方法<br>，用于对集合中元素进行排序、搜索以及线程安全等各种操作</li>
</ol>
<h4 id="TreeMap-和TreeSet-在排序时如何比较元素？"><a href="#TreeMap-和TreeSet-在排序时如何比较元素？" class="headerlink" title="TreeMap 和TreeSet 在排序时如何比较元素？"></a>TreeMap 和TreeSet 在排序时如何比较元素？</h4><ol>
<li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接<br>口提供了比较元素的compareTo() 方法，当插入元素时会回调该方法比较<br>元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable<br>接口从而根据键对元素进行排序</li>
</ol>
<h4 id="Collections-工具类中的sort-方法如何比较元素？"><a href="#Collections-工具类中的sort-方法如何比较元素？" class="headerlink" title="Collections 工具类中的sort() 方法如何比较元素？"></a>Collections 工具类中的sort() 方法如何比较元素？</h4><p>sort 方法有两种重载的形式</p>
<ol>
<li>待排序容器中存放的对象比较实现Comparable 接口</li>
<li>不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，<br>参数是Comparator 接口的子类型（需重写compare 方法实现元素比较）</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>机器学习</span></a></div><div class="next-post pull-right"><a href="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><span>JAVA总结1</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/02/16/JAVA集合总结/';
  this.page.title = 'JAVA集合总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>