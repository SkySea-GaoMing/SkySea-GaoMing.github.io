<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JAVA集合总结"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>JAVA集合总结 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java集合"><span class="toc-number">2.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Java的集合？使用集合有什么好处？"><span class="toc-number">2.1.</span> <span class="toc-text">什么是Java的集合？使用集合有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的集合类有哪些？"><span class="toc-number">2.2.</span> <span class="toc-text">常用的集合类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List，Set，Map三者的区别？"><span class="toc-number">2.3.</span> <span class="toc-text">List，Set，Map三者的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterable接口是什么？"><span class="toc-number">2.4.</span> <span class="toc-text">Iterable接口是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterable接口的作用是什么？"><span class="toc-number">2.5.</span> <span class="toc-text">Iterable接口的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator怎么使用？有什么特点？"><span class="toc-number">2.6.</span> <span class="toc-text">Iterator怎么使用？有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator的作用是什么？"><span class="toc-number">2.7.</span> <span class="toc-text">Iterator的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator和foreach遍历集合的区别？"><span class="toc-number">2.8.</span> <span class="toc-text">Iterator和foreach遍历集合的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是快速失败（fast-fail）机制？"><span class="toc-number">2.9.</span> <span class="toc-text">什么是快速失败（fast-fail）机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator和ListIterator有什么区别？"><span class="toc-number">2.10.</span> <span class="toc-text">Iterator和ListIterator有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎么确保一个集合不能被修改？"><span class="toc-number">2.11.</span> <span class="toc-text">怎么确保一个集合不能被修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合框架底层数据结构是什么？"><span class="toc-number">2.12.</span> <span class="toc-text">集合框架底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见接口和类的作用是什么？"><span class="toc-number">2.13.</span> <span class="toc-text">常见接口和类的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历一个List有哪些不同的方式？"><span class="toc-number">2.14.</span> <span class="toc-text">遍历一个List有哪些不同的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList继承和实现的接口有哪些？"><span class="toc-number">2.15.</span> <span class="toc-text">ArrayList继承和实现的接口有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList是什么？底层数据结构是什么？"><span class="toc-number">2.16.</span> <span class="toc-text">ArrayList是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList与LinkedList的区别？"><span class="toc-number">2.17.</span> <span class="toc-text">ArrayList与LinkedList的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList与LinkedList的应用场景？"><span class="toc-number">2.18.</span> <span class="toc-text">ArrayList与LinkedList的应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList的扩容机制是什么样的？"><span class="toc-number">2.19.</span> <span class="toc-text">ArrayList的扩容机制是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList的add方法具体是如何实现的？"><span class="toc-number">2.20.</span> <span class="toc-text">ArrayList的add方法具体是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ensureExplicitCapacity具体如何实现？"><span class="toc-number">2.21.</span> <span class="toc-text">ensureExplicitCapacity具体如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩容方法grow是如何实现的？"><span class="toc-number">2.22.</span> <span class="toc-text">扩容方法grow是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hugeCapcity的具体实现？"><span class="toc-number">2.23.</span> <span class="toc-text">hugeCapcity的具体实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简要说说ArrayList的扩容机制"><span class="toc-number">2.24.</span> <span class="toc-text">简要说说ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么情况下modCount会增加"><span class="toc-number">2.25.</span> <span class="toc-text">什么情况下modCount会增加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList按照索引增加和减少是什么样的？"><span class="toc-number">2.26.</span> <span class="toc-text">ArrayList按照索引增加和减少是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList⽤来做队列合适么？"><span class="toc-number">2.27.</span> <span class="toc-text">ArrayList⽤来做队列合适么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList的遍历和LinkedList遍历性能⽐较如何？"><span class="toc-number">2.28.</span> <span class="toc-text">ArrayList的遍历和LinkedList遍历性能⽐较如何？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList的优缺点有哪些？"><span class="toc-number">2.29.</span> <span class="toc-text">ArrayList的优缺点有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现数组和List之间的转换？"><span class="toc-number">2.30.</span> <span class="toc-text">如何实现数组和List之间的转换？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么ArrayList的elementData加上transient修饰？"><span class="toc-number">2.31.</span> <span class="toc-text">为什么ArrayList的elementData加上transient修饰？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArryList-是线程不安全的？为什么？"><span class="toc-number">2.32.</span> <span class="toc-text">ArryList 是线程不安全的？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList是什么？底层数据结构是什么？"><span class="toc-number">2.33.</span> <span class="toc-text">LinkedList是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue有什么作用？"><span class="toc-number">2.34.</span> <span class="toc-text">Queue有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deque有什么作用？"><span class="toc-number">2.35.</span> <span class="toc-text">Deque有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList用什么保存元素？"><span class="toc-number">2.36.</span> <span class="toc-text">LinkedList用什么保存元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList如何实现插入？"><span class="toc-number">2.37.</span> <span class="toc-text">LinkedList如何实现插入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入和删除是否受元素位置的影响？"><span class="toc-number">2.38.</span> <span class="toc-text">插入和删除是否受元素位置的影响？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector是什么？底层数据结构是什么？"><span class="toc-number">2.39.</span> <span class="toc-text">Vector是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-和-Vector-的区别是什么？"><span class="toc-number">2.40.</span> <span class="toc-text">ArrayList 和 Vector 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程场景下如何使用-ArrayList？"><span class="toc-number">2.41.</span> <span class="toc-text">多线程场景下如何使用 ArrayList？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack是什么？底层数据结构是什么？"><span class="toc-number">2.42.</span> <span class="toc-text">Stack是什么？底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList、LinkedList、Vector和Stack的区别"><span class="toc-number">2.43.</span> <span class="toc-text">ArrayList、LinkedList、Vector和Stack的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList、LinkedList、Vector-各自的特点以及优缺点？"><span class="toc-number">2.44.</span> <span class="toc-text">ArrayList、LinkedList、Vector 各自的特点以及优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-和-LinkedList-的区别-异同？"><span class="toc-number">2.45.</span> <span class="toc-text">ArrayList 和 LinkedList 的区别&#x2F;异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractMap的作用是什么？"><span class="toc-number">2.46.</span> <span class="toc-text">AbstractMap的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SortedMap的作用是什么？"><span class="toc-number">2.47.</span> <span class="toc-text">SortedMap的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap用哪个类保存键值对"><span class="toc-number">2.48.</span> <span class="toc-text">HashMap用哪个类保存键值对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap的底层数据结构是什么？"><span class="toc-number">2.49.</span> <span class="toc-text">HashMap的底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap在JDK7之前是如何实现的？"><span class="toc-number">2.50.</span> <span class="toc-text">HashMap在JDK7之前是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap的loadFactor和threshold两个字段有什么用？"><span class="toc-number">2.51.</span> <span class="toc-text">HashMap的loadFactor和threshold两个字段有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么元素个数达到threshold就进行扩容？"><span class="toc-number">2.52.</span> <span class="toc-text">为什么元素个数达到threshold就进行扩容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认负载因子为什么是0-75？"><span class="toc-number">2.53.</span> <span class="toc-text">默认负载因子为什么是0.75？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap的最大容量是多少？"><span class="toc-number">2.54.</span> <span class="toc-text">HashMap的最大容量是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Float-isNaN有什么作用？"><span class="toc-number">2.55.</span> <span class="toc-text">Float.isNaN有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap的构造方法具体内容是什么？"><span class="toc-number">2.56.</span> <span class="toc-text">HashMap的构造方法具体内容是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tableSizeFor方法的作用是什么？"><span class="toc-number">2.57.</span> <span class="toc-text">tableSizeFor方法的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putMapEntries方法的作用是什么？"><span class="toc-number">2.58.</span> <span class="toc-text">putMapEntries方法的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put方法的具体原理是什么？"><span class="toc-number">2.59.</span> <span class="toc-text">put方法的具体原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putVal方法的实现原理是什么？"><span class="toc-number">2.60.</span> <span class="toc-text">putVal方法的实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put中的冲突有哪两种情况？"><span class="toc-number">2.61.</span> <span class="toc-text">put中的冲突有哪两种情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize方法的作用是什么？"><span class="toc-number">2.62.</span> <span class="toc-text">resize方法的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap中如何通过键获取相应的值？"><span class="toc-number">2.63.</span> <span class="toc-text">HashMap中如何通过键获取相应的值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getNode方法具体是如何实现的？"><span class="toc-number">2.64.</span> <span class="toc-text">getNode方法具体是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap中如何通过键删除相应的值？"><span class="toc-number">2.65.</span> <span class="toc-text">HashMap中如何通过键删除相应的值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeNode方法具体是如何实现的？"><span class="toc-number">2.66.</span> <span class="toc-text">removeNode方法具体是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap是如何遍历键值对的？"><span class="toc-number">2.67.</span> <span class="toc-text">HashMap是如何遍历键值对的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EntrySet类的作用是什么？"><span class="toc-number">2.68.</span> <span class="toc-text">EntrySet类的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EntryIterator类的作用是什么？"><span class="toc-number">2.69.</span> <span class="toc-text">EntryIterator类的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap中元素的遍历顺序和元素的插入顺序有关系吗？"><span class="toc-number">2.70.</span> <span class="toc-text">HashMap中元素的遍历顺序和元素的插入顺序有关系吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap的重要属性是什么？"><span class="toc-number">2.71.</span> <span class="toc-text">HashMap的重要属性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap将旧数组复制到新数组的过程是怎样的？"><span class="toc-number">2.72.</span> <span class="toc-text">HashMap将旧数组复制到新数组的过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩容在JDK1-8中有什么不一样？"><span class="toc-number">2.73.</span> <span class="toc-text">扩容在JDK1.8中有什么不一样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap中key的存储索引是怎么计算的？"><span class="toc-number">2.74.</span> <span class="toc-text">HashMap中key的存储索引是怎么计算的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap中的hash函数如何实现的？"><span class="toc-number">2.75.</span> <span class="toc-text">HashMap中的hash函数如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8为什么要hashcode异或其右移十六位的值"><span class="toc-number">2.76.</span> <span class="toc-text">JDK1.8为什么要hashcode异或其右移十六位的值?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么hash值要与length-1相与？"><span class="toc-number">2.77.</span> <span class="toc-text">为什么hash值要与length-1相与？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap的底层数据结构是什么？-1"><span class="toc-number">2.77.1.</span> <span class="toc-text">HashMap的底层数据结构是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树"><span class="toc-number">2.77.2.</span> <span class="toc-text">为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不用红黑树，用二叉查找树可以么"><span class="toc-number">2.77.3.</span> <span class="toc-text">不用红黑树，用二叉查找树可以么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#当链表转为红黑树后，什么时候退化为链表"><span class="toc-number">2.77.4.</span> <span class="toc-text">当链表转为红黑树后，什么时候退化为链表?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么链表改为红黑树的阈值是-8"><span class="toc-number">2.77.5.</span> <span class="toc-text">为什么链表改为红黑树的阈值是 8?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap中key的存储索引是怎么计算的？-1"><span class="toc-number">2.77.6.</span> <span class="toc-text">HashMap中key的存储索引是怎么计算的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8为什么要hashcode异或其右移十六位的值？"><span class="toc-number">2.77.7.</span> <span class="toc-text">JDK1.8为什么要hashcode异或其右移十六位的值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么-hash-值要与length-1相与？"><span class="toc-number">2.77.8.</span> <span class="toc-text">为什么 hash 值要与length-1相与？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap数组的长度为什么是-2-的幂次方？"><span class="toc-number">2.77.9.</span> <span class="toc-text">HashMap数组的长度为什么是 2 的幂次方？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-的put方法流程？"><span class="toc-number">2.77.10.</span> <span class="toc-text">HashMap 的put方法流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-7-和1-8-的put方法区别是什么？"><span class="toc-number">2.77.11.</span> <span class="toc-text">JDK1.7 和1.8 的put方法区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-的扩容方式？"><span class="toc-number">2.77.12.</span> <span class="toc-text">HashMap 的扩容方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩容在JDK1-8中有什么不一样？-1"><span class="toc-number">2.77.13.</span> <span class="toc-text">扩容在JDK1.8中有什么不一样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#还知道哪些hash算法？"><span class="toc-number">2.77.14.</span> <span class="toc-text">还知道哪些hash算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key-可以为-Null-吗"><span class="toc-number">2.77.15.</span> <span class="toc-text">key 可以为 Null 吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一般用什么作为HashMap的key"><span class="toc-number">2.77.16.</span> <span class="toc-text">一般用什么作为HashMap的key?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用可变类当-HashMap-的-key-有什么问题"><span class="toc-number">2.77.17.</span> <span class="toc-text">用可变类当 HashMap 的 key 有什么问题?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap的底层数据结构是什么？"><span class="toc-number">2.78.</span> <span class="toc-text">TreeMap的底层数据结构是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap的comparator属性有什么用？"><span class="toc-number">2.79.</span> <span class="toc-text">TreeMap的comparator属性有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap是用什么数据结构来描述键值对？"><span class="toc-number">2.80.</span> <span class="toc-text">TreeMap是用什么数据结构来描述键值对？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap的特点是什么？"><span class="toc-number">2.81.</span> <span class="toc-text">TreeMap的特点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap是否可以指定元素的值进行排序？"><span class="toc-number">2.82.</span> <span class="toc-text">TreeMap是否可以指定元素的值进行排序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap的底层实现原理是什么？"><span class="toc-number">2.83.</span> <span class="toc-text">LinkedHashMap的底层实现原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap如何保存键值对？"><span class="toc-number">2.84.</span> <span class="toc-text">LinkedHashMap如何保存键值对？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap相较于父类HashMap重写了什么内容？"><span class="toc-number">2.85.</span> <span class="toc-text">LinkedHashMap相较于父类HashMap重写了什么内容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？"><span class="toc-number">2.86.</span> <span class="toc-text">LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap是如何重写newNode？"><span class="toc-number">2.87.</span> <span class="toc-text">LinkedHashMap是如何重写newNode？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap是如何重写afterNodeRemoval？"><span class="toc-number">2.88.</span> <span class="toc-text">LinkedHashMap是如何重写afterNodeRemoval？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap是如何遍历元素的？"><span class="toc-number">2.89.</span> <span class="toc-text">LinkedHashMap是如何遍历元素的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedKeySet和LinkedEntrySet的作用？"><span class="toc-number">2.90.</span> <span class="toc-text">LinkedKeySet和LinkedEntrySet的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap的属性accessOrder有什么作用？"><span class="toc-number">2.91.</span> <span class="toc-text">LinkedHashMap的属性accessOrder有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap如何重写afterNodeInsertion？"><span class="toc-number">2.92.</span> <span class="toc-text">LinkedHashMap如何重写afterNodeInsertion？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeEldestEntry的作用是什么？"><span class="toc-number">2.93.</span> <span class="toc-text">removeEldestEntry的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable的底层实现原理？有什么特点？"><span class="toc-number">2.94.</span> <span class="toc-text">Hashtable的底层实现原理？有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何得到线程安全的Map？"><span class="toc-number">2.95.</span> <span class="toc-text">如何得到线程安全的Map？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet的底层实现原理？"><span class="toc-number">2.96.</span> <span class="toc-text">HashSet的底层实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet的底层实现原理？"><span class="toc-number">2.97.</span> <span class="toc-text">TreeSet的底层实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet的底层实现原理？"><span class="toc-number">2.98.</span> <span class="toc-text">LinkedHashSet的底层实现原理？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">57</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JAVA集合总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/02/16/JAVA集合总结/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nowcoder.com/discuss/593247" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/593247</a><br><a href="https://www.nowcoder.com/discuss/589336" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/589336</a><br><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">https://blog.csdn.net/qq_36520235/article/details/82417949</a><br><a href="https://thinkwon.blog.csdn.net/article/details/104588551" target="_blank" rel="noopener">https://thinkwon.blog.csdn.net/article/details/104588551</a><br><a href="https://blog.csdn.net/Hacker_ZhiDian/article/details/85270407" target="_blank" rel="noopener">https://blog.csdn.net/Hacker_ZhiDian/article/details/85270407</a></p>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="什么是Java的集合？使用集合有什么好处？"><a href="#什么是Java的集合？使用集合有什么好处？" class="headerlink" title="什么是Java的集合？使用集合有什么好处？"></a>什么是Java的集合？使用集合有什么好处？</h3><p>Java 的集合也称为容器，是用来存放数据的容器，不过注意，集合存放的<br>只能是引用数据类型的数据，也就是一个个的对象（如果存入基本数据类型<br>的数据，会自动装箱成包装类）。集合的好处如下</p>
<ol>
<li>集合的长度是可变的</li>
<li>集合可以存放不同类型的对象</li>
<li>使用集合之后，可以像操作基本数据类型那样来操作对象</li>
<li>集合为我们提供了多种数据结构和操作的API，选用合适的集合，能够提<br>程序性能和开发效率</li>
</ol>
<h3 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h3><p>Map接口和Collection接口是所有集合框架的父接口</p>
<ul>
<li>Collection接口的子接口包括：Set接口、List接口和Queue接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、LinkedHashMap<br>、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
<h3 id="List，Set，Map三者的区别？"><a href="#List，Set，Map三者的区别？" class="headerlink" title="List，Set，Map三者的区别？"></a>List，Set，Map三者的区别？</h3><ol>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可<br>以重复，可以插入多个null元素，元素都有索引。常用的实现类有ArrayList<br>、LinkedList 和 Vector</li>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元<br>素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是<br>HashSet、LinkedHashSet 以及 TreeSet</li>
<li>Map：是一个键值对集合，存储键、值和之间的映射。 Key无序唯一，value<br>不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元<br>素时，只要给出键对象，就会返回对应的值对象</li>
</ol>
<h3 id="Iterable接口是什么？"><a href="#Iterable接口是什么？" class="headerlink" title="Iterable接口是什么？"></a>Iterable接口是什么？</h3><p>Iterable接口实际上是JAVA集合中最顶级的接口，Collection接口直接继承<br>了这个接口，所以Collection的子接口List和Set间接继承它。Map没有直接<br>继承这个接口，但是可以通过Map的KeySet来遍历Map</p>
<h3 id="Iterable接口的作用是什么？"><a href="#Iterable接口的作用是什么？" class="headerlink" title="Iterable接口的作用是什么？"></a>Iterable接口的作用是什么？</h3><p>作用：Iterable接口有一个产生迭代器Iterator 的方法，其作用就是提供了<br>统一的方法接口来方便我们遍历容器，foreach 的实现原理是编译器帮我们将<br>遍历直接转换成了对集合iterator.next()的调用（可以使用foreach进行遍<br>历集合都实现了Iterable接口），所以如果自定义类实现了Iterable接口并<br>且实现了该接口中iterator()方法的具体定义，则可以通过foreach语法来<br>遍历自定义的类。对于List接口来说，它是可以产生一个ListIterator对象<br>的，而这个接口也是继承于Iterator接口，提供了向前访问和向后访问两种<br>方式。</p>
<h3 id="Iterator怎么使用？有什么特点？"><a href="#Iterator怎么使用？有什么特点？" class="headerlink" title="Iterator怎么使用？有什么特点？"></a>Iterator怎么使用？有什么特点？</h3><p>这个接口有三个方法。如果类本身也实现了Iterator接口，那么iterator方<br>法可直接返回this，注意在使用foreach之后需要重置迭代器位置，也证明<br>了foreach确实是通过迭代器实现的</p>
<ol>
<li>next()：返回序列中的下一个元素</li>
<li>hasNext()：检查序列中是否还有元素</li>
<li>使用remove()：将迭代器新返回的元素删除</li>
</ol>
<h3 id="Iterator的作用是什么？"><a href="#Iterator的作用是什么？" class="headerlink" title="Iterator的作用是什么？"></a>Iterator的作用是什么？</h3><p>迭代器给我们提供了统一的接口来遍历实现了迭代器接口的类的对象，实现了<br>遍历集合方法的复用，减少我们的代码量</p>
<h3 id="Iterator和foreach遍历集合的区别？"><a href="#Iterator和foreach遍历集合的区别？" class="headerlink" title="Iterator和foreach遍历集合的区别？"></a>Iterator和foreach遍历集合的区别？</h3><p>foreach的实现原理是编译器将遍历直接转换成了对集合iterator.next()<br>的调用（可以使用foreach进行遍历集合都实现了Iterable接口），所以如<br>果自定义类实现了Iterable接口并且实现了该接口中iterator()方法的具<br>体定义，则可以通过foreach语法来遍历自定义的类。区别如下</p>
<ol>
<li>foreach 不可以在遍历的过程中删除元素，不然会出现并发修改异常<br>（ConcurrentModificationException）,这是因为当使用 foreach(<br>for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历<br>该 list，但同时该 list 正在被 Iterator.remove() 修改。Java一<br>般不允许一个线程在遍历 Collection 时另一个线程修改它</li>
<li>使用iterator遍历时可以通过iterator.remove()删除元素</li>
</ol>
<h3 id="什么是快速失败（fast-fail）机制？"><a href="#什么是快速失败（fast-fail）机制？" class="headerlink" title="什么是快速失败（fast-fail）机制？"></a>什么是快速失败（fast-fail）机制？</h3><p>foreach 不可以在遍历的过程中删除元素就是因为快速失败机制。快速失<br>败是Java集合的一种错误检测机制，当多个线程对集合进行结构上的改变<br>的操作时，有可能会产生fail-fast。<br>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历<br>集合A中的元素，在某个时候，线程2修改了集合A的结构（是结构上面的<br>修改，而不是简单的修改集合元素的内容），那么这个时候程序就可能<br>会抛出ConcurrentModificationException异常，从而产生快速失败。<br>而迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个<br>modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount<br>的值。当迭代器使用hashNext()/next()遍历下一个元素之前，都会检<br>测modCount变量是否为expectedModCount值，是的话就返回遍历，否<br>则抛出异常，终止遍历。<br>解决方法如下</p>
<ol>
<li>在遍历过程中，所有涉及到改变modCount值的地方全部加上synchronized</li>
<li>使用 JUC 中的线程安全类来替代，比如使用 CopyOnWriteArrayList<br>来替代 ArrayList ，使用ConcurrentHashMap 来替代 HashMap </li>
</ol>
<h3 id="Iterator和ListIterator有什么区别？"><a href="#Iterator和ListIterator有什么区别？" class="headerlink" title="Iterator和ListIterator有什么区别？"></a>Iterator和ListIterator有什么区别？</h3><ol>
<li>Iterator可以遍历Set和List集合，而ListIterator只能遍历List</li>
<li>Iterator只能单向遍历，而ListIterator可以双向遍历（向前/后遍历）</li>
<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，<br>比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置</li>
</ol>
<h3 id="怎么确保一个集合不能被修改？"><a href="#怎么确保一个集合不能被修改？" class="headerlink" title="怎么确保一个集合不能被修改？"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c)方法<br>来创建一个只读集合，这样改变集合的任何操作都会抛出<br>UnsupportedOperationException 异常</p>
<h3 id="集合框架底层数据结构是什么？"><a href="#集合框架底层数据结构是什么？" class="headerlink" title="集合框架底层数据结构是什么？"></a>集合框架底层数据结构是什么？</h3><ol>
<li>List</li>
</ol>
<ul>
<li>Arraylist： Object数组</li>
<li>Vector： Object数组</li>
<li>LinkedList： 双向循环链表</li>
</ul>
<ol start="2">
<li>Set</li>
</ol>
<ul>
<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap<br>来保存元素</li>
<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是<br>通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap<br>其内部是基于 Hashmap 实现一样，不过还是有一点点区别的</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li>
</ul>
<ol start="3">
<li>Map</li>
</ol>
<ul>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap<br>的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）<br>.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值<br>（默认为8）时，将链表转化为红黑树，以减少搜索时间</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层<br>仍然是基于拉链式散列结构即由数组和链表和红黑树组成。LinkedHashMap<br>在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键<br>值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关<br>逻辑</li>
<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是<br>主要为了解决哈希冲突而存在的</li>
<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="常见接口和类的作用是什么？"><a href="#常见接口和类的作用是什么？" class="headerlink" title="常见接口和类的作用是什么？"></a>常见接口和类的作用是什么？</h3><ol>
<li>Collection 接口提供了线性类型和集合类型的集合的通用接口方法<br>，比如add remove contain等方法</li>
<li>List 新增排序方法sort(Comparator&lt;? super E&gt; c)，并且增加<br>了按照下标添加、修改和删除元素的方法</li>
<li>Set 没有新增任何方法，集合有三个特性：无序、有限、无重复</li>
<li>Map map 即为映射，其提供了两种不同类型的数据对象进行相互关联的<br>能力，也就是键值对。Map中通过Map.Entry 接口来描述这种类型的元素，<br>Entry接口代表一个key-value对（键值对）形成的数据结构，即为映射元<br>素。这个接口中有获取键和值的方法，在Map(HashMap、 LinkedHashMap)<br>中正是通过实现了这个接口的类对象来储存键值对的信息。Map 中添加键<br>值对和通过 key获取键值对的方法，还有一个entrySet方法返回一个包<br>含了所有键值对对象的集合类型对象</li>
<li>AbstractCollection Collection有一个名为AbstractCollection<br>的抽象类，而List接口和Set接口下的具体类都直接/间接的继承了这个抽<br>象类。<br>作用：该类提供了Collection接口的骨架实现，以最小化实现该接口所需<br>代价要实现不可修改的集合，开发者只需要继承这个类并实现iterator()<br>方法和size()方法，即返回一个迭代器（实现了hasNext和next 方法）<br>用于遍历集合和一个表示集合元素个数的值。<br>为了实现可修改的集合，开发者必须另外重写该类的add方法（否则抛出<br>UnsupportedOperationException 异常），迭代器方法返回的迭代器<br>还必须实现其remove方法。使用到了模板方法设计模式</li>
<li>AbstractList的作用<br>它继承了AbstractCollection，同时也是ArrayList等具体集合类的父类。<br>作用：该类提供了List接口的骨架实现，以最大限度地减少实现由 “随机访<br>问”数据存储（如数组）所支持的接口所需的工作量。对于顺序访问数据（如<br>链接列表），应该优先使用AbstractSequentialList类。<br>如果要实现一个不可修改的列表，程序员只需要扩展这个类并为 get(int)<br>和 size() 方法提供实现。<br>要实现一个可修改的列表，程序员必须另外重写 set(int, E) 方法。如果列<br>表是可变大小，程序员必须另外重写add(int E) 和remove(int) 方法，即<br>当前类并没有实现获取随机访问集合和修改集合元素信息的方法。<br>与其他抽象集合实现不同，这个类已经实现了 iterator() 方法，子类可以<br>不必提供迭代器实现，对于某些方法，如果子类允许更有效的实现，设计者<br>鼓励子类可以重写这些方法中的任何一个</li>
<li>SubList的作用<br>表示一个列表的子列表，表示范围：源列表下标范围 [fromIndex, toIndex)<br>并没有新建一个列表对象，还是利用源列表来进行相关操作，创建一个字段指<br>向源列表对象，并且将起始下标（fromIndex）作为偏移量，而之后对子列表<br>元素的相关操作都是通过调用源列表的相关方法并且算上偏移量（offset）<br>来实现的（委托的设计思想）</li>
</ol>
<h3 id="遍历一个List有哪些不同的方式？"><a href="#遍历一个List有哪些不同的方式？" class="headerlink" title="遍历一个List有哪些不同的方式？"></a>遍历一个List有哪些不同的方式？</h3><ol>
<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每<br>一个位置的元素，当读取到最后一个元素后停止</li>
<li>迭代器遍历，Iterator。Iterator是面向对象的一个设计模式，目的是屏蔽<br>不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了<br>Iterator 模式</li>
<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用<br>时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只<br>能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换</li>
</ol>
<h3 id="ArrayList继承和实现的接口有哪些？"><a href="#ArrayList继承和实现的接口有哪些？" class="headerlink" title="ArrayList继承和实现的接口有哪些？"></a>ArrayList继承和实现的接口有哪些？</h3><p>ArrayList类继承于AbstractList抽象类，ArrayList类还实现Serializable<br>、RandomAccess、Cloneable 接口。其中 Serializable 接口是用于将对象序<br>列化以储存在文件中或者通过流的形式在网络中传输的接口，RandomAccess接<br>口是一个没有声明任何方法的空接口，cloneable接口是一个对象复写Object<br>类中clone()方法必须实现的接口</p>
<h3 id="ArrayList是什么？底层数据结构是什么？"><a href="#ArrayList是什么？底层数据结构是什么？" class="headerlink" title="ArrayList是什么？底层数据结构是什么？"></a>ArrayList是什么？底层数据结构是什么？</h3><p>ArrayList就是有序的动态数组列表，主要⽤来装载数据，只能装载包装类，<br>它的主要底层实现是数组Object[] elementData</p>
<h3 id="ArrayList与LinkedList的区别？"><a href="#ArrayList与LinkedList的区别？" class="headerlink" title="ArrayList与LinkedList的区别？"></a>ArrayList与LinkedList的区别？</h3><ol>
<li>数据结构实现 ArrayList 是动态数组的数据结构实现，而LinkedList<br>是双向链表的数据结构实现</li>
<li>随机访问效率 ArrayList比LinkedList在随机访问的时候效率要高，因为<br>LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找</li>
<li>增加和删除效率 在非首尾的增加和删除操作，LinkedList要比ArrayList<br>效率要高，因为ArrayList增删操作要影响数组内的其他数据的下标</li>
<li>内存空间占用 LinkedList 比 ArrayList 更占内存，因为 LinkedList<br>的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后<br>一个元素</li>
<li>线程安全 ArrayList和LinkedList都是不同步的，也就是不保证线程安全</li>
</ol>
<h3 id="ArrayList与LinkedList的应用场景？"><a href="#ArrayList与LinkedList的应用场景？" class="headerlink" title="ArrayList与LinkedList的应用场景？"></a>ArrayList与LinkedList的应用场景？</h3><p>在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作<br>较多时，更推荐使用 LinkedList。如果需要线程安全的就是可以使用Vector，<br>CopyOrWriteArrayList</p>
<h3 id="ArrayList的扩容机制是什么样的？"><a href="#ArrayList的扩容机制是什么样的？" class="headerlink" title="ArrayList的扩容机制是什么样的？"></a>ArrayList的扩容机制是什么样的？</h3><ol>
<li>JDK1.7 相当于设计模式中的饿汉式，第一次创建无参构造器时就创建一个<br>初始容量为10的数组，否则就根据参数创建指定长度的数组</li>
<li>JDK1.8 相当于设计模式中的懒汉式，ArrayList可以通过构造⽅法在初始<br>化的时候指定底层数组的⼤⼩。 通过⽆参构造⽅法的⽅式ArrayList()初始化<br>，则赋值底层数组 Object[] elementData 为⼀个默认的空数组 Object[]<br>DEFAULTCAPACITY_EMPTY_ELEMENTDATA ={}，所以数组容量为0，注意只有<br>真正对数据进⾏添加add时，如果当前数组就是那个默认空数组，才分配默认<br>DEFAULT_CAPACITY = 10的初始容量</li>
</ol>
<h3 id="ArrayList的add方法具体是如何实现的？"><a href="#ArrayList的add方法具体是如何实现的？" class="headerlink" title="ArrayList的add方法具体是如何实现的？"></a>ArrayList的add方法具体是如何实现的？</h3><p>add方法的思路：add添加一个元素时进入ensureCapacityInternal(int)方<br>法，首先判断elementData是不是默认的空数组，如果是那么minCapacity就<br>赋值为初始容量10，否则直接使用当前元素个数加1的值进入下一个判断方法<br>。判断方法结束以后就在数组末尾添加元素</p>
<h3 id="ensureExplicitCapacity具体如何实现？"><a href="#ensureExplicitCapacity具体如何实现？" class="headerlink" title="ensureExplicitCapacity具体如何实现？"></a>ensureExplicitCapacity具体如何实现？</h3><p>首先modeCount会1，表示列表元素结构进行了更改。然后比较minCapicaty和<br>数组长度的大小关系，如果已经大于数组长度那么就会调用扩容方法grow</p>
<h3 id="扩容方法grow是如何实现的？"><a href="#扩容方法grow是如何实现的？" class="headerlink" title="扩容方法grow是如何实现的？"></a>扩容方法grow是如何实现的？</h3><p>grow方法的实现思路如下，首先获得一个原数组1.5倍长的长度 newCapacity<br>，如果minCapacity小于这个1.5倍的长度那么这个1.5倍的长度就是新长度，<br>否则新长度就是指定的容量，这个容量可能是10或者元素个数加1。<br>接下来还要判断这个新长度是否溢出，与Integer.MAX_VALUE - 8进行比较<br>，如果大于就调用hugeCapacity(minCapacity)，这里调用的参数是min是<br>因为newCapacity比minCapacity大，但是minCapacity不一定超</p>
<h3 id="hugeCapcity的具体实现？"><a href="#hugeCapcity的具体实现？" class="headerlink" title="hugeCapcity的具体实现？"></a>hugeCapcity的具体实现？</h3><p>在hugeCapacity中判断minCapacity如果已经超出最大整数的限制那么就<br>直接抛出异常，如果还没有还有一次判断，如果minCapacity还没有大于<br>最大整数减8，那么就直接赋值为最大整数减8，如果已经大于最大整数减<br>8那么就直接赋值为最大整数<br>获取新长度之后回到gorw方法，然后就开始将原数组扩容为新数组，调用<br>Arrays.copyOf方法，将原数组中的值拷贝到新数组中</p>
<h3 id="简要说说ArrayList的扩容机制"><a href="#简要说说ArrayList的扩容机制" class="headerlink" title="简要说说ArrayList的扩容机制"></a>简要说说ArrayList的扩容机制</h3><p>总结一句话：先判断元素数组是否需要扩容 ⇒ 确定扩容后的容量（第一次<br>将容量调整为默认容量（10），之后 以1.5 倍数进行扩容）⇒ 判断扩容<br>后容量是否溢出 ⇒ 进行数组扩容并复制原数组元素到新数组中</p>
<h3 id="什么情况下modCount会增加"><a href="#什么情况下modCount会增加" class="headerlink" title="什么情况下modCount会增加"></a>什么情况下modCount会增加</h3><p>add和remove方法修改数组会增加modCount，set方法不会增加modcount<br>，modCountb表是结构上面的修改，而不是简单的修改集合元素的内容</p>
<h3 id="ArrayList按照索引增加和减少是什么样的？"><a href="#ArrayList按照索引增加和减少是什么样的？" class="headerlink" title="ArrayList按照索引增加和减少是什么样的？"></a>ArrayList按照索引增加和减少是什么样的？</h3><p>ArrayList有指定index（索引下标）新增，也有尾部新增，但是都有校验长<br>度的判断ensureCapacityInternal，就是说如果⻓度不够，是需要扩容的。<br>在扩容的时候，1.7是取余，1.8是位运算，右移⼀位，其实就是除以2这个<br>操作</p>
<h3 id="ArrayList⽤来做队列合适么？"><a href="#ArrayList⽤来做队列合适么？" class="headerlink" title="ArrayList⽤来做队列合适么？"></a>ArrayList⽤来做队列合适么？</h3><p>队列⼀般是FIFO（先⼊先出）的，如果⽤ArrayList做队列，就需要在数组尾<br>部追加数据，数组头部删除数组，反过来也可以。但是⽆论如何总会有⼀个操<br>作会涉及到数组的数据搬迁，这个是⽐较耗费性能的。<br>结论：ArrayList不适合做队列</p>
<h3 id="ArrayList的遍历和LinkedList遍历性能⽐较如何？"><a href="#ArrayList的遍历和LinkedList遍历性能⽐较如何？" class="headerlink" title="ArrayList的遍历和LinkedList遍历性能⽐较如何？"></a>ArrayList的遍历和LinkedList遍历性能⽐较如何？</h3><p>ArrayList要比LinkedList快得多，ArrayList遍历最大的优势在于内存的<br>连续性，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内<br>存的性能开销</p>
<h3 id="ArrayList的优缺点有哪些？"><a href="#ArrayList的优缺点有哪些？" class="headerlink" title="ArrayList的优缺点有哪些？"></a>ArrayList的优缺点有哪些？</h3><p>ArrayList的优点如下</p>
<ul>
<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了<br>RandomAccess 接口，因此查找的时候非常快</li>
<li>ArrayList 在顺序添加一个元素的时候非常方便</li>
</ul>
<p>ArrayList的缺点如下</p>
<ul>
<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那<br>么就会比较耗费性能</li>
<li>插入元素的时候，也需要做一次元素复制操作，缺点同上</li>
</ul>
<h3 id="如何实现数组和List之间的转换？"><a href="#如何实现数组和List之间的转换？" class="headerlink" title="如何实现数组和List之间的转换？"></a>如何实现数组和List之间的转换？</h3><ul>
<li>数组转 List：使用 Arrays.asList(array) 进行转换</li>
<li>List 转数组：使用 List 自带的 toArray() 方法</li>
</ul>
<h3 id="为什么ArrayList的elementData加上transient修饰？"><a href="#为什么ArrayList的elementData加上transient修饰？" class="headerlink" title="为什么ArrayList的elementData加上transient修饰？"></a>为什么ArrayList的elementData加上transient修饰？</h3><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。<br>transient的作用是不希望elementData数组被序列化，重写了writeObject<br>实现。每次序列化时，先调用defaultWriteObject()方法序列化ArrayList<br>中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素<br>，这样既加快了序列化的速度，又减小了序列化之后的文件大小</p>
<h3 id="ArryList-是线程不安全的？为什么？"><a href="#ArryList-是线程不安全的？为什么？" class="headerlink" title="ArryList 是线程不安全的？为什么？"></a>ArryList 是线程不安全的？为什么？</h3><p>ArrayList 是线程不安全的，因为ArrayList里的方法没有加锁，也没有<br>使用其他保证线程安全的措施，当多个线程来对 ArrayList 进行操作时<br>，就会出现并发修改异常</p>
<h3 id="LinkedList是什么？底层数据结构是什么？"><a href="#LinkedList是什么？底层数据结构是什么？" class="headerlink" title="LinkedList是什么？底层数据结构是什么？"></a>LinkedList是什么？底层数据结构是什么？</h3><p>底层使用的是双向链表数据结构，可以作为队列/双端队列使用。LinkedList<br>类继承了AbstractSequentialList抽象类，同时实现了List、Queue、Deque<br> 、Cloneable、Serializable接口。Queue接口声明了队列的相关方法</p>
<h3 id="Queue有什么作用？"><a href="#Queue有什么作用？" class="headerlink" title="Queue有什么作用？"></a>Queue有什么作用？</h3><p>这个接口声明一个队列的相关操作。<br>add添加一个元素到队列尾部，offer添加一个元素到队列尾部，remove移除<br>头部元素如果队列为空抛出异常，poll也是移除头部元素如果队列为空返回<br>null，element取出头部元素，如果队列为空抛出异常，peek也是取出头部<br>元素当队列为空时返回null</p>
<h3 id="Deque有什么作用？"><a href="#Deque有什么作用？" class="headerlink" title="Deque有什么作用？"></a>Deque有什么作用？</h3><p>这个接口声明了双端队列的相关操作。<br>addFirst添加元素到双端队列的头部，addLast添加元素到双端队列的尾部，<br>以上两个如果有容量限制添加失败会抛出异常。offerFirst添加元素到双端<br>队列头部，offerLast添加元素到双端队列尾部，以上两个添加失败false。<br>removeFirst removeLast poolFirst pollLast getFirst getLast<br>peekFirst peekLast</p>
<h3 id="LinkedList用什么保存元素？"><a href="#LinkedList用什么保存元素？" class="headerlink" title="LinkedList用什么保存元素？"></a>LinkedList用什么保存元素？</h3><p>LinkedList有一个用来表示元素节点的类Node，有前驱和后继指针字段。<br>LinkedList没有扩容机制，添加元素时只需要插入链表尾即可。但是每个<br>节点除了保存元素值外还要保存前驱和后继指针，消耗额外的内存空间。<br>有一个first和last指针分别指向头结点和尾节点</p>
<h3 id="LinkedList如何实现插入？"><a href="#LinkedList如何实现插入？" class="headerlink" title="LinkedList如何实现插入？"></a>LinkedList如何实现插入？</h3><p>add方法默认是将元素插入到链表尾部。如果使用add(int index,E e)来<br>添加元素的话首先判断越界以及是否是直接插入在尾部，否则就会先找到<br>节点的位置，这里是调用node方法找到节点位置，思路是如果index不大<br>于链表长度的1/2就正向遍历，否则就反向遍历，这种设计能够最小化减<br>少循环的次数。注意索引是从0开始，找到这个节点后还要获取该节点的<br>前驱节点，注意插入的意思是新节点要插入到index这个位置，所以新<br>节点的后继节点就是找到的这个节点</p>
<h3 id="插入和删除是否受元素位置的影响？"><a href="#插入和删除是否受元素位置的影响？" class="headerlink" title="插入和删除是否受元素位置的影响？"></a>插入和删除是否受元素位置的影响？</h3><ol>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置<br>的影响。 比如：执行add(E e)方法的时候， ArrayList会默认在将指定的元<br>素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位<br>置i插入和删除元素的话（add(int index, E element)）时间复杂度就为<br>O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)<br>个元素都要执行向后位/向前移一位的操作。</li>
<li>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位<br>置的影响，都是近似O(1)而数组为近似O(n)</li>
</ol>
<h3 id="Vector是什么？底层数据结构是什么？"><a href="#Vector是什么？底层数据结构是什么？" class="headerlink" title="Vector是什么？底层数据结构是什么？"></a>Vector是什么？底层数据结构是什么？</h3><p>Vecctor类和ArrayList继承的类和实现的接口都一样，也是有序的动态数据<br>列表，Vector可以指定每次扩容的增量，如果不指定默认每次扩容2倍。默认<br>的数组长度也是10。Vector类的所有方法都是同步的。</p>
<h3 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h3><ol>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安<br>全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只<br>不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%</li>
</ol>
<h3 id="多线程场景下如何使用-ArrayList？"><a href="#多线程场景下如何使用-ArrayList？" class="headerlink" title="多线程场景下如何使用 ArrayList？"></a>多线程场景下如何使用 ArrayList？</h3><ol>
<li>Vector类替代</li>
<li>ArrayList不是线程安全的，如果遇到多线程场景，可以通过Collections<br>的 synchronizedList 方法将其转换成线程安全的容器后再使用。核心就是<br>arrayList 的 add() 的外面套了一层 synchronized 锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">"aaa"</span>);</span><br><span class="line">synchronizedList.add(<span class="string">"bbb"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>JUC中的CopyOnWriteArrayList（写时复制）CopyOnWriteArrayList<br>是 java.util.concurrent 包里的类，是个线程安全的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =<span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
CopyOnWriteArrayList 的思想是写时复制</li>
</ol>
<ul>
<li>写时复制：我们要向一个文件中添加新数据时，先将原来文件拷贝一份，<br>然后在这个拷贝文件上进行添加，而此时如果有别人读取数据，还是从原文<br>件读取，添加数据完成后，再用这个拷贝文件替换掉原来的文件。这样做的<br>好处是，读写分离，写的是拷贝文件，读的是原文件，可以支持多线程并<br>发读取，而不需要加锁。其中的 setArray方法中的array是用volatile<br>修饰的，可以保证可见性。其中add操作依然是要加锁的</li>
</ul>
<h3 id="Stack是什么？底层数据结构是什么？"><a href="#Stack是什么？底层数据结构是什么？" class="headerlink" title="Stack是什么？底层数据结构是什么？"></a>Stack是什么？底层数据结构是什么？</h3><p>Stack继承了Vector类，也是线程安全的。<br>作用：提供了栈的实现。push pop peek都是线程安全的方法，add本质是在<br>链表尾部添加元素，pop本质是在链表尾部移除元素，peek本质是在链表尾<br>部取出元素</p>
<h3 id="ArrayList、LinkedList、Vector和Stack的区别"><a href="#ArrayList、LinkedList、Vector和Stack的区别" class="headerlink" title="ArrayList、LinkedList、Vector和Stack的区别"></a>ArrayList、LinkedList、Vector和Stack的区别</h3><ul>
<li>ArrayList：内部采用数组保存元素，初始默认容量为 10，之后添加元素时<br>，如果数组容量不足，则以1.5倍扩容数组，溢出时抛出OutOfMemeryError<br>异常。扩容操作即为新建一个更大的数组并将原数组中的元素拷贝到新数组中<br>。在元素较多时扩容操作开销较大，如果一开始可以确定最大需要的容量，那<br>么建议使用另一个构造方法来创建指定初始容量的ArrayList以提高效率。因<br>为采用的数组储存元素，所以插入和删除元素操作较慢（时间复杂度为O(N)<br>）。ArrayList为非线程安全的类</li>
<li>LinkedList ：内部采用双向链表来储存元素，每添加一个元素就新建一个<br>Node 并添加到对应的位置，就没有所谓的扩容机制，同时实现了 Deque 接<br>口，可以作为队列 / 双端队列使用。插入元素、移除元素效率较高（时间复<br>杂度为 O(1)），但是随机访问元素效率较低（时间复杂度为 O(N)）。<br>LinkedList 非线程安全</li>
<li>Vector ：和 ArrayList 相似，内部采用数组保存元素，默认容量为 10。创<br>建时如果指定了 capacityIncrement 参数，那么每次扩容时数组容量增加<br>capacityIncrement ，否则扩容时数组容量变为原来的 2 倍。Vector 线程<br>安全</li>
<li>Stack ：继承于Vector类，提供了数据结构中栈的相关操作方法，线程安全</li>
</ul>
<h3 id="ArrayList、LinkedList、Vector-各自的特点以及优缺点？"><a href="#ArrayList、LinkedList、Vector-各自的特点以及优缺点？" class="headerlink" title="ArrayList、LinkedList、Vector 各自的特点以及优缺点？"></a>ArrayList、LinkedList、Vector 各自的特点以及优缺点？</h3><p><img src="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/7.jpg" alt></p>
<h3 id="ArrayList-和-LinkedList-的区别-异同？"><a href="#ArrayList-和-LinkedList-的区别-异同？" class="headerlink" title="ArrayList 和 LinkedList 的区别/异同？"></a>ArrayList 和 LinkedList 的区别/异同？</h3><ol>
<li>ArrayList底层使用的是数组实现，LinkedList底层使用双向链表实现</li>
<li>ArrayList 随机查找和遍历速度快，插入删除速度慢，LinkedList随机<br>查找和遍历速度快，插入和删除速度快</li>
<li>ArrayList 插入和删除元素的速度会受插入位置的影响，LinkedList插<br>入和删除元素的速度不会受插入位置的影响</li>
<li>ArrayList 内存空间会耗费在列表后面的预留空间，LinkedList内存空间<br>会耗费在每个数据要多存储一个前驱和后继</li>
<li>ArrayList 需要扩容，扩容是当前容量×1.5，LinkedList 无需扩容</li>
<li>ArrayList 和 LinkedList 都不是同步的，都是不保证线程安全</li>
</ol>
<h3 id="AbstractMap的作用是什么？"><a href="#AbstractMap的作用是什么？" class="headerlink" title="AbstractMap的作用是什么？"></a>AbstractMap的作用是什么？</h3><p>这个抽象类提供了Map的骨架实现，以最小化实现Map接口功能所需的要求。<br>如果要实现一个不可更改的map对象，开发者只需要继承这个类并实现entrySet<br>方法，返回一个包含当前 Map 对象中所有键值对的集合。通常，这个集合应该<br>基于AbstractSet类来实现，并且不应该支持添加和删除元素的方法，其迭代<br>器不应该支持移除元素的方法。<br>如果要实现可更改的 map 对象，开发者必须重写 put 方法，并且通过<br>entrySet().iterator() 方法返回的迭代器必须实现移除元素的方法</p>
<h3 id="SortedMap的作用是什么？"><a href="#SortedMap的作用是什么？" class="headerlink" title="SortedMap的作用是什么？"></a>SortedMap的作用是什么？</h3><p>实现这个接口的容器应该要按某个规则对容器内的元素进行排序，并且可以通<br>过这个接口提供的方法获取容器特定的一些元素。但是接口本身不干预容器的<br>排序规则，具体的排序方式由容器自己决定。Map 接口中的具体类 TreeMap<br>就是一个实现了 SortedMap 接口的类</p>
<p>HashMap默认的初始化容量是16，并且容量必须是2的次幂，最大容量是2^30。<br>默认的负载因子是0.75，用于计算出下一次扩容时的容量阈值</p>
<h3 id="HashMap用哪个类保存键值对"><a href="#HashMap用哪个类保存键值对" class="headerlink" title="HashMap用哪个类保存键值对"></a>HashMap用哪个类保存键值对</h3><p>在HashMap中通过一个名为Node的静态内部类来实现Map.Entry接口并实现接<br>口中的方法。Node类中有键的哈希值、key、value、next指针用于指向下一个<br>Node（用于处理冲突）</p>
<h3 id="HashMap的底层数据结构是什么？"><a href="#HashMap的底层数据结构是什么？" class="headerlink" title="HashMap的底层数据结构是什么？"></a>HashMap的底层数据结构是什么？</h3><ol>
<li>jdk7及jdk7之前，底层是用数组+链表 来实现的</li>
<li>jdk8及jdk8之后，底层是用数组+链表+红黑树来实现的，HashMap是通过<br>一个Node类型的数组table保存所有键值对，长度必须是2的幂次方。有一个<br>Set类型的集合entrySet保存所有键值对</li>
</ol>
<h3 id="HashMap在JDK7之前是如何实现的？"><a href="#HashMap在JDK7之前是如何实现的？" class="headerlink" title="HashMap在JDK7之前是如何实现的？"></a>HashMap在JDK7之前是如何实现的？</h3><ol>
<li>jdk7及jdk7之前，底层是用 数组+链表 来实现的</li>
<li>new HashMap()之后，底层会创建一个长度为16的数组(Entry[] table)</li>
<li>put 数据时(put(key,value))，会先调用 key 所在类的hashCode方法<br>，计算出此key的哈希值，再将此哈希值经过处理计算后，得到该数据在数组<br>table上的位置</li>
</ol>
<h3 id="HashMap的loadFactor和threshold两个字段有什么用？"><a href="#HashMap的loadFactor和threshold两个字段有什么用？" class="headerlink" title="HashMap的loadFactor和threshold两个字段有什么用？"></a>HashMap的loadFactor和threshold两个字段有什么用？</h3><ol>
<li>loadFactor 意为负载因子，这个值用于计算出下一次需要对HashMap进<br>行扩容时HashMap中包含的最大元素（即键值对）数</li>
<li>threshold 意为容纳键值对的最大值</li>
</ol>
<p>Node[] table的初始化长度length(默认值是16)，Load factor为负载因<br>子(默认值是0.75)，threshold 是 HashMap 所能容纳键值对的最大值。<br>threshold = length * Load factor。也就是说，在数组定义好长度之<br>后，负载因子越大，所能容纳的键值对个数越多。如果键值对的数量超出<br>threshold就会扩容</p>
<h3 id="为什么元素个数达到threshold就进行扩容？"><a href="#为什么元素个数达到threshold就进行扩容？" class="headerlink" title="为什么元素个数达到threshold就进行扩容？"></a>为什么元素个数达到threshold就进行扩容？</h3><p>这样做确实会浪费一部分内存，但是主要目的是为了减少元素冲突。当当前的<br>HashMap 容量越大的时候，给元素的 key 计算出来的 hashCode 的选择也<br>就越多，这样就越不容易产生冲突。而 HashMap 的任务其实主要是致力于保<br>证在尽可能低的时间复杂度O(1)中插入和查询元素。所以从这个角度上来说<br>牺牲一点内存是值得的</p>
<h3 id="默认负载因子为什么是0-75？"><a href="#默认负载因子为什么是0-75？" class="headerlink" title="默认负载因子为什么是0.75？"></a>默认负载因子为什么是0.75？</h3><p>0.75是对空间和时间效率的一个平衡选择</p>
<ul>
<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Load<br>factor的值</li>
<li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子<br>loadFactor的值，这个值可以大于1</li>
</ul>
<p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较<br>高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包<br>括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，<br>并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，<br>rehash操作将不会发生</p>
<h3 id="HashMap的最大容量是多少？"><a href="#HashMap的最大容量是多少？" class="headerlink" title="HashMap的最大容量是多少？"></a>HashMap的最大容量是多少？</h3><p>最大容量MAXIMUM_CAPACITY是1073741824，2*MAXIMUM_CAPACITY-1就是<br>最大整数</p>
<h3 id="Float-isNaN有什么作用？"><a href="#Float-isNaN有什么作用？" class="headerlink" title="Float.isNaN有什么作用？"></a>Float.isNaN有什么作用？</h3><p>为了判断出一个值是否为 “非数字” 值， “非数字”值指的是类似于0.0/0.0<br>得到的值。在 Java 中，小数除以 0 不会抛出 ArithmeticException异常<br>，但是每次 0.0 / 0.0 得到的结果都是不同的值（对象）</p>
<h3 id="HashMap的构造方法具体内容是什么？"><a href="#HashMap的构造方法具体内容是什么？" class="headerlink" title="HashMap的构造方法具体内容是什么？"></a>HashMap的构造方法具体内容是什么？</h3><ol>
<li>自定义初始容量和负载因子，如果初始容量大于最大容量1073741824那么<br>就设置为最大容量1073741824，负载因子不能小于0 或者是一个非数，注意</li>
<li>0/0.0不会抛异常但是每次的结果不同，然后就会通过tableSizeFor方法<br>得到下一次要进行扩容时 HashMap对象包含的元素数目，赋值给threshold</li>
<li>自定义初始化容量，默认负载因子是0.75</li>
<li>无参构造函数 默认容量是16，默认负载因子0.75</li>
<li>参数是一个Map对象 默认负载因子是0.75，并且把该对象的所有所有键<br>值对通过putMapEntries方法传入</li>
</ol>
<h3 id="tableSizeFor方法的作用是什么？"><a href="#tableSizeFor方法的作用是什么？" class="headerlink" title="tableSizeFor方法的作用是什么？"></a>tableSizeFor方法的作用是什么？</h3><p>tableSizeFor方法中对当前cap指定的容量进行操作，返回第一个大于等于<br>cap的2的次幂值，具体实现就是把n的二进制数中最左边的那一位1之后的0<br>全变为1，如果n是正常的再加上1，那么一定就是2的次幂。一开始赋值时n<br>要减1是因为防止本来就是一个2的次幂再扩大两倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = cap - <span class="number">1</span> = <span class="number">5</span></span><br><span class="line"><span class="comment">//n 的二进制：000..00(29个0) 101，之后省略前导零</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span> = (<span class="number">101</span>) | (<span class="number">010</span>) = <span class="number">111</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span> = (<span class="number">111</span>) | (<span class="number">001</span>) = <span class="number">111</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span> = (<span class="number">0</span>) | (<span class="number">111</span>) = <span class="number">111</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span> = (<span class="number">0</span>) | (<span class="number">111</span>) = <span class="number">111</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span> = (<span class="number">0</span>) | (<span class="number">111</span>) = <span class="number">111</span></span><br></pre></td></tr></table></figure>

<h3 id="putMapEntries方法的作用是什么？"><a href="#putMapEntries方法的作用是什么？" class="headerlink" title="putMapEntries方法的作用是什么？"></a>putMapEntries方法的作用是什么？</h3><p>到目前为止还没有为table分配内存空间，有一个构造参数也是Map时会调用<br>putMapEntries进行存入对象，这个方法中有一个resize和putVal方法，<br>那么真正存入键值对应该就是这个putVal方法</p>
<h3 id="put方法的具体原理是什么？"><a href="#put方法的具体原理是什么？" class="headerlink" title="put方法的具体原理是什么？"></a>put方法的具体原理是什么？</h3><p>put方法是用来存放键值对，而put方法核心就是直接调用了putVal方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="putVal方法的实现原理是什么？"><a href="#putVal方法的实现原理是什么？" class="headerlink" title="putVal方法的实现原理是什么？"></a>putVal方法的实现原理是什么？</h3><ol>
<li>首先就判断table是否为null或者长度为0，如果是的话就通过resize<br>方法申请空间并调整table的容量</li>
<li>然后将key和value存入键值对中 hash就是传入的hash(key)，然后与<br>数组长度进行与运算得到下标</li>
<li>如果这个下标在table数组中代表的数组元素为null，证明这个下标可<br>用（不会产生冲突），那么直接赋值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li>
<li>如果这个下标在table数组中代表的数组元素不为null，也就是产生冲<br>突</li>
<li>如果插入的键值对的 “键” 和冲突的键值对的 “键” 等价，那么先记录<br>产生冲突的元素，到后面更新值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br></pre></td></tr></table></figure></li>
<li>否则不等价，如果产生已存在的键值对元素为TreeNode类型，证明当前<br>链表已经被树化（变成一颗红黑树），那么把节点（键值对元素）插入树中<br>，（涉及到红黑树的维护）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br></pre></td></tr></table></figure></li>
<li>不等价，并且依然是一条链表，那么就会遍历整个冲突链表。这里的不等<br>价是说与table[index]的key不等价，当也有可能与链表中其他元素等价</li>
<li>如果当前已经到达链表尾部，那么把元素节点插入到链表尾部，这里就<br>说明与整个链表的所有元素都不等价。然后判断链表长度是否大于8，如果<br>大于8的话就调用treeifyBin(tab, hash)方法，这个方法中如果数组长<br>度大于等于64就树化链表，否则就进行扩容</li>
<li>如果遍历过程中插入的键值对元素的 “键” 和某个已经存在的键值对的<br>“键” 等价，那么直接跳出循环，之后会更新这个等价的键值对的值</li>
<li>如果 e 不为null，证明有某个键值对的“键” 和插入的键值对的“键”<br>是等价的，更新已经存在的那个键值对的值，并直接return oldValue</li>
<li>如果e为null，modCount增加1，如果插入键值对后元素数目大于重新<br>分配 HashMap 容量的阀值，那么再次分配 HashMap 容量。return null<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="put中的冲突有哪两种情况？"><a href="#put中的冲突有哪两种情况？" class="headerlink" title="put中的冲突有哪两种情况？"></a>put中的冲突有哪两种情况？</h3><p>这里的冲突是指两个键值对元素的 “键” 的 hashCode 相同</p>
<ol>
<li>要插入的键值对的 “键” 和冲突的键值对的 “键” 等价（两个引用指向<br>一个对象或者两个引用指向的对象的 equals 方法返回 true）。此时记录<br>这个键值对，到后面更新一下它的值即可</li>
<li>要插入的键值对的 “键” 和冲突的键值对的 “键” 不等价（两个引用指<br>向的对象的 equals 方法返回 false）。这种情况下就需要进行特殊处理<br>（链化或者树化节点）</li>
</ol>
<h3 id="resize方法的作用是什么？"><a href="#resize方法的作用是什么？" class="headerlink" title="resize方法的作用是什么？"></a>resize方法的作用是什么？</h3><p>这个方法是真正给HashMap扩容的方法。</p>
<ol>
<li>首先判断数组长度是否大于0，如果大于0分为两种情况。第一种情况就是<br>数组长度已经大于HashMap指定的最大容量，那么这个时候数组的长度就不<br>能再增大了，但是阈值threshold变为最大整数。第二种情况就是如果当前<br>HashMap容量不小于默认容量（16）并且其*2 小于允许的最大容量，那<br>么将HashMap容量变成原来的两倍，并且容量分配阀值*2<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">return</span> oldTab;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">           oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">           newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br></pre></td></tr></table></figure></li>
<li>如果当前HashMap的容量为0，并且容量分配阀值大于0。之前解析构造方<br>法时已经说明了，当调用传入指定初始容量的构造方法时，数组依然没有扩<br>容，所以长度为0，但是阈值threshold设置为大于等于初始容量的2的次幂<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br></pre></td></tr></table></figure></li>
<li>HashMap的容量和容量分配阀值都为0。说明这个时候调用的是默认的无参<br>构造器，那么HashMap的容量就设置为16，阈值就是12<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;    <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">       newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>如果新分配的阈值newThr为0，说明调用了有初始容量和指定负载因子的<br>构造器，通过刚刚的代码可以看到只设置了newCap还没有设置newThr。直接<br>使用loadFactor字段计算出新的容量分配阀值。newThr就是扩容后的阈值<br>threshold<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>到此HashMap的新长度和阈值都已经获取，接下来为table申请内存空间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="HashMap中如何通过键获取相应的值？"><a href="#HashMap中如何通过键获取相应的值？" class="headerlink" title="HashMap中如何通过键获取相应的值？"></a>HashMap中如何通过键获取相应的值？</h3><p>get方法中通过参数key获取值，本质是调用getNode方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getNode方法具体是如何实现的？"><a href="#getNode方法具体是如何实现的？" class="headerlink" title="getNode方法具体是如何实现的？"></a>getNode方法具体是如何实现的？</h3><ol>
<li>首先判断数组table是否为null，如果为null说明根本没有这个键值对，<br>直接返回null</li>
<li>如果数组table不为null，key的hash值与length-1向与的结果得到索<br>引，如果数组中相应索引位置第一个键值对与要查询的键等价那么直接返回<br>第一个键值对</li>
<li>如果不等价的话，根据这个节点是树类型节点还是链表类型节点在相应<br>数据结构中查找等价的键</li>
</ol>
<h3 id="HashMap中如何通过键删除相应的值？"><a href="#HashMap中如何通过键删除相应的值？" class="headerlink" title="HashMap中如何通过键删除相应的值？"></a>HashMap中如何通过键删除相应的值？</h3><p>remove方法中通过参数key删除相应键值对，本质是调用removeNode方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="removeNode方法具体是如何实现的？"><a href="#removeNode方法具体是如何实现的？" class="headerlink" title="removeNode方法具体是如何实现的？"></a>removeNode方法具体是如何实现的？</h3><ol>
<li>首先判断数组table是否为null，如果为null说明根本没有这个键值对，<br>直接返回null</li>
<li>如果数组table不为null，那么就要根据索引位置取得要删除的节点</li>
<li>如果要删除的是树类型节点，那么直接从红黑树中移除</li>
<li>如果要删除的是链表类型节点，如果删除的是头结点那么直接将数组下<br>标赋给下一个节点，如果不是头结点那么删除时注意上一个节点的next要改</li>
</ol>
<h3 id="HashMap是如何遍历键值对的？"><a href="#HashMap是如何遍历键值对的？" class="headerlink" title="HashMap是如何遍历键值对的？"></a>HashMap是如何遍历键值对的？</h3><p>有三种遍历方式</p>
<ol>
<li>通过 entrySet() 方法得到 HashMap 的键值对集合，再通过集合提供<br>的迭代器来遍历元素，这个遍历过程其实就是顺序遍历HashMap中的table<br>数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">   Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过得到 HashMap 的所有键值对中 “键” 的集合，然后通过 get()方<br>法得到值来遍历元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks;</span><br><span class="line">    <span class="keyword">return</span> (ks = keySet) == <span class="keyword">null</span> ? (keySet = <span class="keyword">new</span> KeySet()) : ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过 forEach方法来实现HashMap中的元素遍历（JDK1.8以上支持）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="EntrySet类的作用是什么？"><a href="#EntrySet类的作用是什么？" class="headerlink" title="EntrySet类的作用是什么？"></a>EntrySet类的作用是什么？</h3><p>EntrySet 类是 HashMap 的一个内部类，而 HashMap 的 entrySet方<br>法中返回的也是一个 EntrySet 对象，也就是说我们通过 entrySet方<br>法得到的其实是一个 EntrySet 对象，我们对 Set 进行遍历时是通过<br>其提供的迭代器进行的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EntryIterator类的作用是什么？"><a href="#EntryIterator类的作用是什么？" class="headerlink" title="EntryIterator类的作用是什么？"></a>EntryIterator类的作用是什么？</h3><p>EntryIterator就是一个实现了Itreator接口的迭代器，通过next方法<br>遍历HashMap中所有的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中初始化next引用为table数组中第一个不为null的元素，然<br>后开始按照数组的顺序遍历。如果当前位置有一个链表，那么会从头节点<br>到尾节点的顺序遍历。我通过阅读源码发现如果是一个红黑树的话，链表<br>树化的过程中next节点没有变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="comment">// 这里循环为了排除 table 数组的 null 元素，index 下标一直++，</span></span><br><span class="line">	    <span class="comment">// 直到遇到一个不为 null 的元素时结束循环，</span></span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap中元素的遍历顺序和元素的插入顺序有关系吗？"><a href="#HashMap中元素的遍历顺序和元素的插入顺序有关系吗？" class="headerlink" title="HashMap中元素的遍历顺序和元素的插入顺序有关系吗？"></a>HashMap中元素的遍历顺序和元素的插入顺序有关系吗？</h3><p>没有任何关系，因为插入元素时主要依据的是元素的键的 hashCode 值，而<br>每个元素的键的 hashCode 没有什么规则（根据键所属的类的实现而定），<br>所以我们并不能试图按照插入元素的顺序来取出元素。如果需要使得取出的<br>元素顺序是按照插入元素的先后顺序排序的话，使用 LinkedHashMap</p>
<h3 id="HashMap的重要属性是什么？"><a href="#HashMap的重要属性是什么？" class="headerlink" title="HashMap的重要属性是什么？"></a>HashMap的重要属性是什么？</h3><ol>
<li>容量（默认为 16，如果自定义初始容量，那么会处理成最小的不小于指<br>定的容量的 2 的次幂数，注意 HashMap 的容量一定会是 2 的次幂数）</li>
<li>扩容机制（每次扩容变成上一次容量的 2 倍，如果当前元素数目达到扩<br>容阀值（负载因子 * 当前 HashMap 总容量），进行扩容）</li>
<li>负载因子（默认 0.75 ）</li>
<li>最大容量(Integer.MAX_VALUE - 8)，可以指定的最小容量(1(2^0))</li>
</ol>
<h3 id="HashMap将旧数组复制到新数组的过程是怎样的？"><a href="#HashMap将旧数组复制到新数组的过程是怎样的？" class="headerlink" title="HashMap将旧数组复制到新数组的过程是怎样的？"></a>HashMap将旧数组复制到新数组的过程是怎样的？</h3><p>如果旧数组不为null的话还要把之前数组的元素复制到新数组，复制过程如下</p>
<ol>
<li>如果原数组元素引用不为null，并且这个元素没有next节点，证明没有元<br>素和它产生冲突，那么直接复制到新数组，注意这个索引位置有变化，用新长<br>度与hash值进行按位与操作。注意如果是TreeNode类型的节点也有next，因<br>为TreeNode继承了Node类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	            <span class="comment">// 原数组元素引用赋值为 null，防止内存泄露</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>如果有冲突，并且节点类型是TreeNode类型，那么就会处理树中元素的重排<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有冲突，处理树节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br></pre></td></tr></table></figure></li>
<li>如果有冲突，并且节点类型是链表节点类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//loHead,loTail 代表扩容后不用变换下标</span></span><br><span class="line">    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//hiHead,hiTail 代表扩容后变换下标，也就是原索引 + oldCap</span></span><br><span class="line">    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = e.next;</span><br><span class="line">        <span class="comment">// 把它添加到 “低” 链表部分</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则添加到 “高” 链表部分</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 “低” 链表尾节点不为 null，将其 next 赋值为 null，</span></span><br><span class="line">        <span class="comment">// 并将其头结点赋值给新数组对应下标的元素</span></span><br><span class="line">        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 “高” 链表尾节点不为 null，将其 next 赋值为 null，</span></span><br><span class="line">        <span class="comment">// 并将其头结点赋值给新数组对应下标的元素</span></span><br><span class="line">        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="扩容在JDK1-8中有什么不一样？"><a href="#扩容在JDK1-8中有什么不一样？" class="headerlink" title="扩容在JDK1.8中有什么不一样？"></a>扩容在JDK1.8中有什么不一样？</h3><ol>
<li>resize 之后，元素的位置在原来的位置，或者原来的位置+oldCap（原<br>来哈希表的长度）。不需要像 JDK1.7 的实现那样重新计算hash ，只需要<br>看看原来的 hash 值新增的那个bit是1还是0就好了，是0的话索引没变，<br>是1的话索引变成“原索引 + oldCap ”。这个设计非常的巧妙，省去了重<br>新计算 hash 值的时间 <img src="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/5.jpg" alt></li>
<li>JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的<br>数组索引位置相同，则链表元素会倒置（头插法）。JDK1.8 不会倒置，使<br>用尾插法</li>
</ol>
<h3 id="HashMap中key的存储索引是怎么计算的？"><a href="#HashMap中key的存储索引是怎么计算的？" class="headerlink" title="HashMap中key的存储索引是怎么计算的？"></a>HashMap中key的存储索引是怎么计算的？</h3><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值<br>，最后通过hash&amp;（length-1）计算得到存储的位置</p>
<h3 id="HashMap中的hash函数如何实现的？"><a href="#HashMap中的hash函数如何实现的？" class="headerlink" title="HashMap中的hash函数如何实现的？"></a>HashMap中的hash函数如何实现的？</h3><p>首先取key的hashCode值、根据hashcode计算出hash值。JDK1.7和1.8的<br>不同之处在于根据hashcode计算出hash值</p>
<ol>
<li>JDK1.7 <img src="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/3.jpg" alt></li>
<li>JDK1.8 <img src="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/4.jpg" alt><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="number">0</span> : (h = key.hashCode()) ^ h &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="JDK1-8为什么要hashcode异或其右移十六位的值"><a href="#JDK1-8为什么要hashcode异或其右移十六位的值" class="headerlink" title="JDK1.8为什么要hashcode异或其右移十六位的值?"></a>JDK1.8为什么要hashcode异或其右移十六位的值?</h3><ol>
<li>因为在JDK 1.7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。</li>
<li>从速度、功效、质量来考虑，JDK1.8优化了高位运算的算法，通过<br>hashCode()的高16位异或低16位：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)<br>这么做可以在数组 table 的length 比较小的时候，也能保证考虑到高低<br>Bit都参与到Hash的计算中，同时不会有太大的开销</li>
</ol>
<h3 id="为什么hash值要与length-1相与？"><a href="#为什么hash值要与length-1相与？" class="headerlink" title="为什么hash值要与length-1相与？"></a>为什么hash值要与length-1相与？</h3><ol>
<li>把hash值对数组长度取模运算，模运算的消耗很大，没有位运算快</li>
<li>HashMap 的容量必须是2的次幂，所以其容量n转换成二进制中必然只有<br>一位是1，那么n - 1，就是将最左边的那一位1变为0，并且将其右边的0变<br>成1，再将得到的值和hash通过&amp;按位相与，这样的话得到的结果必然不会<br>大于n-1。位操作速度一般的操作符快</li>
</ol>
<ol start="7">
<li>put的流程<br>已经得到了键以后，如果数组所在索引位置元素为null就直接赋值，如<br>果已经有元素了，如果插入的键值对和冲突的键等价先记录冲突的元素<br>之后再赋值，如果不等价就判断Node是否是TreeNode类型，如果是的<br>话说明这个链表已经转化为了红黑树，就直接插入树中，否则就遍历<br>整个链表，如果键等价也跟之前一样记录，否则就直接插入链表末尾<br>，插入末尾的话还要判断整个链表的长度是否大于等于8，如果超过<br>就树化。到此再根据之前是否有key等价更新value。<br>如果插入键值对后元素数目大于重新分配HashMap容量的阀值，那么再次<br>分配HashMap容量</li>
<li>HashMap扩容如何实现<br>首先得到旧数组的长度oldCap，如果数组一开始就是空的话长度就是0，<br>如果oldCap大于等于默认最大长度的话那么阈值就设置为最大整数并直<br>接返回，如果oldCap不小于默认容量16并且*2小于默认最大容量那么<br>新的阈值就是旧阈值的2倍。如果当前HashMap容量为0但是阈值不为0，<br>这种情况是因为调用了带有初始容量的构造参数，刚刚已经说了构造<br>方法中并没有进行扩容，所以容量依然是0但是阈值不是0，所以新的<br>数组长度就是阈值。如果阈值也为0说明调用的是默认的构造参数这时<br>就分配默认的初始容量为16，阈值为12。<br>以上完成后还有一种特殊情况就是新的阈值为0，说明调用了带有负载<br>因子的构造参数但是这个负载因子可能有问题，所以使用默认的负载<br>因子计算新的阈值</li>
</ol>
<h4 id="HashMap的底层数据结构是什么？-1"><a href="#HashMap的底层数据结构是什么？-1" class="headerlink" title="HashMap的底层数据结构是什么？"></a>HashMap的底层数据结构是什么？</h4><ul>
<li>在JDK1.7中，由“数组+链表”组成，数组是HashMap的主体，链表则是主要为<br>了解决哈希冲突而存在的</li>
<li>在JDK1.8中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响HashMap<br>的性能，红黑树搜索时间复杂度是O(logn)，而链表是糟糕的O(n)。因此，JDK1.8<br>对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进<br>行转换：当链表长度超过 8 且数据总量大于等于 64 才会转红黑树。将链表转换<br>成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，<br>而不是转换为红黑树，以减少搜索时间</li>
</ul>
<h4 id="为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树"><a href="#为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树" class="headerlink" title="为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?"></a>为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</h4><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元<br>素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于<br>8 个的时候，红黑树搜索时间复杂度是O(logn)，而链表是O(n)，此时需要红黑树<br>来加快查询速度，但是新增节点的效率变慢了。因此，如果一开始就用红黑树结构<br>，元素太少，新增效率又比较慢，无疑这是浪费性能的</p>
<h4 id="不用红黑树，用二叉查找树可以么"><a href="#不用红黑树，用二叉查找树可以么" class="headerlink" title="不用红黑树，用二叉查找树可以么?"></a>不用红黑树，用二叉查找树可以么?</h4><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构<br>一样了，造成很深的问题），遍历查找会非常慢</p>
<h4 id="当链表转为红黑树后，什么时候退化为链表"><a href="#当链表转为红黑树后，什么时候退化为链表" class="headerlink" title="当链表转为红黑树后，什么时候退化为链表?"></a>当链表转为红黑树后，什么时候退化为链表?</h4><p>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下<br>，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成<br>链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁<br>的发生树转链表、链表转树，效率会很低。</p>
<h4 id="为什么链表改为红黑树的阈值是-8"><a href="#为什么链表改为红黑树的阈值是-8" class="headerlink" title="为什么链表改为红黑树的阈值是 8?"></a>为什么链表改为红黑树的阈值是 8?</h4><p>是因为泊松分布，理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的<br>频率遵循泊松分布，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照<br>表，可以看到链表中元素个数为8时的概率已经非常小，再多的就更少了，所以原<br>作者在选择链表元素个数时选择了8，是根据概率统计而选择的</p>
<h4 id="HashMap中key的存储索引是怎么计算的？-1"><a href="#HashMap中key的存储索引是怎么计算的？-1" class="headerlink" title="HashMap中key的存储索引是怎么计算的？"></a>HashMap中key的存储索引是怎么计算的？</h4><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后<br>通过hash&amp;（length-1）计算得到存储的位置。这里的 Hash 算法本质上就是三<br>步：取key的 hashCode值、根据 hashcode 计算出hash值、通过取模计算下标</p>
<h4 id="JDK1-8为什么要hashcode异或其右移十六位的值？"><a href="#JDK1-8为什么要hashcode异或其右移十六位的值？" class="headerlink" title="JDK1.8为什么要hashcode异或其右移十六位的值？"></a>JDK1.8为什么要hashcode异或其右移十六位的值？</h4><p>因为在JDK 1.7 中扰动了4次，计算 hash 值的性能会稍差一点点。 从速度、功效<br>、质量来考虑，JDK1.8 优化了高位运算的算法，通过hashCode()的高16位异或低<br>16位实现：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)。这么做可以在数组 table 的<br>length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不<br>会有太大的开销</p>
<h4 id="为什么-hash-值要与length-1相与？"><a href="#为什么-hash-值要与length-1相与？" class="headerlink" title="为什么 hash 值要与length-1相与？"></a>为什么 hash 值要与length-1相与？</h4><p>把hash值对数组长度取模运算，模运算的消耗很大，没有位运算快。当length总是<br>2的n次方时，h&amp; (length-1) 运算等价于对length取模，也就是 h%length，但<br>是&amp;比%具有更高的效率</p>
<h4 id="HashMap数组的长度为什么是-2-的幂次方？"><a href="#HashMap数组的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap数组的长度为什么是 2 的幂次方？"></a>HashMap数组的长度为什么是 2 的幂次方？</h4><p>这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外，2的N<br>次幂有助于减少碰撞的几率。如果 length 为2的幂次方，则 length-1 转化为<br>二进制必定是11111……的形式，在与h的二进制与操作效率会非常的快，而且空<br>间不浪费</p>
<h4 id="HashMap-的put方法流程？"><a href="#HashMap-的put方法流程？" class="headerlink" title="HashMap 的put方法流程？"></a>HashMap 的put方法流程？</h4><p>简要流程如下：</p>
<ol>
<li>首先根据key的值计算hash值，找到该元素在数组中存储的下标</li>
<li>如果数组是空的，则调用 resize 进行初始化</li>
<li>如果没有哈希冲突直接放在对应的数组下标里</li>
<li>如果冲突了，且 key 已经存在，就覆盖掉 value</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上</li>
<li>如果冲突后是链表，判断该链表是否大于8 ，如果大于8并且数组容量小于64<br>，就进行扩容</li>
<li>如果链表长度大于 8 并且数组的容量大于等于 64，则将这个结构转换为红黑树</li>
<li>否则，链表插入键值对，若 key 存在，就覆盖掉 value</li>
</ol>
<h4 id="JDK1-7-和1-8-的put方法区别是什么？"><a href="#JDK1-7-和1-8-的put方法区别是什么？" class="headerlink" title="JDK1.7 和1.8 的put方法区别是什么？"></a>JDK1.7 和1.8 的put方法区别是什么？</h4><p>解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定<br>条件，链表会转换为红黑树。链表插入元素时，JDK1.7 使用头插法插入元素，<br>在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环。因此<br>，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，就不会<br>出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是线程不安全的</p>
<h4 id="HashMap-的扩容方式？"><a href="#HashMap-的扩容方式？" class="headerlink" title="HashMap 的扩容方式？"></a>HashMap 的扩容方式？</h4><p>Hashmap 在容量超过负载因子所定义的容量之后，就会扩容。Java里的数组是<br>无法自动扩容的，方法是将Hashmap 的大小扩大为原来数组的两倍，并将原来<br>的对象放入新的数组中</p>
<h4 id="扩容在JDK1-8中有什么不一样？-1"><a href="#扩容在JDK1-8中有什么不一样？-1" class="headerlink" title="扩容在JDK1.8中有什么不一样？"></a>扩容在JDK1.8中有什么不一样？</h4><p>JDK1.8做了两处优化：resize 之后，元素的位置在原来的位置，或者原来的<br>位置 +oldCap (原来哈希表的长度）。不需要像 JDK1.7 的实现那样重新计<br>算hash ，只需要看看原来的 hash值新增的那个bit是1还是0就好了，是0<br>的话索引没变，是1的话索引变成“原索引 + oldCap ”。这个设计非常的巧<br>妙，省去了重新计算 hash 值的时间</p>
<h4 id="还知道哪些hash算法？"><a href="#还知道哪些hash算法？" class="headerlink" title="还知道哪些hash算法？"></a>还知道哪些hash算法？</h4><p>Hash函数是指把一个大范围映射到一个小范围，目的往往是为了节省空间，使得<br>数据容易保存。 比较出名的有MurmurHash、MD4、MD5等等</p>
<h4 id="key-可以为-Null-吗"><a href="#key-可以为-Null-吗" class="headerlink" title="key 可以为 Null 吗?"></a>key 可以为 Null 吗?</h4><p>可以，key 为 Null 的时候，hash算法最后的值以0来计算，也就是放在数组<br>的第一个位置</p>
<h4 id="一般用什么作为HashMap的key"><a href="#一般用什么作为HashMap的key" class="headerlink" title="一般用什么作为HashMap的key?"></a>一般用什么作为HashMap的key?</h4><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且String<br>最为常用。因为字符串是不可变的，所以在它创建的时候 hashcode 就被<br>缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的<br>原因。因为获取对象的时候要用到 equals() 和 hashCode() 方法，那<br>么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写<br>了 hashCode() 以及 equals() 方法</p>
<h4 id="用可变类当-HashMap-的-key-有什么问题"><a href="#用可变类当-HashMap-的-key-有什么问题" class="headerlink" title="用可变类当 HashMap 的 key 有什么问题?"></a>用可变类当 HashMap 的 key 有什么问题?</h4><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为<br>常用。因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不<br>需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。因为获取对象<br>的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个<br>方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals()<br>方法</p>
<h3 id="TreeMap的底层数据结构是什么？"><a href="#TreeMap的底层数据结构是什么？" class="headerlink" title="TreeMap的底层数据结构是什么？"></a>TreeMap的底层数据结构是什么？</h3><p>底层数据结构是红黑树，TreeMap 本身继承自AbstractMap 抽象类，实现了<br>NavigableMap 接口，这个 NavigableMap 接口实际上是继承了SortedMap<br>接口</p>
<h3 id="TreeMap的comparator属性有什么用？"><a href="#TreeMap的comparator属性有什么用？" class="headerlink" title="TreeMap的comparator属性有什么用？"></a>TreeMap的comparator属性有什么用？</h3><p>TreeMap 的实现原理是红黑树，即为一种二叉搜索树，comparator的任务就<br>是为了判断出两个节点的大小关系的。Comparator是提供了一个泛型参数的<br>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">/*比较两个对象的大小，如果 o1 大于 o2，返回大于 0 的值，如果o1</span></span><br><span class="line"><span class="comment">	  等于 o2，返回 0，如果 o1 小于 o2，返回小于 0 的值*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap是用什么数据结构来描述键值对？"><a href="#TreeMap是用什么数据结构来描述键值对？" class="headerlink" title="TreeMap是用什么数据结构来描述键值对？"></a>TreeMap是用什么数据结构来描述键值对？</h3><p>用一个Entry类来实现键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 左右子节点和父节点</span></span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">//当前节点是否为红色节点（任意节点颜色要么红色要么黑色，因此叫红黑树），默认为黑色</span></span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap的特点是什么？"><a href="#TreeMap的特点是什么？" class="headerlink" title="TreeMap的特点是什么？"></a>TreeMap的特点是什么？</h3><p>TreeMap最大的特点是能根据插入的键值对的键来对键值对元素节点进行<br>排序，而当我们遍历TreeMap对象的时候取得的元素顺序是按照某个规则<br>来进行排序的，具体规则我们可以在创建 TreeMap对象的实现传入一个<br>Comparator对象的参数来进行指定。注意如果没有指定 TreeMap 的<br>Comparator对象，那么需要保证TreeMap储存的键值对元素的 “键”<br>是实现了 Comparable 接口的，否则会报类型转换异常</p>
<h3 id="TreeMap是否可以指定元素的值进行排序？"><a href="#TreeMap是否可以指定元素的值进行排序？" class="headerlink" title="TreeMap是否可以指定元素的值进行排序？"></a>TreeMap是否可以指定元素的值进行排序？</h3><p>我们已经知道 TreeMap 默认会依据键值对元素的键来对元素进行排序。我<br>们也可以通过自定义的 Comparator 接口对象来指定其对键的排序方式，<br>也可以通过指定对元素的值的排序方式来对元素进行排序。<br>可以利用TreeMap会利用键来对键值对元素进行排序的特点，来自定义一个<br>“键的包装类”来作为新的键，我们就叫它 KeyWrap吧，这个KeyWrap内部<br>有两个引用，分别指向原本的 Key 和 Value两个属性，我们使得这个类<br>实现Comparable接口，并且重写其 compareTo方法，这个方法直接调用<br>Value 的 compareTo 方法作为返回值。同时，因为 TreeMap 本身需要<br>用到 Key的equals 方法来进行键的等价比较，因此我们实现这两个方法<br>并且调用对应键的方法来作为返回值</p>
<h3 id="LinkedHashMap的底层实现原理是什么？"><a href="#LinkedHashMap的底层实现原理是什么？" class="headerlink" title="LinkedHashMap的底层实现原理是什么？"></a>LinkedHashMap的底层实现原理是什么？</h3><p>LinkedHashMap内部通过双向链表来维持元素顺序，同时继承于HashMap<br>，元素的遍历顺序和插入顺序相同。有一个链表头和链表尾节点</p>
<h3 id="LinkedHashMap如何保存键值对？"><a href="#LinkedHashMap如何保存键值对？" class="headerlink" title="LinkedHashMap如何保存键值对？"></a>LinkedHashMap如何保存键值对？</h3><p>使用内部类Entry保存键值对，继承于 HashMap.Node，每个节点都有一<br>个前驱和后继节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after; <span class="comment">// 当前键值对元素节点的前继和后继节点</span></span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap相较于父类HashMap重写了什么内容？"><a href="#LinkedHashMap相较于父类HashMap重写了什么内容？" class="headerlink" title="LinkedHashMap相较于父类HashMap重写了什么内容？"></a>LinkedHashMap相较于父类HashMap重写了什么内容？</h3><p>put 和 remove 方法都没有在LinkedHashMap 中提供，但是我们在使用<br>LinkedHashMap的时候都是直接使用这些方法来操作元素，那么很显然其<br>是复用了父类(HashMap)的相关方法。HashMap中提供了3个方法供<br>LinkedHashMap重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？"><a href="#LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？" class="headerlink" title="LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？"></a>LinkedHashMap是怎么实现元素访问顺序和插入顺序相同的功能？</h3><p>在 HashMap 的 putVal（HashMap 的 put 方法中会调用）方法中还会调<br>用newNode和newTreeNode 方法。以上5个方法都会进行重写。这5个方法在<br>HashMap 中都是默认修饰符的，我们知道，默认修饰符的属性只能被同一<br>个类文件或者同一个包中的其他类访问，子类是没办法访问的（没有可见<br>性），这里 LinkedHashMap 是 HashMap的子类，从这个角度上来说，<br>其是没有对这 5 个方法的访问权的（可以理解为它根本看不到父类的这<br>5 个方法），但是它还有另外一重身份：和HashMap 同包（HashMap和<br>LinkedHashMap 都是在 java.utl 包中），因此从这方面来说，其可<br>以对这 5 个方法进行重写</p>
<h3 id="LinkedHashMap是如何重写newNode？"><a href="#LinkedHashMap是如何重写newNode？" class="headerlink" title="LinkedHashMap是如何重写newNode？"></a>LinkedHashMap是如何重写newNode？</h3><p>这个方法新建的是 LinkedHashMap 提供的表示双向链表节点的类对象，<br>之后调用了linkNodeLast方法来连接这个新建的链表元素，也就是将新<br>建的节点连接到链表尾部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = </span><br><span class="line">    	<span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap是如何重写afterNodeRemoval？"><a href="#LinkedHashMap是如何重写afterNodeRemoval？" class="headerlink" title="LinkedHashMap是如何重写afterNodeRemoval？"></a>LinkedHashMap是如何重写afterNodeRemoval？</h3><p>removeNode方法中最后会调用afterNodeRemoval(node)方法，既然移<br>除了一个元素，自然要把这个元素从链表中移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 类的方法：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap是如何遍历元素的？"><a href="#LinkedHashMap是如何遍历元素的？" class="headerlink" title="LinkedHashMap是如何遍历元素的？"></a>LinkedHashMap是如何遍历元素的？</h3><p>和其他Map一样，LinkedHashMap也是通过迭代器(Iterator)来遍历元<br>素的，有两种方式遍历元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到键的集合，之后通过 get 方法取到对应值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks;</span><br><span class="line">    <span class="keyword">return</span> (ks = keySet) == <span class="keyword">null</span> ? (keySet = <span class="keyword">new</span> LinkedKeySet()) : ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到键值对的集合，之后通过 getKey() 和 getValue() 方法得到键值</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> LinkedEntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedKeySet和LinkedEntrySet的作用？"><a href="#LinkedKeySet和LinkedEntrySet的作用？" class="headerlink" title="LinkedKeySet和LinkedEntrySet的作用？"></a>LinkedKeySet和LinkedEntrySet的作用？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 返回了一个 LinkedKeyIterator 迭代器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedKeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 返回了一个 LinkedEntryIterator 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedEntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个迭代器对象都调用了nextNode方法，实际就是根据已经有的双向链表<br>的来顺序遍历元素 <img src="/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/6.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    current = e;</span><br><span class="line">    next = e.after;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap的属性accessOrder有什么作用？"><a href="#LinkedHashMap的属性accessOrder有什么作用？" class="headerlink" title="LinkedHashMap的属性accessOrder有什么作用？"></a>LinkedHashMap的属性accessOrder有什么作用？</h3><p>表示链表元素排序依据：按访问顺序排序(true)，按插入顺序排序(false)<br>，比如一开始插入了很多元素，第一次遍历的时候完全按照插入的顺序进行<br>遍历，第二次遍历时，如果中间访问了一些元素，那么这些元素就会放在后<br>面，也就是说accessOrder为true时会将已经访问的元素放到链表末尾，<br>这里已经访问包括get和put</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法只是改变了双向链表中节点的顺序，将节点移至链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedHashMap如何重写afterNodeInsertion？"><a href="#LinkedHashMap如何重写afterNodeInsertion？" class="headerlink" title="LinkedHashMap如何重写afterNodeInsertion？"></a>LinkedHashMap如何重写afterNodeInsertion？</h3><p>这个方法在插入元素之后（putVal 之中会调用，即在元素插入完成之后会<br>调用），并且传递的参数 evict值为true，这里面将removeEldestEntry<br>方法的返回值作为一个条件判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 移除链表最老的节点（因为采用尾插法建立双向链表，因此头结点是最老的节点）</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法直接返回了false，并且它是protected修饰的，因此可以被子类<br>重写，假设我们自定义一个子类并且将这个方法重写返回true的话，在上<br>面的代码中就会调用（当链表头结点不为 null 时）removeNode 将新添<br>加的节点移除，这样的话 LinkedHashMap 就是一个没有任何元素的空链<br>表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="removeEldestEntry的作用是什么？"><a href="#removeEldestEntry的作用是什么？" class="headerlink" title="removeEldestEntry的作用是什么？"></a>removeEldestEntry的作用是什么？</h3><p>根据removeEldestEntry的介绍来看，主要是用于当LinkedHashMap作为<br>缓存映射时，可以节省内存而设计的。其实我们熟悉的LRU缓存算法就可以<br>通过LinkedHashMap中提供的accessOrder和removeEldestEntry方法来<br>实现，我们知道LRU 算法的缓存的思想是每次有新元素加入时，淘汰最近<br>最少被使用的元素。其核心思想是 如果数据最近被访问过，那么将来被访<br>问的几率也更高。也就是说每当元素被访问时，LRU就将该元素移至缓存队<br>列顶部，而每次如果需要淘汰元素时，LRU将缓存队列底部的元素淘汰。而<br>在LinkedHashMap中，我们可以通过accessOrder属性来控制将每次访问<br>的元素移至链表尾部，通过removeEldestEntry方法来控制是否移除链表<br>头部节点，只是将链表尾部看成了 LRU 中缓存队列的顶部，将链表头部<br>看成了 LRU 中缓存队列的底部</p>
<h3 id="Hashtable的底层实现原理？有什么特点？"><a href="#Hashtable的底层实现原理？有什么特点？" class="headerlink" title="Hashtable的底层实现原理？有什么特点？"></a>Hashtable的底层实现原理？有什么特点？</h3><p>这个类类似于 HashMap，不过它相对于HashMap而言其中的相关操作元素<br>的方法名前多用了一个synchronized关键字修饰，也就是说这个类是多<br>线程安全的。默认初始容量为11，扩容因子为 0.75，每次扩容后的容量<br>变为之前容量的 2 倍 + 1</p>
<h3 id="如何得到线程安全的Map？"><a href="#如何得到线程安全的Map？" class="headerlink" title="如何得到线程安全的Map？"></a>如何得到线程安全的Map？</h3><ol>
<li>通过 Collections 类中的 synchronizedMap 方法来得到一个保证<br>线程安全的Map，这是一个静态的方法，返回一个线程安全的 Map，这个<br>方法只是对参数中的 Map对象进行了一下包装，返回了一个新的Map对象<br>，将参数中的Map 对象的相关操作方法都通过使用 synchronized 关键<br>字修饰的方法包装了一下，但是具体的操作流程还是和原来的Map对象一<br>样<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>使用 ConcurrentHashMap 类，这个类是 JDK1.5 新增的一个类，可<br>以非常高效的进行相关的元素操作，同时还保证多线程安全。内部实现非<br>常巧妙，简单来说就是内部有多个互斥锁，每个互斥锁负责一段区域</li>
</ol>
<h3 id="HashSet的底层实现原理？"><a href="#HashSet的底层实现原理？" class="headerlink" title="HashSet的底层实现原理？"></a>HashSet的底层实现原理？</h3><p>这个类用来尽量保证以 O(1) 的时间复杂度来添加/判断元素存在/移除元<br>素等。所有对元素的相关操作都交给了其内部的一个HashMap 对象处理，<br>而添加进HashSet中的元素其实都是作为“键”储存在了这个HashMap对象<br>中</p>
<h3 id="TreeSet的底层实现原理？"><a href="#TreeSet的底层实现原理？" class="headerlink" title="TreeSet的底层实现原理？"></a>TreeSet的底层实现原理？</h3><p>这个类可以使得添加进入 Set 集合中的元素按照某种规则来排序，而和<br>HashSet类似，其内部也是借助了一个TreeMap类型的对象来实现相关的<br>操作</p>
<h3 id="LinkedHashSet的底层实现原理？"><a href="#LinkedHashSet的底层实现原理？" class="headerlink" title="LinkedHashSet的底层实现原理？"></a>LinkedHashSet的底层实现原理？</h3><p>就像 HashMap 和 LinkedHashMap 的关系一样，LinkedHashSet 是继承<br>了 HashSet 的，这个类的作用时保证遍历元素得到的元素序列的顺序和插<br>入元素的先后顺序一样。而其中没有重写任何操作元素的方法</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/">https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>机器学习</span></a></div><div class="next-post pull-right"><a href="/2021/01/30/JAVA%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><span>JAVA基础总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/02/16/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/';
  this.page.identifier = '2021/02/16/JAVA集合总结/';
  this.page.title = 'JAVA集合总结';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>