<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java总结2"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Java总结2 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举"><span class="toc-number">1.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举类"><span class="toc-number">1.1.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-注解是什么？"><span class="toc-number">1.2.</span> <span class="toc-text">Java 注解是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-注解有什么作用？"><span class="toc-number">1.3.</span> <span class="toc-text">Java 注解有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元注解是什么？"><span class="toc-number">1.4.</span> <span class="toc-text">元注解是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-number">2.</span> <span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是流"><span class="toc-number">2.1.</span> <span class="toc-text">什么是流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO流的分类"><span class="toc-number">2.2.</span> <span class="toc-text">Java IO流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输入流与输出流"><span class="toc-number">2.2.1.</span> <span class="toc-text">输入流与输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字节流与字符流"><span class="toc-number">2.2.2.</span> <span class="toc-text">字节流与字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要有字符流"><span class="toc-number">2.2.3.</span> <span class="toc-text">为什么要有字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#节点流和处理流"><span class="toc-number">2.2.4.</span> <span class="toc-text">节点流和处理流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字节流"><span class="toc-number">2.2.5.</span> <span class="toc-text">字节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符流"><span class="toc-number">2.2.6.</span> <span class="toc-text">字符流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO使用的设计模式"><span class="toc-number">2.3.</span> <span class="toc-text">Java IO使用的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取用键盘输入常用的两种方法"><span class="toc-number">2.4.</span> <span class="toc-text">获取用键盘输入常用的两种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞和非阻塞IO"><span class="toc-number">2.5.</span> <span class="toc-text">阻塞和非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步IO"><span class="toc-number">2.6.</span> <span class="toc-text">同步和异步IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-常见IO-模型"><span class="toc-number">2.7.</span> <span class="toc-text">Java 常见IO 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-NIO-AIO-有什么区别"><span class="toc-number">2.8.</span> <span class="toc-text">BIO,NIO,AIO 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有了解过Java中的NIO吗？原理是什么？"><span class="toc-number">2.9.</span> <span class="toc-text">有了解过Java中的NIO吗？原理是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO"><span class="toc-number">3.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO和IO的区别"><span class="toc-number">3.1.</span> <span class="toc-text">NIO和IO的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用NIO"><span class="toc-number">3.2.</span> <span class="toc-text">为什么使用NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO同步非阻塞特性"><span class="toc-number">3.3.</span> <span class="toc-text">NIO同步非阻塞特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化线程模型"><span class="toc-number">3.4.</span> <span class="toc-text">优化线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proactor与Reactor"><span class="toc-number">3.5.</span> <span class="toc-text">Proactor与Reactor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件驱动模型"><span class="toc-number">3.6.</span> <span class="toc-text">事件驱动模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在Reactor中实现读"><span class="toc-number">3.7.</span> <span class="toc-text">在Reactor中实现读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在Proactor中实现读"><span class="toc-number">3.8.</span> <span class="toc-text">在Proactor中实现读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-number">3.9.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel"><span class="toc-number">3.9.1.</span> <span class="toc-text">SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP服务端的NIO写法"><span class="toc-number">3.9.2.</span> <span class="toc-text">TCP服务端的NIO写法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer"><span class="toc-number">3.10.</span> <span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector"><span class="toc-number">3.11.</span> <span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存映射文件"><span class="toc-number">3.12.</span> <span class="toc-text">内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO实现零拷贝"><span class="toc-number">3.13.</span> <span class="toc-text">NIO实现零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO的直接内存"><span class="toc-number">3.14.</span> <span class="toc-text">NIO的直接内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC具体过程"><span class="toc-number">3.15.</span> <span class="toc-text">RPC具体过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO分为哪几种？"><span class="toc-number">3.16.</span> <span class="toc-text">Java IO分为哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO-是什么？"><span class="toc-number">3.17.</span> <span class="toc-text">BIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-是什么？"><span class="toc-number">3.18.</span> <span class="toc-text">NIO 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-和IO-多路复用的关系？"><span class="toc-number">3.19.</span> <span class="toc-text">NIO 和IO 多路复用的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO-是什么？"><span class="toc-number">3.20.</span> <span class="toc-text">AIO 是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor模式"><span class="toc-number">4.</span> <span class="toc-text">Reactor模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程IO的致命缺陷"><span class="toc-number">4.1.</span> <span class="toc-text">多线程IO的致命缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单线程Reactor模型"><span class="toc-number">4.2.</span> <span class="toc-text">单线程Reactor模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程的Reactor"><span class="toc-number">4.3.</span> <span class="toc-text">多线程的Reactor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java命名规范"><span class="toc-number">5.</span> <span class="toc-text">Java命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#驼峰命名法"><span class="toc-number">5.1.</span> <span class="toc-text">驼峰命名法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#蛇形命名法"><span class="toc-number">5.2.</span> <span class="toc-text">蛇形命名法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见规范"><span class="toc-number">5.3.</span> <span class="toc-text">常见规范</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java总结2</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/05/30/Java%E6%80%BB%E7%BB%932/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/05/30/Java总结2/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>enum关键字在java5中引入表示一种特殊类型的类，其总是继承java.lang.Enum<br>类，以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录<br>可接受值的列表，并避免由于传入无效值而引起的意外行为</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>当定义一个枚举类型时，每一个枚举类型成员都可以看作是Enum 类的实例，这些<br>枚举成员默认都被 final、public、static 修饰，当使用枚举类型成员时，直接<br>使用枚举名称调用成员即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">values()	以数组形式返回枚举类型的所有成员</span><br><span class="line">valueOf()	将普通字符串转换为枚举实例</span><br><span class="line">compareTo()	比较两个枚举成员在定义时的顺序</span><br><span class="line">ordinal()	获取枚举成员的索引位置</span><br></pre></td></tr></table></figure>


<h3 id="Java-注解是什么？"><a href="#Java-注解是什么？" class="headerlink" title="Java 注解是什么？"></a>Java 注解是什么？</h3><p>Java 注解用于为Java 代码提供元数据。作为元数据，注解不直接影响你的<br>代码执行，但也有一些类型的注解实际上可以用于这一目的，注解可以放在<br>类或者方法上,在类、方法、成员变量、形参位置</p>
<ol>
<li>自定义注解 自定义注解就是我们自己写的注解</li>
<li>JDK内置注解 @Override @Deprecated</li>
<li>还有第三方框架提供的注解 SpringMVC的 @Controller</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@Override，表示当前的方法定义将覆盖超类中的方法</li>
<li>@Deprecated，如果程序员使用了注解为它的元素，那么编译器会发出警告信息</li>
<li>@SuppressWarnings，关闭不当的编译器警告信息。在java SE5之前的<br>版本中，也可以使用该注解，不过会被忽略不起作用。</li>
</ul>
<h3 id="Java-注解有什么作用？"><a href="#Java-注解有什么作用？" class="headerlink" title="Java 注解有什么作用？"></a>Java 注解有什么作用？</h3><ol>
<li>生成帮助文档</li>
<li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并<br>不是覆盖了超类方法，则编译时就能检查出，@Deprecated标识方法过期</li>
<li>提供信息给编译器 编译器可以利用注解来检测出错误或者警告信息，<br>打印出日志</li>
</ol>
<h3 id="元注解是什么？"><a href="#元注解是什么？" class="headerlink" title="元注解是什么？"></a>元注解是什么？</h3><p>注解的注解，它是作用在注解中，方便我们使用注解实现想要的功能</p>
<ol>
<li>@Retention 表示注解存在阶段是保留在源码（编译期），字节码（类<br>加载）或者运行期（JVM中运行），使用枚举来表示注解保留时期</li>
<li>@Target 表示注解作用的范围可以是类，方法，方法参数变量</li>
<li>@Documented 将注解中的元素包含到 Javadoc 中去</li>
<li>@Inherited 该注解了的注解修饰了一个父类，如果他的子类没有被其<br>他注解修饰，则它的子类也继承了父类的注解</li>
<li>@Repeatable 被这个元注解修饰的注解可以同时作用一个对象多次，但<br>是每次作用注解又可以代表不同的含义</li>
</ol>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p>I/O（Input/Outpu）即输入/输出。指应用程序和外部设备之间的数据传递，<br>常见的外部设备包括文件、管道、网络连接。用户空间的程序不能直接访问内核<br>空间必须通过系统调用来间接访问内核空间，主要是磁盘IO（读写文件）和网<br>络IO（网络请求和响应）</p>
<h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>流是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式<br>发送信息的通道。流的特性有三点</p>
<ol>
<li>先进先出：最先写入输出流的数据最先被输入流读取到</li>
<li>顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序<br>读取一串字节，不能随机访问中间的数据。（RandomAccessFile除外）</li>
<li>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能<br>，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，<br>如果既要写入数据，又要读取数据，则要分别提供两个流</li>
</ol>
<h3 id="Java-IO流的分类"><a href="#Java-IO流的分类" class="headerlink" title="Java IO流的分类"></a>Java IO流的分类</h3><p>IO流主要的分类方式有以下3种：</p>
<ol>
<li>按数据流的方向：输入流、输出流</li>
<li>按处理数据单位：字节流、字符流</li>
<li>按功能：节点流、处理流</li>
</ol>
<h4 id="输入流与输出流"><a href="#输入流与输出流" class="headerlink" title="输入流与输出流"></a>输入流与输出流</h4><p>输入与输出是相对于应用程序而言的，比如文件读写，读取文件是输入流，写文<br>件是输出流，这点很容易搞反</p>
<h4 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h4><p>字节流和字符流的用法几乎完全一样，区别在于字节流和字符流所操作的数据<br>单元不同，字节流操作的单元是数据单元是8位的字节，字符流操作的是数据<br>单元为16位的字符</p>
<h4 id="为什么要有字符流"><a href="#为什么要有字符流" class="headerlink" title="为什么要有字符流"></a>为什么要有字符流</h4><p>Java中字符是采用Unicode标准，Unicode 编码中，一个英文为一个字节，一<br>个中文为两个字节。而在UTF-8编码中，一个中文字符是3个字节。如果使用字节<br>流处理中文，如果一次读写一个字符对应的字节数就不会有问题，一旦将一个<br>字符对应的字节分裂开来，就会出现乱码了。并且如果我们不知道编码类型就<br>很容易出现乱码问题。为了更方便地处理中文这些字符，Java 就推出了字符<br>流。字节流和字符流的其他区别如下</p>
<ol>
<li>字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一<br>般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本<br>文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本<br>文件</li>
<li>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字<br>符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了</li>
</ol>
<h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><ol>
<li>节点流：直接操作数据读写的流类，比如FileInputStream</li>
<li>处理流：对一个已存在的流的链接和封装，通过对数据进行处理为程序提供<br>功能强大、灵活的读写功能，例如BufferedInputStream（缓冲字节流）</li>
</ol>
<p>程序与磁盘的交互相对于内存运算是很慢的，容易成为程序的性能瓶颈。减少程<br>序与磁盘的交互，是提升程序效率一种有效手段。缓冲流，就应用这种思路：普<br>通流每次读写一个字节，而缓冲流在内存中设置一个缓存区，缓冲区先存储足<br>够的待操作数据后，再与内存或磁盘进行交互。这样在总数据量不变的情况下<br>，通过提高每次交互的数据量，减少了交互次数</p>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>InputStream与OutputStream是两个抽象类，是字节流的基类，所有具体的字节<br>流实现类都是分别继承了这两个类</p>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>与字节流类似，字符流也有两个抽象基类，分别是Reader和Writer。其他的字符<br>流实现类都是继承了这两个类</p>
<h3 id="Java-IO使用的设计模式"><a href="#Java-IO使用的设计模式" class="headerlink" title="Java IO使用的设计模式"></a>Java IO使用的设计模式</h3><p>使用了适配器模式和装饰器模式</p>
<ol>
<li>适配器模式 把一个类的接口变换成客户端所期待的另一种接口，从而<br>使原本因接口不匹配而无法在一起工作的两个类能够在一起工作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现从字节流解码成字符流；</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line"><span class="comment">//字节输出流转字符输出流通过</span></span><br><span class="line">Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream);</span><br></pre></td></tr></table></figure></li>
<li>装饰器模式 一种动态地往一个类中添加新的行为的设计模式。就功能而<br>言，装饰器模式相比生成子类更为灵活，这样可以给某个对象而不是整个<br>类添加一些功能，BufferedInputStream 为FileInputStream 提供缓<br>存的功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(inputStream));</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h3><ol>
<li>通过 Scanner<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></li>
<li>通过 BufferedReader<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="阻塞和非阻塞IO"><a href="#阻塞和非阻塞IO" class="headerlink" title="阻塞和非阻塞IO"></a>阻塞和非阻塞IO</h3><p>IO操作包括：对硬盘的读写、对socket的读写以及外围设备的读写。<br>当用户线程发起一个IO请求操作，内核会去查看要读取的数据是否就绪，对于阻<br>塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪，对于非阻塞<br>IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数<br>据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完<br>整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：</p>
<ol>
<li>查看数据是否就绪</li>
<li>进行数据拷贝（内核将数据拷贝到用户线程）</li>
</ol>
<p>那么阻塞和非阻塞的区别就在于第一个阶段，如果数据没有就绪，在查看数据<br>是否就绪的过程中是一直等待，还是直接返回一个标志信息。Java中传统的IO<br>都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没<br>有就绪，当前线程就会一直阻塞在read 方法调用那里，直到有数据才返回，<br>而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信<br>息，告知当前线程数据没有就绪，而不是一直在那里等待</p>
<h3 id="同步和异步IO"><a href="#同步和异步IO" class="headerlink" title="同步和异步IO"></a>同步和异步IO</h3><ol>
<li>同步IO：当用户发出IO请求操作后，内核会去查看要读取的数据是否就<br>绪，如果没有，就一直等待。期间用户线程或内存会不断地轮询数据是否就<br>绪。当数据就绪时，再把数据从内核拷贝到用户空间</li>
<li>异步IO：用户线程只需发出IO请求和接收IO操作完成通知，期间的IO操<br>作由内核自动完成，并发送通知告知用户线程IO操作已经完成。也就是说，<br>在异步IO中，并不会对用户线程产生任何阻塞</li>
</ol>
<h3 id="Java-常见IO-模型"><a href="#Java-常见IO-模型" class="headerlink" title="Java 常见IO 模型"></a>Java 常见IO 模型</h3><ol>
<li>BIO(Blocking I/O) BIO属于同步阻塞IO 模型。同步阻塞IO 模型中，应用<br>程序发起 read 调用后会一直阻塞，直到在内核把数据拷贝到用户空间。在客户<br>端连接数量不高的情况下是没问题的。但是当面对十万甚至百万级连接的时候，<br>传统的 BIO 模型是无能为力的。因此我们需要一种更高效的I/O 处理模型来应<br>对更高的并发量</li>
<li>NIO(Non-blocking/New I/O) 对应java.nio包，提供了Channel, Selector<br>，Buffer 等抽象。NIO 中的N 可以理解为Non-blocking，不单纯是New。它支持面<br>向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使<br>用NIO。NIO 可以看作是I/O 多路复用模型</li>
<li>AIO (Asynchronous I/O) 异步IO 模型。异步IO 是基于事件和回调机制实<br>现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操<br>作系统会通知相应的线程进行后续的操作</li>
</ol>
<h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别"></a>BIO,NIO,AIO 有什么区别</h3><ol>
<li>BIO：Block IO 同步阻塞式IO，就是我们平常使用的传统IO，它的特点<br>是模式简单使用方便，并发处理能力低。在服务器中实现的模式为一个连接<br>一个线程。也就是说客户端有连接请求的时候，服务器就需要启动一个线程<br>进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这<br>也可以通过线程池机制改善。BIO 一般适用于连接数目小且固定的架构，<br>这种方式对于服务器资源要求比较高，而且并发局限于应用中，是<br>JDK1.4之前的唯一选择，但好在程序直观简单，易理解</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端<br>通过Channel（通道）通讯，实现了多路复用。同步并非阻塞，在服务器中<br>实现的模式为一个请求一个线程，也就是说客户端发送的连接请求都会注<br>册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程<br>进行处理。NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并<br>发局限于应用中，编程比较复杂，从JDK1.4开始支持</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非<br>阻塞IO ，异步 IO 的操作基于事件和回调机制。异步并非阻塞，在服务器<br>中实现的模式为一个有效请求一个线程，也就是说，客户端的IO请求都是<br>通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO<br>一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作<br>系统参与并发操作，编程比较复杂，从JDK1.7开始支持</li>
</ol>
<h3 id="有了解过Java中的NIO吗？原理是什么？"><a href="#有了解过Java中的NIO吗？原理是什么？" class="headerlink" title="有了解过Java中的NIO吗？原理是什么？"></a>有了解过Java中的NIO吗？原理是什么？</h3><ol>
<li>基于直接内存实现</li>
<li>NIO底层原理，同步非阻塞的IO模型，它是面向缓冲区的</li>
</ol>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO实现高性能处理的原理是使用较少的线程处理更多的任务</p>
<h3 id="NIO和IO的区别"><a href="#NIO和IO的区别" class="headerlink" title="NIO和IO的区别"></a>NIO和IO的区别</h3><ol>
<li>IO是面向流的，NIO是面向缓冲区的。 Java IO 面向流意味着每次从流中<br>读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。NIO 的<br>缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，一次处理一个<br>数据块</li>
<li>IO的各种流是阻塞的。这意味着当一个线程调用read()或write()时，该<br>线程被阻塞，直到有一些数据被读取或写入。该线程在此期间不能再干任何事<br>情了。 NIO 的非阻塞模式使一个线程从某通道发送请求读取数据，但是它仅<br>能得到目前可用的数据，如果目前没有数据可用时就什么都不会获取。而不<br>是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他<br>的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需<br>要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO<br>的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管<br>理多个输入和输出通道</li>
<li>常规io使用的byte[]、char[]进行封装，而NIO采用ByteBuffer类来操<br>作数据，再结合针对File或socket技术的channel，采用同步非阻塞技术来<br>实现高性能处理，而Netty正是采用ByteBuffer（缓冲区）、Channel（通<br>道）、Selector（选择器）进行封装的</li>
<li>传统IO基于字节流和字符流进行操作，NIO基于Channel和Buffer(缓冲区)<br>进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<br>Selector（选择区）用于监听多个通道的事件（比如：连接打开，数据到<br>达）。因此单个线程可以监听多个数据通道。</li>
</ol>
<h3 id="为什么使用NIO"><a href="#为什么使用NIO" class="headerlink" title="为什么使用NIO"></a>为什么使用NIO</h3><ol>
<li>传统的服务器端同步阻塞 I/O 处理使用多线程，主要原因在于socket.<br>accept()、socket.read()、socket.write() 三个主要函数都是同步阻塞<br>的，当一个连接在处理I/O 的时候，系统是阻塞的，如果是单线程的话必然<br>就挂死在那里；但CPU是被释放出来的，开启多线程，就可以让CPU去处理更<br>多的事情。其实这也是所有使用多线程的本质： 1. 利用多核。 2. 当I/O<br>阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</li>
<li>现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低<br>。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不<br>错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多<br>考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲<br>一些系统处理不了的连接或请求。</li>
<li>这个模型最本质的问题在于严重依赖于线程。但线程是很”贵”的资源，主<br>要表现在： 1. 线程的创建和销毁成本很高，在Linux这样的操作系统中，<br>线程本质上就是一个进程。创建和销毁都是重量级的系统函数。 2. 线程本<br>身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果<br>系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。 3. 线程的切<br>换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，<br>然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于<br>线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率<br>特别高（超过20%以上)，导致系统几乎陷入不可用的状态。 4. 容易造成<br>锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程<br>数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返<br>回，激活大量阻塞线程从而使系统负载压力过大。</li>
<li>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待<br>就绪阶段都是非阻塞的，真正的I/O 操作是同步阻塞的（消耗CPU但性能非<br>常高）。回忆BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，<br>一是没有办法知道到底能不能写、能不能读，只能”傻等”，即使通过各种估<br>算，算出来操作系统没有能力进行读写，也没法在socket.read()和socket<br>.write()函数中返回，这两个函数无法进行有效的中断。所以除了多开线程<br>另起炉灶，没有好的办法利用CPU</li>
<li>NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机<br>会：如果一个连接不能读写（socket.read()返回0或者socket.write()<br>返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注<br>册标记位，然后切换到其它就绪的连接（channel）继续进行读写。</li>
</ol>
<h3 id="NIO同步非阻塞特性"><a href="#NIO同步非阻塞特性" class="headerlink" title="NIO同步非阻塞特性"></a>NIO同步非阻塞特性</h3><p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。<br>我们首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时<br>机告诉事件选择器：我对这个事件感兴趣。对于写操作，就是写不出去的时候<br>对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的<br>数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一<br>般是connect失败需要重连或者直接异步调用connect的时候。<br>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6 之前是<br>select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事<br>件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写<br>或者有连接到来。<br>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的<br>轮询(select，poll )，这个函数是阻塞的。所以你可以放心大胆地在一个<br>while(true)里面调用这个函数而不用担心CPU空转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IO线程主循环:</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">IoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Channel channel;</span><br><span class="line">   <span class="keyword">while</span>(channel=Selector.select())&#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">      <span class="keyword">if</span>(channel.event==accept)&#123;</span><br><span class="line">         registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(channel.event==write)&#123;</span><br><span class="line">         getChannelHandler(channel).channelWritable(channel);</span><br><span class="line">         <span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(channel.event==read)&#123;</span><br><span class="line">          getChannelHandler(channel).channelReadable(channel);</span><br><span class="line">          <span class="comment">//如果可以读，则执行读事件</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化线程模型"><a href="#优化线程模型" class="headerlink" title="优化线程模型"></a>优化线程模型</h3><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读<br>写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要<br>阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p>
<h3 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h3><p>一般情况下，I/O 复用机制需要事件分发器。事件分发器的作用，即将那些读写<br>事件源分发给各读写事件的处理者，开发人员在开始的时候需要在分发器那里<br>注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函<br>数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调<br>函数。涉及到事件分发器的两种模式称为：Reactor和Proactor。 </p>
<ol>
<li>Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。在<br>Reactor 模式中，事件分发器等待某个事件或者可应用或可操作的状态发生<br>（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事<br>件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</li>
<li>而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起<br>一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发<br>起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于<br>存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得<br>知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事<br>件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO<br>操作（称为overlapped技术），事件分发器等IO Complete事件完成。这<br>种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之<br>为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系<br>统代劳的。</li>
<li>Reactor模式：主动模式，所谓主动，是指应用程序不断轮询，询问操作系<br>统或者网络框架，IO是否就绪。其中java的NIO就属于这种模式。在这种模式下<br>，实际的IO操作还是应用程序执行的。</li>
<li>Procator模式：被动模式，应用程序的读写函数操作交给操作系统或者<br>网络框架，实际IO操作由操作系统或者网络框架完成，之后再回调应用程序<br>。微软的asio库就是这种模式。</li>
</ol>
<h3 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h3><ol>
<li>采用轮询的方式：线程不断轮询询问相关事件发生源有没有发生事件，有发<br>生事件就调用事件处理逻辑</li>
<li>事件驱动方式：发生事件，主线程把事件加入到事件队列，在另外线程不断<br>循环消费事件列表的事件，调用事件对应的处理逻辑事件。事件驱动方式也被称<br>为消息通知方式，其实是设计模式中观察者模式的思路。基于事件驱动的优点：<br>可扩展性好，高性能。</li>
</ol>
<h3 id="在Reactor中实现读"><a href="#在Reactor中实现读" class="headerlink" title="在Reactor中实现读"></a>在Reactor中实现读</h3><ol>
<li>注册读就绪事件和相应的事件处理器。</li>
<li>事件分发器等待事件。</li>
<li>事件到来，激活分发器，分发器调用事件对应的处理器。</li>
<li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返<br>还控制权。</li>
</ol>
<p>Reactor线程模型中2个关键组成：</p>
<ol>
<li>Reactor:Reactor在一个单独的线程运行，负责监听和分发事件，分发给适<br>当的处理程序来对IO事件做出反应。</li>
<li>Handlers:处理程序执行I/O事件要完成的实际事件。</li>
</ol>
<p>Reactor的三种模型：单Reactor单线程、单Reactor多线程、主从Reactor多线程。</p>
<ol>
<li>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服</li>
<li>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 Reactor 多线程，多个前台接待员，多个服务生</li>
</ol>
<p>Netty主要基于主从Reactor多线程模型，主从Reactor主从模型有多个Reactor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainReactor负责客户端的连接请求，并将请求转交给SubReactor</span></span><br><span class="line"><span class="comment">// SubReactor负责相应通道的IO读写请求</span></span><br><span class="line"><span class="comment">// 非IO请求（具体业务逻辑处理)的任务则会直接写入队列，等待worker线程进行处理。</span></span><br><span class="line"></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EvenLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">server.group(bossGroup,workerGroup).channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>bossGroup线程池则只是在bind某个端口后，获得其中一个线程作为MainReactor<br>，专门处理端口的Accept事件，每个端口对应一个Boss线程，workerGroup线程<br>池会被各个SubReactor和Worker线程充分利用。</p>
<ol>
<li>NioEventLoop：维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用</li>
<li>NioEventLoop的run方法，执行I/O任务和非I/O任务：</li>
</ol>
<p>任务分为两种</p>
<ol>
<li>I/O任务：即selectionKey中的ready的事件，如accept、connect、read、<br>write等，由processSelectKeys方法触发。</li>
<li>非I/O任务：添加到taskQueue中的任务，如register0、bind0等任务，由<br>runAllTasks方法触发。</li>
</ol>
<h3 id="在Proactor中实现读"><a href="#在Proactor中实现读" class="headerlink" title="在Proactor中实现读"></a>在Proactor中实现读</h3><ol>
<li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下<br>，处理器无视IO就绪事件，它关注的是完成事件。</li>
<li>事件分发器等待操作完成事件。</li>
<li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并<br>将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li>
<li>事件分发器呼唤处理器。</li>
<li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，<br>并将控制权返回事件分发器。</li>
</ol>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的<br>，譬如：InputStream, OutputStream。而Channel是双向的，既可以用来<br>进行读操作，又可以用来进行写操作。<br>在Java NIO 中的通道（Channel）就相当于操作系统的内核空间（kernel<br>space）的缓冲区，而缓冲区（Buffer）对应的相当于操作系统的用户空间<br>（user space）中的用户缓冲区（user buffer）</p>
<ol>
<li>FileChannel 对应文件IO</li>
<li>DatagramChannel 对应UDP</li>
<li>SocketChannel 对应TCP Client</li>
<li>ServerSocketChannel 对应TCP Server</li>
</ol>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>NIO的channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现<br>非阻塞式的信道。在非阻塞式信道上调用一个方法总是会立即返回。这种调用<br>的返回值指示了所请求的操作完成的程度。<br>例如在一个非阻塞式ServerSocketChannel上调用accept()方法，如果有连<br>接请求来了，则返回客户端SocketChannel，否则返回null。</p>
<h4 id="TCP服务端的NIO写法"><a href="#TCP服务端的NIO写法" class="headerlink" title="TCP服务端的NIO写法"></a>TCP服务端的NIO写法</h4><p>Selector类可以用于避免使用阻塞式客户端中很浪费资源的“忙等”方法。一个<br>Selector实例可以同时检查一组信道的I/O状态。用专业术语来说，选择器就<br>是一个多路开关选择器，因为一个选择器能够管理多个信道上的I/O操作。<br>当一个信道有I/O操作的时候，他会通知Selector，Selector就是记住这个信<br>道有I/O操作，并且知道是何种I/O操作，是读呢？是写呢？还是接受新的连接<br>；所以如果使用Selector ，它返回的结果只有两种结果，一种是0，即在你调<br>用的时刻没有任何客户端需要I/O操作，另一种结果是一组需要I/O操作的客户<br>端。要使用选择器（Selector），需要创建一个Selector实例（使用静态工厂<br>方法open()）并将其注册（register）到想要监控的信道上（注意，这要通过<br>channel的方法实现，而不是使用selector的方法）。最后调用选择器select()<br>方法。该方法会阻塞等待，直到有一个或更多的信道准备好了I/O操作或等待超时。<br>select()方法将返回可进行I/O操作的信道数量。现在，在一个单独的线程中，<br>通过调用select()方法就能检查多个信道是否准备好进行I/O操作。如果经过一<br>段时间后仍然没有信道准备好，select()方法就会返回0，并允许程序继续执行<br>其他任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可<br>以通过调用selector的selectedKeys() 方法，访问“已选择键集（selected<br>key set）”中的就绪通道。当向Selector注册Channel时，Channel.register()<br>方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。</p>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer,<br>FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数<br>据类型: byte, char, double, float, int, long, short。<br>使用Buffer一般遵循下面几个步骤：</p>
<ol>
<li>分配空间（ByteBuffer buf = ByteBuffer.allocate(1024); ）</li>
<li>写入数据到Buffer(int bytesRead = fileChannel.read(buf);)</li>
<li>调用filp()方法（ buf.flip();）在将缓冲区的数据写到输出通道之前<br>调用</li>
<li>从Buffer中读取数据（System.out.print((char)buf.get());）</li>
<li>调用clear()方法或者compact()方法，调用clear()方法：position将<br>被设回0limit设置成capacity，换句话说Buffer被清空了，使用compact()<br>方法。该方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最<br>后一个未读元素正后面</li>
</ol>
<p>Buffer顾名思义：缓冲区，实际上是一个容器，一个连续数组。Channel提供<br>从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。</p>
<ol>
<li>向Buffer中写数据：</li>
</ol>
<ul>
<li>从Channel写到Buffer (fileChannel.read(buf))</li>
<li>通过Buffer的put()方法 （buf.put(…)）</li>
</ul>
<ol start="2">
<li>从Buffer中读取数据：</li>
</ol>
<ul>
<li>从Buffer读取到Channel (channel.write(buf))</li>
<li>使用get()方法从Buffer中读取数据 （buf.get()）</li>
</ul>
<p>可以把Buffer简单地理解为一组基本数据类型的元素列表，它通过几个变量来<br>保存这个数据的当前位置状态：capacity, position, limit, mark：</p>
<ol>
<li>capacity 缓冲区数组的总长度</li>
<li>position 下一个要操作的数据元素的位置</li>
<li>limit 缓冲区数组中不可操作的下一个元素的位置：limit&lt;=capacity</li>
<li>mark用于记录当前position的前一个位置或者默认是-1</li>
</ol>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每<br>个连接的流量都很低，使用Selector 就会很方便。例如在一个聊天服务器中。<br>要使用Selector, 得向Selector注册Channel，然后调用它的select() 方<br>法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，<br>线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。<br>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选<br>择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让<br>一个线程就可以处理多个事件。<br>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还<br>未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找<br>到 IO 事件已经到达的 Channel 执行。</p>
<ol>
<li>创建选择器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></li>
<li>将通道注册到选择器上<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道<br>在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理<br>完毕才能去处理其它事件，显然这和选择器的作用背道而驰。<br>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</li>
</ol>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<ol start="3">
<li>监听事件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure>
使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</li>
<li>获取到达的事件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>事件循环<br>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一<br>直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>JAVA处理大文件，一般用BufferedReader,BufferedInputStream这类带缓冲<br>的IO类，不过如果文件超大的话，更快的方式是采用MappedByteBuffer。<br>MappedByteBuffer是NIO引入的文件内存映射方案，读写性能极高。NIO最主要<br>的就是实现对异步操作支持。其中一种通过把一个套接字通道(SocketChannel)<br>注册到一个选择器(Selector)中,不时调用后者的选择(select)方法就能返回<br>满足的选择键(SelectionKey),键中包含了SOCKET事件信息。这就是select模<br>型。<br>SocketChannel的读写是通过一个类叫ByteBuffer来操作的。ByteBuffer有两<br>种模式:直接/间接。间接模式最典型(也只有这么一种)的就是HeapByteBuffer<br>,即操作堆内存 (byte[]).但是内存毕竟有限，这时就必须使用”直接”模式,即<br>MappedByteBuffer,文件映射。<br>FileChannel提供了map方法来把文件影射为内存映像文件：MappedByteBuffer<br>map(int mode,long position,long size);可以把文件的从position开始的<br>size大小的区域映射为内存映像文件</p>
<h3 id="NIO实现零拷贝"><a href="#NIO实现零拷贝" class="headerlink" title="NIO实现零拷贝"></a>NIO实现零拷贝</h3><p>NIO的零拷贝由transferTo()方法实现。该方法将数据从FileChannel对象传<br>送到可写的字节通道（如Socket Channel等）。在内部实现中，由native方<br>法transferTo0()来实现，它依赖底层操作系统的支持。在UNIX和Linux系统<br>中，调用这个方法将会引起sendfile()系统调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.zip"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fileChannel = raf.getChannel();</span><br><span class="line">SocketChannel socketChannel= SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">""</span>, <span class="number">1234</span>));</span><br><span class="line"><span class="comment">// 直接使用了transferTo()进行通道间的数据传输</span></span><br><span class="line">fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br></pre></td></tr></table></figure>

<h3 id="NIO的直接内存"><a href="#NIO的直接内存" class="headerlink" title="NIO的直接内存"></a>NIO的直接内存</h3><p>它的作用位置处于传统IO（BIO）与零拷贝之间</p>
<ol>
<li>IO，可以把磁盘的文件经过内核空间，读到JVM空间，然后进行各种操作，<br>最后再写到磁盘或是发送到网络，效率较慢但支持数据文件操作</li>
<li>零拷贝则是直接在内核空间完成文件读取并转到磁盘（或发送到网络）。<br>由于它没有读取文件数据到JVM这一环，因此程序无法操作该文件数据，尽<br>管效率很高</li>
</ol>
<p>而直接内存则介于两者之间，效率一般且可操作文件数据。直接内存（mmap技<br>术）将文件直接映射到内核空间的内存，返回==一个操作地址（address）==<br>，它解决了文件数据需要拷贝到JVM才能进行操作的窘境。而是直接在内核空间<br>直接进行操作，省去了内核空间拷贝到用户空间这一步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"test.zip"</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fileChannel = raf.getChannel();</span><br><span class="line">MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, </span><br><span class="line">	<span class="number">0</span>, fileChannel.size());</span><br></pre></td></tr></table></figure>
<p>由于MappedByteBuffer申请的是堆外内存，因此不受Minor GC控制，只能在<br>发生Full GC时才能被回收。<br>直接内存的大小可通过jvm参数来设置：-XX:MaxDirectMemorySize</p>
<h3 id="RPC具体过程"><a href="#RPC具体过程" class="headerlink" title="RPC具体过程"></a>RPC具体过程</h3><p>当远程过程调用，简称为RPC，是一个计算机通信协议，它允许运行于一台<br>计算机的程序调用另一台计算机的子程序，而无需额外地为这个交互作用<br>编程</p>
<ol>
<li>传输效率高(二进制传输)，发起调用的一方无需知道RPC的具体实现，如同<br>调用本地函数般调用</li>
<li>通用性不如HTTP好(HTTP是标准协议)</li>
<li>RPC适合内部服务间的通信调用；HTTP适合面向用户与服务间的通信调用</li>
</ol>
<h3 id="Java-IO分为哪几种？"><a href="#Java-IO分为哪几种？" class="headerlink" title="Java IO分为哪几种？"></a>Java IO分为哪几种？</h3><ol>
<li>BIO：同步阻塞IO</li>
<li>NIO：同步非阻塞IO</li>
<li>AIO：异步非阻塞IO</li>
</ol>
<h3 id="BIO-是什么？"><a href="#BIO-是什么？" class="headerlink" title="BIO 是什么？"></a>BIO 是什么？</h3><ol>
<li>同步阻塞IO，每个客户端的Socket连接请求，服务端都会对应有个处理<br>线程与之对应，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当<br>于是一个连接一个线程</li>
<li>使用一个独立的线程维护一个socket连接，随着连接数量的增多，对虚<br>拟机造成一定压力</li>
<li>使用流来读取数据，流是阻塞的，当没有可读/可写数据时，线程等待<br>，会造成资源的浪费</li>
</ol>
<h3 id="NIO-是什么？"><a href="#NIO-是什么？" class="headerlink" title="NIO 是什么？"></a>NIO 是什么？</h3><ol>
<li>同步非阻塞，也就是说如果你调用NIO接口去执行IO操作，其实还是同步<br>等待的，但是在底层的IO操作上 ，会对系统内核发起非阻塞IO请求，以非<br>阻塞的形式来执行IO。也就是说，如果底层数据没到位，那么内核返回异常<br>信息，不会阻塞住，但是NIO接口内部会采用非阻塞方式过一会儿再次调用<br>内核发起IO请求，直到成功为止。但是之所以说是同步非阻塞，这里的“同<br>步”指的就是因为在你的Java代码调用NIO接口层面是同步的，你还是要同<br>步等待底层IO操作真正完成了才可以返回，只不过在执行底层IO的时候采<br>用了非阻塞的方式来执行罢了</li>
<li>服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发<br>现某个Socket端口上有数据可读时说明读就绪，则调用该socket连接的相<br>应读操作。如果发现某个 Socket端口上有数据可写时说明写就绪，则调用<br>该socket连接的相应写操作。如果某个端口的Socket连接已经中断，则调<br>用相应的析构方法关闭该端口</li>
<li>每个线程中包含一个Selector对象，它相当于一个通道管理器，可以实<br>现在一个线程中处理多个通道的目的，减少线程的创建数量。远程连接对应<br>一个channel，数据的读写通过buffer均在同一个channel中完成，并且<br>数据的读写是非阻塞的</li>
<li>通道创建后需要注册在selector中，同时需要为该通道注册感兴趣事件<br>（客户端连接服务端事件、服务端接收客户端连接事件、读事件、写事件），<br>selector线程需要采用轮训的方式调用selector的select函数，直到所<br>有注册通道中有兴趣的事件发生，则返回，否则一直阻塞。而后循环处理<br>所有就绪的感兴趣事件。以上步骤解决BIO的两个瓶颈：</li>
</ol>
<ul>
<li>不必对每个连接分别创建线程</li>
<li>数据读写非阻塞</li>
</ul>
<p>Java NIO由以下三个核心部分组成</p>
<ol>
<li>selector：Selector 允许单线程处理多个Channel。如果你的应用打开<br>了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便<br>。要使用Selector，得向Selector注册Channel，然后调用他的select 方<br>法，这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回<br>，线程就可以处理这些事件，事件的例子入有新连接接进来，数据接收等</li>
<li>Channel：基本上所有的IO在NIO中都从一个Channel开始。Channel有点<br>像流，数据可以从channel读到buffer，也可以从buffer写到channel</li>
<li>Buffer：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个<br>容器对象( 含数组)，该对象提供了一组方法，可以更轻松的使用内存块，缓<br>冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变换情况，Channel<br>提供从文件，网络读取数据的渠道，但是读取或者写入的数据都必须经由Buffer</li>
</ol>
<h3 id="NIO-和IO-多路复用的关系？"><a href="#NIO-和IO-多路复用的关系？" class="headerlink" title="NIO 和IO 多路复用的关系？"></a>NIO 和IO 多路复用的关系？</h3><ol>
<li>实际上，如果基于NIO进行网络通信，采取的就是多路复用的IO模型，这个<br>多路复用IO模型针对的是网络通信中的IO场景来说的</li>
<li>简单来说，就是在基于Socket进行网络通信的时候，如果有多个客户端跟<br>你的服务端建立了Socket连接，那你就需要维护多个Socket连接</li>
<li>而所谓的多路复用IO模型，就是说你的Java代码直接通过一个select函数<br>调用，直接会进入一个同步等待的状态。必须在这里同步等待某个Socket连接<br>有请求到来，接着你就要同步等着select函数去对底层的多个Socket 连接<br>进行轮询，不断的查看各个 Socket 连接谁有请求到达，就可以让select<br>函数返回</li>
<li>select函数在底层会通过非阻塞的方式轮询各个Socket，任何一个Socket<br>如果没有数据到达，那么非阻塞的特性会立即返回一个信息，然后select函数<br>可以轮询下一个Socket，不会阻塞在某个Socket上</li>
<li>这就是所谓的“同步非阻塞”，但是因为操作系统把上述工作都封装在一个<br>select函数调用里了，可以对多路Socket连接同时进行监视，所以就把这种<br>模型称之为“IO多路复用”模型</li>
<li>通过这种IO多路复用的模型，就可以用一个线程，调用一个select函数<br>，然后监视大量的客户端连接</li>
</ol>
<h3 id="AIO-是什么？"><a href="#AIO-是什么？" class="headerlink" title="AIO 是什么？"></a>AIO 是什么？</h3><ol>
<li>AIO是异步非阻塞IO，相比NIO更进一步，进程读取数据时只负责发送跟接<br>收指令，数据的准备工作完全由操作系统来处理</li>
<li>可以基于AIO API发起一个请求，比如说接收网络数据，AIO API底层会<br>基于异步IO模型来调用操作系统内核，此时不需要去管这个IO是否成功了，<br>AIO接口会直接返回</li>
<li>BIO、NIO都是同步的，你发起IO请求，都必须同步等待IO操作完成</li>
<li>不过你需要提供一个回调函数给AIO接口，一旦底层系统内核完成了具体<br>的IO请求，比如网络读写之类的，就会回调你提供的回调函数</li>
</ol>
<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><h3 id="多线程IO的致命缺陷"><a href="#多线程IO的致命缺陷" class="headerlink" title="多线程IO的致命缺陷"></a>多线程IO的致命缺陷</h3><p>最最原始的网络编程思路就是服务器用一个while循环，不断监听端口是否有新<br>的套接字连接，如果有那么就调用一个处理函数处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	socket = accept();</span><br><span class="line">	handle(socket)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的最大问题是无法并发，效率太低，如果当前的请求没有处理完，那么<br>后面的请求只能被阻塞，服务器的吞吐量太低。之后想到了使用多线程，也就是<br>很经典的connection per thread，每一个连接用一个线程处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicModel</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket ss =</span><br><span class="line">                    <span class="keyword">new</span> ServerSocket(SystemConfig.SOCKET_SERVER_PORT);</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted())</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Handler(ss.accept())).start();</span><br><span class="line">            <span class="comment">//创建新线程来handle</span></span><br><span class="line">            <span class="comment">// or, single-threaded, or a thread pool</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Socket socket;</span><br><span class="line">        Handler(Socket s) &#123; socket = s; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[SystemConfig.INPUT_SIZE];</span><br><span class="line">                socket.getInputStream().read(input);</span><br><span class="line">                <span class="keyword">byte</span>[] output = process(input);</span><br><span class="line">                socket.getOutputStream().write(output);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] process(<span class="keyword">byte</span>[] input) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] output=<span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每一个请求都分发给一个线程，每个线程中都独自处理上面的流程。tomcat<br>服务器的早期版本确实是这样实现的。<br>多线程并发模式，一个连接一个线程的优点是：<br>一定程度上极大地提高了服务器的吞吐量，因为之前的请求在read阻塞以后，不<br>会影响到后续的请求，因为他们在不同的线程中。这也是为什么通常会讲“一个线<br>程只能对应一个socket”的原因。另外有个问题如果一个线程中对应多个socket<br>连接不行吗？语法上确实可以，但是实际上没有用，每一个socket都是阻塞的<br>，所以在一个线程里只能处理一个socket，就算accept了多个也没用，前一个<br>socket被阻塞了，后面的是无法被执行到的。<br>多线程并发模式，一个连接一个线程的缺点是：<br>缺点在于资源要求太高，系统中创建线程是需要比较高的系统资源的，如果连接数<br>太高，系统无法承受，而且线程的反复创建-销毁也需要代价。<br>改进方法是：采用基于事件驱动的设计，当有事件触发时，才会调用处理器进行<br>数据处理。使用Reactor模式对线程的数量进行控制，一个线程处理大量的事件。</p>
<h3 id="单线程Reactor模型"><a href="#单线程Reactor模型" class="headerlink" title="单线程Reactor模型"></a>单线程Reactor模型</h3><p>Java的NIO模式的Selector网络通讯，其实就是一个简单的Reactor模型。可以<br>说是Reactor模型的朴素原型。负责多路分离套接字，Accept新连接，并分派请<br>求到Handler处理器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span></span><br><span class="line"><span class="class">   </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="comment">// 1、获取Selector选择器</span></span><br><span class="line">           Selector selector = Selector.open();</span><br><span class="line">           <span class="comment">// 2、获取通道</span></span><br><span class="line">           ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">           <span class="comment">// 3.设置为非阻塞</span></span><br><span class="line">           serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">           <span class="comment">// 4、绑定连接</span></span><br><span class="line">           serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(SystemConfig.</span><br><span class="line">           	SOCKET_SERVER_PORT));</span><br><span class="line">           <span class="comment">// 5、将通道注册到选择器上,并注册的操作为：“接收”操作</span></span><br><span class="line">           serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">           <span class="comment">// 6、采用轮询的方式，查询获取“准备就绪”的注册过的操作</span></span><br><span class="line">           <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 7、获取当前选择器中所有注册的选择键（“已经准备就绪的操作”）</span></span><br><span class="line">               Iterator&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys().</span><br><span class="line">               iterator();</span><br><span class="line">               <span class="keyword">while</span> (selectedKeys.hasNext())</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 8、获取“准备就绪”的时间</span></span><br><span class="line">                   SelectionKey selectedKey = selectedKeys.next();</span><br><span class="line">                   <span class="comment">// 9、判断key是具体的什么事件</span></span><br><span class="line">                   <span class="keyword">if</span> (selectedKey.isAcceptable())</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="comment">// 10、若接受的事件是“接收就绪” 操作,就获取客户端连接</span></span><br><span class="line">                       SocketChannel socketChannel = serverSocketChannel.</span><br><span class="line">                       	accept();</span><br><span class="line">                       <span class="comment">// 11、切换为非阻塞模式</span></span><br><span class="line">                       socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                       <span class="comment">// 12、将该通道注册到selector选择器上</span></span><br><span class="line">                       socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (selectedKey.isReadable())</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="comment">// 13、获取该选择器上的“读就绪”状态的通道</span></span><br><span class="line">                       SocketChannel socketChannel = (SocketChannel) </span><br><span class="line">                       selectedKey.channel();</span><br><span class="line">                       <span class="comment">// 14、读取数据</span></span><br><span class="line">                       ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                       <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">                       <span class="keyword">while</span> ((length = socketChannel.read(byteBuffer)) != -<span class="number">1</span>)</span><br><span class="line">                       &#123;</span><br><span class="line">                           byteBuffer.flip();</span><br><span class="line">                           System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), </span><br><span class="line">                           	<span class="number">0</span>, length));</span><br><span class="line">                           byteBuffer.clear();</span><br><span class="line">                       &#125;</span><br><span class="line">                       socketChannel.close();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 15、移除选择键</span></span><br><span class="line">                   selectedKeys.remove();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 7、关闭连接</span></span><br><span class="line">           serverSocketChannel.close();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           testServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>实际上的Reactor模式，是基于Java NIO的，在他的基础上，抽象出来两个组件<br>——Reactor和Handler两个组件：</p>
<ol>
<li>Reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的<br>Handler去处理；新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li>Handler:将自身（handler）与事件绑定，负责事件的处理，完成channel<br>的读入，完成处理业务逻辑后，负责将结果写出channel。</li>
</ol>
<p>单线程模式的缺点:</p>
<ol>
<li>当其中某个 handler 阻塞时，会导致其他所有的 client 的 handler都<br>得不到执行， 并且更严重的是， handler 的阻塞也会导致整个服务不能接收<br>新的 client 请求(因为 acceptor 也被阻塞了)。 因为有这么多的缺陷，因<br>此单线程Reactor模型用的比较少。这种单线程模型不能充分利用多核资源，<br>所以实际使用的不多。</li>
<li>因此单线程模型仅仅适用于handler 中业务处理组件能快速完成的场景</li>
</ol>
<h3 id="多线程的Reactor"><a href="#多线程的Reactor" class="headerlink" title="多线程的Reactor"></a>多线程的Reactor</h3><p>在单线程Reactor模式基础上，做如下改进：</p>
<ol>
<li>将Handler处理器的执行放入线程池，多线程进行业务处理。</li>
<li>而对于Reactor而言，可以仍为单个线程。如果服务器为多核的CPU，为充分<br>利用系统资源，可以将Reactor拆分为两个线程。</li>
</ol>
<h2 id="Java命名规范"><a href="#Java命名规范" class="headerlink" title="Java命名规范"></a>Java命名规范</h2><h3 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h3><ol>
<li>大驼峰命名法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类名需要使用大驼峰命名法</span><br><span class="line">ServiceDiscovery、ServiceInstance、LruCacheFactory</span><br></pre></td></tr></table></figure></li>
<li>小驼峰命名法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法名、参数名、成员变量、局部变量需要使用小驼峰命名法</span><br><span class="line">getUserInfo()、createCustomThreadPool()、setNameFormat(String nameFormat)</span><br><span class="line">uservice userService;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="蛇形命名法"><a href="#蛇形命名法" class="headerlink" title="蛇形命名法"></a>蛇形命名法</h3><p>测试方法名、常量、枚举名称需要使用蛇形命名法，在蛇形命名法中，各个单词<br>之间通过下划线“_”连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">should_get_200_status_code_when_request_is_valid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见规范"><a href="#常见规范" class="headerlink" title="常见规范"></a>常见规范</h3><ol>
<li>包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 “.” 分隔符连<br>接，并且各个单词必须为单数</li>
<li>抽象类命名使用 Abstract 开头</li>
<li>异常类命名使用 Exception 结尾</li>
<li>测试类命名以它要测试的类的名称开始，以Test 结尾</li>
<li>项目名全部小写，多个单词用中划线分隔‘-’</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/05/30/Java%E6%80%BB%E7%BB%932/">https://skysea-gaoming.github.io/2021/05/30/Java%E6%80%BB%E7%BB%932/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/31/RPC%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>RPC总结</span></a></div><div class="next-post pull-right"><a href="/2021/05/24/shell%E6%80%BB%E7%BB%93/"><span>Shell总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/05/30/Java%E6%80%BB%E7%BB%932/';
  this.page.identifier = '2021/05/30/Java总结2/';
  this.page.title = 'Java总结2';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>