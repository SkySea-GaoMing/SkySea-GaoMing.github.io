<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="高并发选课项目3"><meta name="keywords" content="项目"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>高并发选课项目3 | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#事务型消息"><span class="toc-number">1.</span> <span class="toc-text">事务型消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异步消息发送时机问题"><span class="toc-number">1.1.</span> <span class="toc-text">异步消息发送时机问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事务提交问题"><span class="toc-number">1.1.1.</span> <span class="toc-text">事务提交问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方法"><span class="toc-number">1.1.2.</span> <span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务型消息-1"><span class="toc-number">1.2.</span> <span class="toc-text">事务型消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#库存流水"><span class="toc-number">2.</span> <span class="toc-text">库存流水</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UNKNOWN状态处理"><span class="toc-number">2.1.</span> <span class="toc-text">UNKNOWN状态处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#库存售罄处理"><span class="toc-number">2.2.</span> <span class="toc-text">库存售罄处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流量削峰"><span class="toc-number">3.</span> <span class="toc-text">流量削峰</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#业务解耦—秒杀令牌"><span class="toc-number">3.1.</span> <span class="toc-text">业务解耦—秒杀令牌</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#限流—令牌大闸"><span class="toc-number">3.1.1.</span> <span class="toc-text">限流—令牌大闸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#限流-对列泄洪"><span class="toc-number">3.2.</span> <span class="toc-text">限流-对列泄洪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#防刷限流"><span class="toc-number">3.3.</span> <span class="toc-text">防刷限流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#验证码"><span class="toc-number">3.3.1.</span> <span class="toc-text">验证码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#限并发"><span class="toc-number">3.3.2.</span> <span class="toc-text">限并发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#限流方案—令牌桶-漏桶"><span class="toc-number">3.4.</span> <span class="toc-text">限流方案—令牌桶&#x2F;漏桶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RateLimiter限流实现"><span class="toc-number">3.4.1.</span> <span class="toc-text">RateLimiter限流实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#登录态管理"><span class="toc-number">4.</span> <span class="toc-text">登录态管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql性能"><span class="toc-number">5.</span> <span class="toc-text">mysql性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql分布式架构扩展"><span class="toc-number">6.</span> <span class="toc-text">mysql分布式架构扩展</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">高并发选课项目3</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/05/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%80%89%E8%AF%BE%E9%A1%B9%E7%9B%AE3/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/05/11/高并发选课项目3/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="事务型消息"><a href="#事务型消息" class="headerlink" title="事务型消息"></a>事务型消息</h2><h3 id="异步消息发送时机问题"><a href="#异步消息发送时机问题" class="headerlink" title="异步消息发送时机问题"></a>异步消息发送时机问题</h3><p>目前扣减库存的事务ItemService.decreaseStock是封装在OrderService<br>.createOrder事务里面的。在扣减Redis 库存、发送异步消息之后，还有订<br>单入库、增加销量的操作。如果这些操作失败，那么createOrder 事务会回<br>滚，decreaseStock事务也回滚，但是Redis的扣减操作却不能回滚，会导<br>致数据不一致。<br>解决的方法就是在订单入库、增加销量成功之后再发送异步消息，ItemService<br>.decreaseStock只负责扣减Redis库存，不发送异步消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow=redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span>+itemId,amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//&gt;0，表示Redis扣减成功</span></span><br><span class="line">    <span class="keyword">if</span>(affectedRow&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//抽离了发送异步消息的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Redis扣减失败，回滚</span></span><br><span class="line">        increaseStock(itemId, amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().increment(<span class="string">"promo_item_stock_"</span>+</span><br><span class="line">    	itemId,amount.intValue());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将发送异步消息的逻辑抽取出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ItemService</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncDecreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mqProducer.asyncReduceStock(itemId, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再在OrderService.createOrder里面调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="comment">//订单入库</span></span><br><span class="line">orderDOMapper.insertSelective(orderDO);</span><br><span class="line"><span class="comment">//销量增加</span></span><br><span class="line">itemService.increaseSales(itemId,amount);</span><br><span class="line"><span class="comment">//执行完最后一步才发送异步消息</span></span><br><span class="line"><span class="keyword">boolean</span> mqResult=itemService.asyncDecreaseStock(itemId,amount);</span><br><span class="line">    <span class="keyword">if</span>(!mqResult)&#123;</span><br><span class="line">        <span class="comment">//回滚redis库存</span></span><br><span class="line">        itemService.increaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.MQ_SEND_FAIL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样就算订单入库失败、销量增加失败、消息发送失败，都能保证缓存和数<br>据库的一致性</p>
<h4 id="事务提交问题"><a href="#事务提交问题" class="headerlink" title="事务提交问题"></a>事务提交问题</h4><p>但是这么做，依然有问题。Spring 的@Transactional 标签，会在事务方法<br>返回后才提交，如果提交的过程中，发生了异常，则数据库回滚，但是Redis<br>库存已扣，还是无法保证一致性。我们需要在事务提交成功后再发送异步消息</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>TransactionSynchronizationManager.registerSynchronization方法<br>，这个方法的传入一个TransactionSynchronizationAdapter的匿名类，<br>通过afterCommit方法，在事务提交成功后，执行发送消息操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(</span><br><span class="line">	<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> mqResult=itemService.asyncDecreaseStock(itemId,amount);</span><br><span class="line">    <span class="keyword">if</span>(!mqResult)&#123;</span><br><span class="line">        itemService.increaseStock(itemId,amount);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.MQ_SEND_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务型消息-1"><a href="#事务型消息-1" class="headerlink" title="事务型消息"></a>事务型消息</h3><p>上面的做法，依然不能保证万无一失。假设现在事务提交成功了，等着执行<br>afterCommit方法，这个时候突然宕机了，那么订单已然入库，销量已然<br>增加，但是去数据库扣减库存的这条消息却“丢失”了。这里就需要引入<br>RocketMQ的事务型消息。<br>所谓事务型消息，也会被发送到消息队列里面，这条消息处于prepared状<br>态，broker会接受到这条消息，但是不会把这条消息给消费者消费。该状<br>态的消息，会执行TransactionListener的executeLocalTransaction<br>方法，根据执行结果，改变事务型消息的状态，让消费端消费或是不消费<br>在mq.MqProducer类里面新注入一个TransactionMQProducer类，与<br>DefaultMQProducer类似，也需要设置服务器地址、命名空间等。<br>新建一个transactionAsyncReduceStock的方法，该方法使用事务型消<br>息进行异步扣减库存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务型消息同步库存扣减消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transactionAsyncReduceStock</span><span class="params">(Integer userId, Integer itemId, Integer promoId, Integer amount, String stockLogId)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; bodyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    bodyMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    bodyMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    <span class="comment">//用于执行orderService.createOrder的传参</span></span><br><span class="line">    Map&lt;String, Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    argsMap.put(<span class="string">"itemId"</span>, itemId);</span><br><span class="line">    argsMap.put(<span class="string">"amount"</span>, amount);</span><br><span class="line">    argsMap.put(<span class="string">"userId"</span>, userId);</span><br><span class="line">    argsMap.put(<span class="string">"promoId"</span>, promoId);</span><br><span class="line"></span><br><span class="line">    Message message = <span class="keyword">new</span> Message(topicName, <span class="string">"increase"</span>,</span><br><span class="line">                JSON.toJSON(bodyMap).toString().getBytes(</span><br><span class="line">                	Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注意，发送的是sendMessageInTransaction</span></span><br><span class="line">        transactionMQProducer.sendMessageInTransaction(message, argsMap);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就会发送一个事务型消息到broke，而处于prepared状态的事务型<br>消息，会执行TransactionListener的executeLocalTransaction方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">transactionMQProducer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, </span></span></span><br><span class="line"><span class="function"><span class="params">    	Object args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在事务型消息中去进行下单</span></span><br><span class="line">    Integer itemId = (Integer) ((Map) args).get(<span class="string">"itemId"</span>);</span><br><span class="line">    Integer promoId = (Integer) ((Map) args).get(<span class="string">"promoId"</span>);</span><br><span class="line">    Integer userId = (Integer) ((Map) args).get(<span class="string">"userId"</span>);</span><br><span class="line">    Integer amount = (Integer) ((Map) args).get(<span class="string">"amount"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用下单接口</span></span><br><span class="line">        orderService.createOrder(userId, itemId, promoId, amount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BizException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">//发生异常就回滚消息</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在事务型消息中去执行下单操作，下单失败，则消息回滚，不会去数<br>据库扣减库存。下单成功，则消息被消费，扣减数据库库存</p>
<h2 id="库存流水"><a href="#库存流水" class="headerlink" title="库存流水"></a>库存流水</h2><p>不要以为这样就万事大吉了上述流程还有一个漏洞，就是当执行orderService<br>.createOrder后，突然又宕机了，根本没有返回，这个时候事务型消息就会进<br>入UNKNOWN状态，我们需要处理这个状态。<br>在匿名类TransactionListener里面，还需要覆写checkLocalTransaction方<br>法，这个方法就是用来处理UNKNOWN状态的。应该怎么处理？这就需要引入库存<br>流水。<br>数据库新建一张stock_log的表，用来记录库存流水</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stock_log(</span><br><span class="line">     stock_log_id <span class="built_in">varchar</span>(<span class="number">64</span>) primary <span class="keyword">key</span>,</span><br><span class="line">     item_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">     amount <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">     <span class="keyword">status</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>添加一个ItemService.initStockLog方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">initStockLog</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    StockLogDO stockLogDO = <span class="keyword">new</span> StockLogDO();</span><br><span class="line">    stockLogDO.setItemId(itemId);</span><br><span class="line">    stockLogDO.setAmount(amount);</span><br><span class="line">    stockLogDO.setStockLogId(UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">    <span class="comment">//1表示初始状态，2表示下单扣减库存成功，3表示下单回滚</span></span><br><span class="line">    stockLogDO.setStatus(<span class="number">1</span>);</span><br><span class="line">    stockLogDOMapper.insertSelective(stockLogDO);</span><br><span class="line">    <span class="keyword">return</span> stockLogDO.getStockLogId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事务型消息会调用OrderService.createOrder方法，执行Redis扣减库存<br>、订单入库、销量增加的操作，当这些操作都完成后，就说明下单完成了，<br>等着异步更新数据库了。那么需要修改订单流水的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderService.createOrder</span></span><br><span class="line"><span class="comment">//订单入库</span></span><br><span class="line">orderDOMapper.insertSelective(orderDO);</span><br><span class="line"><span class="comment">//增加销量</span></span><br><span class="line">itemService.increaseSales(itemId, amount);</span><br><span class="line">StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line"><span class="keyword">if</span> (stockLogDO == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR);</span><br><span class="line"><span class="comment">//设置库存流水状态为成功</span></span><br><span class="line">stockLogDO.setStatus(<span class="number">2</span>);</span><br><span class="line">stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);</span><br></pre></td></tr></table></figure>
<p>异步更新数据库，需要事务型消息从prepare状态变成commit状态。假如此时<br>orderService.createOrder本身发生了异常，那么就回滚事务型消息，并<br>且返回LocalTransactionState.ROLLBACK_MESSAGE，这个下单操作就会<br>被取消。<br>如果本身没有发生异常，那么就返回LocalTransactionState.COMMIT_MESSAGE<br>，此时事务型消息会从prepare状态变为commit状态，接着被消费端消费，异<br>步扣减库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MqProducer.TransactionListener().executeLocalTransaction()</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    orderService.createOrder(userId, itemId, promoId, amount, stockLogId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BizException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//如果发生异常，createOrder已经回滚，此时要回滚事务型消息。</span></span><br><span class="line">    <span class="comment">//设置stockLog为回滚状态</span></span><br><span class="line">    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line">    stockLogDO.setStatus(<span class="number">3</span>);</span><br><span class="line">    stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);</span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br></pre></td></tr></table></figure>
<h3 id="UNKNOWN状态处理"><a href="#UNKNOWN状态处理" class="headerlink" title="UNKNOWN状态处理"></a>UNKNOWN状态处理</h3><p>如上节结尾所述，如果在执行createOrder的时候，突然宕机了，此时事务<br>型消息的状态是UNKNOWN，需要在checkLocalTransaction方法中进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据是否扣减库存成功，来判断要返回COMMIT，ROLLBACK还是UNKNOWN</span></span><br><span class="line">    String jsonString = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    Map&lt;String, Object&gt; map = JSON.parseObject(jsonString, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    String stockLogId = (String) map.get(<span class="string">"stockLogId"</span>);</span><br><span class="line">    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);</span><br><span class="line">    <span class="keyword">if</span> (stockLogDO == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    <span class="comment">//订单操作已经完成，等着异步扣减库存，那么就提交事务型消息</span></span><br><span class="line">    <span class="keyword">if</span> (stockLogDO.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    <span class="comment">//订单操作还未完成，需要执行下单操作，那么就维持为prepare状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stockLogDO.getStatus() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就回滚</span></span><br><span class="line">    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="库存售罄处理"><a href="#库存售罄处理" class="headerlink" title="库存售罄处理"></a>库存售罄处理</h3><p>现在是用户请求一次OrderController.createOrder就初始化一次流水，<br>但是如果10000个用户抢10个商品，就会初始化10000次库存流水，这显然<br>是不行的。<br>解决的方法是在ItemService.decreaseStock中，如果库存没有了，就打<br>上“售罄标志”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> affectedRow = redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_item_stock_"</span> + itemId, amount.intValue() * -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (affectedRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (affectedRow == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//打上售罄标识</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_invalid_"</span> + </span><br><span class="line">        	itemId, <span class="string">"true"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        increaseStock(itemId, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在OrderController.createOrder初始化流水之前，先判断一下是否售<br>罄，售罄了就直接抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否售罄</span></span><br><span class="line"><span class="keyword">if</span> (redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span>+itemId))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.STOCK_NOT_ENOUGH);</span><br><span class="line">String stockLogId = itemService.initStockLog(itemId, amount);</span><br></pre></td></tr></table></figure>

<h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p>秒杀秒杀，就是在活动开始的一瞬间，有大量流量涌入，优化不当，会导致<br>服务器停滞，甚至宕机。所以引入流量削峰技术十分有必要</p>
<h3 id="业务解耦—秒杀令牌"><a href="#业务解耦—秒杀令牌" class="headerlink" title="业务解耦—秒杀令牌"></a>业务解耦—秒杀令牌</h3><p>之前的验证逻辑和下单逻辑都耦合在OrderService.createOrder里面，现<br>在利用秒杀令牌，使校验逻辑和下单逻辑分离。<br>PromoService新开一个generateSecondKillToken，将活动、商品、用户<br>信息校验逻辑封装在里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSecondKillToken</span><span class="params">(Integer promoId,Integer itemId,</span></span></span><br><span class="line"><span class="function"><span class="params">	Integer userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断库存是否售罄，若Key存在，则直接返回下单失败</span></span><br><span class="line">    <span class="keyword">if</span>(redisTemplate.hasKey(<span class="string">"promo_item_stock_invalid_"</span>+itemId))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    PromoDO promoDO=promoDOMapper.selectByPrimaryKey(promoId);</span><br><span class="line">    PromoModel promoModel=convertFromDataObj(promoDO);</span><br><span class="line">    <span class="keyword">if</span>(promoModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(promoModel.getStartDate().isAfterNow()) &#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(promoModel.getEndDate().isBeforeNow())&#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        promoModel.setStatus(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断活动是否正在进行</span></span><br><span class="line">    <span class="keyword">if</span>(promoModel.getStatus()!=<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断item信息是否存在</span></span><br><span class="line">    ItemModel itemModel=itemService.getItemByIdInCache(itemId);</span><br><span class="line">    <span class="keyword">if</span>(itemModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断用户是否存在</span></span><br><span class="line">    UserModel userModel=userService.getUserByIdInCache(userId);</span><br><span class="line">    <span class="keyword">if</span>(userModel==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//生成Token，并且存入redis内，5分钟时限</span></span><br><span class="line">    String token= UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_token_"</span>+promoId+<span class="string">"_userid_"</span>+</span><br><span class="line">    	userId+<span class="string">"_itemid_"</span>+itemId,token);</span><br><span class="line">    redisTemplate.expire(<span class="string">"promo_token_"</span>+promoId+<span class="string">"_userid_"</span>+userId+</span><br><span class="line">    	<span class="string">"_itemid_"</span>+itemId, <span class="number">5</span>,TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OrderController新开一个generateToken接口，以便前端请求，返回令牌</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/generatetoken"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">generateToken</span><span class="params">(···)</span> <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    <span class="comment">//用户登录状态校验</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//获取秒杀访问令牌</span></span><br><span class="line">    String promoToken = promoService.generateSecondKillToken(promoId, </span><br><span class="line">    	itemId, userModel.getId());</span><br><span class="line">    <span class="keyword">if</span> (promoToken == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, </span><br><span class="line">        	<span class="string">"生成令牌失败"</span>);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(promoToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端在点击“下单”后，首先会请求generateToken接口，返回秒杀令牌。然后<br>将秒杀令牌promoToken作为参数，再去请求后端createOrder接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/createorder"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">createOrder</span><span class="params">(··· @RequestParam(name = </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"promoToken"</span>, required = <span class="keyword">false</span>)</span> String promoToken) <span class="keyword">throws</span> BizException </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//校验秒杀令牌是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (promoId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String inRedisPromoToken = (String) redisTemplate.opsForValue().</span><br><span class="line">                    get(<span class="string">"promo_token_"</span> + promoId + <span class="string">"_userid_"</span> + </span><br><span class="line">                    	userModel.getId() + <span class="string">"_itemid_"</span> + itemId);</span><br><span class="line">    <span class="keyword">if</span> (inRedisPromoToken == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, </span><br><span class="line">        	<span class="string">"令牌校验失败"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.equals(promoToken, inRedisPromoToken)) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.PARAMETER_VALIDATION_ERROR, </span><br><span class="line">        	<span class="string">"令牌校验失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就彻底完成了校验逻辑和下单逻辑的分离。现在的问题是，假设有1E个<br>用户请求下单，那么就会生成1E的令牌，这是十分消耗性能的，所以接下<br>来会引入秒杀大闸进行限流</p>
<h4 id="限流—令牌大闸"><a href="#限流—令牌大闸" class="headerlink" title="限流—令牌大闸"></a>限流—令牌大闸</h4><p>大闸的意思就是令牌的数量是有限的，当令牌用完时，就不再发放令牌了，<br>那么下单将无法进行。之前我们通过PromoService.publishPromo将库存<br>发布到了Redis上，现在我们将令牌总量也发布到Redis上，这里我们设定<br>令牌总量是库存的5倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishPromo</span><span class="params">(Integer promoId)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">//库存同步到Redis</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_item_stock_"</span> + itemModel.getId(), </span><br><span class="line">    	itemModel.getStock());</span><br><span class="line">    <span class="comment">//大闸限制数量设置到redis内</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"promo_door_count_"</span> + promoId, itemModel.</span><br><span class="line">    	getStock().intValue() * <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在PromoService.generateSecondKillToken方法中，在生成令<br>牌之前，首先将Redis里的令牌总量减1，然后再判断是否剩余，如果&lt;0，<br>直接返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取大闸数量</span></span><br><span class="line"><span class="keyword">long</span> result = redisTemplate.opsForValue().</span><br><span class="line">                increment(<span class="string">"promo_door_count_"</span> + promoId, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (result &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//令牌生成</span></span><br></pre></td></tr></table></figure>

<h3 id="限流-对列泄洪"><a href="#限流-对列泄洪" class="headerlink" title="限流-对列泄洪"></a>限流-对列泄洪</h3><p>队列泄洪，就是让多余的请求排队等待。排队有时候比多线程并发效率更<br>高，多线程毕竟有锁的竞争、上下文的切换，很消耗性能。而排队是无锁<br>的，单线程的，某些情况下效率更高。<br>比如Redis就是单线程模型，多个用户同时执行set操作，只能一一等待。<br>比如MySQL的insert和update语句，会维护一个行锁。阿里SQL就不会，<br>而是让多个SQL语句排队，然后依次执行。<br>像支付宝就使用了队列泄洪，双11的时候，支付宝作为网络科技公司，可<br>以承受很高的TPS，但是下游的各个银行，无法承受这么高的TPS。支付宝<br>维护了一个“拥塞窗口”，慢慢地向下游银行发送流量，保护下游。<br>那对于我们的项目，什么时候引入“队列泄洪”呢？在OrderController里<br>面，之前拿到秒杀令牌后，就要开始执行下单的业务了。现在，我们把下<br>单业务封装到一个固定大小的线程池中，一次只处理固定大小的请求。<br>在OrderController里面引入j.u.c.ExcutorService，创建一个init方<br>法，初始化线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//20个线程的线程池</span></span><br><span class="line">    executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拿到秒杀令牌后，使用线程池来处理下单请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String stockLogId = itemService.initStockLog(itemId, amount);</span><br><span class="line">        <span class="keyword">if</span> (!mqProducer.transactionAsyncReduceStock(userModel.getId(), itemId, promoId, amount, stockLogId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.UNKNOWN_ERROR, <span class="string">"下单失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="防刷限流"><a href="#防刷限流" class="headerlink" title="防刷限流"></a>防刷限流</h3><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>之前的流程是，用户点击下单后，会直接拿到令牌然后执行下单流程。现在<br>用户点击下单后，前端会弹出一个“验证码”，用户输入之后，才能请求下<br>单接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/generateverifycode"</span>,···)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateVerifyCode</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">	BizException, IOException </span>&#123;</span><br><span class="line">    ···验证</span><br><span class="line">    <span class="comment">//验证用户信息</span></span><br><span class="line">    Map&lt;String, Object&gt; map = CodeUtil.generateCodeAndPic();</span><br><span class="line">    <span class="comment">//生成的验证码存到Redis里，并设置过期时间</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"verify_code_"</span> + userModel.getId(), </span><br><span class="line">    	map.get(<span class="string">"code"</span>));</span><br><span class="line">    redisTemplate.expire(<span class="string">"verify_code_"</span> + userModel.getId(), <span class="number">10</span>, </span><br><span class="line">    	TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//生成的图片，响应到前端页面</span></span><br><span class="line">    ImageIO.write((RenderedImage) map.get(<span class="string">"codePic"</span>), <span class="string">"jpeg"</span>, response.getOutputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="限并发"><a href="#限并发" class="headerlink" title="限并发"></a>限并发</h4><p>限制并发量意思就是同一时间只有一定数量的线程去处理请求，实现也<br>比较简单，维护一个全局计数器，当请求进入接口时，计数器-1，并且<br>判断计数器是否&gt;0，大于0则处理请求，小于0则拒绝等待。<br>但是一般衡量并发性，是用TPS或者QPS，而该方案由于限制了线程数，<br>自然不能用TPS或者QPS衡量</p>
<h3 id="限流方案—令牌桶-漏桶"><a href="#限流方案—令牌桶-漏桶" class="headerlink" title="限流方案—令牌桶/漏桶"></a>限流方案—令牌桶/漏桶</h3><p>客户端请求接口，必须先从令牌桶中获取令牌，令牌是由一个“定时器”<br>定期填充的。在一个时间内，令牌的数量是有限的。令牌桶的大小为100<br>，那么TPS就为100。</p>
<h4 id="RateLimiter限流实现"><a href="#RateLimiter限流实现" class="headerlink" title="RateLimiter限流实现"></a>RateLimiter限流实现</h4><p>google.guava.RateLimiter就是令牌桶算法的一个实现类，OrderController<br>引入这个类，在init方法里面，初始令牌数量为200</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//20个线程的线程池</span></span><br><span class="line">    executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//200个令牌，即200TPS</span></span><br><span class="line">    orderCreateRateLimiter = RateLimiter.create(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求createOrder接口之前，会调用RateLimiter.tryAcquire方法，看<br>当前令牌是否足够，不够直接抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!orderCreateRateLimiter.tryAcquire())</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BizException(EmBizError.RATELIMIT);</span><br></pre></td></tr></table></figure>

<h2 id="登录态管理"><a href="#登录态管理" class="headerlink" title="登录态管理"></a>登录态管理</h2><h2 id="mysql性能"><a href="#mysql性能" class="headerlink" title="mysql性能"></a>mysql性能</h2><h2 id="mysql分布式架构扩展"><a href="#mysql分布式架构扩展" class="headerlink" title="mysql分布式架构扩展"></a>mysql分布式架构扩展</h2><p>application.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8081</span><br><span class="line">server.tomcat.accept-count&#x3D;1000</span><br><span class="line">server.tomcat.max-threads&#x3D;800</span><br><span class="line">server.tomcat.min-spare-threads&#x3D;100</span><br><span class="line">server.tomcat.max-connections&#x3D;10000</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;172.16.227.230:3306&#x2F;soquick?serverTimezone&#x3D;UTC</span><br><span class="line">server.tomcat.accesslog.enabled&#x3D;true</span><br><span class="line"></span><br><span class="line">server.tomcat.accesslog.directory&#x3D;&#x2F;var&#x2F;www&#x2F;soquick&#x2F;tomcat</span><br><span class="line"></span><br><span class="line">server.tomcat.accesslog.pattern&#x3D;%h %l %u %t &quot;%r&quot; %s %b %D</span><br><span class="line"></span><br><span class="line">spring.redis.host&#x3D;172.16.227.230</span><br></pre></td></tr></table></figure>

<p>deploy.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms400m -Xmx400m -XX:NewSize&#x3D;200m -XX:MaxNewSize&#x3D;200m -jar soquick.jar --spring.config.additional-location&#x3D;&#x2F;var&#x2F;www&#x2F;soquick&#x2F;application.properties</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/05/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%80%89%E8%AF%BE%E9%A1%B9%E7%9B%AE3/">https://skysea-gaoming.github.io/2021/05/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%80%89%E8%AF%BE%E9%A1%B9%E7%9B%AE3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE/">项目</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/16/MySQL%E5%AE%9E%E6%88%98/"><i class="fa fa-chevron-left">  </i><span>MySQL总结2</span></a></div><div class="next-post pull-right"><a href="/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C4/"><span>网络安全总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/05/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%80%89%E8%AF%BE%E9%A1%B9%E7%9B%AE3/';
  this.page.identifier = '2021/05/11/高并发选课项目3/';
  this.page.title = '高并发选课项目3';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>