<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Netty"><meta name="keywords" content="Java"><meta name="author" content="高明"><meta name="copyright" content="高明"><title>Netty | SkySea-GaoMing</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty"><span class="toc-number">1.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty简介"><span class="toc-number">1.1.</span> <span class="toc-text">Netty简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不直接用NIO"><span class="toc-number">1.2.</span> <span class="toc-text">为什么不直接用NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty的优点"><span class="toc-number">1.3.</span> <span class="toc-text">Netty的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty和Tomcat的区别"><span class="toc-number">1.4.</span> <span class="toc-text">Netty和Tomcat的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty为什么传输快"><span class="toc-number">1.5.</span> <span class="toc-text">Netty为什么传输快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty的应用场景"><span class="toc-number">1.6.</span> <span class="toc-text">Netty的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty核心组件"><span class="toc-number">1.7.</span> <span class="toc-text">Netty核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bootstrap-和ServerBootstrap"><span class="toc-number">1.7.1.</span> <span class="toc-text">Bootstrap 和ServerBootstrap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">1.7.2.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventLoop"><span class="toc-number">1.7.3.</span> <span class="toc-text">EventLoop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventLoopGroup"><span class="toc-number">1.7.4.</span> <span class="toc-text">EventLoopGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bytebuf"><span class="toc-number">1.7.5.</span> <span class="toc-text">Bytebuf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelHandler"><span class="toc-number">1.7.6.</span> <span class="toc-text">ChannelHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelFuture"><span class="toc-number">1.7.7.</span> <span class="toc-text">ChannelFuture</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty的核心组件"><span class="toc-number">1.8.</span> <span class="toc-text">Netty的核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-和EventLoop-的关系"><span class="toc-number">1.9.</span> <span class="toc-text">Channel 和EventLoop 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventloopGroup-和EventLoop-的关系"><span class="toc-number">1.10.</span> <span class="toc-text">EventloopGroup 和EventLoop 的关系</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2762516417,1589137703&amp;fm=26&amp;gp=0.jpg"></div><div class="author-info__name text-center">高明</div><div class="author-info__description text-center">JAVA工程师</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SkySea-GaoMing</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Netty</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-31</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B/">秋招</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/05/31/Netty/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/05/31/Netty/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty 基于NIO（NIO 是一种同步非阻塞的I/O 模型，在Java 1.4 中引入了<br>NIO ）。使用 Netty 可以极大地简化并简化了TCP 和UDP 套接字服务器等网<br>络编程，并且性能以及安全性等很多方面都非常优秀</p>
<h3 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h3><ol>
<li>Netty 是一个 基于 NIO 的 client-server(客户端服务器)框架，使用<br>它可以快速简单地开发网络应用程序</li>
<li>它极大地简化并优化了TCP 和UDP 套接字服务器等网络编程，并且性能以<br>及安全性等很多方面甚至都要更好</li>
<li>支持多种协议 如FTP，SMTP，HTTP以及各种二进制和基于文本的传统协议</li>
</ol>
<h3 id="为什么不直接用NIO"><a href="#为什么不直接用NIO" class="headerlink" title="为什么不直接用NIO"></a>为什么不直接用NIO</h3><ol>
<li>NIO的编程模型复杂而且存在一些BUG，并且对编程功底要求比较高</li>
<li>NIO在面对断连重连、包丢失、粘包等问题时处理过程非常复杂</li>
</ol>
<h3 id="Netty的优点"><a href="#Netty的优点" class="headerlink" title="Netty的优点"></a>Netty的优点</h3><ol>
<li>统一的 API，支持多种传输类型，阻塞和非阻塞的。</li>
<li>简单而强大的线程模型。</li>
<li>自带编解码器解决TCP 粘包/拆包问题。</li>
<li>自带各种协议栈。</li>
<li>真正的无连接数据包套接字支持。</li>
<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗<br>和更少的内存复制</li>
<li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持</li>
<li>Dubbo、RocketMQ、Elasticsearch、gRPC、Spark、Elasticsearch 等等热<br>门开源项目都用到了Netty</li>
</ol>
<h3 id="Netty和Tomcat的区别"><a href="#Netty和Tomcat的区别" class="headerlink" title="Netty和Tomcat的区别"></a>Netty和Tomcat的区别</h3><p>Netty和Tomcat最大的区别就在于通信协议</p>
<ol>
<li>Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器</li>
<li>Netty能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解<br>码字节流</li>
</ol>
<h3 id="Netty为什么传输快"><a href="#Netty为什么传输快" class="headerlink" title="Netty为什么传输快"></a>Netty为什么传输快</h3><p>零拷贝。一般我们的数据如果需要从IO读取到堆内存，中间需要经过Socket缓冲<br>区，也就是说一个数据会被拷贝两次才能到达他的的终点，如果数据量大，就会<br>造成不必要的资源浪费。在堆内存之外开辟一块内存，数据就直接从IO读到了那<br>块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从<br>而加快了传输速度。</p>
<h3 id="Netty的应用场景"><a href="#Netty的应用场景" class="headerlink" title="Netty的应用场景"></a>Netty的应用场景</h3><ol>
<li>作为RPC 框架的网络通信工具：我们在分布式系统中，不同服务节点之间经常<br>需要相互调用，这个时候就需要 RPC 框架了。不同服务节点的通信是使用Netty<br>来做</li>
<li>实现一个自己的HTTP 服务器：通过Netty 我们可以自己实现一个简单的HTTP<br>服务器</li>
<li>实现一个即时通讯系统： 使用Netty 我们可以实现一个可以聊天类似微信的<br>即时通讯系统</li>
<li>实现消息推送系统 ：市面上有很多消息推送系统都是基于 Netty 来做的</li>
</ol>
<h3 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h3><h4 id="Bootstrap-和ServerBootstrap"><a href="#Bootstrap-和ServerBootstrap" class="headerlink" title="Bootstrap 和ServerBootstrap"></a>Bootstrap 和ServerBootstrap</h4><p>一种是用于客户端的Bootstrap，一种是用于服务端的ServerBootstrap。<br>前者的功能是连接到远程主机和端口，后者的功能是绑定本机端口。<br>Bootstrap 是客户端的启动引导类/辅助类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">          Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">          <span class="comment">//指定线程模型</span></span><br><span class="line">          b.group(group).</span><br><span class="line">                  ......</span><br><span class="line">          <span class="comment">// 尝试建立连接</span></span><br><span class="line">          ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">          f.channel().closeFuture().sync();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">          group.shutdownGracefully();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>ServerBootstrap 服务端的启动引导类/辅助类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">      EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">      EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">          ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">          <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">          b.group(bossGroup, workerGroup).</span><br><span class="line">                 ......</span><br><span class="line">          <span class="comment">// 6.绑定端口</span></span><br><span class="line">          ChannelFuture f = b.bind(port).sync();</span><br><span class="line">          <span class="comment">// 等待连接关闭</span></span><br><span class="line">          f.channel().closeFuture().sync();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">          bossGroup.shutdownGracefully();</span><br><span class="line">          workerGroup.shutdownGracefully();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Bootstrap 通常使用connet() 方法连接到远程的主机和端口，作为一<br>个Netty TCP 协议通信中的客户端。另外Bootstrap 也可以通过 bind()<br>方法绑定本地的一个端口，作为UDP 协议通信中的一端</li>
<li>ServerBootstrap通常使用 bind() 方法绑定本地的端口上，然后等待<br>客户端的连接</li>
<li>Bootstrap 只需要配置一个线程组—EventLoopGroup，而ServerBootstrap<br>需要配置两个线程组— EventLoopGroup ，一个用于接收连接，一个用于具体<br>的 IO 处理</li>
</ol>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>网络操作抽象类。一旦客户端成功连接服务端，就会新建一个Channel 同该用<br>户端进行绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通过 Bootstrap 的 connect 方法连接到服务端</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Channel <span class="title">doConnect</span><span class="params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">       CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">       bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener)</span><br><span class="line">       	future -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">               completableFuture.complete(future.channel());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>比较常用的Channel接口实现类是 ：</p>
<ol>
<li>NioServerSocketChannel（服务端）</li>
<li>NioSocketChannel（客户端）</li>
</ol>
<h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>事件循环。EventLoop 的主要作用实际就是责监听网络事件并调用事件处理器进<br>行相关I/O 操作（读写）的处理。Channel为Netty 网络操作（读写等操作）抽<br>象类，EventLoop 负责处理注册到其上的Channel 的I/O 操作，两者配合进行<br>I/O 操作。<br>EventLoopGroup 包含多个 EventLoop（每一个 EventLoop 通常内部包含一<br>个线程），它管理着所有的EventLoop的生命周期。并且EventLoop 处理的I/O<br>事件都将在它专有的Thread 上被处理，即Thread 和EventLoop 属于1:1的关<br>系，从而保证线程安全。</p>
<h4 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h4><p>Netty 中EventLoopGroup 是Reactor 模型的一个实现。<br>Reactor 就是一个执行while (true) { selector.select();…}循环的线程<br>，会源源不断产生新的事件，称作反应堆很贴切。 事件又分为连接事件、IO 读和<br>IO 写事件，一般把连接事件单独放一线程里处理，即主Reactor(MainReactor)<br>，IO读和IO写事件放到另外的一组线程里处理，即从Reactor(SubReactor)，从<br>Reactor线程数量一般为2*(CPUs - 1)。 所以在运行时，MainReactor只处理<br>Accept事件，连接到来，马上按照策略转发给从Reactor之一，只处理连接，故<br>开销非常小；每个SubReactor管理多个连接，负责这些连接的读和写，属于IO<br>密集型线程，读到完整的消息就丢给业务线程池处理业务，处理完比后，响应<br>消息一般放到队列里，SubReactor会去处理队列，然后将消息写回</p>
<h4 id="Bytebuf"><a href="#Bytebuf" class="headerlink" title="Bytebuf"></a>Bytebuf</h4><p>字节容器，网络通信最终都是通过字节流进行传输的。ByteBuf就是Netty提供<br>的一个字节容器，其内部是一个字节数组。可以将ByteBuf看作是Netty对Java<br>NIO 提供了ByteBuffer 字节容器的封装和抽象</p>
<h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p>消息处理器，主要负责处理客户端/服务端接收和发送的数据。<br>当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。 一<br>个Channel包含一个ChannelPipeline。 ChannelPipeline为ChannelHandler<br>的链，一个pipeline 上可以有多个 ChannelHandler。<br>我们可以在ChannelPipeline 上通过addLast() 方法添加一个或者多个<br>ChannelHandler（一个数据或者事件可能会被多个Handler 处理）。当<br>一个ChannelHandler处理完之后就将数据交给下一个ChannelHandler。<br>当ChannelHandler 被添加到的 ChannelPipeline 它得到一个 ChannelHandlerContext，它代表一个 ChannelHandler 和 ChannelPipeline<br>之间的“绑定”。 ChannelPipeline 通过 ChannelHandlerContext来间接管理<br>ChannelHandler 。</p>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><h3 id="Netty的核心组件"><a href="#Netty的核心组件" class="headerlink" title="Netty的核心组件"></a>Netty的核心组件</h3><ol start="2">
<li>Bootstrap 和 ServerBootstrap（启动引导类）Bootstrap 是客户端的<br>启动引导类/辅助类，ServerBootstrap 客户端的启动引导类/辅助类</li>
</ol>
<ul>
<li>bootstrap 通常使用 connet() 方法连接到远程的主机和端口，作为一个<br>Netty TCP 协议通信中的客户端。另外，Bootstrap 也可以通过bind() 方<br>法绑定本地的一个端口，作为UDP 协议通信中的一端</li>
<li>ServerBootstrap通常使用 bind() 方法绑定本地的端口上，然后等待客户<br>端的连接</li>
<li>Bootstrap 只需要配置一个线程组EventLoopGroup，而ServerBootstrap<br>需要配置两个线程组EventLoopGroup ，一个用于接收连接，一个用于具体的<br>IO 处理</li>
</ul>
<h3 id="Channel-和EventLoop-的关系"><a href="#Channel-和EventLoop-的关系" class="headerlink" title="Channel 和EventLoop 的关系"></a>Channel 和EventLoop 的关系</h3><p>Channel 为 Netty 网络操作(读写等操作)抽象类，EventLoop 负责处理注册<br>到其上的Channel 的 I/O 操作，两者配合进行 I/O 操作</p>
<h3 id="EventloopGroup-和EventLoop-的关系"><a href="#EventloopGroup-和EventLoop-的关系" class="headerlink" title="EventloopGroup 和EventLoop 的关系"></a>EventloopGroup 和EventLoop 的关系</h3><p>EventLoopGroup 包含多个 EventLoop（每一个 EventLoop 通常内部包含<br>一个线程），它管理着所有的 EventLoop 的生命周期。EventLoop 处理的<br>I/O 事件都将在它专有的Thread 上被处理，即Thread 和EventLoop属于<br>1 : 1 的关系，从而保证线程安全</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skysea-gaoming.github.io/2021/05/31/Netty/">https://skysea-gaoming.github.io/2021/05/31/Netty/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>算法总结</span></a></div><div class="next-post pull-right"><a href="/2021/05/31/RPC%E6%80%BB%E7%BB%93/"><span>RPC总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://skysea-gaoming.github.io/2021/05/31/Netty/';
  this.page.identifier = '2021/05/31/Netty/';
  this.page.title = 'Netty';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '你的disqus的 short-name' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://你的disqus的 short-name.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2333247715,1420619508&amp;fm=26&amp;gp=0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 高明</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>